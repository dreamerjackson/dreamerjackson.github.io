<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jonson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreamerjonson.com/"/>
  <updated>2020-07-01T07:07:39.340Z</updated>
  <id>https://dreamerjonson.com/</id>
  
  <author>
    <name>Jonson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>thewaytogolang2</title>
    <link href="https://dreamerjonson.com/2020/07/01/thewaytogolang2/"/>
    <id>https://dreamerjonson.com/2020/07/01/thewaytogolang2/</id>
    <published>2020-07-01T06:56:54.000Z</published>
    <updated>2020-07-01T07:07:39.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang快速入门21-go语言开发环境配置-windows"><a class="markdownIt-Anchor" href="#golang快速入门21-go语言开发环境配置-windows"></a> golang快速入门[2.1]-go语言开发环境配置-windows</h1><ul><li>本文将讲解在windows系统下构建go语言的开发环境</li></ul><h2 id="windows安装go语言开发包"><a class="markdownIt-Anchor" href="#windows安装go语言开发包"></a> windows安装Go语言开发包</h2><ul><li>配置go语言的开发环境的第一步是要在<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">go官网下载页面</a>下载开发包</li><li>windows系统下需要下载msi后缀文件，msi是windows下的安装包文件格式,用于安装，存储和删除程序</li></ul><img src="/2020/07/01/thewaytogolang2/8.png" title="golang"><ul><li>上图中是 64 位的开发包，如果读者的电脑是 32 位系统或者有特殊的软件需求，则需要下载 32 位的开发包</li><li>如下图所示为windows下32位系统的开发包</li></ul><img src="/2020/07/01/thewaytogolang2/9.png" title="golang"><ul><li>双击后即可启动程序，如下图所示，这是Go语言的用户许可协议，直接点击勾选即可。</li></ul><img src="/2020/07/01/thewaytogolang2/10.png" title="golang"><ul><li>Go语言开发包会默认安装到 C 盘的 Go 目录下，这就是叫做GOROOT的目录，推荐使用此目录，也可以选择任意的目录。如下图所示，确认无误后点击“Next”</li></ul><img src="/2020/07/01/thewaytogolang2/11.png" title="golang"><ul><li>如下图所示，点击“Install”即可开始安装，没有其他需要配置的操作</li></ul><img src="/2020/07/01/thewaytogolang2/12.png" title="golang"><ul><li>等待程序完成安装，点击“Finish”完成安装。</li></ul><img src="/2020/07/01/thewaytogolang2/13.png" title="golang"><ul><li>安装完成后，在我们所设置的安装目录下(c:/go)将生成特定的文件和文件夹，如下图所示：</li></ul><img src="/2020/07/01/thewaytogolang2/14.png" title="golang"><h2 id="设置环境变量"><a class="markdownIt-Anchor" href="#设置环境变量"></a> 设置环境变量</h2><ul><li>开始写 go 项目代码之前，需要我们先配置好GOPATH环境变量，GOPATH是go中的一个重要概念，我们在之后的文章中会详细介绍</li><li>如下图所示，在桌面或者资源管理器右键 我的电脑 - 属性 - 高级系统设置 - 环境变量。</li></ul><img src="/2020/07/01/thewaytogolang2/15.png" title="golang"><ul><li>在弹出的界面里点击 GOPATH 对应的选项，点击编辑之后就可以对GOPATH进行修改。</li><li>如果没有GOPATH环境变量，则可以点击新建进行创建。</li><li>GOPATH可以设置为任何目录，但是尽量选择新的空目录，例如 :\Go。</li></ul><img src="/2020/07/01/thewaytogolang2/16.png" title="golang"><ul><li>提示：填写完成后，每个打开的窗口都需要点击“确定”来保存设置。</li><li>其它的Go环境变量会由安装包自动设置。</li><li>在任意目录下使用终端执行 go env 命令，输出如下结果说明Go语言开发包已经安装成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt; go env</span><br><span class="line">set GO111MODULE=</span><br><span class="line">set GOARCH=amd64</span><br><span class="line">set GOBIN=</span><br><span class="line">set GOCACHE=C:\Users\jackson\AppData\Local\go-build</span><br><span class="line">set GOENV=C:\Users\jackson\AppData\Roaming\go\env</span><br><span class="line">set GOEXE=.exe</span><br><span class="line">set GOFLAGS=</span><br><span class="line">set GOHOSTARCH=amd64</span><br><span class="line">set GOHOSTOS=windows</span><br><span class="line">set GONOPROXY=</span><br><span class="line">set GONOSUMDB=</span><br><span class="line">set GOOS=windows</span><br><span class="line">set GOPATH=C:\Users\jackson\go</span><br><span class="line">set GOPRIVATE=</span><br><span class="line">set GOPROXY=https://proxy.golang.org,direct</span><br><span class="line">set GOROOT=c:\go</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="http://c.biancheng.net/view/3992.html" target="_blank" rel="noopener">在Windows上安装Go语言开发包</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;golang快速入门21-go语言开发环境配置-windows&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#golang快速入门21-go语言开发环境配置-windows&quot;&gt;&lt;/a&gt; golang快速入门[2.1]-go语言开发环境配
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go语言快速入门[1]-go语言简介</title>
    <link href="https://dreamerjonson.com/2020/06/29/thewaytogolang1/"/>
    <id>https://dreamerjonson.com/2020/06/29/thewaytogolang1/</id>
    <published>2020-06-29T10:14:51.000Z</published>
    <updated>2020-07-01T07:21:45.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h2><ul><li>这是一套帮助初学者从0到1学习go语言的开源教程，致力于打造最完整、最强悍、最有深度的Go语言学习体系</li><li>我希望这套课程能够涵盖Go语言的所有体系、并致力于用大量的案例来诠释其用法</li><li>鉴于作者水平有限，真诚地希望能够集所有人的智慧，完善此项目，链接附后</li></ul><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言</li><li>Go的最初目标是消除Google软件开发的缓慢性和笨拙性，从而使流程更具效率和可扩展性，更多的关注于软件工程领域</li><li>Go致力于解决当代大型工程项目面临的多核处理，网络系统，海量计算集群、快速构建等问题，Go在语言级别考虑并发问题,提供简单高效的并发编程</li><li>罗伯特·格瑞史莫(Robert Griesemer)，罗勃·派克（Rob Pike）及肯·汤普逊(Ken Thompson)于2007年9月开始设计Go，稍后Ian Lance Taylor、Russ Cox加入项目</li><li>Go是基于Inferno操作系统所开发的</li><li>Go于2009年11月正式宣布推出，成为开放源代码项目，支持Linux、macOS、Windows等操作系统</li><li>在2016年，Go被软件评价公司TIOBE 选为“TIOBE 2016 年最佳语言”</li><li>很多重要的开源项目都是使用Go语言开发的，其中包括 Docker、Go-Ethereum、Thrraform、Kubernetes、etcd、hyperledger、tidb</li></ul><h2 id="基本语言的历史"><a class="markdownIt-Anchor" href="#基本语言的历史"></a> 基本语言的历史</h2><ul><li>1960年 Ken Thompson(肯.汤普森) 发明了B语言</li><li>1972年 Dennis Ritchie(丹尼斯·里奇)发明了C语言</li><li>1982年 Bjarne Stroustrup(本贾尼)发明了C++语言</li><li>1989年 Guido von Rossum 发明了Python语言</li><li>1995年SUN公司发明了Java语言</li><li>2007年Go语言诞生</li><li>2009年的11月对外正式发布</li></ul><h2 id="go语言创始人"><a class="markdownIt-Anchor" href="#go语言创始人"></a> Go语言创始人</h2><p>对语言进行评估时，明白设计者的动机以及语言要解决的问题很重要。Go语言出自 Ken Thompson 和 Rob Pike、Robert Griesemer 之手，他们都是计算机科学领域的重量级人物。</p><ul><li>Ken Thompson<br>贝尔实验室 Unix 团队成员，C语言、Unix 和 Plan 9 的创始人之一，在 20 世纪 70 年代，设计并实现了最初的 UNIX 操作系统，仅从这一点说，他对计算机科学的贡献怎么强调都不过分。他还与 Rob Pike 合作设计了 UTF-8 编码方案</li><li>Rob Pike<br>Go语言项目总负责人，贝尔实验室 Unix 团队成员，除帮助设计 UTF-8 外，还帮助开发了分布式多用户操作系统 Plan 9、Inferno 操作系统和 Limbo 编程语言，并与人合著了《The Unix Programming Environment》，对 UNIX 的设计理念做了正统的阐述</li><li>Robert Griesemer<br>就职于 Google，参与开发 Java HotSpot 虚拟机，对语言设计有深入的认识，并负责 Chrome 浏览器和 Node.js 使用的 Google V8 JavaScript 引擎的代码生成部分</li></ul><h2 id="go语言的继承"><a class="markdownIt-Anchor" href="#go语言的继承"></a> go语言的继承</h2><ul><li>Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”</li><li>Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等思想</li><li>Go继承了C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配</li><li>Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设计的Pascal语言</li><li>Modula-2语言激发了包的概念，然后Oberon语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还有Oberon语言的面向对象特性所提供的方法的声明语法等</li><li>Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程（communicating sequential processes，缩写为CSP）<br>在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过Tony Hoare的CSP只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言<br>Rob Pike和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引入CSP特性的编程语言叫Squeak，是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的<br>然后是改进版的Newsqueak语言，提供了类似C语言语句和表达式的语法和类似Pascal语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。在Newsqueak语言中管道是动态创建的，属于第一等公民,可以保存到变量中<br>在Plan9操作系统中，这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦<br>注：在Aelf之后还有一个叫Limbo的编程语言，Go语言从其中借鉴了很多特性。具体请参考Pike的讲稿：<a href="http://talks.golang.org/2012/concurrency.slide#9" target="_blank" rel="noopener">http://talks.golang.org/2012/concurrency.slide#9</a></li><li>Go语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从APL语言借鉴，词法作用域与嵌套函数来自于Scheme语言和其他很多语言</li><li>Go中也有很多创新的设计，比如Go语言的切片为动态数组提供了有效的随机存取的性能，还有Go语言新发明的defer语句</li></ul><h2 id="go语言的特点"><a class="markdownIt-Anchor" href="#go语言的特点"></a> go语言的特点</h2><p>所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。</p><ul><li>简洁<br>Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）<br>正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性<br>通过增加功能、选项、配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，卽使从长远来看，简洁依然是好软件的关键因素<br>简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变或坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应<br>而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化<br>附带了相关的工具和标准库<br>没有隐式的数值转换<br>没有构造函数和析构函数<br>没有运算符重载<br>没有默认参数<br>没有继承<br>没有泛型（go2中考虑加入）<br>没有异常，即没有与错误处理相关的控制结构<br>没有宏<br>没有函数修饰<br>没有线程局部存储。<br>没有指针运算<br>没有类型别名<br>数组边界总是受到检查</li><li>基本特性<br>自动垃圾回收<br>包管理<br>函数作为一等公民<br>系统调用接口<br>只读的UTF8字符串<br>函数多返回值<br>匿名函数和闭包<br>反射<br>静态链接<br>严格的依赖规范<br>CSP并发编程<br>Goroutine协程<br>接口类型</li><li>向后兼容<br>Go语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码</li><li>类型系统<br>相比较于js、python，Go语言的类型系统避免动态语言中那些粗心的类型错误。但是Go语言的类型系统相比传统的强类型语言又要简洁很多，虽然有时候这会导致一个“无类型”的抽象类型的概念<br>Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中Go语言简洁的类型系统给了程序员带来了更多的安全性和更好的运行时性能<br>Go语言遵循当代计算机系统设计的原则，特别是局部的重要性。Go的内置数据类型和大多数的标准数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因此内存分配和内存初始化代码被隐藏在库代码中了<br>Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存分配，而且指针操作比其他间接操作的语言也更有效率</li><li>并发支持<br>由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。<br>Go并发的座右铭：不要通过共享内存进行通信，而要通过通信共享内存（Don’t communicate by sharing memory, share memory by communicating）</li><li>自动垃圾回收机制<br>对于系统语言，垃圾回收可能是一个有争议的功能<br>Go没有显式的内存释放操作：分配的内存返回池的唯一方法是通过垃圾回收器。<br>内存管理对语言在实践中的工作方式具有深远的影响。在C和C++中，太多的编程工作花费在内存分配和释放上<br>由于垃圾回收机制，语言更易于使用。<br>垃圾回收会带来巨大的成本：常规开销，延迟和实现的复杂性<br>知识渊博的程序员可以限制收集器所承受的压力，从而提高性能。（此外，Go安装附带了用于研究正在运行的程序的动态内存性能的良好工具）<br>自动垃圾回收算法是一个持续跟新的过程、活跃的开发领域</li><li>强大的标准库与规范<br>Go语言的标准库，提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议<br>库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且每个Go程序结构都是如此的相似，因此Go程序也很容易学习<br>Go语言自带工具构建Go语言项目只需要使用文件名、标识符名称以及少量的注释确定所有的库、可执行文件、测试、基准测试、案例、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范</li><li>开源,活跃的社区</li><li>组成而不是继承<br>Go采用一种不寻常的方法来进行面向对象的编程（接口），它允许有相同方法的任何类型继承,而不仅是类<br>Go没有任何形式的基于类型的继承,这意味着没有类型层次结构<br>这是一个故意的设计选择，尽管类型层次结构已用于构建许多成功的软件，但Go认为该模型已被过度使用</li></ul><h2 id="go语言的优势"><a class="markdownIt-Anchor" href="#go语言的优势"></a> Go语言的优势</h2><ul><li>学习曲线容易，语法简单清晰<br>单就类型和规则而言，Go 与 C99、C11 相似之处颇多，这也是Go语言被冠以“NextC”名号的重要原因。<br>Go语言的语法规则严谨，没有歧义，更没什么黑魔法变异用法。<br>任何人写出的代码都基本一致，这使得Go语言简单易学。放弃部分“灵活”和“自由”，换来更好的维护性</li><li>强大的标准库和工具链<br>完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具<br>内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的 pprof，这些都是保障代码能正确而稳定运行的必备利器<br>可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现</li><li>自动垃圾回收机制<br>垃圾回收一直是个难题。早年间，Java 就因垃圾回收低效被嘲笑了许久，后来 Sun 连续收纳了好多人和技术才发展到今天。可即便如此，在 Hadoop 等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰<br>相比 Java，Go 面临的困难要更多。因指针的存在，所以回收内存不能做收缩处理。幸好，指针运算被阻止，否则要做到精确回收都难<br>每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低 STW 时间，直到 Go 的 1.5 版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作</li><li>静态链接<br>运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库</li><li>编译迅速</li><li>清晰的依赖关系</li><li>并发编程<br>在早期 CPU 都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表<br>随着处理器技术的发展，单核时代以提升处理器频率来提高运行效率的方式遇到了瓶颈，单核 CPU 发展的停滞，给多核 CPU 的发展带来了机遇<br>现代计算机都拥有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。编程时需要写大量的线程同步代码来利用多个核，很容易导致错误<br>Go语言正是在多核和网络化的时代背景下诞生的原生支持并发的编程语言。Go语言从底层原生支持并发，无须第三方库，开发人员可以很轻松地在编写程序时决定怎么使用 CPU 资源<br>Goroutine 是 Go 最显著的特征<br>Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能<br>Go用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易<br>无须处理回调，无须关注线程切换，仅一个关键字，简单而自然<br>搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱</li><li>内存分配<br>Go 选择了 tcmalloc，它本就是为并发而设计的高性能内存分配组件<br>刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。使用 cache 为当前执行线程提供无锁分配，多个 central 在不同线程间平衡内存单元复用<br>heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务</li></ul><h2 id="go语言擅长的领域"><a class="markdownIt-Anchor" href="#go语言擅长的领域"></a> Go语言擅长的领域</h2><ul><li>Go语言主要用作服务器端开发，适合于多人周期较长的大型软件和支持云计算的网络服务</li><li>在服务器编程方面，Go语言适合处理日志、中间件、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等</li><li>网络编程方面，Go语言广泛应用于 Web 应用、API 应用、下载应用等</li><li>此外，Go语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用 Go 开发</li><li>由于Go垃圾回收牺牲了一些性能，因此其不适合做操作系统编程以及对速度要求极致的程序，不适合直接处理数据分析与计算</li></ul><h2 id="使用go语言的公司"><a class="markdownIt-Anchor" href="#使用go语言的公司"></a> 使用Go语言的公司</h2><p>参见<a href="https://github.com/golang/go/wiki/GoUsers" target="_blank" rel="noopener">世界上使用Go语言的企业</a></p><ul><li>Google<br>作为创造了Go语言的 google 公司，当然会力挺Go语言了。Google 有很多基于 Go 开发的开源项目，比如 kubernets，docker，大家可以参考《哪些项目使用Go语言开发》一节了解更多的Go语言开源项目</li><li>Facebook<br>Facebook 也在使用Go语言，为此他们还专门在 Github 上建立了一个开源组织 facebookgo。大家可以通过 <a href="https://github.com/facebookgo" target="_blank" rel="noopener">https://github.com/facebookgo</a> 访问查看 facebook 开源的项目，其中最具代表性的就是著名平滑重启工具 grace</li><li>腾讯<br>腾讯在 15 年就已经做了 Docker 万台规模的实践。因为腾讯主要的开发语言是 C/C++ ，所以在使用Go语言方面会方便很多，也有很多优势，不过日积月累的 C/C++ 代码很难改造，也不敢动，所以主要在新业务上尝试使用 Go</li><li>百度<br>百度主要在运维方面使用到了Go语言，比如百度运维的一个 BFE 项目，主要负责前端流量的接入，其次就是百度消息通讯系统的服务器端也使用到了Go语言</li><li>七牛云<br>七牛云算是国内第一家选Go语言做服务端的公司。早在 2011 年，当Go语言的语法还没完全稳定下来的情况下，七牛云就已经选择将 Go 作为存储服务端的主体语言</li><li>京东<br>京东云消息推送系统、云存储，以及京东商城的列表页等都是使用Go语言开发的</li><li>小米<br>小米对Go语言的支持，在于运维监控系统的开源，它的官方网址是 <a href="http://open-falcon.org/%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%B0%8F%E7%B1%B3%E4%BA%92%E5%A8%B1%E3%80%81%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E3%80%81%E5%B0%8F%E7%B1%B3%E8%A7%86%E9%A2%91%E3%80%81%E5%B0%8F%E7%B1%B3%E7%94%9F%E6%80%81%E9%93%BE%E7%AD%89%E5%9B%A2%E9%98%9F%E9%83%BD%E5%9C%A8%E4%BD%BF%E7%94%A8Go%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">http://open-falcon.org/。此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Go语言</a></li><li>360<br>360 对Go语言的使用也不少，比如开源的日志搜索系统 Poseidon，大家可以通过 <a href="https://github.com/Qihoo360/poseidon" target="_blank" rel="noopener">https://github.com/Qihoo360/poseidon</a> 查看，还有 360 的推送团队也在使用Go语言<br>除了上面提到的，还有很多公司开始尝试使用Go语言，比如美团、滴滴、新浪等。</li></ul><h2 id="go语言吉祥物"><a class="markdownIt-Anchor" href="#go语言吉祥物"></a> Go语言吉祥物</h2><p>Go语言有一个吉祥物，在会议、文档页面和博文中，大多会包含下图所示的 Go Gopher，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。</p><img src="/2020/06/29/thewaytogolang1/1.jpg" title="golang"><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://github.com/dreamerjackson/theWayToGolang" target="_blank" rel="noopener">项目链接</a></li><li><a href="https://dreamerjonson.com/">My Blog</a></li><li><a href="https://github.com/golang" target="_blank" rel="noopener">Go源码</a></li><li><a href="https://golang.org/" target="_blank" rel="noopener">Go官网</a></li><li><a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">优秀的Go语言项目</a></li><li><a href="https://swtch.com/~rsc/thread/" target="_blank" rel="noopener">Bell Labs and CSP Threads</a></li><li><a href="http://c.biancheng.net/view/1.html" target="_blank" rel="noopener">Go语言简介</a></li><li><a href="https://github.com/KeKe-Li/book/blob/master/Go/The.Go.Programming.Language.pdf" target="_blank" rel="noopener">The Go Programming Language</a></li><li><a href="https://golang.org/doc/faq" target="_blank" rel="noopener">Go FAQ</a></li><li><a href="https://talks.golang.org/2012/splash.article" target="_blank" rel="noopener">Go at Google: Language Design in the Service of Software Engineering</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;声明&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#声明&quot;&gt;&lt;/a&gt; 声明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这是一套帮助初学者从0到1学习go语言的开源教程，致力于打造最完整、最强悍、最有深度的Go语言学习体系&lt;/li&gt;
&lt;li&gt;我希望这套
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac利用sz rz 从服务器下载 上传资源</title>
    <link href="https://dreamerjonson.com/2020/04/28/mac-linux-rz-sz/"/>
    <id>https://dreamerjonson.com/2020/04/28/mac-linux-rz-sz/</id>
    <published>2020-04-28T03:14:58.000Z</published>
    <updated>2020-04-28T03:26:49.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><h2 id="安装脚本"><a class="markdownIt-Anchor" href="#安装脚本"></a> 安装脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">wget https://raw.github.com/aikuyun/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line">wget https://raw.github.com/aikuyun/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><h2 id="权限"><a class="markdownIt-Anchor" href="#权限"></a> 权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure><h2 id="配置item2"><a class="markdownIt-Anchor" href="#配置item2"></a> 配置item2</h2><img src="/2020/04/28/mac-linux-rz-sz/1.png" title="代码结构"><p>在iTerm 2添加Triggers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Regular expression: rz waiting to receive.\*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">Regular expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><img src="/2020/04/28/mac-linux-rz-sz/2.png" title="代码结构"><h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h2><ul><li><p>将文件传到远端服务器</p></li><li><p>在远端服务器上输入 rz ，回车</p></li><li><p>选择本地要上传的文件</p></li><li><p>等待上传</p></li><li><p>从远端服务器下载文件</p></li><li><p>在远端服务器输入 sz filename filename1 … filenameN</p></li><li><p>选择本地的存储目录</p></li><li><p>等待下载</p></li><li><p>PS:远端服务器也需要安装lrzsz。centOS安装方法： yum -y install lrzsz</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="mac" scheme="https://dreamerjonson.com/categories/mac/"/>
    
    
      <category term="linux" scheme="https://dreamerjonson.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>6.824分布式系统[4]-Zookeeper</title>
    <link href="https://dreamerjonson.com/2020/02/02/distributed-systerm-4-Zookeeper/"/>
    <id>https://dreamerjonson.com/2020/02/02/distributed-systerm-4-Zookeeper/</id>
    <published>2020-02-02T08:25:07.000Z</published>
    <updated>2020-02-16T12:59:49.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>阅读： [<a href="https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf</a>](“ZooKeeper: wait-free coordination for internet-scale systems”)<br>阅读：我之前写好的raft系列文章</p><h2 id="为什么要阅读这篇文章"><a class="markdownIt-Anchor" href="#为什么要阅读这篇文章"></a> 为什么要阅读这篇文章</h2><ul><li>Zookeeper是广泛使用的主从状态机服务<ul><li>受Chubby（Google的全局锁定服务）启发</li><li>最初在Yahoo得到应用，后来在Mesos, HBase广泛使用</li></ul></li><li>Apache 开源项目<ul><li><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">项目链接</a></li></ul></li><li>主从复制的案例研究</li><li>API支持广泛的用例</li><li>性能优越</li></ul><h2 id="发展zookeeper的动机"><a class="markdownIt-Anchor" href="#发展zookeeper的动机"></a> 发展Zookeeper的动机</h2><ul><li>服务集群中的许多应用程序需要协调通信<ul><li>例如对于GFS服务需要master存储每一个块服务器的列表，master决定哪一个块是primary等。</li></ul></li><li>应用程序之间需要相互发现<ul><li>MapReduce架构中需要了解GFS master的ip和port</li></ul></li><li>性能优越<ul><li>以lab3中3个节点的raft算法作对比，需要执行2次磁盘写入和一次消息往返，对于磁盘，大约50 msg/sec。对于ssd，大约200 msg/sec</li><li>但是Zookeeper能处理大约21,000 msg/sec,源于client允许异步调用机制，以及pipelining消息处理。</li></ul></li></ul><h2 id="zookeeper的替代方案为每一个应用程序开发容错的master服务"><a class="markdownIt-Anchor" href="#zookeeper的替代方案为每一个应用程序开发容错的master服务"></a> Zookeeper的替代方案：为每一个应用程序开发容错的master服务</h2><ul><li>根据DNS标识ip与端口</li><li>处理容错</li><li>高性能</li></ul><h2 id="zookeeper设计-通用的协调服务"><a class="markdownIt-Anchor" href="#zookeeper设计-通用的协调服务"></a> Zookeeper设计: 通用的协调服务</h2><ul><li><p>设计挑战</p><ul><li>API的设计</li><li>如何使master容错</li><li>如何获得良好的表现</li></ul></li><li><p>基本设计</p><ul><li>主从状态机</li><li>主从复制的是znodes对象</li><li>znodes以路径命名，拥有层次结构，类似于unix的文件系统</li><li>znodes包含应用程序的元数据（配置信息、时间戳、版本号）</li><li>znodes的类型：Regular(客户端通过显式创建和删除常规znode来操作它们)，empheral(客户端创建了此类znode，它们要么显式删除它们，要么让系统在创建它们的会话终止时（故意或由于失败）自动将其删除)</li><li>znode命名规则: name + 序列号。  如果n是新的znode，p是父znode，则n的序列值永远不会小于在p下创建的任何其他znode名称中的序列值</li></ul></li><li><p>会话(session)</p><ul><li>客户端连接上zookeeper时会初始化会话</li><li>会话允许在故障发生时，客户端请求转移到另一个服务（client知道最后完成操作的术语和索引）</li><li>会话有时间限制，client必须持续刷新会话（通过心跳检测）</li></ul></li><li><p>znodes上的操作</p><ul><li>create(path, data, flags)</li><li>delete(path, version) if znode.version = version, then delete</li><li>exists(path, watch)</li><li>getData(path, watch)</li><li>setData(path, data, version) if znode.version = version, then update</li><li>getChildren(path, watch)</li><li>sync() 除此操作的其他操作是异步的，每个client的所有操作均按FIFO顺序排序。同步会一直等到之前的所有操作都认可为止</li></ul></li><li><p>顺序保证</p><ul><li>所有写操作都是完全有序的</li><li>ZooKeeper会对所有client发起的写操作做全局统一排序</li><li>每一个client的操作都是FIFO顺序的。</li><li>read操作能够感知到相同客户端的其他写操作</li><li>read操作能够感知之前的写操作针对相同的znode</li></ul></li></ul><h2 id="ready-znode"><a class="markdownIt-Anchor" href="#ready-znode"></a> ready  znode</h2><ul><li>ZooKeeper中，新的leader可以将某个path指定为ready znode。 其他节点将仅在该znode存在时使用配置。</li><li>当leader 重建配置之后，会通知其他副本重建配置，并新建ready znode.</li><li>副本为了防止出现不一致，必须在重建配置时，处理完其之前的所有事务。保证所有服务的状态一致。</li><li>任何一个副本更新失败，都不能够应用都需要进行重试。</li></ul><h2 id="zookeeper使用lock的例子"><a class="markdownIt-Anchor" href="#zookeeper使用lock的例子"></a> Zookeeper使用lock的例子</h2><ul><li>下面的伪代码向我们锁的实现。通过create试图持有锁，如果锁已经被其他的client持有，则通过watch方式监控锁的释放。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">acquire lock:</span><br><span class="line">   retry:</span><br><span class="line">     r = create(&quot;app/lock&quot;, &quot;&quot;, empheral)</span><br><span class="line">     if r:</span><br><span class="line">       return</span><br><span class="line">     else:</span><br><span class="line">       getData(&quot;app/lock&quot;, watch=True)</span><br><span class="line"></span><br><span class="line">    watch_event:</span><br><span class="line">       goto retry</span><br><span class="line"></span><br><span class="line">  release lock: </span><br><span class="line">    delete(&quot;app/lock&quot;)</span><br></pre></td></tr></table></figure><ul><li>由于上面的伪代码可能会出现羊群效应，可以尝试下面的方式</li><li>znode下方的children中，序号最低的的是持有锁的</li><li>其他在等待的client只watch前一个znode的变化，避免了羊群效应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">acquire lock:</span><br><span class="line">   n = create(&quot;app/lock/request-&quot;, &quot;&quot;, empheral|sequential)</span><br><span class="line"> retry:</span><br><span class="line">   requests = getChildren(l, false)</span><br><span class="line">   if n is lowest znode in requests:</span><br><span class="line">     return</span><br><span class="line">   p = &quot;request-%d&quot; % n - 1</span><br><span class="line">   if exists(p, watch = True)</span><br><span class="line">     goto retry</span><br><span class="line"></span><br><span class="line">  watch_event:</span><br><span class="line">     goto retry</span><br></pre></td></tr></table></figure><h2 id="zookeeper简化程序构建但其不是最终的解决方案"><a class="markdownIt-Anchor" href="#zookeeper简化程序构建但其不是最终的解决方案"></a> Zookeeper简化程序构建但其不是最终的解决方案</h2><ul><li>应用程序还有许多需要解决的问题</li><li>例如如果我们要在GFS中使用Zookeeper，那么我们还需要<ul><li>chunks的副本方案</li><li>primary失败的协议</li><li>…</li></ul></li><li>但是使用了Zookeeper，至少可以使master容错，不会发生网络分区脑裂的问题</li></ul><h2 id="zookeeper实现细节"><a class="markdownIt-Anchor" href="#zookeeper实现细节"></a> Zookeeper实现细节</h2><ul><li>和lab3相似</li><li>具有两层<ul><li>ZooKeeper 服务层  (K/V 层)</li><li>ZAB 层 (Raft 层)</li></ul></li><li>Start() 在底层执行插入操作</li><li>随后，ops从每个副本服务器的底层弹出，这些操作按照弹出的顺序提交(commited),在lab3中使用apply channel，在ZAB层中，通过调用abdeliver()</li></ul><h2 id="挑战处理重复的客户端请求"><a class="markdownIt-Anchor" href="#挑战处理重复的客户端请求"></a> 挑战：处理重复的客户端请求</h2><ul><li>场景：primary收到客户端请求后，返回失败，客户端进行重试</li><li>在lab3中，我们使用了map来解决重复的请求问题，但是每一个客户端时候堵塞的，只能够等待完成才能进行下一个</li><li>在Zookeeper中，在一段时间内的操作是幂等的，以最后一次操作为准</li></ul><h2 id="挑战-读取操作的效率"><a class="markdownIt-Anchor" href="#挑战-读取操作的效率"></a> 挑战： 读取操作的效率</h2><ul><li>大部分的操作都是读取操作，他们不修改状态</li><li>读取操作是否必须通过ZAB层？</li><li>任何副本服务器都可以执行读取操作？</li><li>如果读取操作通过Raft/ZAB层，则性能会降低</li><li>读取操作如果不通过Raft/ZAB层、可能会返回过时的数据</li></ul><h2 id="zookeeper解决方案允许返回过时的数据"><a class="markdownIt-Anchor" href="#zookeeper解决方案允许返回过时的数据"></a> Zookeeper解决方案：允许返回过时的数据</h2><ul><li>读取可以由任何副本执行</li><li>读取吞吐量随着服务器数量的增加而增加</li><li>读取返回它看到的最后一个zxid</li><li>只有sync-read() 保证数据不过时</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h2&gt;
&lt;p&gt;阅读： [&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/zookeeper.pd
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>微服务理论与实践[1]-什么是微服务</title>
    <link href="https://dreamerjonson.com/2020/01/31/Microservices-1/"/>
    <id>https://dreamerjonson.com/2020/01/31/Microservices-1/</id>
    <published>2020-01-31T02:37:33.000Z</published>
    <updated>2020-02-04T06:18:22.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是微服务"><a class="markdownIt-Anchor" href="#什么是微服务"></a> 什么是微服务</h2><img src="/2020/01/31/Microservices-1/0.jpg"><ul><li>微服务 (Microservices) 是一种软件架构风格，将应用程序构造为围绕业务的小型自治服务的集合</li><li>微服务以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础。每个服务都是独立的，并实现单个业务功能</li><li>微服务利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API 集相互通信</li><li>微服务运用了以业务功能为主导的设计概念，应用程序在设计时就能先以业务功能或流程设计先行分割，将各个业务功能都独立实现成一个能自主运行的个体服务，然后再利用相同的协议将所有应用程序需要的服务都组合起来，形成一个应用程序</li></ul><h2 id="微服务例子1"><a class="markdownIt-Anchor" href="#微服务例子1"></a> 微服务例子1</h2><ul><li>以购物车应用程序为例，当打开购物车应用程序时，您看到的只是一个网站。但是，在后台，购物车应用程序具有用于接受付款服务，客户服务等</li><li>假设此应用程序的开发人员使用了单体框架，架构如下图:</li></ul><img src="/2020/01/31/Microservices-1/1.png" title="单体"><center><div>单体架构</div></center><ul><li>如图，在单体架构中，所有功能都放在一个代码库中，并在一个基础数据库下。</li><li>现在，假设市场上出现了一个新品牌，并且开发人员希望将即将到来的品牌的所有详细信息放入此应用程序中</li><li>此时，不仅需要处理新品牌的服务，而且还必须重新构建整个系统并相应地进行部署。为了避免此类挑战，开发人员决定将其应用程序从单体架构转换为微服务</li></ul><img src="/2020/01/31/Microservices-1/2.png" title="单体"><center><div>微服务架构</div></center><ul><li>开发人员为搜索，推荐，客户服务等创建了单独的微服务。</li><li>此微服务架构不仅可以帮助开发人员克服以前的架构所面临的所有挑战，而且还可以轻松地构建，部署和扩展购物车应用程序。</li></ul><h2 id="微服务例子2"><a class="markdownIt-Anchor" href="#微服务例子2"></a> 微服务例子2</h2><ul><li>以旅游行业应用程序为例</li></ul><img src="/2020/01/31/Microservices-1/3.jpg" title="单体"><center><div>整体架构</div></center>* 整体服务包括了旅客关系管理、付款、消息通知等服务* 传统的单体常常采用如上图所示的整体式架构，并采取MVC的设计模式* 三层架构（MVC）的具体内容如下  + 表示层（view）： 用户使用应用程序时，看到的、听见的、输入的或者交互的部分。  + 业务逻辑层（controller）： 根据用户输入的信息，进行逻辑计算或者业务处理的部分。  + 数据访问层（model）： 关注有效地操作原始数据的部分，如将数据存储到存储介质（如数据库、文件系统）及  + 从存储介质中读取数据等。* 虽然现在程序被分成了三层，但只是逻辑上的分层，并不是物理上的分层。也就是说，对不同层的代码而言，经过编译、打包和部署后，所有的代码最终还是运行在同一个进程中。单体架构在规模比较小的情况下工作情况良好，但是随着系统规模的扩大，它暴露出来的问题也越来越多，主要有以下几点：* 复杂性逐渐变高  + 比如有的项目有几十万行代码，各个模块之间区别比较模糊，逻辑比较混乱，代码越多复杂性越高，越难解决遇到的问题。*  技术债务逐渐上升   + 公司的人员流动是再正常不过的事情，有的员工在离职之前，疏于代码质量的自我管束，导致留下来很多坑，由于单体项目代码量庞大的惊人，留下的坑很难被发觉，这就给新来的员工带来很大的烦恼，人员流动越大所留下的坑越多，也就是所谓的技术债务越来越多。* 维护成本大  + 当应用程序的功能越来越多、团队越来越大时，沟通成本、管理成本显著增加。当出现 bug 时，可能引起 bug 的原因组合越来越多，导致分析、定位和修复的成本增加；并且在对全局功能缺乏深度理解的情况下，容易在修复bug 时引入新的 bug。* 持续交付周期长  + 构建和部署时间会随着功能的增多而增加，任何细微的修改都会触发部署流水线。新人培养周期长：新成员了解背景、熟悉业务和配置环境的时间越来越长。* 技术选型成本高  + 单块架构倾向于采用统一的技术平台或方案来解决所有问题，如果后续想引入新的技术或框架，成本和风险都很大。* 可扩展性差  + 随着功能的增加，垂直扩展的成本将会越来越大；而对于水平扩展而言，因为所有代码都运行在同一个进程，没办法做到针对应用程序的部分功能做独立的扩展。<h2 id="微服务架构"><a class="markdownIt-Anchor" href="#微服务架构"></a> 微服务架构</h2><img src="/2020/01/31/Microservices-1/4.jpg" title="单体"><center><div>整体架构</div></center><ul><li>将上面的整体架构改造为如上图所示的微服务</li><li>来自不同设备的不同客户端尝试使用不同的服务，例如搜索，构建，配置和其他管理功能</li><li>所有服务均根据其功能进行分离，并进一步分离为单个微服务</li><li>这些微服务具有自己的负载均衡和执行环境以执行其功能,并在其自己的数据库中捕获数据</li><li>微服务之间通过无状态服务器(REST、GRPC或消息总线)进行通信</li><li>微服务借助服务发现来了解其通信路径并执行自动化，监控等操作功能</li><li>微服务执行的所有功能通过API网关传达给客户端</li></ul><h2 id="微服务特点"><a class="markdownIt-Anchor" href="#微服务特点"></a> 微服务特点</h2><ul><li>解耦<ul><li>系统中的服务在很大程度上是解耦的。因此，整个应用程序可以轻松构建，更改和扩展</li></ul></li><li>组件化<ul><li>微服务被视为独立的组件，可以轻松替换和升级</li></ul></li><li>专注业务功能<ul><li>业务功能–微服务非常简单，专注于单一功能</li></ul></li><li>独立自主<ul><li>开发人员和团队可以彼此独立地工作，从而提高了速度</li></ul></li><li>持续交付<ul><li>通过自动化的构建、测试和部署，允许频繁发布软件。</li></ul></li><li>分散治理<ul><li>重点是使用正确的工具完成正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</li></ul></li><li>敏捷开发<ul><li>微服务支持敏捷开发。任何新功能都可以快速开发并丢弃</li></ul></li></ul><h2 id="微服务的优点"><a class="markdownIt-Anchor" href="#微服务的优点"></a> 微服务的优点</h2><ul><li>单一职责<ul><li>微服务架构中的每个服务，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。</li></ul></li><li>轻量级通信<ul><li>服务之间通过轻量级的通信机制实现互通互联，而所谓的轻量级，通常指语言无关、平台无关的交互方式。</li><li>对于轻量级通信的格式而言，我们熟悉的 XML 和 JSON，它们是语言无关、平台无关的；对于通信的协议而言，通常基于 HTTP，能让服务间的通信变得标准化、无状态化。目前大家熟悉的 REST（Representational StateTransfer）、GRPC是实现服务间互相协作的轻量级通信机制之一。使用轻量级通信机制，可以让团队选择更适合的语言、工具或者平台来开发服务本身。</li></ul></li><li>提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪</li><li>独立性<ul><li>服务独立测试、部署、升级、发布</li><li>在单块架构中所有功能都在同一个代码库，功能的开发不具有独立性；当不同小组完成多个功能后，需要经过集成和回归测试，测试过程也不具有独立性；当测试完成后，应用被构建成一个包，如果某个功能存在 bug，将导致整个部署失败或者回滚</li></ul></li><li>新技术的应用，系统不会被长期限制在某个技术栈上</li><li>可以根据市场需求，灵活多变的组合出新的业务场景</li><li>降低代码耦合度</li><li>服务实例水平扩展，服务单一职责，功能独立。保证可靠性与性能，提升资源利用<ul><li>由于微服务是以业务功能导向的实现，因此不会受到应用程序的干扰，微服务的管理员可以视运算资源的需要来配置微服务到不同的运算资源内，或是布建新的运算资源并将它配置进去</li></ul></li><li>提升开发交流，每个服务足够内聚，足够小，代码容易理解</li><li>进程隔离、故障隔离<ul><li>单块架构中，整个系统运行在同一个进程中，当应用进行部署时，必须停掉当前正在运行的应用，部署完成后再重启进程，无法做到独立部署。<br>有时候我们会将重复的代码抽取出来封装成组件，在单块架构中，组件通常的形态叫做共享库（如 jar 包或者DLL），但是当程序运行时，所有组件最终也会被加载到同一进程中运行。</li><li>在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上。</li></ul></li></ul><ul><li>即使应用程序的一项服务不起作用，系统仍然可以继续运行</li></ul><ul><li>数据分区，数据独立，可靠性保证</li></ul><h2 id="微服务的缺点"><a class="markdownIt-Anchor" href="#微服务的缺点"></a> 微服务的缺点</h2><ul><li>微服务提高了系统的复杂度</li><li>开发人员要处理分布式系统的复杂性</li><li>服务之间的分布式事务问题</li><li>服务的注册与发现问题</li><li>数据隔离再来的报表处理问题</li><li>不同服务实例的管理困难，持续自动化部署的要求</li><li>运维要求较高<ul><li>对于单体架构来讲，我们只需要维护好这一个项目就可以了，但是对于微服务架构来讲，由于项目是由多个微服务构成的，每个模块出现问题都会造成整个项目运行出现异常，想要知道是哪个模块造成的问题往往是不容易的，因为我们无法一步一步通过debug的方式来跟踪，这就对运维人员提出了很高的要求。</li></ul></li><li>分布式的复杂性</li></ul><ul><li>对于单体架构来讲，我们可以不使用分布式，但是对于微服务架构来说，分布式几乎是必会用的技术，由于分布式本身的复杂性，导致微服务架构也变得复杂起来。</li></ul><ul><li>接口调整成本高<ul><li>比如，用户微服务是要被订单微服务和电影微服务所调用的，一旦用户微服务的接口发生大的变动，那么所有依赖它的微服务都要做相应的调整，由于微服务可能非常多，那么调整接口所造成的成本将会明显提高。</li></ul></li></ul><h2 id="微服务的沟通"><a class="markdownIt-Anchor" href="#微服务的沟通"></a> 微服务的沟通</h2><h3 id="沟通与事件广播"><a class="markdownIt-Anchor" href="#沟通与事件广播"></a> 沟通与事件广播</h3><p>微服务的规划与单体式应用程序十分不同，微服务中每个服务都需要避免与其他服务有所牵连，且都要能够自主，并在其他服务发生错误时不受干扰。<br>倘若真有沟通，也应采用异步沟通的方式来避免紧密的相依性问题。要达到此目的，则可用下列两种方式：</p><ul><li><p>事件存储中心（Event Store）<br>这可以让你在服务集群中广播事件，并且在每个服务中监听这些事件并作处理，这令服务之间没有紧密的相依性，而这些发生的事件都会被保存在事件存储中心里。这意味着当微服务重新上线、部署时可以重播（Replay）所有的事件。这也造就了微服务的数据库随时都可以被删除、摧毁，且不需要从其他服务中获取数据。</p></li><li><p>消息队列（Message Queue）</p><ul><li>能够在服务集群中广播消息，并传递到每个服务中</li><li>比较有名的消息中间件如：NSQ、RabbitMQ、Nats、Kafka</li><li>A 服务上广播一个事件，此事件可以顺带一些数据。B 服务可以监听这个事件并在接收到之后有所处理。这些过程都是异步处理的</li><li>A 服务并不需要等到 B 服务处理完该事件后才能继续，而这也代表 A 服务无法获取 B 服务的处理结果</li><li>与事件存储中心不同的是：消息队列并不会保存事件。一旦事件被消化（接收）后就会从队列中消失</li></ul></li></ul><h3 id="服务发现"><a class="markdownIt-Anchor" href="#服务发现"></a> 服务发现</h3><ul><li>单个微服务在上线的时候，会向服务注册中心注册自己的 IP 位置、服务内容</li><li>当服务需要调用另一个服务的时候，会去询问服务探索中心该服务的 IP 位置，得到位置后即可直接向目标服务发起调用</li><li>这么做的用意是可以统一集中所有服务的位置，就不会分散于每个微服务中</li><li>服务探索中心可以每隔一段时间就向微服务进行健康检查（TCP 调用、HTTP 调用、Ping）</li><li>倘若该服务在时间内没有回应，则将其从服务中心移除，避免其他微服务对一个无回应的服务进行调用</li><li>即便微服务重新在其他ip上部署，其他服务也是无感知的</li><li>比较常用的服务发现有：etcd，consul，普遍都采用了raft等分布式算法</li></ul><h2 id="微服务其他需要考虑的因素"><a class="markdownIt-Anchor" href="#微服务其他需要考虑的因素"></a> 微服务其他需要考虑的因素</h2><ul><li>网络延迟</li><li>分布式事务</li><li>限流<ul><li>例如一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉。</li><li>因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。</li></ul></li><li>熔断<ul><li>当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。</li><li>如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。</li></ul></li><li>服务降级<ul><li>当Service A调用Service B，失败多次达到一定阀值，Service A不会再去调Service B，而会去执行本地的降级方法。</li><li>降级服务其实就是牺牲掉一些逻辑处理，或者停止部分依赖服务的请求。以保障服务可以提供关键能力</li></ul></li><li>权限控制<ul><li>API网关</li></ul></li><li>分布式追踪</li><li>分布式日志记录</li><li>配置中心</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">维基百科：微服务</a><br><a href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener">什么是微服务架构？</a><br><a href="https://www.edureka.co/blog/what-is-microservices/" target="_blank" rel="noopener">What Is Microservices – Introduction To Microservice Architecture</a><br><a href="https://wumansgy.github.io/2018/12/22/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">微服务介绍</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是微服务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是微服务&quot;&gt;&lt;/a&gt; 什么是微服务&lt;/h2&gt;
&lt;img src=&quot;/2020/01/31/Microservices-1/0.jpg&quot;&gt;
&lt;ul&gt;
&lt;li&gt;微服务 (Mic
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>6.824分布式系统[3]-主从复制</title>
    <link href="https://dreamerjonson.com/2020/01/28/distributed-systerm-3-replication/"/>
    <id>https://dreamerjonson.com/2020/01/28/distributed-systerm-3-replication/</id>
    <published>2020-01-28T07:14:14.000Z</published>
    <updated>2020-01-30T12:05:08.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>阅读：<a href="https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf" target="_blank" rel="noopener">Fault-Tolerant Virtual Machines</a></p><h2 id="为什么要阅读这篇文章"><a class="markdownIt-Anchor" href="#为什么要阅读这篇文章"></a> 为什么要阅读这篇文章</h2><ul><li>了解分布式系统的容错机制</li><li>本文是对于容错机制的比较特殊的实现，其并不是要设计一个应用程序级别的容错系统，而是一个系统级别的。需要处理中断，能够为了实现一个容错的虚拟机系统（VM-FT），难度更大。</li></ul><h2 id="容错fault-tolerance"><a class="markdownIt-Anchor" href="#容错fault-tolerance"></a> 容错（Fault tolerance）</h2><ul><li>即使发生故障也会继续提供服务的能力<br>一些理想的属性：</li><li>可用性：尽管[某些故障]仍然可用</li><li>一致性：对于客户端来说就像一台服务器</li><li>对用户和软件透明（内部运行机制透明）</li><li>高效</li></ul><h2 id="我们将尝试解决哪些失败"><a class="markdownIt-Anchor" href="#我们将尝试解决哪些失败"></a> 我们将尝试解决哪些失败？</h2><ul><li>失败-停止错误</li><li>网络丢包</li><li>网络分区</li></ul><h2 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想</h2><ul><li>容错的核心思想是建立副本，需要两个以上的服务器。</li><li>每一个副本都维持相同的状态，如果一个服务器失败,其他服务器可以继续进行。</li><li>需要思考的重要问题：<ul><li>什么状态需要去复制？</li><li>primary（主服务器）需要等待副本服务器复制完成吗？</li><li>什么时候需要切换到副本服务器</li><li>转换时是否可见异常？</li><li>转换到副本时能否加速？</li></ul></li></ul><h2 id="两种主要的方式"><a class="markdownIt-Anchor" href="#两种主要的方式"></a> 两种主要的方式</h2><ul><li>状态转移<ul><li>primary执行操作</li><li>primary将状态转移到副本</li><li>状态转移虽然简单，但是状态可能很大，转移可能很慢</li><li>论文中的虚拟机使用了复制状态机。</li></ul></li><li>复制状态机<ul><li>所有副本执行所有操作</li><li>相同的开始状态</li><li>相同的操作</li><li>相同的顺序</li><li>确定性的操作</li><li>则具有相同的最终状态</li><li>更有效率，但是更复杂</li></ul></li></ul><h2 id="本论文的目标"><a class="markdownIt-Anchor" href="#本论文的目标"></a> 本论文的目标</h2><ul><li>构建复制状态机</li><li>Primary和副本具有相同的初始状态（内存，磁盘文件）</li><li>primary通过日志通道（logging channel）传递给副本服务器</li><li>相同的指令、相同的输入、相同的执行</li></ul><h2 id="什么时候在主数据库上执行与备份上可能不同"><a class="markdownIt-Anchor" href="#什么时候在主数据库上执行与备份上可能不同"></a> 什么时候在主数据库上执行与备份上可能不同？</h2><ul><li>来自外部的输入（网络）</li><li>从存储服务器读取的数据</li><li>定时器中断（Timing of interrupts）。 参考：<a href="https://en.wikibooks.org/wiki/Operating_System_Design/Processes/Interrupt" target="_blank" rel="noopener">wikibook</a></li><li>一些特殊的指令：循环计数</li><li>冲突（）</li></ul><h2 id="不一致的原因"><a class="markdownIt-Anchor" href="#不一致的原因"></a> 不一致的原因</h2><ul><li>锁定服务器将锁定授予客户端C1，拒绝来自C2的后续请求</li><li>锁定服务器在一分钟后撤消锁定</li><li>假设C1持有锁并且，1分钟马上就要到时，c2请求锁。这时，Primary可能会在定时器1分钟发送中断之前立即看到C2的请求，拒绝其请求。副本可能会在定时器1分钟发送中断之后看到C2的请求，同意它。</li><li>因此：副本必须在指令流中的同一点以相同的顺序看到相同的事件。</li></ul><h2 id="解决定时器中断的解决方案"><a class="markdownIt-Anchor" href="#解决定时器中断的解决方案"></a> 解决定时器中断的解决方案</h2><ul><li>primary</li></ul><ul><li>FT 收到定时器中断信号</li><li>FT从CPU读取指令号</li><li>FT在日志通道（logging channel）上发送的&quot;在指令x处触发计时器中断”</li><li>FT给primary发送中断信号，然后恢复。</li></ul><ul><li>Backup</li></ul><ul><li>忽略自己的计时器硬件</li><li>在副本得到指令X之前，观察是否日志中有需要在这之前执行的日志。</li><li>FT告诉CPU在指令X处中断</li><li>FT模拟计时器中断，然后恢复。</li></ul><h2 id="解决磁盘-网络数据输入可能不一致的问题"><a class="markdownIt-Anchor" href="#解决磁盘-网络数据输入可能不一致的问题"></a> 解决磁盘、网络数据输入可能不一致的问题</h2><p>FT拦截，只能够让primary能够访问硬件。</p><ul><li>Primary:<ul><li>FT通知硬件通过方式将数据存入FT的私有缓存中</li><li>在某一时刻，硬件执行DMA，然后中断</li><li>FT收到中断信号</li><li>FT暂停primary</li><li>FT复制缓冲区数据到primary内存中。</li><li>FT为primary模拟中断，稍后恢复。</li><li>FT将数据和指令发送到备份<br>Backup:</li><li>FT从日志流中获取数据和指令</li><li>FT告诉CPU在指令X处中断</li><li>FT在中断期间复制数据</li></ul></li></ul><p>缓冲区（bounce buffer）的目的就是为了在内存的同一个时间点执行相同的操作，读取相同的数据。</p><h2 id="解决特殊的指令"><a class="markdownIt-Anchor" href="#解决特殊的指令"></a> 解决特殊的指令</h2><ul><li>Primary:<ul><li>如果primary执行了特殊的指令，FT会通知CPU中断</li><li>FT执行指令并记录结果</li><li>将结果和指令发送到备份</li></ul></li><li>Backup:<ul><li>副本在执行此指令时也会中断。</li><li>副本应用从primary中得到的值。</li></ul></li></ul><h2 id="output-rule"><a class="markdownIt-Anchor" href="#output-rule"></a> Output Rule</h2><ul><li>primary必须在副本收到此输出指令的日志后，才能够输出。</li><li>此规则是必要的，因为我们的服务是为了在奔溃时让用户是无感知的。</li><li>有了此规则，即便peimary奔溃了，副本也能够和primary一样，对于之前的请求返回相同的数据。<ul><li>假设primary收到请求I1 I2 I3 并输出, 这时primary奔溃，副本只能看到I1，I2。这时 一个之前收到I1，I2，I3的客户端由于切换到副本后，相同的请求就只能看到I1，I2。</li></ul></li><li>增加了延迟，限制了性能。</li></ul><h2 id="问-答"><a class="markdownIt-Anchor" href="#问-答"></a> 问 &amp; 答</h2><h3 id="如果primary收到副本对于i3-ack确认后奔溃会发生什么"><a class="markdownIt-Anchor" href="#如果primary收到副本对于i3-ack确认后奔溃会发生什么"></a> 如果primary收到副本对于I3 ack确认后奔溃，会发生什么？</h3><p>这时会切换到副本运行，而副本会执行I3命令，并返回给客户端。</p><h3 id="如果primary在发出输出之后崩溃了怎么办"><a class="markdownIt-Anchor" href="#如果primary在发出输出之后崩溃了怎么办"></a> 如果primary在发出输出之后崩溃了怎么办？</h3><p>副本会立即接管。<br>对于TCP传输：接收者将忽略重复的序列号。<br>对于磁盘：副本将相同的数据写入相同的块。</p><h3 id="如果网络分区primary和副本都认为彼此失活"><a class="markdownIt-Anchor" href="#如果网络分区primary和副本都认为彼此失活"></a> 如果网络分区，primary和副本都认为彼此失活？</h3><p>共享磁盘只允许唯一的一个primary。</p><h3 id="为什么确定性的操作在物理硬件上比虚拟机上更难"><a class="markdownIt-Anchor" href="#为什么确定性的操作在物理硬件上比虚拟机上更难"></a> 为什么确定性的操作，在物理硬件上比虚拟机上更难？</h3><p>虚拟机管理程序（hypervisor）模拟和控制硬件的许多操作，这些操作可能会导致primary和副本执行不同。例如定时中断(timing interrupts)</p><h3 id="什么是虚拟机管理程序hypervisor"><a class="markdownIt-Anchor" href="#什么是虚拟机管理程序hypervisor"></a> 什么是虚拟机管理程序（hypervisor）</h3><p>管理程序是虚拟机系统的一部分，和虚拟机监视器（VMM）一样。 系统管理程序模拟计算机以及在其中运行的操作系统和程序。<br>在本文中，primary和副本是运行在虚拟机中的guest操作系统。而FT是实现每个虚拟机的管理程序的一部分。</p><h3 id="gfs和vmware-ft均提供容错功能谁更好"><a class="markdownIt-Anchor" href="#gfs和vmware-ft均提供容错功能谁更好"></a> GFS和VMware FT均提供容错功能，谁更好？</h3><ul><li>FT更底层强大，对内存,网络包和磁盘提供了一种容错能力。可以使用它为所有运行在其上的服务透明地提供容错功能。</li><li>GFS仅提供存储容错功能。 由于GFS专用于特定的简单服务（存储），因此其复制比FT更有效。 例如，GFS不需要使中断在所有副本上的完全相同的指令处发生。</li><li>GFS是应用程序级别的具有容错能力的大型应用程序之一。</li></ul><h3 id="缓冲区如何帮助避免冲突"><a class="markdownIt-Anchor" href="#缓冲区如何帮助避免冲突"></a> 缓冲区如何帮助避免冲突</h3><p>网络数据包或请求的磁盘块到达primary并且要复制到primary的内存时，</p><ul><li>没有FT，相关硬件将数据复制到内存中，同时 软件正在执行。操作系统指令可以在DMA期间读取该内存。由于冲突，在某一时刻，可能无法看到DMA的数据。因此可能出现由于primary与副本的时间不同，一个能看到，一个不能看到这个数据。</li></ul><h2 id="表现"><a class="markdownIt-Anchor" href="#表现"></a> 表现</h2><ul><li>logging带宽<ul><li>直接反应磁盘读取率 + 网络输入率</li><li>大约18 Mbit/s for my-sql</li></ul></li><li>比较慢应用程序可以至少400 Mbps的速度读取磁盘</li><li>用途<ul><li>关键但强度较低的服务，例如 名称服务器。</li><li>其软件不便于修改的服务。</li></ul></li></ul><h2 id="高吞吐量服务的复制"><a class="markdownIt-Anchor" href="#高吞吐量服务的复制"></a> 高吞吐量服务的复制</h2><pre><code>* 人们将应用程序级复制状态机用于例如 数据库。* 状态只是DB，而不是全部的内存和磁盘。* 事件是数据库命令（put或get），而不是数据包和中断。* 更少的细粒度同步，更少的开销。* GFS使用应用程序级复制，与lab2相似。</code></pre><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://pdos.csail.mit.edu/6.824/notes/l-vm-ft.txt" target="_blank" rel="noopener">讲义</a><br><a href="https://pdos.csail.mit.edu/6.824/papers/vm-ft-faq.txt" target="_blank" rel="noopener">FAQ</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h2&gt;
&lt;p&gt;阅读：&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf&quot; tar
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>6.824分布式系统[2]-GFS案例学习</title>
    <link href="https://dreamerjonson.com/2020/01/21/distributed-systerm-2-GFS/"/>
    <id>https://dreamerjonson.com/2020/01/21/distributed-systerm-2-GFS/</id>
    <published>2020-01-21T07:05:28.000Z</published>
    <updated>2020-01-27T08:32:16.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><ul><li>GFS是Google在2003年发出的经典论文，其作为分布式文件系统实际应用在Google的MapReduce框架实现中作为原始数据和最终结果存储的基础服务，</li><li>同时为其他上层基础系统比如BigTable提供服务。Hadoop中的HDFS就是其开源实现。</li><li>这篇文章讨论了诸如一致性、容错、网络性能等分布式系统工程中的经典问题，启发了后续很多分布式文件系统的发展。</li></ul><h2 id="为什么阅读gfs的论文"><a class="markdownIt-Anchor" href="#为什么阅读gfs的论文"></a> 为什么阅读GFS的论文</h2><ul><li>GFS使用了map/reduce的架构</li><li>好的性能 —— 良好的并行I/O性能</li><li>其实一篇好的系统论文 —— 从apps到网络都有细节说明</li><li>包含分布式的许多概念：performance, fault-tolerance, consistency</li><li>使用广泛（Bigtable、Spanner、Hadoop）</li></ul><h2 id="一致性是什么"><a class="markdownIt-Anchor" href="#一致性是什么"></a> 一致性是什么</h2><ul><li>保证正确的条件，在有多个副本、并且并发下变得尤其困难。</li><li>一致性是分布式系统中最关键的问题，基本所有分布式系统都必须讨论这个问题。</li><li>即考虑如果在一个程序中写，但是在另一个程序的副本中读取的情况。<br>— 强的一致性会保证在另一个程序中读取到的一定是发生在最后一次写入之后。<br>— 弱的一致性无法对其进行保证，可能会读取到过时的数据。</li><li>强一致性可以保证读到最新的写信息，但是对性能肯定会造成影响，好的系统设计就是在这两点中进行平衡。</li></ul><h2 id="理想的一致性模型"><a class="markdownIt-Anchor" href="#理想的一致性模型"></a> 理想的一致性模型</h2><p>分布式文件系统需要达成的“理想的“一致性就是多节点上面操作文件表现处理单机跟本地文件系统一样。</p><ul><li>如果两个应用程序同时写入同一文件怎么办？<br>— 在单机，数据常常有一些混合的内容。即两个程序的处理可能是交错的。</li><li>如果两个应用程序同时写入同一目录怎么办<br>— 在单机，使用了锁。一个应用程序处理完毕后，再处理第二个。</li><li>挑战<br>— 多磁盘<br>— 机器故障，操作无法完成。<br>— 网络分区，可能不能够到达所有的机器和磁盘。</li><li>挑战难以解决的原因<br>— 需要客户端和服务器之间的通信<br>— 协议可能会变得复杂</li></ul><h2 id="不同的模型考虑不同的权衡"><a class="markdownIt-Anchor" href="#不同的模型考虑不同的权衡"></a> 不同的模型考虑不同的权衡</h2><p>— 可串行性(serializability)<br>— 顺序一致性(sequential consistency)<br>— 线性一致性(linearizability)<br>— 单项一致性模型(entry consistency)<br>— 松散一致性(release consistency)</p><h2 id="gfs的目标"><a class="markdownIt-Anchor" href="#gfs的目标"></a> GFS的目标</h2><ul><li>GFS中节点失效就是常见的（每天1000台机器中大约3台失效）</li><li>高性能：大量</li><li>有效的使用网络</li></ul><h2 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> 设计</h2><ul><li>master存储（directories, files, names）</li><li>存储64MB的块，每个块就作为一个linux文件。</li><li>每个块在三台服务器上面做备份（保证可用性，负载均衡）</li><li>块为什么这么大（摊销间接费用、减少master中的状态大小</li><li>master掌握目录的层次结构<br>— 文件夹中有哪些文件<ul><li>对于文件，知道哪些节点存储了此文件。<br>— master在内存中保持状态（每个块的64字节元数据）<br>— 主数据库具有用于元数据的私有可恢复数据库<br>— 操作日志刷新到磁盘<br>— 检查点<br>— master快速恢复<br>— shadow masters略微落后于master</li></ul></li></ul><h2 id="客户端读"><a class="markdownIt-Anchor" href="#客户端读"></a> 客户端读</h2><ul><li>发送文件名和块索引给master</li><li>master回复具有该块的服务器集<br>— 回复版本号<br>— client缓存信息</li><li>请求块服务器<br>— 版本号（如果版本号错误，重新连接master）</li></ul><h2 id="primary"><a class="markdownIt-Anchor" href="#primary"></a> primary</h2><p>primary是一个副本节点的比较高级的</p><h2 id="修改现有文件"><a class="markdownIt-Anchor" href="#修改现有文件"></a> 修改现有文件</h2><ul><li>client请求master 块的位置 和primary的位置</li><li>master回复块服务器，版本已经primary的位置</li><li>client根据网络拓扑计算副本链</li><li>客户端将数据发送到第一个副本节点，然后此副本节点转发给其他人</li><li>副本节点会ack，表明数据已被接收</li><li>client 告诉primary写入数据</li><li>primary分配序列号并写入<br>— primary 告诉其他副本写入<br>— 全部成功后，回复client</li><li>如果另一个客户端并发在同一位置写入数据，该怎么办？<br>— c1 与c2 可能会交替的写入，结果是一致性的，但是不能保证的。</li></ul><h2 id="添加文件"><a class="markdownIt-Anchor" href="#添加文件"></a> 添加文件</h2><ul><li>client 请求master 块的位置。</li><li>client将数据发送给副本，但是没有指定偏移量。</li><li>当数据在所有的块服务器上后，client联系primary</li><li>primary分配序列号</li><li>primary检查是否能够刚好添加到一个块中</li><li>primary为添加选择偏移量，进行添加</li><li>转发请求到其他副本</li><li>失败后进行重试<br>— 不能使用下一个可用偏移量，因为在失败的节点中可能会有空字节。</li><li>GFS支持原子操作，保证至少一次添加，主Chunk服务器选择记录需要添加到的文件位置，然后发送给其他副本。</li><li>如果和一个副本的联系失败，那么主Chunk服务器会告诉客户端重试，如果重试成功，有些副本会出现追加两次的情况(因为这个副本追加成功两次)。</li><li>当GFS要去填塞chunk的边缘时，如果追加操作跨越chunk的边缘，那么文件也可能存在空洞。</li></ul><h2 id="失败情况"><a class="markdownIt-Anchor" href="#失败情况"></a> 失败情况</h2><p>块服务器的失败会引起client重试。<br>master失败会导致GFS不可用，shadow master会服务只读的状态。可能会返回过时的数据。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>性能，容错，一致性（performance, fault-tolerance, consistency）的案例研究</p><ul><li>优势<br>— 大量的顺序读取和写入<br>— 追加文件高效<br>— 大的吞吐量<br>— 数据容错（3个副本）</li><li>劣势<br>— master服务器的容错<br>— 小文件（master服务器的瓶颈）<br>— client会看到过时的数据（弱的一致性）<br>— 追加可能重复</li></ul><h2 id="gfs案例问答"><a class="markdownIt-Anchor" href="#gfs案例问答"></a> GFS案例问答</h2><h3 id="为什么添加数据执行至少一次at-least-once语义而不是精准的一次"><a class="markdownIt-Anchor" href="#为什么添加数据执行至少一次at-least-once语义而不是精准的一次"></a> 为什么添加数据执行至少一次&quot;at-least-once&quot;语义，而不是精准的一次？</h3><p>实现困难，primary需要保留重复的状态。状态必须在服务器之间复制，以便如果primary出现故障, 此信息不会丢失。</p><h3 id="应用程序如何知道块的哪些是有数据的块哪些是重复的数据"><a class="markdownIt-Anchor" href="#应用程序如何知道块的哪些是有数据的块哪些是重复的数据"></a> 应用程序如何知道块的哪些是有数据的块，哪些是重复的数据</h3><p>可以在有效记录的开头做标识（magic number）就可以知道有数据的块。<br>检测重复的块可以为每个记录都有一个特殊的UID标识。</p><h3 id="论文中提到的reference-counts是什么意思"><a class="markdownIt-Anchor" href="#论文中提到的reference-counts是什么意思"></a> 论文中提到的reference counts是什么意思</h3><ul><li>他们是实现快照copy-on-write（写时复制）的一部分。</li><li>当GFS创建快照时，它不复制块，而是增加每个块的引用计数器。</li><li>这使得创建快照的成本不高。 如果客户端写入了一个块，并且主服务器注意到引用计数大于1，</li><li>则主服务器会首先创建一个副本，以便客户端可以更新副本（而不是快照的一部分）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GFS是Google在2003年发出的经典论文，其作为分布式文件系统实际应用在Google的MapReduce框架实现中作为原始数据
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[114]-raft理论与实践[5]-lab2c-持久化</title>
    <link href="https://dreamerjonson.com/2020/01/16/golang-114-raft-5-presis/"/>
    <id>https://dreamerjonson.com/2020/01/16/golang-114-raft-5-presis/</id>
    <published>2020-01-16T14:20:29.000Z</published>
    <updated>2020-01-18T12:12:55.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>1、阅读<a href="http://nil.csail.mit.edu/6.824/2017/papers/raft-extended.pdf" target="_blank" rel="noopener">raft论文</a><br>2、阅读<a href="https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/">raft理论与实践[1]-理论篇</a><br>3、阅读<a href="https://dreamerjonson.com/2020/01/06/golang-111-raft-2/">raft理论与实践[2]-lab2a</a><br>4、阅读<a href="https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/">raft理论与实践[3]-lab2a讲解</a><br>5、阅读<a href="https://dreamerjonson.com/2020/01/12/golang-113-raft-4-log/">raft理论与实践[4]-lab2b日志复制</a><br>6、查看我写的这篇文章： <a href="https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/">模拟RPC远程过程调用</a></p><h2 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h2><ul><li><p>如果基于Raft的服务器重新启动，则应从中断的位置恢复服务。 这就要求Raft保持持久状态，使其在重启后仍然有效。</p></li><li><p>论文中Figure 2指出了那些字段需要持久化。</p></li><li><p>并且raft.go包含有关如何保存和恢复持久性状态的示例。</p></li><li><p>一个“真实的服务在每次Raft更改状态时将Raft的持久状态写入磁盘，并在重新启动时从磁盘读取最新的状态来恢复。</p></li><li><p>但是我们的实现将会采用一个结构体的方式来模拟实现persister.go。</p></li><li><p>调用Raft.Make（）会提供一个Persister，它持有Raft的最近持久状态。</p></li><li><p>Raft应从该Persister初始化其状态，并在每次状态更改时修改其持久状态。</p></li><li><p>主要使用Persister的ReadRaftState（）和SaveRaftState（）方法。</p></li><li><p>在本实验中，我们需要完善在raft.go中的persist() and readPersist()方法。</p></li><li><p>需要使用到labgob包中的编码与解码函数。</p></li><li><p>你需要明确在什么时候需要持久化。</p></li></ul><p>下面只列出两个重要实现，其他不再赘述，留给读者自己实现。</p><h2 id="持久化编码"><a class="markdownIt-Anchor" href="#持久化编码"></a> 持久化编码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">persist</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (2C).</span></span><br><span class="line">w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line"></span><br><span class="line">e:= labgob.NewEncoder(w)</span><br><span class="line">e.Encode(rf.CurrentTerm)</span><br><span class="line">e.Encode(rf.VotedFor)</span><br><span class="line">e.Encode(rf.Logs)</span><br><span class="line"></span><br><span class="line">data := w.Bytes()</span><br><span class="line">rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化解码"><a class="markdownIt-Anchor" href="#持久化解码"></a> 持久化解码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) readPersist(data []byte) &#123;</span><br><span class="line">if data == nil || len(data) &lt; 1 &#123; // bootstrap without any state?</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// Your code here (2C).</span><br><span class="line">r := bytes.NewBuffer(data)</span><br><span class="line"></span><br><span class="line">d:= labgob.NewDecoder(r)</span><br><span class="line">d.Decode(&amp;rf.CurrentTerm)</span><br><span class="line">d.Decode(&amp;rf.VotedFor)</span><br><span class="line">d.Decode(&amp;rf.Logs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; go test -v -run=2C</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h2&gt;
&lt;p&gt;1、阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/raft-exten
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>6.s081[2]-unix内存分配方式-malloc实现</title>
    <link href="https://dreamerjonson.com/2020/01/14/6-s081-2-Memory-allocation/"/>
    <id>https://dreamerjonson.com/2020/01/14/6-s081-2-Memory-allocation/</id>
    <published>2020-01-14T09:23:29.000Z</published>
    <updated>2020-02-05T04:05:18.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统编程systems-programming"><a class="markdownIt-Anchor" href="#系统编程systems-programming"></a> 系统编程（Systems programming）</h2><p><a href="https://en.wikipedia.org/wiki/Systems_programming" target="_blank" rel="noopener">wiki参考</a></p><ul><li>与应用程序编程相比，系统编程的主要区别在于，应用程序编程旨在产生直接向用户提供服务的软件。</li><li>系统编程主要为其他应用程序提供服务，直接操作操作系统。它的目标是实现对可用资源的有效利用。</li></ul><p>例如：</p><ul><li>unix utilities</li><li>K/V servers</li><li>ssh</li><li>bigint library</li></ul><p>挑战：</p><ul><li>低级编程环境<ul><li>数字是64位（不是无限的整数）</li><li>分配/释放内存</li></ul><ul><li>并发<ul><li>允许并行处理请求</li></ul></li></ul></li><li>崩溃</li><li>性能</li><li>为应用程序提供硬件支持</li></ul><p>动态内存分配是一项基本的系统服务</p><ul><li>底层编程： 指针操作，类型转换</li><li>使用底层操作系统请求内存块（memory chunks）</li><li>性能非常重要</li><li>支持广泛类型的应用程序负载</li></ul><h2 id="应用程序结构"><a class="markdownIt-Anchor" href="#应用程序结构"></a> 应用程序结构</h2><ul><li><p>text</p></li><li><p>data  (静态存储)</p></li><li><p>stack (栈存储)</p></li><li><p>heap (动态内存分配)<br>使用 sbrk() o或 mmap() 操作系统接口扩展堆。<br>[text |  data | heap -&gt;  …    &lt;- stack]<br>0                                       top of address space</p></li><li><p>data段的内存分配是静态的，始终存在。</p></li><li><p>栈的分配在函数中，随着函数消亡而释放。</p></li><li><p>堆的分配与释放，调用接口：<br>— malloc(int sz)<br>— free§</p></li></ul><h2 id="堆分配的目标"><a class="markdownIt-Anchor" href="#堆分配的目标"></a> 堆分配的目标</h2><ul><li>快速分配和释放</li><li>内存开销小</li><li>想要使用所有内存</li><li>避免碎片化</li></ul><p>下面介绍几种malloc实现的方式</p><h2 id="方式1kr-malloc"><a class="markdownIt-Anchor" href="#方式1kr-malloc"></a> 方式1：K&amp;R malloc</h2><p>又叫做first-fit规则, 即查找第一个可用的匹配块。与之相对应的是查找第一个最符合（best-fit）的可用块。<br>K&amp;R malloc的实现来自书籍  the C programming language by Kernighan and Ritchie (K&amp;R) Section 8.7</p><h3 id="维持一个链表"><a class="markdownIt-Anchor" href="#维持一个链表"></a> 维持一个链表</h3><p>维持的free list是一个环。 第一个元素是base。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define NALLOC  1024  /* minimum #units to request */</span><br><span class="line"></span><br><span class="line">struct header &#123;</span><br><span class="line">  struct header *ptr;</span><br><span class="line">  size_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct header Header;</span><br><span class="line"></span><br><span class="line">static Header base;</span><br><span class="line">static Header *freep = NULL;</span><br></pre></td></tr></table></figure><h3 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h3><p>指定分配的内存大小为sizeof(Header)的倍数，且一定大于nbytes。nunits就是这个倍数。</p><ul><li>循环free list。 找到第一个符合即大于等于nbytes的块。<br>— 如果刚好合适，则链表删除此块并返回此块。<br>— 如果大于，则截断此元素<br>— 如果没有找到合适的块，则调用moreheap新分配一个。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/* malloc: general-purpose storage allocator */</span><br><span class="line">void *</span><br><span class="line">kr_malloc(size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">  Header *p, *prevp;</span><br><span class="line">  unsigned nunits;</span><br><span class="line"></span><br><span class="line">  nunits = (nbytes + sizeof(Header) - 1) / sizeof(Header) + 1;</span><br><span class="line">  // base作为第一个元素。</span><br><span class="line">  if ((prevp = freep) == NULL) &#123;/* no free list yet */</span><br><span class="line">    base.ptr = freep = prevp = &amp;base;</span><br><span class="line">    base.size = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  for (p = prevp-&gt;ptr; ; prevp = p, p = p-&gt;ptr) &#123;</span><br><span class="line">    if (p-&gt;size &gt;= nunits) &#123;/* big enough */</span><br><span class="line">      if (p-&gt;size == nunits)/* exactly */</span><br><span class="line">prevp-&gt;ptr = p-&gt;ptr;</span><br><span class="line">      else &#123;/* allocate tail end */</span><br><span class="line">p-&gt;size -= nunits;</span><br><span class="line">p += p-&gt;size;</span><br><span class="line">p-&gt;size = nunits;</span><br><span class="line">      &#125;</span><br><span class="line">      freep = prevp;</span><br><span class="line">      return (void *) (p + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    if (p == freep) &#123;/* wrapped around free list */</span><br><span class="line">      if ((p = (Header *) moreheap(nunits)) == NULL) &#123;</span><br><span class="line">return NULL;/* none left */</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sbrk"><a class="markdownIt-Anchor" href="#sbrk"></a> sbrk</h3><p>sbrk是unix增加内存的操作系统调用。<br><a href="https://en.wikipedia.org/wiki/Sbrk" target="_blank" rel="noopener">wiki</a>的解释是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The brk and sbrk calls dynamically change the amount of space allocated for the data segment of the calling process. The change is made by resetting the program break of the process, which determines the maximum space that can be allocated. The program break is the address of the first location beyond the current end of the data region. The amount of available space increases as the break value increases. The available space is initialized to a value of zero, unless the break is lowered and then increased, as it may reuse the same pages in some unspecified way. The break value can be automatically rounded up to a size appropriate for the memory management architecture.[4]</span><br><span class="line">Upon successful completion, the brk subroutine returns a value of 0, and the sbrk subroutine returns the prior value of the program break (if the available space is increased then this prior value also points to the start of the new area). If either subroutine is unsuccessful, a value of −1 is returned and the errno global variable is set to indicate the error.</span><br></pre></td></tr></table></figure><p>由于这里是增加内存，sbrk成功时会返回新增加区域的开始地址，如果失败则会返回-1。<br>新生成一个块之后，调用free函数将其加入到freelist当中。<br>注意这里的up+1 是什么意思。其代表的是新分配的区域的开头。以为新分配的区域之前有Header大小，用于标识大小和下一个区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static Header *moreheap(size_t nu)</span><br><span class="line">&#123;</span><br><span class="line">  char *cp;</span><br><span class="line">  Header *up;</span><br><span class="line"></span><br><span class="line">  if (nu &lt; NALLOC)</span><br><span class="line">    nu = NALLOC;</span><br><span class="line">  cp = sbrk(nu * sizeof(Header));</span><br><span class="line">  if (cp == (char *) -1)</span><br><span class="line">    return NULL;</span><br><span class="line">  up = (Header *) cp;</span><br><span class="line">  up-&gt;size = nu;</span><br><span class="line">  kr_free((void *)(up + 1));</span><br><span class="line">  return freep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="free"><a class="markdownIt-Anchor" href="#free"></a> free</h3><p>ap是要释放的区域，其前面还有Header大小。bp 指向了块的开头。</p><ul><li>遍历free list，找到要插入的中间区域。</li><li>如果前后的区域正好是连在一起的，则进行合并。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* free: put block ap in free list */</span><br><span class="line">void</span><br><span class="line">kr_free(void *ap)</span><br><span class="line">&#123;</span><br><span class="line">  Header *bp, *p;</span><br><span class="line"></span><br><span class="line">  if (ap == NULL)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  bp = (Header *) ap - 1;/* point to block header */</span><br><span class="line">  for (p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;ptr); p = p-&gt;ptr)</span><br><span class="line">    if (p &gt;= p-&gt;ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;ptr))</span><br><span class="line">      break;/* freed block at start or end of arena */</span><br><span class="line"></span><br><span class="line">  if (bp + bp-&gt;sizfe == p-&gt;ptr) &#123;/* join to upper nbr */</span><br><span class="line">    bp-&gt;size += p-&gt;ptr-&gt;size;</span><br><span class="line">    bp-&gt;ptr = p-&gt;ptr-&gt;ptr;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    bp-&gt;ptr = p-&gt;ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (p + p-&gt;size == bp) &#123;/* join to lower nbr */</span><br><span class="line">    p-&gt;size += bp-&gt;size;</span><br><span class="line">    p-&gt;ptr = bp-&gt;ptr;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    p-&gt;ptr = bp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  freep = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式2region-based-allocator-a-special-purpose-allocator"><a class="markdownIt-Anchor" href="#方式2region-based-allocator-a-special-purpose-allocator"></a> 方式2：Region-based allocator, a special-purpose allocator.</h2><ul><li>malloc 与free 快速</li><li>内存开销低</li><li>内存碎片严重</li><li>不通用，用于特定应用程序。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct region &#123;</span><br><span class="line">  void *start;</span><br><span class="line">  void *cur;</span><br><span class="line">  void *end;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct region Region;</span><br><span class="line"></span><br><span class="line">static Region rg_base;</span><br><span class="line"></span><br><span class="line">Region *</span><br><span class="line">rg_create(size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">  rg_base.start = sbrk(nbytes);</span><br><span class="line">  rg_base.cur = rg_base.start;</span><br><span class="line">  rg_base.end = rg_base.start + nbytes;</span><br><span class="line">  return &amp;rg_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">rg_malloc(Region *r, size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">  assert (r-&gt;cur + nbytes &lt;= r-&gt;end);</span><br><span class="line">  void *p = r-&gt;cur;</span><br><span class="line">  r-&gt;cur += nbytes;</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// free all memory in region resetting cur to start</span><br><span class="line">void</span><br><span class="line">rg_free(Region *r) &#123;</span><br><span class="line">  r-&gt;cur = r-&gt;start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式3buddy-allocator"><a class="markdownIt-Anchor" href="#方式3buddy-allocator"></a> 方式3：Buddy allocator</h2><p>我觉得wiki的解释挺好的：<br><a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">wiki解析</a><br>提示：</p><ul><li>对于2^k 大小的空间，我们可以将其分割为大小为2^0, 2^1, 2^2, … 2^k的多种可能。</li><li>malloc(17) 会分配 32 bytes，因此其会一定程度上浪费空间。</li><li>数据结构带来的格外内存开销</li><li>malloc 和free快速。</li></ul><p>下面介绍一种代码实现。</p><p>基本参数</p><ul><li>ROUNDUP(n,sz) 求出要分配n哥字节时，希望分配的实际内存是大于等于n 并且是sz的倍数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define LEAF_SIZE     16 // The smallest allocation size (in bytes)</span><br><span class="line">#define NSIZES        15 // Number of entries in bd_sizes array</span><br><span class="line">#define MAXSIZE       (NSIZES-1) // Largest index in bd_sizes array</span><br><span class="line">#define BLK_SIZE(k)   ((1L &lt;&lt; (k)) * LEAF_SIZE) // Size in bytes for size k</span><br><span class="line">#define HEAP_SIZE     BLK_SIZE(MAXSIZE) </span><br><span class="line">#define NBLK(k)       (1 &lt;&lt; (MAXSIZE-k))  // Number of block at size k</span><br><span class="line">#define ROUNDUP(n,sz) (((((n)-1)/(sz))+1)*(sz))  // Round up to the next multiple of sz</span><br></pre></td></tr></table></figure><ul><li>NBLK求出在第k位置有多少块。</li></ul><p>每一个大小k维护一个<code>sz_info</code>, <code>sz_info</code>中都有一个free list, alloc 是一个char数组用于记录块是否分配。split 是一个char数组用于块是否割裂。<br>这里要注意，使用的是bit数组来记录。  char有8位，如第n位代表的是当前k大小的第5个区块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// The allocator has sz_info for each size k. Each sz_info has a free</span><br><span class="line">// list, an array alloc to keep track which blocks have been</span><br><span class="line">// allocated, and an split array to to keep track which blocks have</span><br><span class="line">// been split.  The arrays are of type char (which is 1 byte), but the</span><br><span class="line">// allocator uses 1 bit per block (thus, one char records the info of</span><br><span class="line">// 8 blocks).</span><br><span class="line">struct sz_info &#123;</span><br><span class="line">  struct bd_list free;</span><br><span class="line">  char *alloc;</span><br><span class="line">  char *split;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct sz_info Sz_info;</span><br></pre></td></tr></table></figure><p>每一个级别的双链表 for free list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// A double-linked list for the free list of each level</span><br><span class="line">struct bd_list &#123;</span><br><span class="line">  struct bd_list *next;</span><br><span class="line">  struct bd_list *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bit数组操作"><a class="markdownIt-Anchor" href="#bit数组操作"></a> bit数组操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Return 1 if bit at position index in array is set to 1</span><br><span class="line">int bit_isset(char *array, int index) &#123;</span><br><span class="line">  char b = array[index/8];</span><br><span class="line">  char m = (1 &lt;&lt; (index % 8));</span><br><span class="line">  return (b &amp; m) == m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Set bit at position index in array to 1</span><br><span class="line">void bit_set(char *array, int index) &#123;</span><br><span class="line">  char b = array[index/8];</span><br><span class="line">  char m = (1 &lt;&lt; (index % 8));</span><br><span class="line">  array[index/8] = (b | m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Clear bit at position index in array</span><br><span class="line">void bit_clear(char *array, int index) &#123;</span><br><span class="line">  char b = array[index/8];</span><br><span class="line">  char m = (1 &lt;&lt; (index % 8));</span><br><span class="line">  array[index/8] = (b &amp; ~m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><p>首先调用mmap分配一个非常大的区域。此大小为2 ^ MAXSIZE * 16,16为分配的最小块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Allocate memory for the heap managed by the allocator, and allocate</span><br><span class="line">// memory for the data structures of the allocator.</span><br><span class="line">void</span><br><span class="line">bd_init() &#123;</span><br><span class="line">  bd_base = mmap(NULL, HEAP_SIZE, PROT_READ | PROT_WRITE,</span><br><span class="line"> MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">  if (bd_base == MAP_FAILED) &#123;</span><br><span class="line">    fprintf(stderr, &quot;couldn&apos;t map heap; %s\n&quot;, strerror(errno));</span><br><span class="line">    assert(bd_base);</span><br><span class="line">  &#125;</span><br><span class="line">  // printf(&quot;bd: heap size %d\n&quot;, HEAP_SIZE);</span><br><span class="line">  for (int k = 0; k &lt; NSIZES; k++) &#123;</span><br><span class="line">    lst_init(&amp;bd_sizes[k].free);</span><br><span class="line">    int sz = sizeof(char)*ROUNDUP(NBLK(k), 8)/8;</span><br><span class="line">    bd_sizes[k].alloc = malloc(sz);</span><br><span class="line">    memset(bd_sizes[k].alloc, 0, sz);</span><br><span class="line">  &#125;</span><br><span class="line">  for (int k = 1; k &lt; NSIZES; k++) &#123;</span><br><span class="line">    int sz = sizeof(char)*ROUNDUP(NBLK(k), 8)/8;</span><br><span class="line">    bd_sizes[k].split = malloc(sz);</span><br><span class="line">    memset(bd_sizes[k].split, 0, sz);</span><br><span class="line">  &#125;</span><br><span class="line">  lst_push(&amp;bd_sizes[MAXSIZE].free, bd_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找到第一个k-使得2k-n"><a class="markdownIt-Anchor" href="#找到第一个k-使得2k-n"></a> 找到第一个k， 使得2^k &gt;= n</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// What is the first k such that 2^k &gt;= n?</span><br><span class="line">int</span><br><span class="line">firstk(size_t n) &#123;</span><br><span class="line">  int k = 0;</span><br><span class="line">  size_t size = LEAF_SIZE;</span><br><span class="line"></span><br><span class="line">  while (size &lt; n) &#123;</span><br><span class="line">    k++;</span><br><span class="line">    size *= 2;</span><br><span class="line">  &#125;</span><br><span class="line">  return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找位置p-如果以2k-大小为区块那么其位于第几个区块"><a class="markdownIt-Anchor" href="#查找位置p-如果以2k-大小为区块那么其位于第几个区块"></a> 查找位置p ， 如果以2^k 大小为区块，那么其位于第几个区块。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Compute the block index for address p at size k</span><br><span class="line">int</span><br><span class="line">blk_index(int k, char *p) &#123;</span><br><span class="line">  int n = p - (char *) bd_base;</span><br><span class="line">  return n / BLK_SIZE(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将k大小序号为bi的区块的首地址计算出来"><a class="markdownIt-Anchor" href="#将k大小序号为bi的区块的首地址计算出来"></a> 将k大小，序号为bi的区块的首地址计算出来</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Convert a block index at size k back into an address</span><br><span class="line">void *addr(int k, int bi) &#123;</span><br><span class="line">  int n = bi * BLK_SIZE(k);</span><br><span class="line">  return (char *) bd_base + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="malloc"><a class="markdownIt-Anchor" href="#malloc"></a> malloc</h3><p>找到一个大小k，块2^k是大于等于要分配的大小。<br>如果db_size[k].free 不为空，说明当前有大小为k的空闲空间。<br>如果没有找到，则让k+1，继续找到更大的空间有无空闲。</p><p>如果找到，则lst_pop(&amp;bd_sizes[k].free)获取第一个块。 blk_index(k, p)获取以k为衡量指标，p位于的第n个块。  并通过bit_set将bd_sizes[k].alloc 在第n号位置设置为1。<br>如果找到的k是比较大的空间，这时候需要对此空间进行分割，一分为2。 一直到找到一个比较符合的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void *</span><br><span class="line">bd_malloc(size_t nbytes)</span><br><span class="line">&#123;</span><br><span class="line">  int fk, k;</span><br><span class="line">  </span><br><span class="line">  assert(bd_base != NULL);</span><br><span class="line"></span><br><span class="line">  // Find a free block &gt;= nbytes, starting with smallest k possible</span><br><span class="line">  fk = firstk(nbytes);</span><br><span class="line">  for (k = fk; k &lt; NSIZES; k++) &#123;</span><br><span class="line">    if(!lst_empty(&amp;bd_sizes[k].free))</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  if(k &gt;= NSIZES)  // No free blocks?</span><br><span class="line">    return NULL;</span><br><span class="line"></span><br><span class="line">  // Found one; pop it and potentially split it.</span><br><span class="line">  char *p = lst_pop(&amp;bd_sizes[k].free);</span><br><span class="line">  bit_set(bd_sizes[k].alloc, blk_index(k, p));</span><br><span class="line">  for(; k &gt; fk; k--) &#123;</span><br><span class="line">    // 第2半的空间</span><br><span class="line">    char *q = p + BLK_SIZE(k-1);</span><br><span class="line">    // 对于大小k来说，其在位置p处是分割的。</span><br><span class="line">    bit_set(bd_sizes[k].split, blk_index(k, p));</span><br><span class="line">    // 对于大小k-1来说，其在位置p处是分配的。</span><br><span class="line">    bit_set(bd_sizes[k-1].alloc, blk_index(k-1, p));</span><br><span class="line">    // 对于大小k-1来说，其在位置q处是空闲的。</span><br><span class="line">    lst_push(&amp;bd_sizes[k-1].free, q);</span><br><span class="line">  &#125;</span><br><span class="line">  // printf(&quot;malloc: %p size class %d\n&quot;, p, fk);</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="free-2"><a class="markdownIt-Anchor" href="#free-2"></a> free</h3><p>当要free位置p时，size找到第一个k，当k+1在p位置是分割的，则返回k。这时候说明在k处区域是可以合并的。这是一种优化。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> // Find the size of the block that p points to.</span><br><span class="line">int</span><br><span class="line">size(char *p) &#123;</span><br><span class="line">  for (int k = 0; k &lt; NSIZES; k++) &#123;</span><br><span class="line">    if(bit_isset(bd_sizes[k+1].split, blk_index(k+1, p))) &#123;</span><br><span class="line">      return k;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">bd_free(void *p) &#123;</span><br><span class="line">  void *q;</span><br><span class="line">  int k;</span><br><span class="line">  </span><br><span class="line">  for (k = size(p); k &lt; MAXSIZE; k++) &#123;</span><br><span class="line">    int bi = blk_index(k, p);</span><br><span class="line">    bit_clear(bd_sizes[k].alloc, bi);</span><br><span class="line">    int buddy = (bi % 2 == 0) ? bi+1 : bi-1;</span><br><span class="line">    if (bit_isset(bd_sizes[k].alloc, buddy)) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    // budy is free; merge with buddy</span><br><span class="line">    q = addr(k, buddy);</span><br><span class="line">    lst_remove(q);</span><br><span class="line">    if(buddy % 2 == 0) &#123;</span><br><span class="line">      p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    bit_clear(bd_sizes[k+1].split, blk_index(k+1, p));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 放入freelist当中。</span><br><span class="line">  // printf(&quot;free %p @ %d\n&quot;, p, k);</span><br><span class="line">  lst_push(&amp;bd_sizes[k].free, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形双链表的基本操作"><a class="markdownIt-Anchor" href="#环形双链表的基本操作"></a> 环形双链表的基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// Implementation of lists: double-linked and circular. Double-linked</span><br><span class="line">// makes remove fast. Circular simplifies code, because don&apos;t have to</span><br><span class="line">// check for empty list in insert and remove.</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">lst_init(Bd_list *lst)</span><br><span class="line">&#123;</span><br><span class="line">  lst-&gt;next = lst;</span><br><span class="line">  lst-&gt;prev = lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">lst_empty(Bd_list *lst) &#123;</span><br><span class="line">  return lst-&gt;next == lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">lst_remove(Bd_list *e) &#123;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void*</span><br><span class="line">lst_pop(Bd_list *lst) &#123;</span><br><span class="line">  assert(lst-&gt;next != lst);</span><br><span class="line">  Bd_list *p = lst-&gt;next;</span><br><span class="line">  lst_remove(p);</span><br><span class="line">  return (void *)p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">lst_push(Bd_list *lst, void *p)</span><br><span class="line">&#123;</span><br><span class="line">  Bd_list *e = (Bd_list *) p;</span><br><span class="line">  e-&gt;next = lst-&gt;next;</span><br><span class="line">  e-&gt;prev = lst;</span><br><span class="line">  lst-&gt;next-&gt;prev = p;</span><br><span class="line">  lst-&gt;next = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">lst_print(Bd_list *lst)</span><br><span class="line">&#123;</span><br><span class="line">  for (Bd_list *p = lst-&gt;next; p != lst; p = p-&gt;next) &#123;</span><br><span class="line">    printf(&quot; %p&quot;, p);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他顺序分配方式"><a class="markdownIt-Anchor" href="#其他顺序分配方式"></a> 其他顺序分配方式</h2><p>dlmalloc<br>slab allocator</p><h2 id="其他目标"><a class="markdownIt-Anchor" href="#其他目标"></a> 其他目标</h2><ul><li>内存开销小</li><li>例如buddy的元数据很大</li><li>良好的内存位置</li><li>cpu核心增加时，扩展性好</li><li>并发malloc / free</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation" target="_blank" rel="noopener">wiki</a><br><a href="https://pdos.csail.mit.edu/6.828/2019/lec/l-allocator.txt" target="_blank" rel="noopener">讲义</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统编程systems-programming&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#系统编程systems-programming&quot;&gt;&lt;/a&gt; 系统编程（Systems programming）&lt;/h2&gt;
&lt;p&gt;&lt;a href
      
    
    </summary>
    
      <category term="unix" scheme="https://dreamerjonson.com/categories/unix/"/>
    
    
      <category term="unix" scheme="https://dreamerjonson.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>golang[113]-raft理论与实践[4]-lab2b日志复制</title>
    <link href="https://dreamerjonson.com/2020/01/12/golang-113-raft-4-log/"/>
    <id>https://dreamerjonson.com/2020/01/12/golang-113-raft-4-log/</id>
    <published>2020-01-12T13:00:32.000Z</published>
    <updated>2020-01-18T12:09:54.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>1、阅读<a href="http://nil.csail.mit.edu/6.824/2017/papers/raft-extended.pdf" target="_blank" rel="noopener">raft论文</a><br>2、阅读<a href="https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/">raft理论与实践[1]-理论篇</a><br>3、阅读<a href="https://dreamerjonson.com/2020/01/06/golang-111-raft-2/">raft理论与实践[2]-lab2a</a><br>4、阅读<a href="https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/">raft理论与实践[3]-lab2a讲解</a><br>5、查看我写的这篇文章： <a href="https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/">模拟RPC远程过程调用</a></p><h2 id="执行日志"><a class="markdownIt-Anchor" href="#执行日志"></a> 执行日志</h2><p>我们需要执行日志中的命令，因此在make函数中，新开一个协程:applyLogEntryDaemon()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span> *<span class="title">Raft</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">go</span> rf.applyLogEntryDaemon() <span class="comment">// start apply log</span></span><br><span class="line">DPrintf(<span class="string">"[%d-%s]: newborn election(%s) heartbeat(%s) term(%d) voted(%d)\n"</span>,</span><br><span class="line">rf.me, rf, rf.electionTimeout, rf.heartbeatInterval, rf.CurrentTerm, rf.VotedFor)</span><br><span class="line"><span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个死循环<br>1、如果rf.lastApplied == rf.commitIndex, 意味着commit log entry命令都已经被执行了，这时用信号量陷入等待。<br>一旦收到信号，说明需要执行命令。这时会把最后执行的log entry之后，一直到最后一个commit log entry的所有log都传入通道apply中进行执行。<br>由于是测试，处理apply的逻辑会在测试代码中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// applyLogEntryDaemon exit when shutdown channel is closed</span><br><span class="line">func (rf *Raft) applyLogEntryDaemon() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">var logs []LogEntry</span><br><span class="line">// wait</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">for rf.lastApplied == rf.commitIndex &#123;</span><br><span class="line">rf.commitCond.Wait()</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down apply log entry to client daemon.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">close(rf.applyCh)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">last, cur := rf.lastApplied, rf.commitIndex</span><br><span class="line">if last &lt; cur &#123;</span><br><span class="line">rf.lastApplied = rf.commitIndex</span><br><span class="line">logs = make([]LogEntry, cur-last)</span><br><span class="line">copy(logs, rf.Logs[last+1:cur+1])</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">for i := 0; i &lt; cur-last; i++ &#123;</span><br><span class="line">// current command is replicated, ignore nil command</span><br><span class="line">reply := ApplyMsg&#123;</span><br><span class="line">CommandIndex: last + i + 1,</span><br><span class="line">Command:      logs[i].Command,</span><br><span class="line">CommandValid: true,</span><br><span class="line">&#125;</span><br><span class="line">// reply to outer service</span><br><span class="line">// DPrintf(&quot;[%d-%s]: peer %d apply %v to client.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d apply to client.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">// Note: must in the same goroutine, or may result in out of order apply</span><br><span class="line">rf.applyCh &lt;- reply</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 Start函数，此函数为leader执行从client发送过来的命令。<br>当client发送过来之后，首先需要做的就是新增entry 到leader的log中。并且将自身的nextIndex 与matchIndex 更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123;</span><br><span class="line">index := -1</span><br><span class="line">term := 0</span><br><span class="line">isLeader := false</span><br><span class="line"></span><br><span class="line">// Your code here (2B).</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">return -1, 0, false</span><br><span class="line">default:</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">// Your code here (2B).</span><br><span class="line">if rf.state == Leader &#123;</span><br><span class="line">log := LogEntry&#123;rf.CurrentTerm, command&#125;</span><br><span class="line">rf.Logs = append(rf.Logs, log)</span><br><span class="line"></span><br><span class="line">index = len(rf.Logs) - 1</span><br><span class="line">term = rf.CurrentTerm</span><br><span class="line">isLeader = true</span><br><span class="line"></span><br><span class="line">//DPrintf(&quot;[%d-%s]: client add new entry (%d-%v), logs: %v\n&quot;, rf.me, rf, index, command, rf.logs)</span><br><span class="line">DPrintf(&quot;[%d-%s]: client add new entry (%d)\n&quot;, rf.me, rf, index)</span><br><span class="line">//DPrintf(&quot;[%d-%s]: client add new entry (%d-%v)\n&quot;, rf.me, rf, index, command)</span><br><span class="line"></span><br><span class="line">// only update leader</span><br><span class="line">rf.nextIndex[rf.me] = index + 1</span><br><span class="line">rf.matchIndex[rf.me] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return index, term, isLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来最重要的部分涉及到日志复制，这是通过AppendEntries实现的。我们知道leader会不时的调用consistencyCheck(n)进行一致性检查。<br>在给第n号节点一致性检查时，首先获取pre = rf.nextIndex，pre至少要为1。代表要给n节点发送的log index。因此AppendEntriesArgs参数中，PrevLogIndex 与 prevlogTerm 都为pre - 1位置。<br>代表leader相信PrevLogIndex及其之前的节点都是与leader相同的。<br>将pre及其之后的entry 加入到AppendEntriesArgs参数中。 这些log entry可能是与leader不相同的，或者是follower根本就没有的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">consistencyCheck</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">pre := max(<span class="number">1</span>,rf.nextIndex[n])</span><br><span class="line"><span class="keyword">var</span> args = AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.CurrentTerm,</span><br><span class="line">LeaderID:     rf.me,</span><br><span class="line">PrevLogIndex: pre - <span class="number">1</span>,</span><br><span class="line">PrevLogTerm:  rf.Logs[pre - <span class="number">1</span>].Term,</span><br><span class="line">Entries:      <span class="literal">nil</span>,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.nextIndex[n] &lt; <span class="built_in">len</span>(rf.Logs)&#123;</span><br><span class="line">args.Entries = <span class="built_in">append</span>(args.Entries, rf.Logs[pre:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">DPrintf(<span class="string">"[%d-%s]: consistency Check to peer %d.\n"</span>, rf.me, rf, n)</span><br><span class="line"><span class="keyword">var</span> reply AppendEntriesReply</span><br><span class="line"><span class="keyword">if</span> rf.sendAppendEntries(n, &amp;args, &amp;reply) &#123;</span><br><span class="line">rf.consistencyCheckReplyHandler(n, &amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来查看follower执行AppendEntries时的反应。<br>AppendEntries会新增两个返回参数：<br>ConflictTerm代表可能发生冲突的term<br>FirstIndex 代表可能发生冲突的第一个index。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type AppendEntriesReply struct &#123;</span><br><span class="line">CurrentTerm int  // currentTerm, for leader to update itself</span><br><span class="line">Success     bool // true if follower contained entry matching prevLogIndex and prevLogTerm</span><br><span class="line">// extra info for heartbeat from follower</span><br><span class="line">ConflictTerm int // term of the conflicting entry</span><br><span class="line">FirstIndex   int // the first index it stores for ConflictTerm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果args.PrevLogIndex &lt; len(rf.Logs), 表明至少当前节点的log长度是合理的。<br>令preLogIdx 与 args.PrevLogIndex相等。prelogTerm为当前follower节点preLogIdx位置的term。<br>如果拥有相同的term，说明follower与leader 在preLogIdx之前的log entry都是相同的。因此请求是成功的。<br>此时会截断follower的log，将传递过来的entry加入到follower的log之后，执行此步骤后，强制要求与leader的log相同了。<br>请求成功后，reply的ConflictTerm为最后一个log entry的term,reply的FirstIndex为最后一个log entry的index。</p><p>否则说明leader与follower的日志是有冲突的，冲突的原因可能是：<br>1、leader认为的match log entry超出了follower的log个数，或者follower 还没有任何log entry（除了index为0的entry是每一个节点都有的）。<br>2、log在相同的index下，leader的term 与follower的term确是不同的。<br>这时找到follower冲突的term即为ConflictTerm。<br>获取此term的第一个entry的index即为FirstIndex。<br>所以最后，AppendEntries会返回冲突的term以及第一个可能冲突的index。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// AppendEntries handler, including heartbeat, must backup quickly</span><br><span class="line">func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    ...</span><br><span class="line">    preLogIdx, preLogTerm := 0, 0</span><br><span class="line">if args.PrevLogIndex &lt; len(rf.Logs) &#123;</span><br><span class="line">preLogIdx = args.PrevLogIndex</span><br><span class="line">preLogTerm = rf.Logs[preLogIdx].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// last log is match</span><br><span class="line">if preLogIdx == args.PrevLogIndex &amp;&amp; preLogTerm == args.PrevLogTerm &#123;</span><br><span class="line">reply.Success = true</span><br><span class="line">// truncate to known match</span><br><span class="line">rf.Logs = rf.Logs[:preLogIdx+1]</span><br><span class="line">rf.Logs = append(rf.Logs, args.Entries...)</span><br><span class="line">var last = len(rf.Logs) - 1</span><br><span class="line"></span><br><span class="line">// min(leaderCommit, index of last new entry)</span><br><span class="line">if args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = min(args.LeaderCommit, last)</span><br><span class="line">// signal possible update commit index</span><br><span class="line">go func() &#123; rf.commitCond.Broadcast() &#125;()</span><br><span class="line">&#125;</span><br><span class="line">// tell leader to update matched index</span><br><span class="line">reply.ConflictTerm = rf.Logs[last].Term</span><br><span class="line">reply.FirstIndex = last</span><br><span class="line"></span><br><span class="line">if len(args.Entries) &gt; 0 &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: AE success from leader %d (%d cmd @ %d), commit index: l-&gt;%d, f-&gt;%d.\n&quot;,</span><br><span class="line">rf.me, rf, args.LeaderID, len(args.Entries), preLogIdx+1, args.LeaderCommit, rf.commitIndex)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: &lt;heartbeat&gt; current logs: %v\n&quot;, rf.me, rf, rf.Logs)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">reply.Success = false</span><br><span class="line"></span><br><span class="line">// extra info for restore missing entries quickly: from original paper and lecture note</span><br><span class="line">// if follower rejects, includes this in reply:</span><br><span class="line">//</span><br><span class="line">// the follower&apos;s term in the conflicting entry</span><br><span class="line">// the index of follower&apos;s first entry with that term</span><br><span class="line">//</span><br><span class="line">// if leader knows about the conflicting term:</span><br><span class="line">// move nextIndex[i] back to leader&apos;s last entry for the conflicting term</span><br><span class="line">// else:</span><br><span class="line">// move nextIndex[i] back to follower&apos;s first index</span><br><span class="line">var first = 1</span><br><span class="line">reply.ConflictTerm = preLogTerm</span><br><span class="line">if reply.ConflictTerm == 0 &#123;</span><br><span class="line">// which means leader has more logs or follower has no log at all</span><br><span class="line">first = len(rf.Logs)</span><br><span class="line">reply.ConflictTerm = rf.Logs[first-1].Term</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i := preLogIdx</span><br><span class="line">// term的第一个log entry</span><br><span class="line">for ; i &gt; 0; i-- &#123;</span><br><span class="line">if rf.Logs[i].Term != preLogTerm &#123;</span><br><span class="line">first = i + 1</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reply.FirstIndex = first</span><br><span class="line">if len(rf.Logs) &lt;= args.PrevLogIndex &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: AE failed from leader %d, leader has more logs (%d &gt; %d), reply: %d - %d.\n&quot;,</span><br><span class="line">rf.me, rf, args.LeaderID, args.PrevLogIndex, len(rf.Logs)-1, reply.ConflictTerm,</span><br><span class="line">reply.FirstIndex)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: AE failed from leader %d, pre idx/term mismatch (%d != %d, %d != %d).\n&quot;,</span><br><span class="line">rf.me, rf, args.LeaderID, args.PrevLogIndex, preLogIdx, args.PrevLogTerm, preLogTerm)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leader调用AppendEntries后，会执行回调函数consistencyCheckReplyHandler。<br>如果调用是成功的，那么正常的跟新matchIndex，nextIndex即下一个要发送的index应该为matchIndex + 1。</p><p>如果调用失败，说明有冲突。<br>如果confiicting term等于0，说明了leader认为的match log entry超出了follower的log个数，或者follower 还没有任何log entry（除了index为0的entry是每一个节点都有的）。<br>此时简单的让nextIndex 为reply.FirstIndex即可。</p><p>如果confiicting term不为0，获取leader节点confiicting term 的最后一个log index，此时nextIndex 应该为此index与reply.FirstIndex的最小值。<br>检查最小值是必须的：<br>假设<br>s1: 0-0 1-1 1-2 1-3 1-4 1-5<br>s2: 0-0 1-1 1-2 1-3 1-4 1-5<br>s3: 0-0 1-1</p><p>此时s1为leader，并一致性检查s3, 从1-5开始检查，此时由于leader有更多的log，因此检查不成功，返回confict term 1， firstindex：2<br>如果只是获取confiicting term 的最后一个log index，那么nextIndex又是1-5，陷入了死循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) consistencyCheckReplyHandler(n int, reply *AppendEntriesReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if rf.state != Leader &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.Success &#123;</span><br><span class="line">// RPC and consistency check successful</span><br><span class="line">rf.matchIndex[n] = reply.FirstIndex</span><br><span class="line">rf.nextIndex[n] = rf.matchIndex[n] + 1</span><br><span class="line">rf.updateCommitIndex() // try to update commitIndex</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// found a new leader? turn to follower</span><br><span class="line">if rf.state == Leader &amp;&amp; reply.CurrentTerm &gt; rf.CurrentTerm &#123;</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d found new term (heartbeat resp from peer %d), turn to follower.&quot;,</span><br><span class="line">rf.me, rf, rf.me, n)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Does leader know conflicting term?</span><br><span class="line">var know, lastIndex = false, 0</span><br><span class="line">if reply.ConflictTerm != 0 &#123;</span><br><span class="line">for i := len(rf.Logs) - 1; i &gt; 0; i-- &#123;</span><br><span class="line">if rf.Logs[i].Term == reply.ConflictTerm &#123;</span><br><span class="line">know = true</span><br><span class="line">lastIndex = i</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d have entry %d is the last entry in term %d.&quot;,</span><br><span class="line">rf.me, rf, rf.me, i, reply.ConflictTerm)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if know &#123;</span><br><span class="line">rf.nextIndex[n] = min(lastIndex, reply.FirstIndex)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rf.nextIndex[n] = reply.FirstIndex</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rf.nextIndex[n] = reply.FirstIndex</span><br><span class="line">&#125;</span><br><span class="line">rf.nextIndex[n] = min(rf.nextIndex[n], len(rf.Logs))</span><br><span class="line">DPrintf(&quot;[%d-%s]: nextIndex for peer %d  =&gt; %d.\n&quot;,</span><br><span class="line">rf.me, rf, n, rf.nextIndex[n])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用AppendEntry成功后，说明follower与leader的log是匹配的。此时leader会找到commited的log并且执行其命令。<br>这里有一个比较巧妙的方法，对matchIndex排序后取最中间的数。<br>由于matchIndex代表follower有多少log与leader的log匹配，因此中间的log index意味着其得到了大部分节点的认可。<br>因此会将此中间的index之前的所有log entry都执行了。<br>rf.Logs[target].Term == rf.CurrentTerm 是必要的：<br>这是由于当一个entry出现在大多数节点的log中，并不意味着其一定会成为commit。考虑下面的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S1: 1 2     1 2 4</span><br><span class="line">S2: 1 2     1 2</span><br><span class="line">S3: 1   --&gt; 1 2</span><br><span class="line">S4: 1       1</span><br><span class="line">S5: 1       1 3</span><br></pre></td></tr></table></figure><p>s1在term2成为leader，只有s1，s2添加了entry2.<br>s5变成了term3的leader，之后s1变为了term4的leader，接着继续发送entry2到s3中。<br>此时，如果s5再次变为了leader，那么即便没有S1的支持，S5任然变为了leader，并且应用entry3，覆盖掉entry2。<br>所以一个entry要变为commit，必须：<br>1、在其term周期内，就复制到大多数。<br>2、如果随后的entry被提交。在上例中，如果s1持续成为term4的leader，那么entry2就会成为commit。</p><p>这是由于以下原因造成的：<br>更高任期为最新的投票规则，以及leader将其日志强加给follower。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// updateCommitIndex find new commit id, must be called when hold lock</span><br><span class="line">func (rf *Raft) updateCommitIndex() &#123;</span><br><span class="line">match := make([]int, len(rf.matchIndex))</span><br><span class="line">copy(match, rf.matchIndex)</span><br><span class="line">sort.Ints(match)</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d try to update commit index: %v @ term %d.\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, rf.matchIndex, rf.CurrentTerm)</span><br><span class="line"></span><br><span class="line">target := match[len(rf.peers)/2]</span><br><span class="line">if rf.commitIndex &lt; target &#123;</span><br><span class="line">//fmt.Println(&quot;target:&quot;,target,match)</span><br><span class="line">if rf.Logs[target].Term == rf.CurrentTerm &#123;</span><br><span class="line">//DPrintf(&quot;[%d-%s]: leader %d update commit index %d -&gt; %d @ term %d command:%v\n&quot;,</span><br><span class="line">//rf.me, rf, rf.me, rf.commitIndex, target, rf.CurrentTerm,rf.Logs[target].Command)</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d update commit index %d -&gt; %d @ term %d\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, rf.commitIndex, target, rf.CurrentTerm)</span><br><span class="line"></span><br><span class="line">rf.commitIndex = target</span><br><span class="line">go func() &#123; rf.commitCond.Broadcast() &#125;()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d update commit index %d failed (log term %d != current Term %d)\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, rf.commitIndex, rf.Logs[target].Term, rf.CurrentTerm)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://github.com/dreamerjackson/Distributed-Systems/blob/master/Lec06_Fault_Tolerance_Raft/l-raft2.txt" target="_blank" rel="noopener">讲义</a><br><a href="https://pdos.csail.mit.edu/6.824/notes/l-raft2.txt" target="_blank" rel="noopener">讲义新</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h2&gt;
&lt;p&gt;1、阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/raft-exten
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[112]-raft理论与实践[3]-lab2a讲解</title>
    <link href="https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/"/>
    <id>https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/</id>
    <published>2020-01-06T12:15:46.000Z</published>
    <updated>2020-01-12T12:56:56.541Z</updated>
    
    <content type="html"><![CDATA[<p>1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer's state</span></span><br><span class="line">peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister *Persister          <span class="comment">// Object to hold this peer's persisted state</span></span><br><span class="line">me        <span class="keyword">int</span>                 <span class="comment">// this peer's index into peers[]</span></span><br><span class="line">dead      <span class="keyword">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line"><span class="comment">// Look at the paper's Figure 2 for a description of what</span></span><br><span class="line"><span class="comment">// state a Raft server must maintain.</span></span><br><span class="line">state             <span class="keyword">int</span>           <span class="comment">// follower, candidate or leader</span></span><br><span class="line">resetTimer        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// for reset election timer</span></span><br><span class="line">electionTimer     *time.Timer   <span class="comment">// election timer</span></span><br><span class="line">electionTimeout   time.Duration <span class="comment">// 400~800ms</span></span><br><span class="line">heartbeatInterval time.Duration <span class="comment">// 100ms</span></span><br><span class="line"></span><br><span class="line">CurrentTerm <span class="keyword">int</span>        <span class="comment">// Persisted before responding to RPCs</span></span><br><span class="line">VotedFor    <span class="keyword">int</span>        <span class="comment">// Persisted before responding to RPCs</span></span><br><span class="line">Logs        []LogEntry <span class="comment">// Persisted before responding to RPCs</span></span><br><span class="line">commitCond  *sync.Cond <span class="comment">// for commitIndex update</span></span><br><span class="line"><span class="comment">//newEntryCond []*sync.Cond // for new log entry</span></span><br><span class="line">commitIndex <span class="keyword">int</span>           <span class="comment">// Volatile state on all servers</span></span><br><span class="line">lastApplied <span class="keyword">int</span>           <span class="comment">// Volatile state on all servers</span></span><br><span class="line">nextIndex   []<span class="keyword">int</span>         <span class="comment">// Leader only, reinitialized after election</span></span><br><span class="line">matchIndex  []<span class="keyword">int</span>         <span class="comment">// Leader only, reinitialized after election</span></span><br><span class="line">applyCh     <span class="keyword">chan</span> ApplyMsg <span class="comment">// outgoing channel to service</span></span><br><span class="line">shutdownCh  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// shutdown channel, shut raft instance gracefully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取当前raft节点的term与状态"><a class="markdownIt-Anchor" href="#获取当前raft节点的term与状态"></a> 获取当前raft节点的term与状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) GetState() (int, bool) &#123;</span><br><span class="line"></span><br><span class="line">var term int</span><br><span class="line">var isleader bool</span><br><span class="line">// Your code here (2A).</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">term = rf.CurrentTerm</span><br><span class="line">isleader = rf.state == Leader</span><br><span class="line">return term, isleader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-填充requestvoteargs和requestvotereply结构"><a class="markdownIt-Anchor" href="#2-填充requestvoteargs和requestvotereply结构"></a> 2、填充RequestVoteArgs和RequestVoteReply结构。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type RequestVoteArgs struct &#123;</span><br><span class="line">// Your data here (2A, 2B).</span><br><span class="line">Term         int // candidate&apos;s term</span><br><span class="line">CandidateID  int // candidate requesting vote</span><br><span class="line">LastLogIndex int // index of candidate&apos;s last log entry</span><br><span class="line">LastLogTerm  int // term of candidate&apos;s last log entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RequestVoteReply struct &#123;</span><br><span class="line">// Your data here (2A).</span><br><span class="line">CurrentTerm int  // currentTerm, for candidate to update itself</span><br><span class="line">VoteGranted bool // true means candidate received vote</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现rpc方法requestvote"><a class="markdownIt-Anchor" href="#实现rpc方法requestvote"></a> 实现RPC方法RequestVote</h2><p>1、获取当前节点的log个数，以及最后一个log的term 确定当前节点的term。<br>2、如果调用节点的term小于当前节点，返回当前term，并且不为其投票。<br>3、如果调用节点的term大于当前节点，修改当前节点的term，当前节点转为follower.<br>4、如果调用节点的term大于当前节点，或者等于当前节点term并且调用节点的log个数大于等于当前节点的log，则为调用节点投票。<br>5、投票后重置当前节点的选举超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">// Your code here (2A, 2B).</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down, reject RV rpc request.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">lastLogIdx, lastLogTerm := rf.lastLogIndexAndTerm()</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: rpc RV, from peer: %d, arg term: %d, my term: %d (last log idx: %d-&gt;%d, term: %d-&gt;%d)\n&quot;, rf.me, rf, args.CandidateID, args.Term, rf.CurrentTerm, args.LastLogIndex,</span><br><span class="line">lastLogIdx, args.LastLogTerm, lastLogTerm)</span><br><span class="line"></span><br><span class="line">if args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">reply.CurrentTerm = rf.CurrentTerm</span><br><span class="line">reply.VoteGranted = false</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if args.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">// convert to follower</span><br><span class="line">rf.CurrentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.VotedFor = -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// if is null (follower) or itself is a candidate (or stale leader) with same term</span><br><span class="line">if rf.VotedFor == -1 &#123; //|| (rf.VotedFor == rf.me &amp;&amp; !sameTerm) &#123; //|| rf.votedFor == args.CandidateID &#123;</span><br><span class="line">// check whether candidate&apos;s log is at-least-as update</span><br><span class="line">if (args.LastLogTerm == lastLogTerm &amp;&amp; args.LastLogIndex &gt;= lastLogIdx) ||</span><br><span class="line">args.LastLogTerm &gt; lastLogTerm &#123;</span><br><span class="line"></span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.VotedFor = args.CandidateID</span><br><span class="line">reply.VoteGranted = true</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d vote to peer %d (last log idx: %d-&gt;%d, term: %d-&gt;%d)\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, args.CandidateID, args.LastLogIndex, lastLogIdx, args.LastLogTerm, lastLogTerm)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改make"><a class="markdownIt-Anchor" href="#修改make"></a> 修改make</h2><p>除了一些基本的初始化过程,新开了一个goroutine。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func Make(peers []*labrpc.ClientEnd, me int,</span><br><span class="line">persister *Persister, applyCh chan ApplyMsg) *Raft &#123;</span><br><span class="line">rf := &amp;Raft&#123;&#125;</span><br><span class="line">rf.peers = peers</span><br><span class="line">rf.persister = persister</span><br><span class="line">rf.me = me</span><br><span class="line">rf.applyCh = applyCh</span><br><span class="line">// Your initialization code here (2A, 2B, 2C).</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.VotedFor = -1</span><br><span class="line">rf.Logs = make([]LogEntry, 1) // first index is 1</span><br><span class="line">rf.Logs[0] = LogEntry&#123;        // placeholder</span><br><span class="line">Term:    0,</span><br><span class="line">Command: nil,</span><br><span class="line">&#125;</span><br><span class="line">rf.nextIndex = make([]int, len(peers))</span><br><span class="line">rf.matchIndex = make([]int, len(peers))</span><br><span class="line"></span><br><span class="line">rf.electionTimeout = time.Millisecond * time.Duration(400+rand.Intn(100)*4)</span><br><span class="line">rf.electionTimer = time.NewTimer(rf.electionTimeout)</span><br><span class="line">rf.resetTimer = make(chan struct&#123;&#125;)</span><br><span class="line">rf.shutdownCh = make(chan struct&#123;&#125;)           // shutdown raft gracefully</span><br><span class="line">rf.commitCond = sync.NewCond(&amp;rf.mu)          // commitCh, a distinct goroutine</span><br><span class="line">rf.heartbeatInterval = time.Millisecond * 40 // small enough, not too small</span><br><span class="line"></span><br><span class="line">// initialize from state persisted before a crash</span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line">go rf.electionDaemon() // kick off election</span><br><span class="line">return rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选举核心electiondaemon"><a class="markdownIt-Anchor" href="#选举核心electiondaemon"></a> 选举核心electionDaemon</h2><p>除了shutdown，还有两个通道，一个是electionTimer，用于选举超时。<br>一个是resetTimer,用于重置选举超时。<br>注意time.reset是很难正确使用的。<br>一旦选举超时，调用go rf.canvassVotes()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// electionDaemon</span><br><span class="line">func (rf *Raft) electionDaemon() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down electionDaemon.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">case &lt;-rf.resetTimer:</span><br><span class="line">if !rf.electionTimer.Stop() &#123;</span><br><span class="line">&lt;-rf.electionTimer.C</span><br><span class="line">&#125;</span><br><span class="line">rf.electionTimer.Reset(rf.electionTimeout)</span><br><span class="line">case &lt;-rf.electionTimer.C:</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d election timeout, issue election @ term %d\n&quot;, rf.me, rf, rf.me, rf.CurrentTerm)</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">go rf.canvassVotes()</span><br><span class="line">rf.electionTimer.Reset(rf.electionTimeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拉票"><a class="markdownIt-Anchor" href="#拉票"></a> 拉票</h2><p>replyHandler是进行请求返回后的处理。<br>当前节点为了成为leader，会调用每一个节点的RequestVote方法。<br>如果返回过来的term大于当前term，那么当前节点变为follower,重置选举超时时间。</p><p>否则，如果收到了超过一半节点的投票,那么其变为了leader，并立即给其他节点发送心跳检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// canvassVotes issues RequestVote RPC</span><br><span class="line">func (rf *Raft) canvassVotes() &#123;</span><br><span class="line">var voteArgs RequestVoteArgs</span><br><span class="line">rf.fillRequestVoteArgs(&amp;voteArgs)</span><br><span class="line">peers := len(rf.peers)</span><br><span class="line"></span><br><span class="line">var votes = 1</span><br><span class="line">replyHandler := func(reply *RequestVoteReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">if rf.state == Candidate &#123;</span><br><span class="line">if reply.CurrentTerm &gt; voteArgs.Term &#123;</span><br><span class="line">rf.CurrentTerm = reply.CurrentTerm</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">//rf.persist()</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; // reset timer</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.VoteGranted &#123;</span><br><span class="line">if votes == peers/2 &#123;</span><br><span class="line">rf.state = Leader</span><br><span class="line">rf.resetOnElection()    // reset leader state</span><br><span class="line">go rf.heartbeatDaemon() // new leader, start heartbeat daemon</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d become new leader.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">votes++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for i := 0; i &lt; peers; i++ &#123;</span><br><span class="line">if i != rf.me &#123;</span><br><span class="line">go func(n int) &#123;</span><br><span class="line">var reply RequestVoteReply</span><br><span class="line">if rf.sendRequestVote(n, &amp;voteArgs, &amp;reply) &#123;</span><br><span class="line">replyHandler(&amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="心跳检测"><a class="markdownIt-Anchor" href="#心跳检测"></a> 心跳检测</h2><p>1、leader调用每一个节点的AppendEntries方法。<br>2、如果当前节点大于调用节点，那么AppendEntries失败。否则，修改当前的term为最大。<br>3、如果当前节点是leader，始终将其变为follower（为了让leader稳定）<br>4、将当前节点投票给调用者（对于落后的节点）。<br>5、重置当前节点的超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) heartbeatDaemon() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">if _, isLeader := rf.GetState(); !isLeader &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// reset leader&apos;s election timer</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">for i := 0; i &lt; len(rf.peers); i++ &#123;</span><br><span class="line">if i != rf.me &#123;</span><br><span class="line">go rf.consistencyCheck(i) // routine heartbeat</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(rf.heartbeatInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (rf *Raft) consistencyCheck(n int) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">pre := rf.nextIndex[n] - 1</span><br><span class="line">var args = AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.CurrentTerm,</span><br><span class="line">LeaderID:     rf.me,</span><br><span class="line">PrevLogIndex: pre,</span><br><span class="line">PrevLogTerm:  rf.Logs[pre].Term,</span><br><span class="line">Entries:      nil,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line">go func() &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: consistency Check to peer %d.\n&quot;, rf.me, rf, n)</span><br><span class="line">var reply AppendEntriesReply</span><br><span class="line">if rf.sendAppendEntries(n, &amp;args, &amp;reply) &#123;</span><br><span class="line">rf.consistencyCheckReplyHandler(n, &amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down, reject AE rpc request.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: rpc AE, from peer: %d, term: %d\n&quot;, rf.me, rf, args.LeaderID, args.Term)</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">//DPrintf(&quot;[%d-%s]: AE failed from leader %d. (heartbeat: leader&apos;s term &lt; follower&apos;s term (%d &lt; %d))\n&quot;,</span><br><span class="line">//rf.me, rf, args.LeaderID, args.Term, rf.currentTerm)</span><br><span class="line">reply.CurrentTerm = rf.CurrentTerm</span><br><span class="line">reply.Success = false</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if rf.CurrentTerm &lt; args.Term &#123;</span><br><span class="line">rf.CurrentTerm = args.Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// for stale leader</span><br><span class="line">if rf.state == Leader &#123;</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">&#125;</span><br><span class="line">// for straggler (follower)</span><br><span class="line">if rf.VotedFor != args.LeaderID &#123;</span><br><span class="line">rf.VotedFor = args.LeaderID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// valid AE, reset election timer</span><br><span class="line">// if the node recieve heartbeat. then it will reset the election timeout</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">reply.Success = true</span><br><span class="line">reply.CurrentTerm = rf.CurrentTerm</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理心跳检测返回"><a class="markdownIt-Anchor" href="#处理心跳检测返回"></a> 处理心跳检测返回</h2><p>如果心跳检测失败了，那么变为follower，重置选举超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// n: which follower</span><br><span class="line">func (rf *Raft) consistencyCheckReplyHandler(n int, reply *AppendEntriesReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if rf.state != Leader &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.Success &#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">// found a new leader? turn to follower</span><br><span class="line">if rf.state == Leader &amp;&amp; reply.CurrentTerm &gt; rf.CurrentTerm &#123;</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d found new term (heartbeat resp from peer %d), turn to follower.&quot;,</span><br><span class="line">rf.me, rf, rf.me, n)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[111]-raft理论与实践[2]-lab2a实验说明</title>
    <link href="https://dreamerjonson.com/2020/01/06/golang-111-raft-2/"/>
    <id>https://dreamerjonson.com/2020/01/06/golang-111-raft-2/</id>
    <published>2020-01-06T06:57:48.000Z</published>
    <updated>2020-01-14T03:12:52.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>1、阅读<a href="http://nil.csail.mit.edu/6.824/2017/papers/raft-extended.pdf" target="_blank" rel="noopener">raft论文</a><br>2、阅读我写的<a href="https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/">raft理论与实践[1]-理论篇</a><br>3、由于我们需要模拟rpc远程调用， 因此需要查看我写的这篇文章： <a href="https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/">模拟RPC远程过程调用</a><br>4、实验开始，我们首先需要拉取代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:dreamerjackson/golang-deep-distributed-lab.git</span><br><span class="line">git checkout --hard   4e6446c</span><br></pre></td></tr></table></figure><h2 id="实验说明"><a class="markdownIt-Anchor" href="#实验说明"></a> 实验说明</h2><p>此代码中labrpc 与 labgob 为模拟rpc的 package。<br>raft文件夹为此实验用到的代码框架。 在其中已经写好了一部分代码，还需要我们通过实验来完善它。<br>在本实验中，我们只需要关注raft.go文件，并实现选举逻辑和心跳检测逻辑。<br>本实验的目标是要保证，唯一的leader能够被选举。<br>当leader被选举后，如果没有任何失败，其将会保持leader。<br>当leader被选举后，如果leader奔溃或者to/from leader 的网络包丢失，则新的leader将会产生。<br>要验证代码的正确性，运行go test -run 2A</p><h2 id="实验提示"><a class="markdownIt-Anchor" href="#实验提示"></a> 实验提示</h2><p>1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。<br>2、填充RequestVoteArgs和RequestVoteReply结构。 修改Make()以创建一个后台goroutine，该后台goroutine将在有一段时间没有收到其他节点的请求时通过发出RequestVote RPC来定期启动领导者选举。 这样，节点将了解谁是leader（如果已经有leader），或者成为leader本身。 实现RequestVote（）RPC处理程序，以便节点之间相互投票。<br>3、要实现心跳检测，请定义AppendEntries RPC结构（尽管您可能还不需要所有参数），并让leader定期调用其他节点此方法。 编写AppendEntries RPC方法，该方法将重置选举超时，以便在已经有leader时，阻止其他节点成为leader。<br>4、确保不同对等方的选举超时不会总是同时触发，否则所有节点都只会为自己投票，而没有人会成为领导者。<br>5、测试要求leader每秒发送心跳RPC的次数不得超过十次。<br>6、测试要求在leader失败后，也能够再5秒之内选出新的leader。 您必须选择足够短的选举超时时间（以及因此产生的心跳间隔），<br>以使选举很有可能在不到五秒钟的时间内完成，即使需要进行多轮选举也是如此。<br>7、raft论文的5.2提到选举超时的范围是150到300毫秒，但是仅当领导者发送心跳的频率大大超过每150毫秒一次的频率时，此范围才有意义。<br>由于测试要求您的心跳检测为每秒10个，因此您将必须使用大于150到300毫秒的选举超时时间，但不能太大，因为那样的话，您可能会在五秒钟内无法选举领导者。<br>8、使用go的rand方法产生随机数。<br>9、go的time.Timer 和 time.Ticker 很难使用正确。<br>10、要调试代码，可以将util.go 的debug设置为1.<br>11、您应该使用go test -race检查代码，并修复它报告的所有问题。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://github.com/dreamerjackson/Distributed-Systems/blob/master/Lec05_Fault_Tolerance_Raft/l-raft.txt" target="_blank" rel="noopener">讲义</a><br><a href="https://pdos.csail.mit.edu/6.824/notes/l-raft.txt" target="_blank" rel="noopener">讲义新</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h2&gt;
&lt;p&gt;1、阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/raft-exten
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>6.s081[1]-操作系统原理</title>
    <link href="https://dreamerjonson.com/2020/01/04/6-s081-1/"/>
    <id>https://dreamerjonson.com/2020/01/04/6-s081-1/</id>
    <published>2020-01-04T06:27:36.000Z</published>
    <updated>2020-01-16T02:20:05.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>实验1需要我们调用unix操作系统保持出的接口，因此首先需要了解unix操作系统有关的知识。</p><h2 id="操作系统operating-system的功能"><a class="markdownIt-Anchor" href="#操作系统operating-system的功能"></a> 操作系统（operating system）的功能</h2><p>操作系统的任务是在多个程序之间共享一台计算机，并提供比单独的硬件所支持的更为有用的服务集。<br>操作系统管理和抽象化低级硬件，因此，例如，文字处理器不必担心自己正在使用哪种类型的硬件。<br>操作系统允许多个程序之间共享硬件，以便它们可以并发运行。<br>最后，操作系统提供了程序交互的方式，以便它们可以共享数据，协同工作。</p><p>操作系统为用户程序提供接口去调用。设计一个好的接口操作系统接口非常困难。<br>一方面希望简单，一方面又希望实现复杂的功能。<br>一种好的设计思路是接口之间可以通过某种机制组合起来以实现复杂的操作。</p><p>本实验中，使用了xv6 操作系统。其提供了unix的基本操作系统接口，并且模仿了Unix的内部设计。<br>unix提供的接口很少，但是由于其可以组合的机制，提供了难以想象的通用性。该接口非常成功，以至于现代操作系统（BSD，Linux，Mac OS X，Solaris，甚至在较小程度上是Microsoft Windows）都具有类似Unix的接口。了解xv6是了解这些系统和许多其他系统的良好起点。</p><p>内核是操作系统的核心，为运行的程序提供服务。 每个正在运行的程序（称为进程）都具有包含指令，数据和堆栈的内存。<br>指令说明了程序的运行逻辑。数据是指令运行所需要的变量。堆栈组织程序的过程调用。<br>当进程需要调用内核服务时，它将通过操作系统提供的接口进行过程调用。 这样的过程称为系统调用。<br>内核使用CPU的硬件保护机制来确保在用户空间中执行的每个进程只能访问其自己的内存。<br>用户程序调用操作系统接口后，硬件提高权限级别，并开始在内核中执行预先安排的功能。</p><p>shell是一个普通程序，可读取用户命令并执行命令。 shell是用户程序而不是内核的一部分，这一事实说明了操作系统接口的强大功能。shell没有什么特别之处，这也意味着shell易于更换；现代Unix系统有多种shell可供选择，每种shell都有其自己的用户界面和脚本功能。 xv6 shell是Unix Bourne shell的简单实现。 可以在（user / sh.c：1）中找到其实现。</p><h2 id="操作系统接口"><a class="markdownIt-Anchor" href="#操作系统接口"></a> 操作系统接口</h2><p>xv6进程由用户空间内存（指令，数据和堆栈）和内核专有的每个进程状态组成。<br>xv6保证进程的并发执行，在多个进程之间切换CPU能力。<br>当某个进程未执行时，xv6保存其CPU寄存器，并在下次运行该进程时恢复它们。 内核将进程标识符或pid与每个进程相关联。<br>进程可以使用fork系统调用来创建新进程。 Fork创建一个称为子进程的新进程，该进程与父进程的内存完全相同。<br>Fork在子进程与父进程中都会返回。<br>在父进程中，fork返回子进程的pid； 在子进程中，它返回零。<br>例如，考虑以下用C编程语言编写的程序片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int pid = fork();</span><br><span class="line">if(pid &gt; 0)&#123;</span><br><span class="line">    printf(&quot;parent: child=%d\en&quot;, pid);</span><br><span class="line">    pid = wait(0);</span><br><span class="line">    printf(&quot;child %d is done\en&quot;, pid);</span><br><span class="line">&#125; else if(pid == 0)&#123;</span><br><span class="line">    printf(&quot;child: exiting\en&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf(&quot;fork error\en&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exit导致调用进程停止执行并释放资源，例如内存和打开的文件。<br>exit接受一个整数状态参数，通常0表示成功，1表示失败。<br>wait系统调用返回当前进程已退出子进程的pid，并将该子进程的退出状态传递给wait。<br>如果子进程都没有退出，一直会等待。<br>如果父进程不在乎子进程的退出状态，则可以传递状态0。</p><p>在下面的例子中，输出是：<br>parent: child=1234<br>child: exiting</p><p>也可能出现另外的情况，具体取决于父进程还是子进程首先进入其printf调用。</p><p>子进程退出后，父进程的wait返回，导致父进程打印出：<br>parent: child 1234 is done。</p><p>尽管子进程最初具有与父进程相同的内存内容，但是父进程和子进程执行时使用的是不同的内存和不同的寄存器。<br>更改一个变量不会影响另一个变量。<br>例如，当wait的返回值在父进程中存储到pid中时，它不会更改子进程中的pid。 子进程中的pid的值仍为零。</p><p>exec系统调用使用从文件系统中存储的文件加载的新的内存映像替换调用进程的内存。<br>该文件必须具有特定的格式，该格式指定文件的哪一部分包含指令，哪一部分是数据，从哪条指令开始等。<br>xv6使用ELF格式，第3章将对此进行详细讨论。<br>当exec成功执行时，它不会返回到调用程序。从文件加载的指令在ELF标头中声明的入口点开始执行。<br>Exec接受两个参数：包含可执行文件的文件名和一个字符串参数数组。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char *argv[3];</span><br><span class="line">argv[0] = &quot;echo&quot;;</span><br><span class="line">argv[1] = &quot;hello&quot;;</span><br><span class="line">argv[2] = 0;</span><br><span class="line">exec(&quot;/bin/echo&quot;, argv);</span><br><span class="line">printf(&quot;exec error\en&quot;);</span><br></pre></td></tr></table></figure><p>该片段将调用程序以程序/ bin / echo的实例替换，参数列表为echo hello。 大多数程序会忽略第一个参数，这通常是程序的名称</p><p>xv6 Shell使用上述调用执行用户运行的程序。</p><p>xv6 Shell使用上述调用代表用户运行程序。<br>shell的主要结构很简单； 参见main（user / sh.c：145）。<br>主循环使用getcmd从用户读取一行输入。 然后，它将调用fork，这将创建shell进程的副本。<br>父进程调用wait，而子进程运行命令。 例如，如果用户键入“ echo hello”给shell，则将以“ echo hello”作为参数调用runcmd。 runcmd（user / sh.c：58）运行实际命令<br>对于“ echo hello”，它将调用exec（user / sh.c：78）<br>如果exec成功，则子进程将从echo执行指令，而不是runcmd。<br>在某些时候，echo将调用exit，这将导致父进程从main（user / sh.c：145）的wait中返回。</p><p>您可能想知道为什么fork和exec不能在单个调用中组合？ 稍后我们将看到，用于创建进程和加载程序的单独调用在Shell中用于I / O重定向的用法很巧妙。<br>为了避免创建重复进程然后立即替换它的浪费，运行中的内核通过使用虚拟内存技术（如copy-on-write 写时复制）来针对此用例优化fork的实现。</p><p>Xv6隐式分配了大多数用户空间内存：fork分配了子进程复制父进程所需的内存，而exec分配了足够的内存来保存可执行文件。<br>一个在运行时需要更多内存的进程（可能是malloc）可以调用sbrk（n）将其数据内存增加n个字节。 sbrk返回新内存的位置。<br>Xv6没有提供用户概念来保护一个用户免受另一个用户侵害；用Unix术语，所有xv6进程都以root身份运行。</p><h2 id="io-与文件描述符"><a class="markdownIt-Anchor" href="#io-与文件描述符"></a> I/O 与文件描述符</h2><pre><code>文件描述符是一个小的整数，表示进程可以从中读取或写入的内核管理的对象。 进程可以通过打开文件，目录或设备，或通过创建管道，或通过复制现有描述符来获取文件描述符。 为简单起见，我们通常将文件描述符所指的对象称为“文件”； 文件描述符接口抽象了文件，管道和设备之间的差异，使它们看起来都像字节流。在内部，xv6内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符专用空间。 按照惯例，进程从文件描述符0（标准输入）读取，将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。 就像我们将看到的那样，shell利用约定来实现I / O重定向(redirection)和管道(pipelines)。 shell确保始终打开三个文件描述符（user / sh.c：151），默认情况下，这三个文件描述符是控制台(console)的文件描述符。</code></pre><p>read系统调用从文件描述符读取字节。<br>write系统调用从文件描述符写入字节。<br>调用read（fd，buf，n）最多从文件描述符fd中读取n个字节，将它们复制到buf中，并返回读取的字节数。 引用文件的每个文件描述符都有一个与之关联的偏移量。read从当前文件偏移量读取数据，随着读取到的数据增加，文件的偏移量随之增加。当没有更多字节可以读取时，read将返回零以指示文件末尾。<br>调用write（fd，buf，n）将buf中的n个字节写入文件描述符fd，并返回写入的字节数。 仅在发生错误时才写入少于n个字节。 与读操作类似，写操作会在当前文件偏移量处写入数据，然后将偏移量增加写入的字节数：每次写操作都从上次中止的位置开始。</p><p>以下程序片段（cat命令的功能）将数据从其标准输入复制到其标准输出。 如果发生错误，它将向标准错误写入一条消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char buf[512];</span><br><span class="line">int n;</span><br><span class="line">for(;;)&#123;</span><br><span class="line">    n = read(0, buf, sizeof buf);</span><br><span class="line">    if(n == 0)</span><br><span class="line">    break;</span><br><span class="line">    if(n &lt; 0)&#123;</span><br><span class="line">        fprintf(2, &quot;read error\en&quot;);</span><br><span class="line">        exit();</span><br><span class="line">    &#125;</span><br><span class="line">    if(write(1, buf, n) != n)&#123;</span><br><span class="line">        fprintf(2, &quot;write error\en&quot;);</span><br><span class="line">        exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在代码片段中要注意的重要一点是cat不知道它是从文件，控制台还是管道中读取。 同样，cat不知道它是要打印到控制台，文件还是其他地方。 使用文件描述符以及文件描述符0是标准输入和输出文件描述符是标准输出的约定可以实现cat的简单实现。close系统调用将释放文件描述符，以供将来的open，pipe或dup系统调用重用。 新分配的文件描述符始终是当前进程中编号最小的未使用的描述符。</code></pre><p>文件描述符和fork交互使I/O重定向易于实现。Fork会复制父文件的文件描述符表及其内存，以便子文件与父文件打开完全相同的文件。 exec系统调用替换了调用进程的内存，但保留了其文件表。 此行为允许Shell通过分叉，重新打开选定的文件描述符，然后exec新程序来实现I / O重定向。 这是shell为cat &lt;input.txt命令运行的代码的简化版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *argv[2];</span><br><span class="line">    argv[0] = &quot;cat&quot;;</span><br><span class="line">    argv[1] = 0;</span><br><span class="line">    if(fork() == 0) &#123;</span><br><span class="line">        close(0);</span><br><span class="line">        open(&quot;input.txt&quot;, O_RDONLY);</span><br><span class="line">        exec(&quot;cat&quot;, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当child关闭文件描述符0后，0 是最小的文件描述符。因此open操作将使文件描述符0（标准输入）指向文件input.txt.xv6 shell中的I / O重定向代码完全以这种方式工作（user / sh.c：82）。</p><p>现在应该清楚为什么将fork和exec分开调用是一个好主意？ 因为如果它们是分开的，则shell可以fork一个child，在该child中使用open，close，dup来更改标准输入和输出文件描述符，然后exec。 不需要更改正在执行的程序（在我们的示例中为cat）。 如果将fork和exec组合到单个系统调用中，则shell将需要一些其他（可能更复杂）的方案来重定向标准输入和输出，或者程序本身将必须了解如何重定向I / O。</p><p>尽管fork复制了文件描述符表，但每个潜在文件的偏移量在父级和子级之间共享。 考虑以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(fork() == 0) &#123;</span><br><span class="line">    write(1, &quot;hello &quot;, 6);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">    write(1, &quot;world\en&quot;, 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，父进程和子进程都将写入文件描述符1.最后输出的数据是&quot;hello world&quot;<br>父进程的写入会等到子进程写入后进行(由于wait)。两个文件描述符共享一个偏移量。<br>此行为有助于从Shell命令序列产生顺序输出，例如（echo hello; echo world）&gt; output.txt。<br>dup系统调用复制了一个现有的文件描述符，并返回了一个新的文件描述符，该描述符引用了相同的潜在I/O对象。两个文件描述符共享一个偏移量，就像fork所复制的文件描述符一样。这是将hello world写入文件的另一种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(1);</span><br><span class="line">write(1, &quot;hello &quot;, 6);</span><br><span class="line">write(fd, &quot;world\en&quot;, 6);</span><br></pre></td></tr></table></figure><p>如果两个文件描述符是通过fork和dup调用序列从同一原始文件描述符派生的，则它们共享一个偏移量。 否则，文件描述符不共享偏移量，即使它们是对同一文件的open产生的。 Dup允许shell执行以下命令： ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1。 2&gt;＆1告诉shell将文件描述符2与描述符1相同。已存在文件的名称和文件不存在等错误消息都将显示在文件tmp1中。 xv6 Shell不支持错误文件描述符的I / O重定向，但是现在您知道如何实现它。</p><p>文件描述符是一种强大的抽象，因为它们隐藏了它们所连接的对象的详细信息：写入文件描述符1的进程可能正在写入文件，诸如控制台的设备或管道。</p><h2 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h2><p>管道是一个小的内核缓冲区，以一对文件描述符的形式暴露给进程，一个用于读取，一个用于写入。 将数据写入管道的一端可使该数据可从管道的另一端读取。 管道为流程进行通信提供了一种方法。 以下示例代码运行程序wc,使用标准输入连接到管道的读取端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int p[2];</span><br><span class="line">char *argv[2];</span><br><span class="line">argv[0] = &quot;wc&quot;;</span><br><span class="line">argv[1] = 0;</span><br><span class="line">pipe(p);</span><br><span class="line">if(fork() == 0) &#123;</span><br><span class="line">    close(0);</span><br><span class="line">    dup(p[0]);</span><br><span class="line">    close(p[0]);</span><br><span class="line">    close(p[1]);</span><br><span class="line">    exec(&quot;/bin/wc&quot;, argv);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    close(p[0]);</span><br><span class="line">    write(p[1], &quot;hello world\en&quot;, 12);</span><br><span class="line">    close(p[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>程序调用pipe创建一个新管道，并将读取和写入文件描述符记录在数组p中。 在fork之后，父进程和子进程都具有引用管道的文件描述符。 子进程将读取端复制到文件描述符0上，关闭p中的文件描述符，然后执行wc。 当wc从其标准输入中读取时，它将从管道中读取。 父进程关闭管道的读取侧，写入管道，然后关闭写入侧。如果没有可用数据，则在管道上进行读取以等待写入数据或所有引用写入端的文件描述符被关闭； 在后一种情况下，读取将返回0，就像到达数据文件的末尾一样。 读取管道会一直堵塞直到无法接受到数据。因此，对于子进程来说，在执行上述wc之前关闭管道的写端很重要：如果wc进程的文件描述符之一引用了管道的写端，则wc将永远等不到文件末尾 。</code></pre><p>xv6 shell实现了管道，例如grep fork sh.c | wc -l 类似于上面的代码（user / sh.c：100）。 子进程创建一个管道，以将管道的左端与右端连接起来。 然后，它在管道的左端调用fork和runcmd，在右端调用fork和runcmd，并等待两者都完成。 管道的右端可能是一个命令，该命令本身包括一个管道（例如a | b | c），该管道本身派生了两个新的子进程（一个用于b，一个用于c）。 因此，shell可以创建进程树。 该树的叶子是命令，内部节点是等待左右子节点完成的进程。 原则上，您可以让内部节点在管道的左端运行，但是这样做会使实现复杂化。</p><p>管道似乎没有临时文件强大：echo hello world | wc<br>可以在没有管道的情况下实现：<br>echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</p><p>在这种情况下，管道比临时文件至少具有四个优点。 首先，管道会自动清理自己； 使用文件重定向，shell必须在完成后小心删除/ tmp / xyz。 其次，管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。 第三，管道允许并行执行管道阶段，而文件方法要求第一个程序在第二个程序启动之前完成。 第四，如果要实现进程间通信，则管道的读写锁比文件的 non-blocking语义更有效。</p><h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2><p>xv6文件系统提供了数据文件和目录，这些数据文件是原始的字节数组。目录包含对数据文件和其他目录的命名引用。 目录形成一棵树，从一个特殊的root目录开始。</p><p>类似于/a/b/c的路径是指根目录/中名为a的文件夹中名为b的文件夹中名为c的文件或文件夹。<br>不以/开头的路径是相对于调用进程的当前目录的。调用进程的当前目录可以通过chdir系统调用对其进行更改。</p><p>下面这两个程序片段都打开同一个文件（假设文件存在）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chdir(&quot;/a&quot;);</span><br><span class="line">chdir(&quot;b&quot;);</span><br><span class="line">open(&quot;c&quot;, O_RDONLY);</span><br><span class="line"></span><br><span class="line">open(&quot;/a/b/c&quot;, O_RDONLY);</span><br></pre></td></tr></table></figure><p>第一个代码片段将进程的当前目录更改为/a /b； 第二个既不引用也不更改进程的当前目录。<br>有多个操作系统接口来创建新文件或文件夹：mkdir创建新文件夹，使用O_CREATE标志调用open将创建新数据文件，而mknod将创建新设备文件。 如下例所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(&quot;/dir&quot;);</span><br><span class="line">fd = open(&quot;/dir/file&quot;, O_CREATE|O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line">mknod(&quot;/console&quot;, 1, 1);</span><br></pre></td></tr></table></figure><p>Mknod在文件系统中创建一个文件，但是该文件没有内容。 但是，文件的元数据会将其标记为设备文件，并记录主设备号和次设备号（mknod的两个参数），它们唯一地标识内核设备。 当以后有一个进程打开文件时，内核会将read和write系统调用转换到内核设备的读写实现，而不是将它们转换到文件系统。</p><p>fstat系统调用得到有关文件描述符引用的对象的信息。此对象信息返回结构体stat，定义在<br>stat.h (kernel/stat.h)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define T_DIR 1 // Directory</span><br><span class="line">#define T_FILE 2 // File</span><br><span class="line">#define T_DEVICE 3 // Device</span><br><span class="line">struct stat &#123;</span><br><span class="line">    int dev; // File system’s disk device</span><br><span class="line">    uint ino; // Inode number</span><br><span class="line">    short type; // Type of file</span><br><span class="line">    short nlink; // Number of links to file</span><br><span class="line">    uint64 size; // Size of file in bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件名与文件不同； 同一个文件（称为inode）可以具有多个名称（称为links）。<br>link系统调用将创建另一个文件名称，该名称引用与现有文件相同的inode。 下面的程序片段创建了一个名为a又为b的新文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;a&quot;, O_CREATE|O_WRONLY);</span><br><span class="line">link(&quot;a&quot;, &quot;b&quot;);</span><br></pre></td></tr></table></figure><p>读取,写入a与读取,写入到b相同。 每个inode由唯一的inode编号标识。 在上面的代码片段之后，可以通过检查fstat的结果确定a和b是否引用相同的文件：两者将返回相同的inode编号（ino），并且nlink将变为2。</p><p>unlink系统调用从文件系统中删除一个名称。 仅当文件的link计数为零且没有文件描述符引用该文件时， 才会将inode和其所在的磁盘空间清除。</p><p>因此当执行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(&quot;a&quot;);</span><br></pre></td></tr></table></figure><p>之后，使用名称b任然能够访问文件。</p><p>下面的程序片段是一种惯用的方式创建一个临时inode。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR);</span><br><span class="line">unlink(&quot;/tmp/xyz&quot;);</span><br></pre></td></tr></table></figure><p>当fd文件描述符被关闭后，临时的inode将会被清除。<br>用于文件系统操作的Shell命令是作为用户级程序（例如mkdir，ln，rm等）实现的。该设计允许任何人通过添加新的用户程序扩展Shell。在事后看来，似乎是理所当然的。<br>但和Unix同时期的其他系统设计，通常将这样的命令构建到shell中（并将shell构建到内核中）。<br>cd是一个例外，它内置在shell中（user / sh.c：160）。 cd必须更改shell本身的当前工作目录。 如果cd以常规命令运行，那么shell将派生一个子进程，该子进程将运行cd，而cd会更改该子进程的工作目录。 父进程(即shell)的工作目录不会更改。</p><h2 id="终结"><a class="markdownIt-Anchor" href="#终结"></a> 终结</h2><p>Unix结合了文件描述符，管道和方便的shell语法以对其进行操作，这是编写通用可复用程序的重大进步。这是Unix的强大功能和广泛使用的原因，外壳程序是第一种所谓的“脚本语言”。Unixit系统调用接口在BSD,Linux,和Mac OSX 上广泛使用。</p><p>Unix系统调用接口已通过可移植操作系统接口（POSIX）标准进行了标准化。 Xv6不兼容POSIX。 它抛弃一些了系统调用（包括诸如lseek之类的基本调用），仅部分实现了系统调用以及其他差异。 xv6的主要目标是简单性和清晰度，同时提供简单的类UNIX系统调用接口。 为了运行基本的Unix程序，一些人用更多的系统调用和一个简单的C库扩展了xv6。 但是，与xv6相比，现代内核提供了更多的系统调用和内核服务。 例如，它们支持联网，窗口系统，用户级线程，许多设备的驱动程序等。 现代内核不断快速发展，并提供了POSIX以外的许多功能。<br>在很大程度上，现代Unix派生的操作系统没有遵循早期的Unix模型，即将设备公开为特殊文件，例如上面讨论的控制台设备文件。Unix的作者继续构建Plan9，将“资源即文件”概念应用于现代设施，将网络，图形和其他资源表示为文件或文件树。<br>文件系统和文件描述符是强大的抽象。 即使这样，也存在其他模型。 Multics是Unix的前身，它以一种类似于内存的方式抽象了文件存储，从而产生了截然不同的界面风格。 Multics设计的复杂性直接影响了Unix的设计师，后者试图构建更简单的东西。<br>本书探讨了xv6如何实现其类似Unix的接口，但是这些思想和概念不仅适用于Unix。 任何操作系统都必须将进程多路复用到基础硬件上，将进程彼此隔离，并提供用于受控的进程间通信的机制。 研究xv6之后，您应该能够查看其他更复杂的操作系统，</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://pdos.csail.mit.edu/6.828/2019/labs/util.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2019/labs/util.html</a><br><a href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</a><br><a href="https://pdos.csail.mit.edu/6.828/2019/lec/l-overview.txt" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2019/lec/l-overview.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;实验1需要我们调用unix操作系统保持出的接口，因此首先需要了解unix操作系统有关的知识。&lt;/p&gt;
&lt;h2 id=&quot;操作系统operating
      
    
    </summary>
    
      <category term="unix" scheme="https://dreamerjonson.com/categories/unix/"/>
    
    
      <category term="unix" scheme="https://dreamerjonson.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>golang[110]-raft算法理论与实践[1]</title>
    <link href="https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/"/>
    <id>https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/</id>
    <published>2019-12-29T15:06:17.000Z</published>
    <updated>2020-01-14T12:01:14.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>我计划写raft的一系列文章，包含从理论到代码实践，此文章依托于MIT的研究生课程。</p><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>raft 是一种分布式的共识算法，其目的是要实现多个节点集群的容错性,一致性从而能够构建大规模的软件系统。<br>在raft之前，比较有名的是Paxos。但是paxos难于理解。<br>raft的诞生是为了让共识算法更容易理解,在工程上更容易实现。</p><p>和其他的共识算法不同的是，raft具有下面的特点：<br>1、leader：raft中会有一个领导者具有超级权限，可以把自己的log 复制到其他节点中。<br>2、leader election： raft每隔一段随机的时间就会进行leader的选举<br>3、raft允许集群配置变化时正常运行。</p><h2 id="replicated-state-machine"><a class="markdownIt-Anchor" href="#replicated-state-machine"></a> Replicated state machine</h2><p>状态机是分布式系统中的一个重要概念，任何一个系统的最终状态都可以看成是每一个操作的集合。因此，算法会维护一份replicated log，将每一份操作都存储起来。<br>每一个节点只要按顺序执行log中的命令，就会到达相同的最终状态。这样，即便是系统奔溃也可以快速的恢复。<br>共识算法需要保证relicated log的一致性,服务器收到客户端发出来的执行命令Command后，会将其加入到log中。<br>服务器之间会相互的交流，保证最后的log的一致性（即便服务器奔溃），即Command 会复制到其他服务器的log中，所有服务器的log是相同的，有序的。<br>其他服务器会执行此log，即会执行此命令。最后，所有的服务器都会到达同一个状态。</p><p>共识算法必须满足下面的属性：<br>1、在极端情况下（丢包、奔溃）任然能够保证安全性。<br>2、大多数节点正常的情况下能够保证可用。<br>3、不能依靠时间戳去保证log的一致性。<br>4、当大部分的节点通过RPC远程调用交流 达成共识后，command就可以被确认和执行。小部分节点的不稳定不会影响整个系统。</p><h2 id="raft-basic"><a class="markdownIt-Anchor" href="#raft-basic"></a> raft basic</h2><p>raft集群一般保持奇数个数量（5个节点比较普遍). 从而只要大部分节点存活，即可用。<br>raft中的节点有3种状态。 leader, Candidates, follower。<br>1、一般的状态只会存在一个leader，其余的节点都是follower。<br>2、leader会处理所有的客户端请求， 如果是客户端请求follower，也会被转发到leader处理。<br>3、Candidates 是一种选举时候的过渡状态，用于自身拉票选举leader。</p><p>在raft中会有一个叫做term的时间周期。term是以选举leader开始的，如果Candidates选举成为了leader，那么其会成为这个term剩下时间的leader。<br>有时候，在整个term周期都没有选举出leader。这时一个新的选举会在不久后开始。<br>Terms 在raft中类似于一种时间戳，后一个一定比前一个后发生，这一点和比特币中的区块链很类似。<br>每一个服务器会存储一个当前的term，其会随着时间的增加而增长。如果某一个节点的当前term小于其他节点，那么节点会更新自己的term为最大的term。<br>如果一个candidate 发现自己当前的term 过时了，那么其会立即变为follower。<br>raft节点之间通过RPC（远程过程调用）来进行通信。 RequestVote 方法用于candidate在选举时候使用，AppendEntries用于leader在通知其他节点复制log时使用。同时也用于心跳检测。<br>RPC 是并发的，并支持失败重试。</p><h2 id="选举"><a class="markdownIt-Anchor" href="#选举"></a> 选举</h2><p>在raft中会有一套心跳检测，只要follower收到来自leader或者Candidates的数据，那么其会保持follower的状态。<br>如果follower一段时间内没有收到RPC请求，这意味着选举超时（ election timeout ）。<br>这时follower会将current term 加1，过渡到Candidates状态。<br>其会给自己投票，并发送RequestVote RPC请求给其他的节点，拉票！</p><p>Candidates状态会持续，直到下面的3种情况发生:<br>1、当其获得了大部分节点的支持后，其赢得了选举，变为了leader。<br>一旦其变为了leader，其会向其他节点发送 AppendEntries RPC， 确认其leader的地位，阻止选举。<br>2、其他节点成为了leader。<br>如果其收到了其他节点的AppendEntries RPC. 并发现其他节点的current term比自己的大,则其变为follower状态。<br>3、一段时间过去任然没有参与者。<br>如果有许多的节点同时变为了candidate,则可能会出现一段时间内都没有节点能够选举成功的情况。<br>在raft中，为了快速解决并修复这个问题，规定了每一个candidate在选举前会重置一个随机的选举超时（ election timeout ）时间，此随机时间会在一个区间内（eg.150-300ms）<br>这样保证了，在大部分的情况下，有一个唯一的节点首先选举超时，其在大部分节点选举超时前发送心跳检测，赢得了选举。</p><p>当一个leader在心跳检测中发现另一个节点有更高的term时，会转变为follower。否则其将一直保持leader状态。</p><h2 id="日志复制log-replication"><a class="markdownIt-Anchor" href="#日志复制log-replication"></a> 日志复制(Log replication)</h2><p>当成为leader后，其会接受来自客户端的请求。每一个客户端请求都包含一个将要被节点的状态机执行的command。<br>leader其会将这个command 包装为一个entry放入到log中，并通过AppendEntries RPC 发送给其他节点，要求其添加此entry到log中。</p><p>当entry被 大部分的节点接受并复制后，这个entry的状态变为了committed.  raft算法保证了commited entry到最后一定能够会被所有节点的状态机执行。<br>一旦follower知道（AppendEntries RPC）某一个entry被commit之后，follower会按顺序执行log中的entry</p><img src="/2019/12/29/golang-110-lab-raft/1.png" title="类型"><center><div>entry in log</div></center>如图所示，我们可以把log 理解为entry的集合。在entry中包含了common命令、entry所在的term 以及每一个entry的顺序编号index。<p>raft的一致性保证了下面的属性：<br>1、如果在不同节点中log中的entry有相同的index 和term。 那么一定存储的是相同的command。<br>2、如果在不同节点中log中的entry有相同的index 和term。 那么此entry之前的所有entry都是相同的。</p><img src="/2019/12/29/golang-110-lab-raft/2.png" title="类型"><center><div>leader crashes</div></center>节点f可能会发生，如果其是term 2的leader, 添加entry到log中，但是没有commit时就奔溃了，其快速恢复后又变为了term 3 的leader， 添加entry到log中，没有commit又继续奔溃了。<p>在正常的情况下，上面的两个属性都能满足，但是异常情况下，这种情况会被打破，可能会出现如上图所示的情形，</p><p>在raft中，为了处理这样的不一致性，强制要求follower的log与leader的log要一致。</p><p>因此leader必须要发现一个entry，在这个entry之后的都是不相同的entry。在这个entry之前的都是一致的entry。在leader中会为每一个follower维护一份nextIndex 数组。标志了将要发送给follower的下一个index。 最后，follower会删除掉所有不同的entry，并用和leader一致的log。这一过程，都会通过AppendEntries RPC 执行完毕。当AppendEntries RPC返回success，就表明follower 与 leader的log是一致的。</p><h2 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h2><p>上面的属性还不能够充分的保证系统的安全性。 考虑下面的例子：</p><img src="/2019/12/29/golang-110-lab-raft/3.png" title="类型"><center><div>safe problem</div></center>上图要说明的是，一个已经被commit的entry 在目前的情况下是有可能被覆盖掉的。例如在a阶段s1成为了leader，其entry还没有commit。 在b阶段,s1奔溃，s5成为了leader ，添加log但是任然没有commit。 在c阶段，s5奔溃，s1成为了leader。其entry成为了commit。 在d阶段s1奔溃，s5成为了leader，其会将本已commit的entry给覆盖掉。<p>raft使用一种更简单的方式来解决这个难题，raft为leader添加了限制:<br>要成为leader 必须要包含过去所有的commit entry。<br>Candidates 要想成为leader，必须要经过大部分follower节点的同意。<br>而commit entry 也表明其已经存在于大部分的服务器中。 因此commit entry 至少会出现在这些follower节点中的至少有一个节点。因此我们可以证明，在大部分的follower中，至少有一个是包含了leader的所有commit entry的。<br>因此 如果一个candidate的log是最新的（即他与其他的节点对比时，如果term更大的，最新。如果term相同的，那么越长的那个log越新。）其才可以成为leader。</p><p>因此可知，一个leader一定包含了以前leader的commit entry。</p><h2 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> todo</h2><p>配置改变、 日志压缩快照（log compaction / snapshotting ）</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>上面对于raft的描述，保证了存在5点：<br>1、Election Safety：在一个term周期内只会存在一个leader。<br>2、Leader Append-Only： leader只会添加log，而不会删除或者覆盖log。<br>3、Log Matching：如果两个log有一个相同index与term的entry，那么他们之前的log都是相同的。<br>4、Leader Completeness：如果一个log entry在一个term周期成为commit， 那么其一定会存在于下一个leader的log中。<br>5、State Machine Safety：如果某节点已经将index A 应用于其状态机。则以后其他节点不可能在同一index A 却具有不同的log entry。 因为应用到状态机说明已经被commit，而借助于第4点得证。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="http://nil.csail.mit.edu/6.824/2017/papers/raft-extended.pdf" target="_blank" rel="noopener">raft论文</a><br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">raft可视化</a><br><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">知乎，写得一般但是有借鉴地方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;我计划写raft的一系列文章，包含从理论到代码实践，此文章依托于MIT的研究生课程。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;mar
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>emacs--构建cc++IDE</title>
    <link href="https://dreamerjonson.com/2019/12/25/emacs-cc/"/>
    <id>https://dreamerjonson.com/2019/12/25/emacs-cc/</id>
    <published>2019-12-25T09:10:26.000Z</published>
    <updated>2019-12-25T09:28:32.400Z</updated>
    
    <content type="html"><![CDATA[<p>mac下安装依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># for cmake</span><br><span class="line">$brew install cmake</span><br><span class="line"> </span><br><span class="line"># for libclang</span><br><span class="line">$brew install llvm</span><br><span class="line">$echo &apos;export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line"> </span><br><span class="line">$echo | clang -x c++ -v -E - 2&gt;&amp;1 | sed -n &apos;/^#include &lt;/,/^End/s|^&amp;#91;^/&amp;#93;*\(&amp;#91;^ &amp;#93;*/include&amp;#91;^ &amp;#93;*\).*$|-I\1|p&apos; &gt; .clang_completion</span><br><span class="line"></span><br><span class="line">brew install rtags</span><br></pre></td></tr></table></figure><p>user-package:</p><pre class="highlight"><code class="">;;; c.el --- c/c++ mode                              -*- lexical-binding: t; -*-;; Keywords: c;;; Code:;;;; irony is for auto-complete, syntax checking and documentation;;;; You will need to install irony-server first time use;; to install irony-server, your system need to install clang, cmake and clang-devel in advance;;;; if error:Could NOT find LibClang (missing: LIBCLANG_LIBRARY LIBCLANG_INCLUDE_DIR);; cmake add this flag:;; -DLIBCLANG_LIBRARY\=/usr/local/opt/llvm/lib/libclang.dylib;; -DLIBCLANG_INCLUDE_DIR\=/usr/local/opt/llvm/include/(use-package irony  :ensure t  :hook ((c++-mode . irony-mode)         (c-mode . irony-mode))  :config  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)  (use-package company-irony-c-headers    :ensure t)  (use-package company-irony    :ensure t    :config    (add-to-list (make-local-variable 'company-backends)                 '(company-irony company-irony-c-headers)))  (use-package flycheck-irony    :ensure t    :config    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)    )  (use-package irony-eldoc    :ensure t    :config    (add-hook 'irony-mode-hook #'irony-eldoc)    )  );;;; rtags enable jump-to-function definition;; system need to install rtags first;;;; for centos, you need llvm-devel, cppunit-devl;; install gcc-4.9, cmake 3.1 and download rtags from github and make it;;(use-package rtags  :ensure t  :config  (rtags-enable-standard-keybindings)  (setq rtags-autostart-diagnostics t)  (rtags-diagnostics)  (setq rtags-completions-enabled t)  (define-key c-mode-base-map (kbd &quot;M-.&quot;)    (function rtags-find-symbol-at-point))  (define-key c-mode-base-map (kbd &quot;M-,&quot;)    (function rtags-find-references-at-point))  );;;; cmake-ide enable rdm(rtags) auto start and rc(rtags) to watch directory;;(use-package cmake-ide  :ensure t  :config  (cmake-ide-setup)  );;;; for editting CMakeLists.txt;;(use-package cmake-mode  :ensure t  :mode ((&quot;CMakeLists\\.txt\\'&quot; . cmake-mode)         (&quot;\\.cmake\\'&quot; . cmake-mode))  :config  (add-hook 'cmake-mode-hook (lambda()                               (add-to-list (make-local-variable 'company-backends)                                            'company-cmake)))  );; for c formatting(use-package clang-format  :ensure t  :config  (setq clang-format-style-option &quot;llvm&quot;)  (add-hook 'c-mode-hook (lambda() (add-hook 'before-save-hook 'clang-format-buffer)))  (add-hook 'c++-mode-hook (lambda() (add-hook 'before-save-hook 'clang-format-buffer)))  )(provide 'c);;; c.el ends here## 参考资料https://github.com/jerryhsieh/Emacs-config/blob/c%2B%2B/custom/c.elhttps://github.com/Sarcasm/irony-mode/issues/351</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac下安装依赖:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
      <category term="emacs" scheme="https://dreamerjonson.com/categories/emacs/"/>
    
    
      <category term="emacs" scheme="https://dreamerjonson.com/tags/emacs/"/>
    
  </entry>
  
  <entry>
    <title>golang[109]-lab-模拟rpc远程过程调用</title>
    <link href="https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/"/>
    <id>https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/</id>
    <published>2019-12-25T03:24:06.000Z</published>
    <updated>2019-12-25T07:54:56.445Z</updated>
    
    <content type="html"><![CDATA[<p>为了实践分布式的第一步，需要模拟远程的过程调用，就好像程序是部署在不同的机器通过tcp进行连接。</p><h2 id="构建client"><a class="markdownIt-Anchor" href="#构建client"></a> 构建client</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ClientEnd struct &#123;</span><br><span class="line">endname interface&#123;&#125; // this end-point&apos;s name</span><br><span class="line">ch      chan reqMsg // copy of Network.endCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>endname 代表client的名字<br>ch 与network共享。用于传递请求参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reqMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">endname  <span class="keyword">interface</span>&#123;&#125; <span class="comment">// name of sending ClientEnd</span></span><br><span class="line">svcMeth  <span class="keyword">string</span>      <span class="comment">// e.g. "Raft.AppendEntries"</span></span><br><span class="line">argsType reflect.Type</span><br><span class="line">args     []<span class="keyword">byte</span></span><br><span class="line">replyCh  <span class="keyword">chan</span> replyMsg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>svcMeth 找到要请求的service，以及调用的方法<br>argsType 存储函数请求的类型，例如要远程调用的函数是，<br>func (js *JunkServer) Handler4(args *JunkArgs, reply *JunkReply) {<br>reply.X = “pointer”<br>}<br>那么argsType存储的是<code>*JunkArgs</code><br>args 代表参数序列化后的字节数组<br>replych 接受返回字节数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type replyMsg struct &#123;</span><br><span class="line">ok    bool</span><br><span class="line">reply []byte</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client调用"><a class="markdownIt-Anchor" href="#client调用"></a> client调用</h2><p>模拟客户端远程过程调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ClientEnd)</span> <span class="title">Call</span><span class="params">(svcMeth <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">req := reqMsg&#123;&#125;</span><br><span class="line">req.endname = e.endname</span><br><span class="line">req.svcMeth = svcMeth</span><br><span class="line">req.argsType = reflect.TypeOf(args)</span><br><span class="line">req.replyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> replyMsg)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// serialize</span></span><br><span class="line">qb := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">qe := gob.NewEncoder(qb)</span><br><span class="line">qe.Encode(args)</span><br><span class="line">req.args = qb.Bytes()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// request param send to network</span></span><br><span class="line">e.ch &lt;- req</span><br><span class="line"></span><br><span class="line">rep := &lt;-req.replyCh</span><br><span class="line"><span class="keyword">if</span> rep.ok &#123;</span><br><span class="line">        <span class="comment">// unserialize</span></span><br><span class="line">rb := bytes.NewBuffer(rep.reply)</span><br><span class="line">rd := gob.NewDecoder(rb)</span><br><span class="line"><span class="keyword">if</span> err := rd.Decode(reply); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"ClientEnd.Call(): decode reply: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="build-network"><a class="markdownIt-Anchor" href="#build-network"></a> build network</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Network struct &#123;</span><br><span class="line">mu             sync.Mutex</span><br><span class="line">reliable       bool</span><br><span class="line">longDelays     bool                        // pause a long time on send on disabled connection</span><br><span class="line">longReordering bool                        // sometimes delay replies a long time</span><br><span class="line">ends           map[interface&#123;&#125;]*ClientEnd  // ends, by name</span><br><span class="line">enabled        map[interface&#123;&#125;]bool        // by end name</span><br><span class="line">servers        map[interface&#123;&#125;]*Server     // servers, by name</span><br><span class="line">connections    map[interface&#123;&#125;]interface&#123;&#125; // endname -&gt; servername</span><br><span class="line">endCh          chan reqMsg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reliable 模拟网络的可靠性<br>longDelays 模拟网络延迟<br>enabled 网络是否可用<br>endCh 用于接收client的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func MakeNetwork() *Network &#123;</span><br><span class="line">rn := &amp;Network&#123;&#125;</span><br><span class="line">rn.reliable = true</span><br><span class="line">rn.ends = map[interface&#123;&#125;]*ClientEnd&#123;&#125;</span><br><span class="line">rn.enabled = map[interface&#123;&#125;]bool&#123;&#125;</span><br><span class="line">rn.servers = map[interface&#123;&#125;]*Server&#123;&#125;</span><br><span class="line">rn.connections = map[interface&#123;&#125;](interface&#123;&#125;)&#123;&#125;</span><br><span class="line">rn.endCh = make(chan reqMsg)</span><br><span class="line"></span><br><span class="line">// single goroutine to handle all ClientEnd.Call()s</span><br><span class="line">go func() &#123;</span><br><span class="line">for xreq := range rn.endCh &#123;</span><br><span class="line">go rn.ProcessReq(xreq)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">return rn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network添加server"><a class="markdownIt-Anchor" href="#network添加server"></a> network添加server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (rn *Network) AddServer(servername interface&#123;&#125;, rs *Server) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.servers[servername] = rs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (rn *Network) DeleteServer(servername interface&#123;&#125;) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.servers[servername] = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确保network-可用"><a class="markdownIt-Anchor" href="#确保network-可用"></a> 确保network 可用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// enable/disable a ClientEnd.</span><br><span class="line">func (rn *Network) Enable(endname interface&#123;&#125;, enabled bool) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.enabled[endname] = enabled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-add-server"><a class="markdownIt-Anchor" href="#network-add-server"></a> network add server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (rn *Network) AddServer(servername interface&#123;&#125;, rs *Server) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.servers[servername] = rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-连接client-与server"><a class="markdownIt-Anchor" href="#network-连接client-与server"></a> network 连接client 与server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// connect a ClientEnd to a server.</span><br><span class="line">// a ClientEnd can only be connected once in its lifetime.</span><br><span class="line">func (rn *Network) Connect(endname interface&#123;&#125;, servername interface&#123;&#125;) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.connections[endname] = servername</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-create-client-end"><a class="markdownIt-Anchor" href="#network-create-client-end"></a> network create client end</h3><p>在这里client的创建是通过network完成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// create a client end-point.</span><br><span class="line">// start the thread that listens and delivers.</span><br><span class="line">func (rn *Network) MakeEnd(endname interface&#123;&#125;) *ClientEnd &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if _, ok := rn.ends[endname]; ok &#123;</span><br><span class="line">log.Fatalf(&quot;MakeEnd: %v already exists\n&quot;, endname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e := &amp;ClientEnd&#123;&#125;</span><br><span class="line">e.endname = endname</span><br><span class="line">e.ch = rn.endCh</span><br><span class="line">rn.ends[endname] = e</span><br><span class="line">rn.enabled[endname] = false</span><br><span class="line">rn.connections[endname] = nil</span><br><span class="line">return e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-统计进入的rpc数量"><a class="markdownIt-Anchor" href="#network-统计进入的rpc数量"></a> network 统计进入的RPC数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// get a server&apos;s count of incoming RPCs.</span><br><span class="line">func (rn *Network) GetCount(servername interface&#123;&#125;) int &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">svr := rn.servers[servername]</span><br><span class="line">return svr.GetCount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network处理client请求"><a class="markdownIt-Anchor" href="#network处理client请求"></a> network处理client请求</h3><p>ProceeReq 接受client发出的处理请求，<br>1、模拟网络的延迟，每次请求花费的时间<br>2、找到此client连接的server,调用server dispatch方法<br>3、等待返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rn *Network)</span> <span class="title">ProcessReq</span><span class="params">(req reqMsg)</span></span> &#123;</span><br><span class="line">enabled, servername, server, reliable, longreordering := rn.ReadEndnameInfo(req.endname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> enabled &amp;&amp; servername != <span class="literal">nil</span> &amp;&amp; server != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reliable == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="comment">// short delay</span></span><br><span class="line">ms := (rand.Int() % <span class="number">27</span>)</span><br><span class="line">time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reliable == <span class="literal">false</span> &amp;&amp; (rand.Int()%<span class="number">1000</span>) &lt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="comment">// drop the request, return as if timeout</span></span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute the request (call the RPC handler).</span></span><br><span class="line"><span class="comment">// in a separate thread so that we can periodically check</span></span><br><span class="line"><span class="comment">// if the server has been killed and the RPC should get a</span></span><br><span class="line"><span class="comment">// failure reply.</span></span><br><span class="line">ech := <span class="built_in">make</span>(<span class="keyword">chan</span> replyMsg)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := server.dispatch(req)</span><br><span class="line">ech &lt;- r</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for handler to return,</span></span><br><span class="line"><span class="comment">// but stop waiting if DeleteServer() has been called,</span></span><br><span class="line"><span class="comment">// and return an error.</span></span><br><span class="line"><span class="keyword">var</span> reply replyMsg</span><br><span class="line">replyOK := <span class="literal">false</span></span><br><span class="line">serverDead := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> replyOK == <span class="literal">false</span> &amp;&amp; serverDead == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reply = &lt;-ech:</span><br><span class="line">replyOK = <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond):</span><br><span class="line">serverDead = rn.IsServerDead(req.endname, servername, server)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do not reply if DeleteServer() has been called, i.e.</span></span><br><span class="line"><span class="comment">// the server has been killed. this is needed to avoid</span></span><br><span class="line"><span class="comment">// situation in which a client gets a positive reply</span></span><br><span class="line"><span class="comment">// to an Append, but the server persisted the update</span></span><br><span class="line"><span class="comment">// into the old Persister. config.go is careful to call</span></span><br><span class="line"><span class="comment">// DeleteServer() before superseding the Persister.</span></span><br><span class="line">serverDead = rn.IsServerDead(req.endname, servername, server)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> replyOK == <span class="literal">false</span> || serverDead == <span class="literal">true</span> &#123;</span><br><span class="line"><span class="comment">// server was killed while we were waiting; return error.</span></span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> reliable == <span class="literal">false</span> &amp;&amp; (rand.Int()%<span class="number">1000</span>) &lt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="comment">// drop the reply, return as if timeout</span></span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> longreordering == <span class="literal">true</span> &amp;&amp; rand.Intn(<span class="number">900</span>) &lt; <span class="number">600</span> &#123;</span><br><span class="line"><span class="comment">// delay the response for a while</span></span><br><span class="line">ms := <span class="number">200</span> + rand.Intn(<span class="number">1</span>+rand.Intn(<span class="number">2000</span>))</span><br><span class="line">time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">req.replyCh &lt;- reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">req.replyCh &lt;- reply</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// simulate no reply and eventual timeout.</span></span><br><span class="line">ms := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> rn.longDelays &#123;</span><br><span class="line"><span class="comment">// let Raft tests check that leader doesn't send</span></span><br><span class="line"><span class="comment">// RPCs synchronously.</span></span><br><span class="line">ms = (rand.Int() % <span class="number">7000</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// many kv tests require the client to try each</span></span><br><span class="line"><span class="comment">// server in fairly rapid succession.</span></span><br><span class="line">ms = (rand.Int() % <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="build-server"><a class="markdownIt-Anchor" href="#build-server"></a> build server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// a server is a collection of services, all sharing</span><br><span class="line">// the same rpc dispatcher. so that e.g. both a Raft</span><br><span class="line">// and a k/v server can listen to the same rpc endpoint.</span><br><span class="line">//</span><br><span class="line">type Server struct &#123;</span><br><span class="line">mu       sync.Mutex</span><br><span class="line">services map[string]*Service</span><br><span class="line">count    int // incoming RPCs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MakeServer() *Server &#123;</span><br><span class="line">rs := &amp;Server&#123;&#125;</span><br><span class="line">rs.services = map[string]*Service&#123;&#125;</span><br><span class="line">return rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server 是由一系列的service组成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// a server is a collection of services, all sharing</span><br><span class="line">// the same rpc dispatcher. so that e.g. both a Raft</span><br><span class="line">// and a k/v server can listen to the same rpc endpoint.</span><br><span class="line">//</span><br><span class="line">type Server struct &#123;</span><br><span class="line">mu       sync.Mutex</span><br><span class="line">services map[string]*Service</span><br><span class="line">count    int // incoming RPCs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MakeServer() *Server &#123;</span><br><span class="line">rs := &amp;Server&#123;&#125;</span><br><span class="line">rs.services = map[string]*Service&#123;&#125;</span><br><span class="line">return rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server 是由一系列的service组成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (rs *Server) AddService(svc *Service) &#123;</span><br><span class="line">rs.mu.Lock()</span><br><span class="line">defer rs.mu.Unlock()</span><br><span class="line">rs.services[svc.name] = svc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server的一个重要方法是调用dispatch ，找到client具体是调用的哪个servise的哪个方法 eg.“Raft.AppendEntries”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (rs *Server) dispatch(req reqMsg) replyMsg &#123;</span><br><span class="line">rs.mu.Lock()</span><br><span class="line"></span><br><span class="line">rs.count += 1</span><br><span class="line"></span><br><span class="line">// split Raft.AppendEntries into service and method</span><br><span class="line">dot := strings.LastIndex(req.svcMeth, &quot;.&quot;)</span><br><span class="line">serviceName := req.svcMeth[:dot]</span><br><span class="line">methodName := req.svcMeth[dot+1:]</span><br><span class="line"></span><br><span class="line">service, ok := rs.services[serviceName]</span><br><span class="line"></span><br><span class="line">rs.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if ok &#123;</span><br><span class="line">return service.dispatch(methodName, req)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">choices := []string&#123;&#125;</span><br><span class="line">for k, _ := range rs.services &#123;</span><br><span class="line">choices = append(choices, k)</span><br><span class="line">&#125;</span><br><span class="line">log.Fatalf(&quot;labrpc.Server.dispatch(): unknown service %v in %v.%v; expecting one of %v\n&quot;,</span><br><span class="line">serviceName, serviceName, methodName, choices)</span><br><span class="line">return replyMsg&#123;false, nil&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="build-service"><a class="markdownIt-Anchor" href="#build-service"></a> build service</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// an object with methods that can be called via RPC.</span><br><span class="line">// a single server may have more than one Service.</span><br><span class="line">type Service struct &#123;</span><br><span class="line">name    string</span><br><span class="line">rcvr    reflect.Value</span><br><span class="line">typ     reflect.Type</span><br><span class="line">methods map[string]reflect.Method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methods 存储所有方法<br>typ 与 rcvr 存储结构体的反射类型<br>name 是结构体的名字<br>makeServise 方法将某个结构体即service的所有方法存起来。</p><p>规定函数必须有三个参数<br>第1个是调用方法的结构体<br>第2个是request参数<br>第3个是reply参数<br>1个返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func MakeService(rcvr interface&#123;&#125;) *Service &#123;</span><br><span class="line">svc := &amp;Service&#123;&#125;</span><br><span class="line">svc.typ = reflect.TypeOf(rcvr)</span><br><span class="line">svc.rcvr = reflect.ValueOf(rcvr)</span><br><span class="line">svc.name = reflect.Indirect(svc.rcvr).Type().Name()</span><br><span class="line">svc.methods = map[string]reflect.Method&#123;&#125;</span><br><span class="line"></span><br><span class="line">for m := 0; m &lt; svc.typ.NumMethod(); m++ &#123;</span><br><span class="line">method := svc.typ.Method(m)</span><br><span class="line">mtype := method.Type</span><br><span class="line">mname := method.Name</span><br><span class="line"></span><br><span class="line">//fmt.Printf(&quot;%v pp %v ni %v 1k %v 2k %v no %v\n&quot;,</span><br><span class="line">//mname, method.PkgPath, mtype.NumIn(), mtype.In(1).Kind(), mtype.In(2).Kind(), mtype.NumOut())</span><br><span class="line"></span><br><span class="line">if method.PkgPath != &quot;&quot; || // capitalized?</span><br><span class="line">mtype.NumIn() != 3 ||</span><br><span class="line">//mtype.In(1).Kind() != reflect.Ptr ||</span><br><span class="line">mtype.In(2).Kind() != reflect.Ptr ||</span><br><span class="line">mtype.NumOut() != 0 &#123;</span><br><span class="line">// the method is not suitable for a handler</span><br><span class="line">//fmt.Printf(&quot;bad method: %v\n&quot;, mname)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// the method looks like a handler</span><br><span class="line">svc.methods[mname] = method</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return svc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>用一个简单的例子来测试并说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type JunkArgs struct &#123;</span><br><span class="line">X int</span><br><span class="line">&#125;</span><br><span class="line">type JunkReply struct &#123;</span><br><span class="line">X string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type JunkServer struct &#123;</span><br><span class="line">mu   sync.Mutex</span><br><span class="line">log1 []string</span><br><span class="line">log2 []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// args is a pointer</span><br><span class="line">func (js *JunkServer) Handler4(args *JunkArgs, reply *JunkReply) &#123;</span><br><span class="line">reply.X = &quot;pointer&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// args is a not pointer</span><br><span class="line">func (js *JunkServer) Handler5(args JunkArgs, reply *JunkReply) &#123;</span><br><span class="line">reply.X = &quot;no pointer&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestTypes(t *testing.T) &#123;</span><br><span class="line">    // 1. create network</span><br><span class="line">    rn := MakeNetwork()</span><br><span class="line">    // 2、create client</span><br><span class="line">e := rn.MakeEnd(&quot;end1-99&quot;)</span><br><span class="line">js := &amp;JunkServer&#123;&#125;</span><br><span class="line">    // 3. create service</span><br><span class="line">svc := MakeService(js)</span><br><span class="line">    // 4. create server</span><br><span class="line">rs := MakeServer()</span><br><span class="line">    // 5. service add to server </span><br><span class="line">rs.AddService(svc)</span><br><span class="line">    // 6. server add to network</span><br><span class="line">rn.AddServer(&quot;server99&quot;, rs)</span><br><span class="line">    //  7. client connect to server</span><br><span class="line">rn.Connect(&quot;end1-99&quot;, &quot;server99&quot;)</span><br><span class="line">    //  8. enable network</span><br><span class="line">rn.Enable(&quot;end1-99&quot;, true)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">var args JunkArgs</span><br><span class="line">var reply JunkReply</span><br><span class="line">// args must match type (pointer or not) of handler.</span><br><span class="line">// 9. call the service wait the reply. </span><br><span class="line">        e.Call(&quot;JunkServer.Handler4&quot;, &amp;args, &amp;reply)</span><br><span class="line">if reply.X != &quot;pointer&quot; &#123;</span><br><span class="line">t.Fatalf(&quot;wrong reply from Handler4&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">var args JunkArgs</span><br><span class="line">var reply JunkReply</span><br><span class="line">// args must match type (pointer or not) of handler.</span><br><span class="line">e.Call(&quot;JunkServer.Handler5&quot;, args, &amp;reply)</span><br><span class="line">if reply.X != &quot;no pointer&quot; &#123;</span><br><span class="line">t.Fatalf(&quot;wrong reply from Handler5&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结与使用"><a class="markdownIt-Anchor" href="#总结与使用"></a> 总结与使用</h2><p>此package很好在本地模拟了远程过程调用，为实现分布式的算法奠定了坚实的基础。<br>使用此package的9个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   // 1. create network</span><br><span class="line">   // 2、create client</span><br><span class="line">   // 3. create service</span><br><span class="line">   // 4. create server</span><br><span class="line">   // 5. service add to server </span><br><span class="line">   // 6. server add to network</span><br><span class="line">   // 7. client connect to server</span><br><span class="line">   // 8. enable network</span><br><span class="line">// 9. call the service wait the reply.</span><br></pre></td></tr></table></figure><h2 id="完整实验代码"><a class="markdownIt-Anchor" href="#完整实验代码"></a> 完整实验代码</h2><p><a href="https://github.com/dreamerjackson/golang-deep-distributed-lab" target="_blank" rel="noopener">https://github.com/dreamerjackson/golang-deep-distributed-lab</a><br>后面的测试多参考一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了实践分布式的第一步，需要模拟远程的过程调用，就好像程序是部署在不同的机器通过tcp进行连接。&lt;/p&gt;
&lt;h2 id=&quot;构建client&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#构建client&quot;&gt;&lt;/a&gt; 构建client&lt;/h2&gt;
&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[108]-2的幂</title>
    <link href="https://dreamerjonson.com/2019/12/18/golang-108-pow-of-two/"/>
    <id>https://dreamerjonson.com/2019/12/18/golang-108-pow-of-two/</id>
    <published>2019-12-17T16:41:10.000Z</published>
    <updated>2019-12-18T10:19:04.752Z</updated>
    
    <content type="html"><![CDATA[<p>单精度浮点数可以表达的范围是：2^-149 - 2^127<br>Denormalized number 从2^-149 - 2^-127<br>Normal number  2 ^-126 - 2^127</p><table><thead><tr><th>Power of Two</th><th>–</th><th>指数位Exponent</th><th>小数位Fraction</th></tr></thead><tbody><tr><td>-149</td><td>0</td><td>00000000</td><td>00000000000000000000001</td></tr><tr><td>-148</td><td>0</td><td>00000000</td><td>00000000000000000000010</td></tr><tr><td>-147</td><td>0</td><td>00000000</td><td>00000000000000000000100</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-128</td><td>0</td><td>00000000</td><td>01000000000000000000000</td></tr><tr><td>-127</td><td>0</td><td>00000000</td><td>10000000000000000000000</td></tr><tr><td>-126</td><td>0</td><td>00000001</td><td>00000000000000000000000</td></tr><tr><td>-125</td><td>0</td><td>00000010</td><td>00000000000000000000000</td></tr><tr><td>-124</td><td>0</td><td>00000011</td><td>00000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-2</td><td>0</td><td>01111101</td><td>00000000000000000000000</td></tr><tr><td>-1</td><td>0</td><td>01111110</td><td>00000000000000000000000</td></tr><tr><td>0</td><td>0</td><td>01111111</td><td>00000000000000000000000</td></tr><tr><td>1</td><td>0</td><td>10000000</td><td>00000000000000000000000</td></tr><tr><td>2</td><td>0</td><td>10000001</td><td>00000000000000000000000</td></tr><tr><td>3</td><td>0</td><td>10000010</td><td>00000000000000000000000</td></tr><tr><td>4</td><td>0</td><td>10000011</td><td>00000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>125</td><td>0</td><td>11111100</td><td>00000000000000000000000</td></tr><tr><td>126</td><td>0</td><td>11111101</td><td>00000000000000000000000</td></tr><tr><td>127</td><td>0</td><td>11111110</td><td>00000000000000000000000</td></tr></tbody></table><p>从上表中可以看出，以2为底的单精度指数有以下特点：<br>1、指数位为0，而小数位只有一个1位<br>2、指数位介于1到254之间，小数位为0.</p><table><thead><tr><th>Power of Two</th><th>–</th><th>Exponent</th><th>Fraction</th></tr></thead><tbody><tr><td>-1074</td><td>0</td><td>00000000000</td><td>0000000000000000000000000000000000000000000000000001</td></tr><tr><td>-1073</td><td>0</td><td>00000000000</td><td>0000000000000000000000000000000000000000000000000010</td></tr><tr><td>-1072</td><td>0</td><td>00000000000</td><td>0000000000000000000000000000000000000000000000000100</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-1024</td><td>0</td><td>00000000000</td><td>0100000000000000000000000000000000000000000000000000</td></tr><tr><td>-1023</td><td>0</td><td>00000000000</td><td>1000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1022</td><td>0</td><td>00000000001</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1021</td><td>0</td><td>00000000010</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1020</td><td>0</td><td>00000000011</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-2</td><td>0</td><td>01111111101</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1</td><td>0</td><td>01111111110</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>0</td><td>0</td><td>01111111111</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>1</td><td>0</td><td>10000000000</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>2</td><td>0</td><td>10000000001</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>3</td><td>0</td><td>10000000010</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>4</td><td>0</td><td>10000000011</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>1021</td><td>0</td><td>11111111100</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>1022</td><td>0</td><td>11111111101</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>1023</td><td>0</td><td>11111111110</td><td>0000000000000000000000000000000000000000000000000000</td></tr></tbody></table><p>从上表中可以看出，以2为底的双精度指数有以下特点：<br>1、指数位为0，而小数位只有一个1位<br>2、指数位介于1到2046之间，小数位为0.</p><h2 id="字节序"><a class="markdownIt-Anchor" href="#字节序"></a> 字节序</h2><p>指定数字二进制编码内的字节如何在内存中排序。有大端序与小端序之分。<br>大端序 ： 高位高字节<br>小端序： 高位低字节</p><p>2^-2  大端排序为 00111110100000000000000000000000<br>2^2   小端排序为 00000000000000001000000000111110</p><h2 id="判断2的幂的10种方法"><a class="markdownIt-Anchor" href="#判断2的幂的10种方法"></a> 判断2的幂的10种方法</h2><p>以单精度浮点数为例。</p><h3 id="方法1"><a class="markdownIt-Anchor" href="#方法1"></a> 方法1</h3><p>看成是10进制，不断除以2。 2的次方数除到最后为1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo</span><span class="params">( x <span class="keyword">uint64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> x % <span class="number">2</span> ==<span class="number">0</span> &amp;&amp; x &gt; <span class="number">1</span> &#123;</span><br><span class="line">x /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法2"><a class="markdownIt-Anchor" href="#方法2"></a> 方法2</h3><p>单精度浮点数最多31个数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo2</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x == <span class="number">1</span> || x == <span class="number">2</span> || x == <span class="number">4</span> || x == <span class="number">8</span> || x == <span class="number">16</span> || x == <span class="number">32</span> ||</span><br><span class="line">x == <span class="number">64</span> || x == <span class="number">128</span> || x == <span class="number">256</span> || x == <span class="number">512</span> || x == <span class="number">1024</span> ||</span><br><span class="line">x == <span class="number">2048</span> || x == <span class="number">4096</span> || x == <span class="number">8192</span> || x == <span class="number">16384</span> ||</span><br><span class="line">x == <span class="number">32768</span> || x == <span class="number">65536</span> || x == <span class="number">131072</span> || x == <span class="number">262144</span> ||</span><br><span class="line">x == <span class="number">524288</span> || x == <span class="number">1048576</span> || x == <span class="number">2097152</span> ||</span><br><span class="line">x == <span class="number">4194304</span> || x == <span class="number">8388608</span> || x == <span class="number">16777216</span> ||</span><br><span class="line">x == <span class="number">33554432</span> || x == <span class="number">67108864</span> || x == <span class="number">134217728</span> ||</span><br><span class="line">x == <span class="number">268435456</span> || x == <span class="number">536870912</span> || x == <span class="number">1073741824</span> ||</span><br><span class="line">x == <span class="number">2147483648</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法3"><a class="markdownIt-Anchor" href="#方法3"></a> 方法3</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不断乘以2,逼近参入参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo3</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> powerOfTwo <span class="keyword">uint32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> powerOfTwo &lt; x &amp;&amp; powerOfTwo &lt; <span class="number">2147483648</span>&#123;</span><br><span class="line">powerOfTwo *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x == powerOfTwo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法4"><a class="markdownIt-Anchor" href="#方法4"></a> 方法4</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事先存好数组，遍历不断逼近参入参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo4</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"> powerOfTwo := [<span class="number">32</span>]<span class="keyword">uint32</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>,<span class="number">2048</span>,<span class="number">4096</span>,<span class="number">8192</span>,<span class="number">16384</span>,<span class="number">32768</span>,</span><br><span class="line"><span class="number">65536</span>,<span class="number">131072</span>,<span class="number">262144</span>,<span class="number">524288</span>,<span class="number">1048576</span>,<span class="number">2097152</span>,<span class="number">4194304</span>,<span class="number">8388608</span>,</span><br><span class="line"><span class="number">16777216</span>,<span class="number">33554432</span>,<span class="number">67108864</span>,<span class="number">134217728</span>,<span class="number">268435456</span>,<span class="number">536870912</span>,</span><br><span class="line"><span class="number">1073741824</span>,<span class="number">2147483648</span>&#125;</span><br><span class="line"><span class="keyword">var</span>  exponent = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> powerOfTwo[exponent] &lt; x &amp;&amp; exponent &lt; <span class="number">31</span>&#123;</span><br><span class="line">exponent++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x == powerOfTwo[exponent])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法5"><a class="markdownIt-Anchor" href="#方法5"></a> 方法5</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo5</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">powerOfTwo := [<span class="number">32</span>]<span class="keyword">uint32</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>,<span class="number">2048</span>,<span class="number">4096</span>,<span class="number">8192</span>,<span class="number">16384</span>,<span class="number">32768</span>,</span><br><span class="line"><span class="number">65536</span>,<span class="number">131072</span>,<span class="number">262144</span>,<span class="number">524288</span>,<span class="number">1048576</span>,<span class="number">2097152</span>,<span class="number">4194304</span>,<span class="number">8388608</span>,</span><br><span class="line"><span class="number">16777216</span>,<span class="number">33554432</span>,<span class="number">67108864</span>,<span class="number">134217728</span>,<span class="number">268435456</span>,<span class="number">536870912</span>,</span><br><span class="line"><span class="number">1073741824</span>,<span class="number">2147483648</span>&#125;</span><br><span class="line">isAPowerOfTwo  := <span class="literal">false</span></span><br><span class="line">interval := <span class="number">16</span>;</span><br><span class="line">exponent := interval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">isAPowerOfTwo = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">isAPowerOfTwo = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">for</span> x != powerOfTwo[exponent] &amp;&amp;  interval&gt;<span class="number">1</span>&#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; powerOfTwo[exponent]&#123;</span><br><span class="line">exponent -= interval / <span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">exponent += interval / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">interval /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">isAPowerOfTwo = (x == powerOfTwo[exponent])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isAPowerOfTwo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法6"><a class="markdownIt-Anchor" href="#方法6"></a> 方法6</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// math.log函数求出2的幂,与2的次方作对比</span><br><span class="line">func isPowerOfTwo6( x uint32) bool &#123;</span><br><span class="line">powerOfTwo := [32]uint32&#123;1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,</span><br><span class="line">65536,131072,262144,524288,1048576,2097152,4194304,8388608,</span><br><span class="line">16777216,33554432,67108864,134217728,268435456,536870912,</span><br><span class="line">1073741824,2147483648&#125;</span><br><span class="line">isAPowerOfTwo  := false</span><br><span class="line">if  x&gt;0 &amp;&amp; x &lt; 2147483648&#123;</span><br><span class="line">exponent := uint32(math.Log2(float64(x)))</span><br><span class="line">isAPowerOfTwo = (x == powerOfTwo[exponent] ||</span><br><span class="line">x == powerOfTwo[exponent+1])</span><br><span class="line">&#125;</span><br><span class="line">return isAPowerOfTwo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法7"><a class="markdownIt-Anchor" href="#方法7"></a> 方法7</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 统计2进制位的个数,2的次方只有1个2进制位</span><br><span class="line">func isPowerOfTwo7( x uint32) bool &#123;</span><br><span class="line">numberOfOneBits := 0</span><br><span class="line"></span><br><span class="line">for x &gt; 0  &amp;&amp; numberOfOneBits &lt;=1&#123;</span><br><span class="line">if  ( x &amp; 1 ) == 1 &#123;</span><br><span class="line">numberOfOneBits++</span><br><span class="line">&#125;</span><br><span class="line">x &gt;&gt;= 1</span><br><span class="line">&#125;</span><br><span class="line">return numberOfOneBits == 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法8"><a class="markdownIt-Anchor" href="#方法8"></a> 方法8</h3><p>2的次方第一位是1，其他位为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func isPowerOfTwo8( x uint32) bool &#123;</span><br><span class="line">for (x &amp; 1) == 0 &amp;&amp; x &gt; 1&#123;</span><br><span class="line"> x &gt;&gt;= 1</span><br><span class="line">&#125;</span><br><span class="line">return x == 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法9"><a class="markdownIt-Anchor" href="#方法9"></a> 方法9</h3><p>malloc.c in the GNU C Library 中的实现方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isPowerOfTwo9( x uint32) bool &#123;</span><br><span class="line">return (x != 0) &amp;&amp; x &amp; (x - 1) == 0 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面简单说明一下x &amp; (x - 1) == 0 的原理。<br>x的二进制从左到右 至少有一个为1的位，标记为i。如果i右边的位都为0，正好是2的次方数。那么 x - 1 在i处为0，在 i右边都为1，这时满足 (x &amp; x - 1) ==0<br>假设 i右边至少有一位不为0， 那么 x  - 1 在i 位仍然为 1 ，这时不满足 (x &amp; x -1) == 0<br>得证。</p><h3 id="方法10"><a class="markdownIt-Anchor" href="#方法10"></a> 方法10</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isPowerOfTwo10( x uint32) bool &#123;</span><br><span class="line">return ((x != 0) &amp;&amp; ((x &amp; (^x + 1)) == x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明方法和方法9相似。</p><h2 id="10的正次方数与2进制之间的有趣性质"><a class="markdownIt-Anchor" href="#10的正次方数与2进制之间的有趣性质"></a> 10的正次方数与2进制之间的有趣性质</h2><p>从下表中我们能够发现，10的正次方数转换为2的次方数后，末尾都是相同的。<br>原因在于  10^n = 2^n * 5^n  5的次方数总是以1结尾的。 而2^n 相当于左移n位</p><table><thead><tr><th>Power of Ten (in Decimal)</th><th>Power of Ten (in Binary)</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>10</td><td>10 10</td></tr><tr><td>100</td><td>1100 100</td></tr><tr><td>1000</td><td>111110 1000</td></tr><tr><td>10000</td><td>100111000 10000</td></tr><tr><td>100000</td><td>11000011010 100000</td></tr></tbody></table><p>因此10^n - 1 有如下性质:</p><table><thead><tr><th>n</th><th>10n-1 (in decimal)</th><th>10n-1 (in binary)</th></tr></thead><tbody><tr><td>1</td><td>9</td><td>1001</td></tr><tr><td>2</td><td>99</td><td>1100011</td></tr><tr><td>3</td><td>999</td><td>1111100111</td></tr><tr><td>4</td><td>9999</td><td>10011100001111</td></tr><tr><td>5</td><td>99999</td><td>11000011010011111</td></tr><tr><td>6</td><td>999999</td><td>11110100001000111111</td></tr><tr><td>7</td><td>9999999</td><td>100110001001011001111111</td></tr><tr><td>8</td><td>99999999</td><td>101111101011110000011111111</td></tr><tr><td>9</td><td>999999999</td><td>111011100110101100100111111111</td></tr><tr><td>10</td><td>9999999999</td><td>1001010100000010111110001111111111</td></tr><tr><td>11</td><td>99999999999</td><td>1011101001000011101101110011111111111</td></tr><tr><td>12</td><td>999999999999</td><td>1110100011010100101001010000111111111111</td></tr></tbody></table><h2 id="在google中做计算"><a class="markdownIt-Anchor" href="#在google中做计算"></a> 在google中做计算</h2><table><thead><tr><th>Expression</th><th>Result</th><th>Notes</th></tr></thead><tbody><tr><td>2^32</td><td>4 294 967 296</td><td>Positive power of two</td></tr><tr><td>2^-6</td><td>0.015625</td><td>Negative power of two</td></tr><tr><td>1/2^6</td><td>0.015625</td><td>Negative power of two</td></tr><tr><td>(2<sup>2)</sup>3</td><td>64</td><td>Composed power of two</td></tr><tr><td>8^7</td><td>2 097 152</td><td>Power of eight</td></tr><tr><td>7<em>16^2 + 13</em>16 + 9</td><td>2 009</td><td>Convert 0x7D9 to decimal by hand</td></tr><tr><td>lg(256)/lg(16)</td><td>2</td><td>Change of base computes log16(256) = 2</td></tr><tr><td>15/2^6</td><td>0.234375</td><td>Dyadic fraction</td></tr><tr><td>lg(65536)</td><td>16</td><td>log2(216) = 16</td></tr><tr><td>log(2^32)</td><td>9.63295986</td><td>232 is 10 digits long in base 10</td></tr></tbody></table><h3 id="10进制转2进制"><a class="markdownIt-Anchor" href="#10进制转2进制"></a> 10进制转2进制</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>2009 to binary</td><td>0b11111011001</td></tr><tr><td>0x07D9 to binary</td><td>0b11111011001</td></tr><tr><td>0o3731 to binary</td><td>0b11111011001</td></tr></tbody></table><h3 id="10进制转16净值"><a class="markdownIt-Anchor" href="#10进制转16净值"></a> 10进制转16净值</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>2009 to hex</td><td>0x7D9</td></tr><tr><td>0b11111011001 to hex</td><td>0x7D9</td></tr><tr><td>0o3731 to hex</td><td>0x7D9</td></tr></tbody></table><h3 id="10进制转16进制"><a class="markdownIt-Anchor" href="#10进制转16进制"></a> 10进制转16进制</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>2009 to octal</td><td>0o3731</td></tr><tr><td>0b11111011001 to octal</td><td>0o3731</td></tr><tr><td>0x07D9 to octal</td><td>0o3731</td></tr></tbody></table><h3 id="转10进制"><a class="markdownIt-Anchor" href="#转10进制"></a> 转10进制</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>0b11111011001 to decimal</td><td>2009</td></tr><tr><td>0x07D9 to decimal</td><td>2009</td></tr><tr><td>0o3731 to decimal</td><td>2009</td></tr></tbody></table><h3 id="计算加进制转换"><a class="markdownIt-Anchor" href="#计算加进制转换"></a> 计算加进制转换</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>0b1010 + 0b1011 to decimal</td><td>21</td></tr><tr><td>0xA * 0xF to binary</td><td>0b10010110</td></tr><tr><td>0o24 / 0o12 to hex</td><td>0x2</td></tr><tr><td>2^10 + 2^8 + 2^1 to binary</td><td>0b10100000010</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单精度浮点数可以表达的范围是：2^-149 - 2^127&lt;br&gt;
Denormalized number 从2^-149 - 2^-127&lt;br&gt;
Normal number  2 ^-126 - 2^127&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Po
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[107]-约瑟夫问题与2的次方的特性</title>
    <link href="https://dreamerjonson.com/2019/12/14/golang-107-Josephus-problem/"/>
    <id>https://dreamerjonson.com/2019/12/14/golang-107-Josephus-problem/</id>
    <published>2019-12-14T13:12:12.000Z</published>
    <updated>2019-12-25T03:18:08.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。</p><p>人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。</p><p>问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。</p><center><img src="/2019/12/14/golang-107-Josephus-problem/1.png"></center><center><div>13人的例子，最后赢家为11号</div></center><p>我们以k = 2 即跳过1人后 执行下一个人为例，来探讨一个有趣的性质。</p><h3 id="假设参与人数为2的次方数"><a class="markdownIt-Anchor" href="#假设参与人数为2的次方数"></a> 假设参与人数为2的次方数。</h3><center><img src="/2019/12/14/golang-107-Josephus-problem/2.png"></center><center><div>参与人数为8人的情形</div></center><p>每回合消除的人数与二叉树类似。<br>Pass 1  four people: 2, 4, 6, 8.<br>Pass 2  two people: 3, 7<br>Pass 3  one person: 5</p><p>最后剩下的人数为1号，这不是偶然的。<br>我们可以用归纳法证明：<br>当参与人数是2^m+1, 经过一轮后，减少人数到2^m，并且减少的都是偶数的编号，编号1保留。<br>因此总会到达上面我们讨论的8人数，得证。</p><h3 id="当参与人数不是2的幂"><a class="markdownIt-Anchor" href="#当参与人数不是2的幂"></a> 当参与人数不是2的幂</h3><p>有一点我们是肯定的，当参数人数不是2的幂后，编号1一定不是最后的幸存者。<br>这是由于总有一次参数会是一个奇数，编号1就会被下一轮干掉。</p><center><img src="/2019/12/14/golang-107-Josephus-problem/3.png"></center><center><div>参数人数不是2的幂</div></center><p>Pass 1 eliminates six people: 2, 4, 6, 8, 10, 12.<br>Pass 2 eliminates four people: 1, 5, 9, 13.<br>Pass 3 eliminates one person: 7.<br>Pass 4 eliminates one person: 3.</p><p>分析：当参与人数不是2的幂时, 到某一时刻总会变为2的幂。<br>变为2的幂后就会符合上面我们指出的规律。</p><center><img src="/2019/12/14/golang-107-Josephus-problem/4.png"></center><center><div>分析</div></center><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>假设参数人数是n = 2^m + k</p><p>那么 在 k 次消除后， n = 2 ^ m  次数编码到达了2k + 1。<br>因此可以证明编号2k + 1 就是幸存者。</p><p>假设n = 2^m + k<br>m = 2k + 1</p><p>可证 w = 2（n - 2^m）+1<br>即 w  =  2（n - 2^(log2(n))）+1</p><h3 id="编程求最后一个安全数"><a class="markdownIt-Anchor" href="#编程求最后一个安全数"></a> 编程求最后一个安全数</h3><p>编程求最后一个安全数的最快方法是<br>假设 n  = 0x1 0 1 0 0 1<br>则安全数为 = 0x010011<br>即将最前面的1移动到最后方。</p><p>(bits.Len64(x) 计算x的最高位。<br>( 1 &lt;&lt; (bits.Len64(x)) -1 ) 最高位变为0<br>(x &lt;&lt; 1 | 1) 最低位加1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func calEndVal(x uint64) uint64&#123;</span><br><span class="line">return   ( 1 &lt;&lt; (bits.Len64(x)) -1 )  &amp;   (x &lt;&lt; 1 | 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h2&gt;
&lt;p&gt;约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。&lt;/p&gt;

      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[106]-深入浮点数</title>
    <link href="https://dreamerjonson.com/2019/12/11/golang-106-IEE754-float/"/>
    <id>https://dreamerjonson.com/2019/12/11/golang-106-IEE754-float/</id>
    <published>2019-12-11T07:49:51.000Z</published>
    <updated>2020-01-10T10:13:17.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>下面的一段简单程序 0.3 + 0.6 结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 <span class="keyword">float64</span> = <span class="number">0.3</span></span><br><span class="line"><span class="keyword">var</span> f2 <span class="keyword">float64</span> = <span class="number">0.6</span></span><br><span class="line">fmt.Println(f1 + f2)</span><br></pre></td></tr></table></figure><p>有人会天真的认为是0.9，但实际输出却是0.8999999999999999（go 1.13.5）</p><p>问题在于大多数小数表示成二进制之后是近似且无限的。<br>以0.1为例。它可能是你能想到的最简单的十进制之一，但是二进制看起来却非常复杂：0.0001100110011001100…<br>其是一串连续循环无限的数字（涉及到10进制转换为2进制,暂不介绍）。<br>结果的荒诞性告诉我们，必须深入理解浮点数在计算机中的存储方式及其性质，才能正确处理数字的计算。<br>golang 与其他很多语言（C、C++、Python…）一样，使用了IEEE-754标准存储浮点数。</p><h2 id="ieee-754-如何存储浮点数"><a class="markdownIt-Anchor" href="#ieee-754-如何存储浮点数"></a> IEEE-754 如何存储浮点数</h2><p>IEEE-754规范使用特殊的以2为基数的科学表示法表示浮点数。</p><table><thead><tr><th>基本的10进制数字</th><th>科学计数法表示</th><th>指数表示</th><th>系数</th><th>底数</th><th>指数</th><th>小数</th></tr></thead><tbody><tr><td>700</td><td>7e+2</td><td>7 * 10^2</td><td>7</td><td>10</td><td>2</td><td>0</td></tr><tr><td>4,900,000,000</td><td>4.9e+9</td><td>4.9 * 10^9</td><td>4.9</td><td>10</td><td>9</td><td>.9</td></tr><tr><td>5362.63</td><td>5.36263e+3</td><td>5.36263 * 10^3</td><td>5.36263</td><td>10</td><td>3</td><td>.36263</td></tr><tr><td>-0.00345</td><td>3.45e-3</td><td>3.45 * 10^-3</td><td>3.45</td><td>10</td><td>-3</td><td>.45</td></tr><tr><td>0.085</td><td>1.36e-4</td><td>1.36 * 2^-4</td><td>1.36</td><td>2</td><td>-4</td><td>.36</td></tr></tbody></table><p>32位的单精度浮点数 与 64位的双精度浮点数的差异</p><table><thead><tr><th>精度</th><th>符号位</th><th>指数位</th><th>小数位</th><th>偏移量</th></tr></thead><tbody><tr><td>Single (32 Bits)</td><td>1 [31]</td><td>8 [30-23]</td><td>23 [22-00]</td><td>127</td></tr><tr><td>Double (64 Bits)</td><td>1 [63]</td><td>11 [62-52]</td><td>52 [51-00]</td><td>1023</td></tr></tbody></table><p>符号位： 1 为 负数， 0 为正数。<br>指数位： 存储 指数加上偏移量，偏移量是为了表达负数而设计的。<br>小数位： 存储系数的小数位的准确或者最接近的值。</p><p>以 数字 0.085 为例。</p><table><thead><tr><th>符号位</th><th>指数位(123)</th><th>小数位 (.36)</th></tr></thead><tbody><tr><td>0</td><td>0111 1011</td><td>010 1110 0001 0100 0111 1011</td></tr></tbody></table><h2 id="小数位的表达方式"><a class="markdownIt-Anchor" href="#小数位的表达方式"></a> 小数位的表达方式</h2><p>以0.36 为例:<br>010 1110 0001 0100 0111 1011 = 0.36  (第一位数字代表1/2,第二位数字是1/4…，0.36 是所有位相加)<br>分解后的计算步骤为:</p><table><thead><tr><th>第n位</th><th>2的幂</th><th>分数</th><th>10进制</th><th>求和</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>1⁄4</td><td>0.25</td><td>0.25</td></tr><tr><td>4</td><td>16</td><td>1⁄16</td><td>0.0625</td><td>0.3125</td></tr><tr><td>5</td><td>32</td><td>1⁄32</td><td>0.03125</td><td>0.34375</td></tr><tr><td>6</td><td>64</td><td>1⁄64</td><td>0.015625</td><td>0.359375</td></tr><tr><td>11</td><td>2048</td><td>1⁄2048</td><td>0.00048828125</td><td>0.35986328125</td></tr><tr><td>13</td><td>8192</td><td>1⁄8192</td><td>0.0001220703125</td><td>0.3599853515625</td></tr><tr><td>17</td><td>131072</td><td>1⁄131072</td><td>0.00000762939453</td><td>0.35999298095703</td></tr><tr><td>18</td><td>262144</td><td>1⁄262144</td><td>0.00000381469727</td><td>0.3599967956543</td></tr><tr><td>19</td><td>524288</td><td>1⁄524288</td><td>0.00000190734863</td><td>0.35999870300293</td></tr><tr><td>20</td><td>1048576</td><td>1⁄1048576</td><td>0.00000095367432</td><td>0.35999965667725</td></tr><tr><td>22</td><td>4194304</td><td>1⁄4194304</td><td>0.00000023841858</td><td>0.35999989509583</td></tr><tr><td>23</td><td>8388608</td><td>1⁄8388608</td><td>0.00000011920929</td><td>0.36000001430512</td></tr></tbody></table><h2 id="go语言显示浮点数-验证之前的理论"><a class="markdownIt-Anchor" href="#go语言显示浮点数-验证之前的理论"></a> go语言显示浮点数 -  验证之前的理论</h2><p>接下来用一个案例有助于我们理解并验证IEEE-754 浮点数的表示方式。<br>math.Float32bits 可以为我们打印出32位数据的二进制表示。(注：math.Float64bits可以打印64位数据的二进制)<br>下面的go代码将输出0.085的浮点数二进制表达，并且为了验证之前理论的正确性，根据二进制表示反向推导出其所表示的原始十进制0.085</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="keyword">float32</span> = <span class="number">0.085</span></span><br><span class="line"><span class="comment">// 打印出32位数据的二进制表示。</span></span><br><span class="line">bits := math.Float32bits(number)</span><br><span class="line">binary := fmt.Sprintf(<span class="string">"%.32b"</span>, bits)</span><br><span class="line"> <span class="comment">// 打印浮点数的符号位、指数位 、小数位</span></span><br><span class="line">fmt.Printf(<span class="string">"Bit Pattern: %s | %s %s | %s %s %s %s %s %s\n\n"</span>,</span><br><span class="line">binary[<span class="number">0</span>:<span class="number">1</span>],</span><br><span class="line">binary[<span class="number">1</span>:<span class="number">5</span>], binary[<span class="number">5</span>:<span class="number">9</span>],</span><br><span class="line">binary[<span class="number">9</span>:<span class="number">12</span>], binary[<span class="number">12</span>:<span class="number">16</span>], binary[<span class="number">16</span>:<span class="number">20</span>],</span><br><span class="line">binary[<span class="number">20</span>:<span class="number">24</span>], binary[<span class="number">24</span>:<span class="number">28</span>], binary[<span class="number">28</span>:<span class="number">32</span>])</span><br><span class="line"> <span class="comment">// 偏移量</span></span><br><span class="line">bias := <span class="number">127</span></span><br><span class="line"> <span class="comment">// 获取符号位</span></span><br><span class="line">sign := bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">exponentRaw := <span class="keyword">int</span>(bits &gt;&gt; <span class="number">23</span>)</span><br><span class="line"> <span class="comment">// 获取指数位</span></span><br><span class="line">exponent := exponentRaw - bias</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mantissa <span class="keyword">float64</span></span><br><span class="line"> <span class="comment">// 小数位求和</span></span><br><span class="line"><span class="keyword">for</span> index, bit := <span class="keyword">range</span> binary[<span class="number">9</span>:<span class="number">32</span>] &#123;</span><br><span class="line"><span class="keyword">if</span> bit == <span class="number">49</span> &#123;</span><br><span class="line">position := index + <span class="number">1</span></span><br><span class="line">bitValue := math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(position))</span><br><span class="line">fractional := <span class="number">1</span> / bitValue</span><br><span class="line">mantissa = mantissa + fractional</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 反向求出最终10进制表示</span></span><br><span class="line">value := (<span class="number">1</span> + mantissa) * math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(exponent))</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Sign: %d Exponent: %d (%d) Mantissa: %f Value: %f\n\n"</span>,</span><br><span class="line">sign,</span><br><span class="line">exponentRaw,</span><br><span class="line">exponent,</span><br><span class="line">mantissa,</span><br><span class="line">value)</span><br></pre></td></tr></table></figure><p>输出： 表明我们对于浮点数的理解正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting Number: 0.085000</span><br><span class="line">Bit Pattern: 0 | 0111 1011 | 010 1110 0001 0100 0111 1011</span><br><span class="line">Sign: 0 Exponent: 123 (-4) Mantissa: 0.360000 Value: 0.085000</span><br></pre></td></tr></table></figure><h2 id="经典问题如何判断一个浮点数其实存储的是整数"><a class="markdownIt-Anchor" href="#经典问题如何判断一个浮点数其实存储的是整数"></a> 经典问题：如何判断一个浮点数其实存储的是整数</h2><p>下面是一个有趣的问题，如何判断一个浮点数其实存储的是整数？<br>思考10秒钟…<br>下面是一段判断浮点数是否为整数的go代码实现，我们接下来逐行分析函数。<br>它可以加深对于浮点数的理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsInt</span><span class="params">(bits <span class="keyword">uint32</span>, bias <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    exponent := <span class="keyword">int</span>(bits &gt;&gt; <span class="number">23</span>) - bias - <span class="number">23</span></span><br><span class="line">    coefficient := (bits &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">23</span>) - <span class="number">1</span>)) | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>)</span><br><span class="line">    intTest := (coefficient &amp; (<span class="number">1</span> &lt;&lt; <span class="keyword">uint32</span>(-exponent) - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\nExponent: %d Coefficient: %d IntTest: %d\n"</span>,</span><br><span class="line">        exponent,</span><br><span class="line">        coefficient,</span><br><span class="line">        intTest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exponent &lt; <span class="number">-23</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"NOT INTEGER\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exponent &lt; <span class="number">0</span> &amp;&amp; intTest != <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"NOT INTEGER\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"INTEGER\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、要保证是整数，一个重要的条件是必须要指数位大于127。指数位大于127，代表指数大于0， 反之指数小于0.</p><p>下面我们以数字234523为例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Starting Number: 234523.000000</span><br><span class="line">Bit Pattern: 0 | 1001 0000 | 110 0101 0000 0110 1100 0000</span><br><span class="line">Sign: 0 Exponent: 144 (17) Mantissa: 0.789268 Value: 234523.000000</span><br><span class="line">Exponent: -6 Coefficient: 15009472 IntTest: 0</span><br><span class="line">INTEGER</span><br></pre></td></tr></table></figure><p>第一步,计算指数。 由于exponent多减去了23，所以在第一个判断中 判断条件为  exponent &lt; -23<br>exponent := int(bits &gt;&gt; 23) - bias - 23</p><p>第二步，<br>(bits &amp; ((1 &lt;&lt; 23) - 1)) 计算小数位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coefficient := (bits &amp; ((1 &lt;&lt; 23) - 1)) | (1 &lt;&lt; 23)</span><br><span class="line"></span><br><span class="line">Bits:                   01001000011001010000011011000000</span><br><span class="line">(1 &lt;&lt; 23) - 1:          00000000011111111111111111111111</span><br><span class="line">bits &amp; ((1 &lt;&lt; 23) - 1): 00000000011001010000011011000000</span><br></pre></td></tr></table></figure><p>| (1 &lt;&lt; 23) 代表 将1加在前方。<br>1 + 小数 = 系数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bits &amp; ((1 &lt;&lt; 23) - 1): 00000000011001010000011011000000</span><br><span class="line">(1 &lt;&lt; 23):              00000000100000000000000000000000</span><br><span class="line">coefficient:            00000000111001010000011011000000</span><br></pre></td></tr></table></figure><p>第三步，计算intTest 只有当指数的倍数可以弥补最小的小数位的时候，才是一个整数。<br>如下，指数是17位，其不能够弥补最后6位的小数。即不能弥补1/2^18 以后的小数。<br>但是由于代表2^18的位之后为0.所以是整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exponent:                     (144 - 127 - 23) = -6</span><br><span class="line">1 &lt;&lt; uint32(-exponent):       000000</span><br><span class="line">(1 &lt;&lt; uint32(-exponent)) - 1: 111111</span><br><span class="line"></span><br><span class="line">coefficient:                 00000000111001010000011011000000</span><br><span class="line">1 &lt;&lt; uint32(-exponent)) - 1: 00000000000000000000000000111111</span><br><span class="line">intTest:                     00000000000000000000000000000000</span><br></pre></td></tr></table></figure><h2 id="golang-decimal-包详解"><a class="markdownIt-Anchor" href="#golang-decimal-包详解"></a> golang decimal 包详解</h2><p>要理解decimal包，首先需要知道两个重要的概念，Normal number、denormal (or subnormal) number 以及精度。</p><h3 id="normal-number-and-denormal-or-subnormal-number"><a class="markdownIt-Anchor" href="#normal-number-and-denormal-or-subnormal-number"></a> Normal number and denormal (or subnormal) number</h3><p>wiki的解释是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In computing, a normal number is a non-zero number in a floating-point representation which is within the balanced range supported by a given floating-point format: it is a floating point number that can be represented without leading zeros in its significand.</span><br></pre></td></tr></table></figure><p>什么意思呢？在IEEE-754中指数位有一个偏移量，偏移量是为了表达负数而设计的。 比如单精度中的0.085，实际的指数是 -3， 存储到浮点数的指数位是123。<br>所以表达的负数就是有上限的。这个上限就是2^-126。 如果比这个负数还要小，例如2^-127,这个时候应该表达为0.1 * 2 ^ -126.   这时系数变为了不是1为前导的数，这个数就叫做denormal (or subnormal) number。<br>正常的系数是以1为前导的数就叫做Normal number。</p><h3 id="概念精度"><a class="markdownIt-Anchor" href="#概念精度"></a> 概念：精度</h3><p>精度是一个非常复杂的概念，在这里笔者讨论的是2进制浮点数的10进制精度。<br>精度为d表示的是在一个范围内，如果我们将d位10进制（按照科学计数法表达）转换为二进制。再将二进制转换为d位10进制。如果数据没有不损失意味着在此范围内是有d精度的。<br>精度的原因在于，数据在进制之间相互转换时，是不能够精准匹配的，而是只能匹配到一个最近的数。如图所示：<br><center><img src="/2019/12/11/golang-106-IEE754-float/1.png"></center><br><center><div>精度转换</div></center><br>在这里暂时不深入探讨，而是给出结论：（注：精度是动态变化的，不同的范围可能有不同的精度。这是由于 2的幂 与 10的幂之间的交错是不同的。）<br>float32的精度为6-8位，<br>float64的精度为15-17位</p><p>目前使用比较多的精准操作浮点数的decimal包是shopspring/decimal。链接:<a href="https://github.com/shopspring/decimal" target="_blank" rel="noopener">https://github.com/shopspring/decimal</a><br>decimal包使用math/big包存储大整数并进行大整数的计算。<br>比如对于字符串 “123.45” 我们可以将其转换为12345这个大整数，以及-2代表指数。参考decimal结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Decimal struct &#123;</span><br><span class="line">value *big.Int</span><br><span class="line">exp int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本文中，笔者不会探讨math/big是如何进行大整数运算的，而是探讨decimal包一个非常重要的函数：<br>NewFromFloat(value float64) Decimal<br>其主要调用了下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func newFromFloat(val float64, bits uint64, flt *floatInfo) Decimal &#123;</span><br><span class="line">if math.IsNaN(val) || math.IsInf(val, 0) &#123;</span><br><span class="line">panic(fmt.Sprintf(&quot;Cannot create a Decimal from %v&quot;, val))</span><br><span class="line">&#125;</span><br><span class="line">exp := int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1)</span><br><span class="line">mant := bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1)</span><br><span class="line">switch exp &#123;</span><br><span class="line">case 0:</span><br><span class="line">exp++</span><br><span class="line">default:</span><br><span class="line">mant |= uint64(1) &lt;&lt; flt.mantbits</span><br><span class="line">&#125;</span><br><span class="line">exp += flt.bias</span><br><span class="line">var d decimal</span><br><span class="line">d.Assign(mant)</span><br><span class="line">d.Shift(exp - int(flt.mantbits))</span><br><span class="line">d.neg = bits&gt;&gt;(flt.expbits+flt.mantbits) != 0</span><br><span class="line">roundShortest(&amp;d, mant, exp, flt)</span><br><span class="line">if d.nd &lt; 19 &#123;</span><br><span class="line">tmp := int64(0)</span><br><span class="line">m := int64(1)</span><br><span class="line">for i := d.nd - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">tmp += m * int64(d.d[i]-&apos;0&apos;)</span><br><span class="line">m *= 10</span><br><span class="line">&#125;</span><br><span class="line">if d.neg &#123;</span><br><span class="line">tmp *= -1</span><br><span class="line">&#125;</span><br><span class="line">return Decimal&#123;value: big.NewInt(tmp), exp: int32(d.dp) - int32(d.nd)&#125;</span><br><span class="line">&#125;</span><br><span class="line">dValue := new(big.Int)</span><br><span class="line">dValue, ok := dValue.SetString(string(d.d[:d.nd]), 10)</span><br><span class="line">if ok &#123;</span><br><span class="line">return Decimal&#123;value: dValue, exp: int32(d.dp) - int32(d.nd)&#125;</span><br><span class="line">&#125;</span><br><span class="line">return NewFromFloatWithExponent(val, int32(d.dp)-int32(d.nd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数会将浮点数转换为Decimal结构。<br>读者想象一下这个问题：如果存储到浮点数中的值（例如0.1）本身就是一个近似值，为什么decimal包能够解决计算的准确性？<br>原因在于，deciimal包可以精准的将一个浮点数转换为10进制。这就是NewFromFloat为我们做的事情。<br>下面我将对此函数做逐行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//2-4行判断浮点数有效性，不能为NAN或INF</span><br><span class="line">   if math.IsNaN(val) || math.IsInf(val, 0) &#123;</span><br><span class="line">panic(fmt.Sprintf(&quot;Cannot create a Decimal from %v&quot;, val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第5行：剥离出IEEE浮点数的指数位<br>exp := int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1)</p><p>第6行：剥离出浮点数的系数的小数位<br>mant := bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1)</p><p>第7行：如果是指数位为0，代表浮点数是denormal (or subnormal) number；<br>默认情况下会在mant之前加上1，因为mant只是系数的小数，在前面加上1后，代表真正的小数位。<br>现在 mant = IEEE浮点数系数 * 2^53</p><p>第13行： 加上偏移量，exp现在代表真正的指数。<br>第14行： 引入了一个中间结构<code>decimal</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type decimal struct &#123;</span><br><span class="line">d     [800]byte</span><br><span class="line">nd    int</span><br><span class="line">dp    int</span><br><span class="line">neg   bool</span><br><span class="line">trunc bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第15行： 调用d.Assign(mant) , 将mant作为10进制数，存起来。<br>10进制数的每一位都作为一个字符存储到 decimal的byte数组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (a *decimal) Assign(v uint64) &#123;</span><br><span class="line">var buf [24]byte</span><br><span class="line"></span><br><span class="line">// Write reversed decimal in buf.</span><br><span class="line">n := 0</span><br><span class="line">for v &gt; 0 &#123;</span><br><span class="line">v1 := v / 10</span><br><span class="line">v -= 10 * v1</span><br><span class="line">buf[n] = byte(v + &apos;0&apos;)</span><br><span class="line">n++</span><br><span class="line">v = v1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Reverse again to produce forward decimal in a.d.</span><br><span class="line">a.nd = 0</span><br><span class="line">for n--; n &gt;= 0; n-- &#123;</span><br><span class="line">a.d[a.nd] = buf[n]</span><br><span class="line">a.nd++</span><br><span class="line">&#125;</span><br><span class="line">a.dp = a.nd</span><br><span class="line">trim(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第16行： 调用shift函数，这个函数非常难理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (a *decimal) Shift(k int) &#123;</span><br><span class="line">switch &#123;</span><br><span class="line">case a.nd == 0:</span><br><span class="line">case k &gt; 0:</span><br><span class="line">for k &gt; maxShift &#123;</span><br><span class="line">leftShift(a, maxShift)</span><br><span class="line">k -= maxShift</span><br><span class="line">&#125;</span><br><span class="line">leftShift(a, uint(k))</span><br><span class="line">case k &lt; 0:</span><br><span class="line">for k &lt; -maxShift &#123;</span><br><span class="line">rightShift(a, maxShift)</span><br><span class="line">k += maxShift</span><br><span class="line">&#125;</span><br><span class="line">rightShift(a, uint(-k))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数的功能是为了获取此浮点数代表的10进制数据的整数位个数以及小数位个数，此函数的完整证明附后。（注1)<br>exp是真实的指数，其也是能够覆盖小数部分2进制位的个数。（参考前面如何判断浮点数是整数）<br>exp - int(flt.mantbits)代表不能被exp覆盖的2进制位的个数<br>如果exp - int(flt.mantbits)  &gt; 0  代表exp能够完全覆盖小数位 因此 浮点数是一个非常大的整数，这时会调用leftShift(a, uint(k))。否则将调用rightShift(a, uint(-k)), 常规rightShift会调用得更多。因此我们来看看rightShift函数的实现。</p><p>第5行： 此for循环将计算浮点数10进制表示的小数部分的有效位为 r-1 。<br>n &gt;&gt; k  是一个重要的衡量指标，代表了小数部分与整数部分的分割。 此函数的完整证明附后。（注1)</p><p>第21行：此时整数部分所占的有效位数为a.dp -=（r-1）<br>第24行：这两个循环做了2件事情：<br>1、计算10进制表示的有效位数<br>2、将10进制表示存入bytes数组中。例如对于浮点数64.125，现在byte数组存储的前5位就是64125</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">func rightShift(a *decimal, k uint) &#123;</span><br><span class="line">r := 0</span><br><span class="line">w := 0</span><br><span class="line">var n uint</span><br><span class="line">for ; n&gt;&gt;k == 0; r++ &#123;</span><br><span class="line">if r &gt;= a.nd &#123;</span><br><span class="line">if n == 0 &#123;</span><br><span class="line">a.nd = 0</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">for n&gt;&gt;k == 0 &#123;</span><br><span class="line">n = n * 10</span><br><span class="line">r++</span><br><span class="line">&#125;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">c := uint(a.d[r])</span><br><span class="line">n = n*10 + c - &apos;0&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 整数部分的有效位数</span><br><span class="line">a.dp -= r - 1</span><br><span class="line"></span><br><span class="line">var mask uint = (1 &lt;&lt; k) - 1</span><br><span class="line">    // 整数部分</span><br><span class="line">for ; r &lt; a.nd; r++ &#123;</span><br><span class="line">c := uint(a.d[r])</span><br><span class="line">dig := n &gt;&gt; k</span><br><span class="line">n &amp;= mask</span><br><span class="line">a.d[w] = byte(dig + &apos;0&apos;)</span><br><span class="line">w++</span><br><span class="line">n = n*10 + c - &apos;0&apos;</span><br><span class="line">&#125;</span><br><span class="line">    // 小数部分</span><br><span class="line">for n &gt; 0 &#123;</span><br><span class="line">dig := n &gt;&gt; k</span><br><span class="line">n &amp;= mask</span><br><span class="line">if w &lt; len(a.d) &#123;</span><br><span class="line">a.d[w] = byte(dig + &apos;0&apos;)</span><br><span class="line">w++</span><br><span class="line">&#125; else if dig &gt; 0 &#123;</span><br><span class="line">a.trunc = true</span><br><span class="line">&#125;</span><br><span class="line">n = n * 10</span><br><span class="line">&#125;</span><br><span class="line">    // 有效位</span><br><span class="line">a.nd = w</span><br><span class="line">trim(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到newFromFloat函数，第18行，调用了roundShortest函数，<br>此函数非常关键。其会将浮点数转换为离其最近的十进制数。<br>这是为什么decimal.NewFromFloat(0.1)能够精准表达0.1的原因。</p><p>参考上面的精度，此函数主要考察了2的幂与10的幂之间的交错关系。四舍五入到最接近的10进制值。<br>此函数实质实现的是Grisu3 算法,有想深入了解的可以去看看论文。笔者在这里提示几点：<br>1、2^exp &lt;= d &lt; 10^dp。<br>2、10进制数之间至少相聚10^(dp-nd)<br>3、2的幂之间的最小间距至少为2^(exp-mantbits)<br>4、什么时候d就是最接近2进制的10进制数？<br>如果10^(dp-nd) &gt; 2^(exp-mantbits)，表明 当十进制下降一个最小位数时，匹配到的是更小的数字value -  2^(exp-mantbits)，所以d就是最接近浮点数的10进制数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) &#123;</span><br><span class="line">if mant == 0 &#123;</span><br><span class="line">d.nd = 0</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">        // d 是否就是最接近的2进制数。</span><br><span class="line">minexp := flt.bias + 1 // minimum possible exponent</span><br><span class="line">if exp &gt; minexp &amp;&amp; 332*(d.dp-d.nd) &gt;= 100*(exp-int(flt.mantbits)) &#123;</span><br><span class="line">// The number is already shortest.</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">        // 计算最接近的大于d的10进制数</span><br><span class="line">upper := new(decimal)</span><br><span class="line">upper.Assign(mant*2 + 1)</span><br><span class="line">upper.Shift(exp - int(flt.mantbits) - 1)</span><br><span class="line"></span><br><span class="line">var mantlo uint64</span><br><span class="line">var explo int</span><br><span class="line">if mant &gt; 1&lt;&lt;flt.mantbits || exp == minexp &#123;</span><br><span class="line">mantlo = mant - 1</span><br><span class="line">explo = exp</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mantlo = mant*2 - 1</span><br><span class="line">explo = exp - 1</span><br><span class="line">&#125;</span><br><span class="line">        // 计算最接近的小于d的10进制数</span><br><span class="line">lower := new(decimal)</span><br><span class="line">lower.Assign(mantlo*2 + 1)</span><br><span class="line">lower.Shift(explo - int(flt.mantbits) - 1)</span><br><span class="line"></span><br><span class="line">inclusive := mant%2 == 0</span><br><span class="line"></span><br><span class="line">//进行四舍五入</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到newFromFloat函数，第19行  如果精度小于19，是位于int64范围内的，可以使用快速路径，否则使用math/big包进行赋值操作，效率稍微要慢一些。<br>第36行，正常情况几乎不会发生。如果setstring在异常的情况下会调用NewFromFloatWithExponent 指定精度进行四舍五入截断。</p><h2 id="注一证明shift函数快速的获取一个浮点数代表的十进制"><a class="markdownIt-Anchor" href="#注一证明shift函数快速的获取一个浮点数代表的十进制"></a> 注一：证明shift函数：快速的获取一个浮点数代表的十进制</h2><p>以典型的数字64.125 为例 ， 它可以被浮点数二进制精准表达为：<br>Bit Patterns: 0 | 10000000101        | 0000000010000000000000000000000000000000000000000000<br>Sign: 0         | Exponent: 1029 (6) |  Mantissa: 0.001953</p><p>即 64.125 = 1.001953125 * 2^6<br>注意观察浮点数的小数位在第九位有1, 代表2^-9  即 0.001953125.</p><p>我们在浮点数的小数位前 附上数字1，10000000010000000000000000000000000000000000000000000  代表其为1 / 2^0 .</p><p>此时我们可以认为这个数代表的是1.001953125. 那么这样长的二进制数变为10进制又是多少呢:4512395720392704。</p><p>即 1.001953125 = 4512395720392704 * 2^(-52)</p><p>所以64.125 = 4512395720392704 * 2^(-52) * 2^6 =  4512395720392704 * 2^(-46)<br>在这里，有一种重要的等式。 即 (2 ^ -46) 等价于向左移动了46位。  并且移动后剩下的部分即为64,而舍弃的部分其实是小数部分0.125。<br>这个等式看似复杂其实很好证明，即第46位其实代表的是2^45。 其除以2^46后是一个小数。依次类推…</p><p>因此对于数字 4512395720392704 ， 我们可以用4，45，451，4512 … 依次除以 2 ^ 46. 一直到找到数451239572039270 其除以2^46不为0。这个不为0的数一定为6。<br>接着我们保留后46位，其实是保留了小数位。</p><p>假设 4512395720392704 / 2^46  = (6 + num)<br>64.125 =(6 + num) * 10 + C = 60 + 10* num + C</p><p>当我们将通过位运算保留后46位，设为A, 则 A / 2^46 = num<br>所以 (A * 10 + C) / 2 ^46 =(num * 10 +C) = 4.125<br>因此此我们又可以把4提取出来，实在精彩。<br>10进制小数位的提取是一样的，留给读者自己探索。<br>这样，就可以快速的把对应的10进制数的每一位都找出来…</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>1、本文介绍了go语言使用的IEEE-754标准存储浮点数的具体存储方式。<br>2、本文通过实际代码片段和一个脑筋急转弯帮助读者理解浮点数的存储方式。<br>3、本文介绍了normal number 以及精度这两个重要概念。<br>4、本文详细介绍了shopspring/decimal的实现方式，即借助了big.int，以及进制的巧妙精准转换。<br>5、shopspring/decimal其实在精度的巧妙转换方面参考了go源码ftoa函数的实现。 读者可以参考go源码<br>6、shopspring/decimal目前roundShortest函数有一个bug，笔者已经提交了pr，此bug已在go源码中得到了修复。<br>7、big.int计算存在效率问题，如果遇到特殊的快速大量计算的场景可能不太适合。<br>8、还有一些decimal的实现，例如tibd/decimal,代码实在不忍淬读。<br>9、浮点数计算，除了要解决进制的转换外，还需要解决重要的溢出问题，例如相乘常常要超过int64的范围，这就是为什么shopspring/decimal使用了big.int,而tibd/decimal将数据转换为了很多的word（int32），导致其计算非常复杂。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://dreamerjonson.com/2019/12/11/golang-106-IEE754-float/">深入浮点数</a><br>我将此文章放在了github上：<a href="https://github.com/dreamerjackson/theWayToGolang/blob/master/3-agrs/8_IEEE754%20Float%20introduce.md" target="_blank" rel="noopener">github地址</a><br><a href="https://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/" target="_blank" rel="noopener">Why 0.1 Does Not Exist In Floating-Point</a></p><p><a href="https://en.wikipedia.org/wiki/Normal_number" target="_blank" rel="noopener">Normal number</a></p><p><a href="https://www.exploringbinary.com/7-bits-are-not-enough-for-2-digit-accuracy/" target="_blank" rel="noopener">7-bits-are-not-enough-for-2-digit-accuracy</a></p><p><a href="https://www.exploringbinary.com/decimal-precision-of-binary-floating-point-numbers/" target="_blank" rel="noopener">Decimal Precision of Binary Floating-Point Numbers</a></p><p><a href="https://www.ardanlabs.com/blog/2014/04/introduction-to-numeric-constants-in-go.html" target="_blank" rel="noopener">Introduction To Numeric Constants In Go</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt; 引言&lt;/h2&gt;
&lt;p&gt;下面的一段简单程序 0.3 + 0.6 结果是什么？&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[105]-stack-trace</title>
    <link href="https://dreamerjonson.com/2019/12/05/golang-105-stack-trace/"/>
    <id>https://dreamerjonson.com/2019/12/05/golang-105-stack-trace/</id>
    <published>2019-12-05T14:10:18.000Z</published>
    <updated>2019-12-11T07:35:58.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p>Having some basic skills in debugging Go programs can save any programmer a good amount of time trying to identify problems. I believe in logging as much information as you can, but sometimes a panic occurs and what you logged is not enough. Understanding the information in a stack trace can sometimes mean the difference between finding the bug now or needing to add more logging and waiting for it to happen again</p><p>I have been seeing stack traces since I started writing Go. At some point we all do something silly that causes the runtime to kill our program and throw a stack trace. I am going to show you the information the stack trace provides, including how to identify the value for each parameter that was passed into each function.</p><p>Functions<br>Let’s start with a small piece of code that will produce a stack trace:</p><h2 id="listing-1"><a class="markdownIt-Anchor" href="#listing-1"></a> Listing 1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">    slice := make([]string, 2, 4)</span><br><span class="line">    Example(slice, “hello”, 10)</span><br><span class="line">&#125;</span><br><span class="line">func Example(slice []string, str string, i int) &#123;</span><br><span class="line">    panic(“Want stack trace”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 1 shows a program where the main function calls the Example function on line 05. The Example function is declared on line 08 and accepts three parameters, a slice of strings, a string and an integer. The only code Example executes is a call to the built-in function panic on line 09, which immediately produces a stack trace:</p><h2 id="listing-2"><a class="markdownIt-Anchor" href="#listing-2"></a> Listing 2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Panic: Want stack trace</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:9 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:5 +0x85</span><br><span class="line"></span><br><span class="line">goroutine 2 [runnable]:</span><br><span class="line">runtime.forcegchelper()</span><br><span class="line">        /Users/bill/go/src/runtime/proc.go:90</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1</span><br><span class="line"></span><br><span class="line">goroutine 3 [runnable]:</span><br><span class="line">runtime.bgsweep()</span><br><span class="line">        /Users/bill/go/src/runtime/mgc0.go:82</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1</span><br></pre></td></tr></table></figure><p>The stack trace in listing 2 shows all the goroutines that existed at the time of the panic, the status of each routine and the call stack under that respective goroutine. The goroutines that were running and the one that caused the stack trace will be at the top. Let’s focus on the goroutine that panicked.</p><h2 id="list3"><a class="markdownIt-Anchor" href="#list3"></a> list3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goroutine 1 [running]:</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:9 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:5 +0x85</span><br></pre></td></tr></table></figure><p>The stack trace on line 01 in listing 3 is showing that goroutine 1 was running prior to the panic. On line 02, we see that the code that panicked was in the Example function in package main. The line indented shows the code file and path this function is located in, plus the line of code that was executing. In this case, the code on line 09 was running which is the call to panic.</p><p>Line 03 shows the name of the function that called Example. This is the main function in the main package. Underneath the function name once again, the line that is indented shows the code file, path and line of code where the call to Example was made.</p><p>The stack trace is showing the chain of function calls in the scope of that goroutine up to the time the panic occurred. Now, let’s focus on the values for each parameter that was passed into the Example function:</p><h2 id="listing-4"><a class="markdownIt-Anchor" href="#listing-4"></a> Listing 4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Declaration</span><br><span class="line">main.Example(slice []string, str string, i int)</span><br><span class="line"></span><br><span class="line">// Call to Example by main.</span><br><span class="line">slice := make([]string, 2, 4)</span><br><span class="line">Example(slice, &quot;hello&quot;, 10)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br></pre></td></tr></table></figure><p>Listing 4 shows the values from the stack trace that were passed into the Example function when the call was made by main and the declaration of the function. When you compare the values from the stack trace with the function declaration, it doesn’t seem to match up. The declaration of the Example function accepts three parameters but the stack trace is showing six hexadecimal values. The key to understanding how the values do match up with the parameters requires knowing the implementation for each parameter type.</p><p>Let’s start with the first parameter which is a slice of strings. A slice is a reference type in Go. This means the value for a slice is a header value with a pointer to some underlying data. In the case of a slice, the header value is a three word structure that contains a pointer to an underlying array, the length of the slice and the capacity. The values associated with the slice header are represented by the first three values in the stack trace:</p><h2 id="listing-5"><a class="markdownIt-Anchor" href="#listing-5"></a> Listing 5</h2><p>// Slice parameter value<br>slice := make([]string, 2, 4)</p><p>// Slice header values<br>Pointer:  0x2080c3f50<br>Length:   0x2<br>Capacity: 0x4</p><p>// Declaration<br>main.Example(slice []string, str string, i int)</p><p>// Stack trace<br>main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</p><p>Listing 5 shows how the first three values in the stack trace do match up with the slice parameter. The first value represents the pointer to the underlying array of strings. The length and capacity numbers used to initialize the slice match with the second and third values. Those three values represent each value of the slice header, the first parameter.</p><p>Now let’s look at the second parameter which is a string. A string is also a reference type but this header value is immutable. The header value for a string is declared as a two word structure that contains a pointer to an underlying byte array and the length of the string:</p><h2 id="listing-6"><a class="markdownIt-Anchor" href="#listing-6"></a> Listing 6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// String parameter value</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">// String header values</span><br><span class="line">Pointer: 0x425c0</span><br><span class="line">Length:  0x5</span><br><span class="line"></span><br><span class="line">// Declaration</span><br><span class="line">main.Example(slice []string, str string, i int)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br></pre></td></tr></table></figure><p>Listing 6 shows how the fourth and fifth values in the stack trace do match up with the string parameter. The fourth value represents the pointer to the underlying array of bytes and the fifth value is the length of the string which was 5. The string “hello” requires 5 bytes. Those two values represent each value of the string header, the second parameter.</p><p>The third parameter is an integer which is a single word value:</p><h2 id="listing-7"><a class="markdownIt-Anchor" href="#listing-7"></a> Listing 7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Integer parameter value</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">// Integer value</span><br><span class="line">Base 16: 0xa</span><br><span class="line"></span><br><span class="line">// Declaration</span><br><span class="line">main.Example(slice []string, str string, i int)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br></pre></td></tr></table></figure><p>Listing 7 shows how the last value in the stack trace matches up with the integer parameter. The very last value in the trace is hexadecimal number 0xa, which is the value of 10. The same value that was passed in for that parameter. That value represents the third parameter.<br>Methods<br>Let’s change the program so the Example function is now a method:</p><h2 id="listing-8"><a class="markdownIt-Anchor" href="#listing-8"></a> Listing 8</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type trace struct&#123;&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">slice := make([]string, 2, 4)</span><br><span class="line">var t trace</span><br><span class="line">t.Example(slice, &quot;hello&quot;, 10)</span><br><span class="line">&#125;</span><br><span class="line">func (t *trace) Example(slice []string, str string, i int) &#123;</span><br><span class="line">fmt.Printf(&quot;Receiver Address: %p\n&quot;, t)</span><br><span class="line">panic(&quot;Want stack trace&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 8 changes the original program by declaring a new type named trace on line 05 and converting the Example function into a method on line 14. The conversion is accomplished by re-declaring the function with a pointer receiver of type trace. Then on line 10, a variable named t is declared of type trace and the method call is made with the variable on line 11.</p><p>Since the method is declared with a pointer receiver, Go will take the address of the t variable to support the receiver type, even though the method call is made with a value. This time when the program is run, the stack trace is a little different:</p><h2 id="listing-9"><a class="markdownIt-Anchor" href="#listing-9"></a> Listing 9</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Receiver Address: 0x1553a8</span><br><span class="line">panic: Want stack trace</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.(*trace).Example(0x1553a8, 0x2081b7f50, 0x2, 0x4, 0xdc1d0, 0x5, 0xa)</span><br><span class="line">           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">           temp/main.go:16 +0x116</span><br><span class="line">main.main()</span><br><span class="line">           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">           temp/main.go:11 +0xae</span><br></pre></td></tr></table></figure><p>The first thing you should notice in listing 9 is that the stack trace on line 02 is making it clear this was a method call using a pointer receiver. The name of the function is now displayed with (*trace) between the package name and the method name. The second thing to notice is how the value list now shows the value of the receiver first. Method calls are really function calls with the first parameter being the receiver value. We are seeing this implementation detail in action from the stack trace.</p><p>Since nothing else changed with the declaration or call to the Example method, all the other values remain the same. The line numbers where the call to Example is made and where the panic occurred changed and reflects the new code.</p><p>Packing<br>When you have multiple parameters that fit inside of a single word, then the values for the parameters in the stack trace will be packed together:</p><h2 id="listing-10"><a class="markdownIt-Anchor" href="#listing-10"></a> Listing 10</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">Example(true, false, true, 25)</span><br><span class="line">&#125;</span><br><span class="line">func Example(b1, b2, b3 bool, i uint8) &#123;</span><br><span class="line">panic(&quot;Want stack trace&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 10 shows a new sample program that changes the Example function to accept four parameters. The first three are booleans and the last one is an eight bit unsigned integer. A boolean value is also an eight bit value, so all four parameters fit inside of a single word on both 32 and 64 bit architectures. When the program runs, it produces an interesting stack trace:</p><h2 id="listing-11"><a class="markdownIt-Anchor" href="#listing-11"></a> Listing 11</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goroutine 1 [running]:</span><br><span class="line">main.Example(0x19010001)</span><br><span class="line">          /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">          temp/main.go:8 +0x64</span><br><span class="line">main.main()</span><br><span class="line">          /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">          temp/main.go:4 +0x32</span><br></pre></td></tr></table></figure><p>Instead of there being four values in the stack trace for the call to Example, there is a single value. All four individual 8 bit values were packed together into a single word:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Parameter values</span><br><span class="line">true, false, true, 25</span><br><span class="line"></span><br><span class="line">// Word value</span><br><span class="line">Bits    Binary      Hex   Value</span><br><span class="line">00-07   0000 0001   01    true</span><br><span class="line">08-15   0000 0000   00    false</span><br><span class="line">16-23   0000 0001   01    true</span><br><span class="line">24-31   0001 1001   19    25</span><br><span class="line"></span><br><span class="line">// Declaration</span><br><span class="line">main.Example(b1, b2, b3 bool, i uint8)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x19010001)</span><br></pre></td></tr></table></figure><p>Listing 12 shows how the value in the stack trace matches up with all four parameter values that were passed in. The value of true is an 8 bit value that is represented with the value of 1 and the value of false is represented with the value of 0. The value of 25 in binary is 11001 which converts to 19 in hexadecimal. Now when we look at the hexadecimal value represented in the stack trace, we see how it does represent the values that were passed in.</p><h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2><p>The Go runtime provides a great deal of information to help us debug our programs. In this post we concentrated on stack traces. The ability to decode the values that were passed into each function throughout the call stack is huge. It has helped me more than once to identify my bug very quickly. Now that you know how to read stack traces, hopefully you can leverage this knowledge the next time a stack trace happens to you.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#introduction&quot;&gt;&lt;/a&gt; Introduction&lt;/h2&gt;
&lt;p&gt;Having some basic skills in debugging Go p
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
</feed>
