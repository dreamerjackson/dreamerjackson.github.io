<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jonson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreamerjonson.com/"/>
  <updated>2019-05-20T12:28:20.425Z</updated>
  <id>https://dreamerjonson.com/</id>
  
  <author>
    <name>Jonson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang[77]-sed</title>
    <link href="https://dreamerjonson.com/2019/05/20/golang-77-sed/"/>
    <id>https://dreamerjonson.com/2019/05/20/golang-77-sed/</id>
    <published>2019-05-20T12:25:10.000Z</published>
    <updated>2019-05-20T12:28:20.425Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://xn--gitlab-9v7ir7c3xowzbo6euxvdws12bf2wblisogno0t.followme.com/CopyTradingGo%E5%AD%97%E7%AC%A6%E7%9A%84%E6%89%80%E6%9C%89go%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">快速替换当前文件夹中包含gitlab.followme.com/CopyTradingGo字符的所有go文件</a> <a href="http://xn--gitlab-ow6o.followme.com/CopyTradingGo" target="_blank" rel="noopener">的gitlab.followme.com/CopyTradingGo</a> <a href="http://xn--fmgo-uh5fp43i8jf.io/trade" target="_blank" rel="noopener">替换为fmgo.io/trade</a><br>sed -i “” ‘s/gitlab.followme.com/CopyTradingGo/fmgo.io/trade/g’ <code>grep -Rl gitlab.followme.com/CopyTradingGo . | grep &quot;.go&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://xn--gitlab-9v7ir7c3xowzbo6euxvdws12bf2wblisogno0t.followme.com/CopyTradingGo%E5%AD%97%E7%AC%A6%E7%9A%84%E6%89%80%E6%9C%89
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[76]-Reflection反射</title>
    <link href="https://dreamerjonson.com/2019/05/18/golang-76-reflection/"/>
    <id>https://dreamerjonson.com/2019/05/18/golang-76-reflection/</id>
    <published>2019-05-18T01:12:41.000Z</published>
    <updated>2019-05-18T01:20:22.148Z</updated>
    
    <content type="html"><![CDATA[<p>Reflection is one of the advanced topics in Go. I will try to make it as simple as possible.</p><p>This tutorial has the following sections.</p><p>What is reflection?<br>What is the need to inspect a variable and find its type?<br>reflect package<br>reflect.Type and reflect.Value<br>reflect.Kind<br>NumField() and Field() methods<br>Int() and String() methods<br>Complete program<br>Should reflection be used?<br>Let’s discuss these sections one by one now.</p><h2 id="what-is-reflection"><a class="markdownIt-Anchor" href="#what-is-reflection"></a> What is reflection?</h2><p>Reflection is the ability of a program to inspect its variables and values at run time and find their type. You might not understand what this means but that’s alright. You will get a clear understanding of reflection by the end of this tutorial, so stay with me.</p><h2 id="what-is-the-need-to-inspect-a-variable-and-find-its-type"><a class="markdownIt-Anchor" href="#what-is-the-need-to-inspect-a-variable-and-find-its-type"></a> What is the need to inspect a variable and find its type?</h2><p>The first question anyone gets when learning about reflection is why do we even need to inspect a variable and find its type at runtime when each and every variable in our program is defined by us and we know its type at compile time itself. Well this is true most of the times, but not always.</p><h2 id="let-me-explain-what-i-mean-lets-write-a-simple-program"><a class="markdownIt-Anchor" href="#let-me-explain-what-i-mean-lets-write-a-simple-program"></a> Let me explain what I mean. Let’s write a simple program.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    i := 10</span><br><span class="line">    fmt.Printf(&quot;%d %T&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, the type of i is known at compile time and we print it in the next line. Nothing magical here.</p><p>Now let’s understand the need to know the type of a variable at run time. Let’s say we want to write a simple function which will take a struct as argument and will create a SQL insert query using it.</p><p>Consider the following program,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">1234</span>,</span><br><span class="line">        customerId: <span class="number">567</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We need to write a function which will take the struct o in the program above as an argument and return the following SQL insert query,</p><p>insert into order values(1234, 567)<br>This function is simple to write. Lets do that now.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(o order)</span> <span class="title">string</span></span> &#123;  </span><br><span class="line">    i := fmt.Sprintf(<span class="string">"insert into order values(%d, %d)"</span>, o.ordId, o.customerId)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">1234</span>,</span><br><span class="line">        customerId: <span class="number">567</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(createQuery(o))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The createQuery function in line no. 12 creates the insert query by using the ordId and customerId fields of o. This program will output,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into order values(1234, 567)</span><br></pre></td></tr></table></figure><p>Now lets take our query creator to the next level. What if we want to generalize our query creator and make it work on any struct. Let me explain what I mean using a program.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type order struct &#123;  </span><br><span class="line">    ordId      int</span><br><span class="line">    customerId int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type employee struct &#123;  </span><br><span class="line">    name string</span><br><span class="line">    id int</span><br><span class="line">    address string</span><br><span class="line">    salary int</span><br><span class="line">    country string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createQuery(q interface&#123;&#125;) string &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Our objective is to finish the createQuery function in line no. 16 of the above program so that it takes any struct as argument and creates an insert query based on the struct fields.</p><p>For example, if we pass the struct below</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o := order &#123;  </span><br><span class="line">    ordId: 1234,</span><br><span class="line">    customerId: 567</span><br><span class="line">&#125;</span><br><span class="line">``</span><br></pre></td></tr></table></figure><p>Our createQuery function should return,</p><p>insert into order values (1234, 567)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Similarly if we pass</span><br><span class="line"></span><br><span class="line">e := employee &#123;</span><br><span class="line">       name: &quot;Naveen&quot;,</span><br><span class="line">       id: 565,</span><br><span class="line">       address: &quot;Science Park Road, Singapore&quot;,</span><br><span class="line">       salary: 90000,</span><br><span class="line">       country: &quot;Singapore&quot;,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>it should return,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into employee values(&quot;Naveen&quot;, 565, &quot;Science Park Road, Singapore&quot;, 90000, &quot;Singapore&quot;)</span><br></pre></td></tr></table></figure><p>Since the createQuery function should work with any struct, it takes a interface{} as argument. For simplicity, we will only deal with structs that contain fields of type string and int but this can be extended for any type.</p><p>The createQuery function should work on any struct. The only way to write this function is to examine the type of the struct argument passed to it at run time, find its fields and then create the query. This is where reflection is useful. In the next steps of the tutorial, we will learn how we can achieve this using the reflect package.</p><h2 id="reflect-package"><a class="markdownIt-Anchor" href="#reflect-package"></a> reflect package</h2><p>The reflect package implements run-time reflection in Go. The reflect package helps to identify the underlying concrete type and the value of a interface{} variable. This is exactly what we need. The createQuery function takes a interface{} argument and the query needs to be created based on the concrete type and value of the interface{} argument. This is exactly what the reflect package helps in doing.</p><p>There are a few types and methods in the reflect package which we need to know first before writing our generic query generator program. Lets look at them one by one.</p><h2 id="reflecttype-and-reflectvalue"><a class="markdownIt-Anchor" href="#reflecttype-and-reflectvalue"></a> reflect.Type and reflect.Value</h2><p>The concrete type of interface{} is represented by reflect.Type and the underlying value is represented by reflect.Value. There are two functions reflect.TypeOf() and reflect.ValueOf() which return the reflect.Type and reflect.Value respectively. These two types are the base to create our query generator. Let’s write a simple example to understand these two types.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    t := reflect.TypeOf(q)</span><br><span class="line">    v := reflect.ValueOf(q)</span><br><span class="line">    fmt.Println(<span class="string">"Type "</span>, t)</span><br><span class="line">    fmt.Println(<span class="string">"Value "</span>, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, the createQuery function in line no. 13 takes a interface{} as argument. The function reflect.TypeOf in line no. 14 takes a interface{} as argument and returns the reflect.Type containing the concrete type of the interface{} argument passed. Similarly the reflect.ValueOf function in line no. 15 takes a interface{} as argument and returns the reflect.Value which contains the underlying value of the interface{} argument passed.</p><p>The above program prints,</p><p>Type  main.order<br>Value  {456 56}<br>From the output, we can see that the program prints the concrete type and the value of the interface.</p><h2 id="reflectkind"><a class="markdownIt-Anchor" href="#reflectkind"></a> reflect.Kind</h2><p>There is one more important type in the reflection package called Kind.</p><p>The types Kind and Type in the reflection package might seem similar but they have a difference which will be clear from the program below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type order struct &#123;  </span><br><span class="line">    ordId      int</span><br><span class="line">    customerId int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createQuery(q interface&#123;&#125;) &#123;  </span><br><span class="line">    t := reflect.TypeOf(q)</span><br><span class="line">    k := t.Kind()</span><br><span class="line">    fmt.Println(&quot;Type &quot;, t)</span><br><span class="line">    fmt.Println(&quot;Kind &quot;, k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      456,</span><br><span class="line">        customerId: 56,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The program above outputs,</p><p>Type  main.order<br>Kind  struct<br>I think you will now be clear about the differences between the two. Type represents the actual type of the interface{}, in this case main.Order and Kind represents the specific kind of the type. In this case, it’s a struct.</p><h2 id="numfield-and-field-methods"><a class="markdownIt-Anchor" href="#numfield-and-field-methods"></a> NumField() and Field() methods</h2><p>The NumField() method returns the number of fields in a struct and the Field(i int) method returns the reflect.Value of the ith field.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;</span><br><span class="line">        v := reflect.ValueOf(q)</span><br><span class="line">        fmt.Println(<span class="string">"Number of fields"</span>, v.NumField())</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Field:%d type:%T value:%v\n"</span>, i, v.Field(i), v.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, in line no. 14 we first check whether the Kind of q is a struct because the NumField method works only on struct. The rest of the program is self explanatory. This program outputs,</p><p>Number of fields 2<br>Field:0 type:reflect.Value value:456<br>Field:1 type:reflect.Value value:56</p><h2 id="int-and-string-methods"><a class="markdownIt-Anchor" href="#int-and-string-methods"></a> Int() and String() methods</h2><p>The methods Int and String help extract the reflect.Value as an int64 and string respectively.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">56</span></span><br><span class="line">    x := reflect.ValueOf(a).Int()</span><br><span class="line">    fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">    b := <span class="string">"Naveen"</span></span><br><span class="line">    y := reflect.ValueOf(b).String()</span><br><span class="line">    fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, y, y)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, in line no. 10, we extract the reflect.Value as an int64 and in line no. 13, we extract it as string. This program prints,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type:int64 value:56  </span><br><span class="line">type:string value:Naveen</span><br></pre></td></tr></table></figure><h2 id="complete-program"><a class="markdownIt-Anchor" href="#complete-program"></a> Complete Program</h2><p>Now that we have enough knowledge to finish our query generator, lets go ahead and do it.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    id      <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">    salary  <span class="keyword">int</span></span><br><span class="line">    country <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;</span><br><span class="line">        t := reflect.TypeOf(q).Name()</span><br><span class="line">        query := fmt.Sprintf(<span class="string">"insert into %s values("</span>, t)</span><br><span class="line">        v := reflect.ValueOf(q)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> v.Field(i).Kind() &#123;</span><br><span class="line">            <span class="keyword">case</span> reflect.Int:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s%d"</span>, query, v.Field(i).Int())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s, %d"</span>, query, v.Field(i).Int())</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> reflect.String:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s\"%s\""</span>, query, v.Field(i).String())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s, \"%s\""</span>, query, v.Field(i).String())</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">"Unsupported type"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        query = fmt.Sprintf(<span class="string">"%s)"</span>, query)</span><br><span class="line">        fmt.Println(query)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"unsupported type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">    e := employee&#123;</span><br><span class="line">        name:    <span class="string">"Naveen"</span>,</span><br><span class="line">        id:      <span class="number">565</span>,</span><br><span class="line">        address: <span class="string">"Coimbatore"</span>,</span><br><span class="line">        salary:  <span class="number">90000</span>,</span><br><span class="line">        country: <span class="string">"India"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(e)</span><br><span class="line">    i := <span class="number">90</span></span><br><span class="line">    createQuery(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In line no. 22, we first check whether the passed argument is a struct. In line no. 23 we get the name of the struct from its reflect.Type using the Name() method. In the next line, we use t and start creating the query.</p><p>The case statement in line. 28 checks whether the current field is reflect.Int, if that’s the case we extract the value of that field as int64 using the Int() method. The if else statement is used to handle edge cases. Please add logs to understand why it is needed. Similar logic is used to extract the string in line no. 34.</p><p>We have also added checks to prevent the program from crashing when unsupported types are passed to the createQuery function. The rest of the program is self explanatory. I recommend adding logs at appropriate places and checking their output to understand this program better.</p><p>This program prints,</p><p>insert into order values(456, 56)<br>insert into employee values(“Naveen”, 565, “Coimbatore”, 90000, “India”)<br>unsupported type<br>I would leave it as an exercise for the reader to add the field names to the output query. Please try changing the program to print query of the format,</p><p>insert into order(ordId, customerId) values(456, 56)<br>Should reflection be used?<br>Having shown a practical use of reflection, now comes the real question. Should you be using reflection? I would like to quote Rob Pike’s proverb on the use of reflection which answers this question.</p><p>Clear is better than clever. Reflection is never clear.</p><p>Reflection is a very powerful and advanced concept in Go and it should be used with care. It is very difficult to write clear and maintainable code using reflection. It should be avoided wherever possible and should be used only when absolutely necessary.</p><p>This brings us to and end of this tutorial. Hope you enjoyed it. Have a good day.</p><p>Like my tutorials? Please show your support by donating. Your donations will help me create more awesome tutorials.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reflection is one of the advanced topics in Go. I will try to make it as simple as possible.&lt;/p&gt;
&lt;p&gt;This tutorial has the following secti
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[75]-useDocker</title>
    <link href="https://dreamerjonson.com/2019/05/16/golang-75-useDocker/"/>
    <id>https://dreamerjonson.com/2019/05/16/golang-75-useDocker/</id>
    <published>2019-05-16T14:19:47.000Z</published>
    <updated>2019-05-17T10:49:05.835Z</updated>
    
    <content type="html"><![CDATA[<p>在docker中编译 Go mod程序。需要用到gitlab的私有仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:alpine</span><br><span class="line"></span><br><span class="line">RUN apk update</span><br><span class="line">RUN apk add --no-cache git</span><br><span class="line">RUN apk add openssh</span><br><span class="line">ADD id_ed25519 /root/.ssh/id_ed25519</span><br><span class="line">RUN chmod 600 /root/.ssh/id_ed25519</span><br><span class="line"></span><br><span class="line">RUN echo -e  &quot;[url \&quot;git@gitlab.followme.com:\&quot;]\n\tinsteadOf = https://gitlab.followme.com/&quot; &gt;&gt; /root/.gitconfig</span><br><span class="line"># Skip Host verification for git</span><br><span class="line">RUN echo &quot;StrictHostKeyChecking no &quot; &gt; /root/.ssh/config</span><br><span class="line">WORKDIR /contour</span><br><span class="line">COPY . .</span><br><span class="line">RUN go build -o remote -v viperRemote/viperRemote.go</span><br><span class="line">ENTRYPOINT [&quot;./remote&quot;]</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/paperchain/fetching-private-github-repos-from-a-docker-container-273f25ec5a74" target="_blank" rel="noopener">https://medium.com/paperchain/fetching-private-github-repos-from-a-docker-container-273f25ec5a74</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在docker中编译 Go mod程序。需要用到gitlab的私有仓库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>a-mac-effitive</title>
    <link href="https://dreamerjonson.com/2019/05/15/a-mac-effitive/"/>
    <id>https://dreamerjonson.com/2019/05/15/a-mac-effitive/</id>
    <published>2019-05-15T07:20:17.000Z</published>
    <updated>2019-05-15T07:23:13.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="按住-option-键来快捷缩放窗口"><a class="markdownIt-Anchor" href="#按住-option-键来快捷缩放窗口"></a> 按住 ⌥Option 键来快捷缩放窗口</h2><p>窗口管理应该是每个用户都会有的需求，如果你还没有窗口管理工具，可以在我派搜索到许多款质量不俗的。但如果你不想受制于这些工具硬性规定的窗口尺寸，在某些场景下需要手动调整，按住 ⌥Option 键再缩放窗口则可以获得更加快捷的体验。</p><p>而除此之外，你还可以将常用的文件及文件夹拖拽到 Finder 工具栏，形成快捷入口，只要按住 ⌘Command 键并拖动目标，看到绿色的加号再释放即可，下次使用就不用再「翻箱倒柜」一番了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;按住-option-键来快捷缩放窗口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#按住-option-键来快捷缩放窗口&quot;&gt;&lt;/a&gt; 按住 ⌥Option 键来快捷缩放窗口&lt;/h2&gt;
&lt;p&gt;窗口管理应该是每个用户都会有的需求，如果你还没
      
    
    </summary>
    
      <category term="mac" scheme="https://dreamerjonson.com/categories/mac/"/>
    
    
      <category term="mac" scheme="https://dreamerjonson.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>golang[74]-goland-技巧</title>
    <link href="https://dreamerjonson.com/2019/05/11/golang-74-goland-tips/"/>
    <id>https://dreamerjonson.com/2019/05/11/golang-74-goland-tips/</id>
    <published>2019-05-11T01:59:34.000Z</published>
    <updated>2019-05-11T03:26:02.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="implement-interface"><a class="markdownIt-Anchor" href="#implement-interface"></a> Implement Interface</h2><p>Implement Interface is a hidden gem that can be found by using the common Intellij keystroke combo ⌥ (Option/Alt) + Enter on the struct that you wish to implement the interface. This will open a search window, and you can type the interface that you wish to implement.</p><h2 id="extract-interface"><a class="markdownIt-Anchor" href="#extract-interface"></a> Extract Interface</h2><p>I wish this had a great keyboard combination, but it doesn’t currently by default. If you wish to extract an interface, then you need to Right-Click on struct → Refactor → Extract → Interface. Once the menu pops up it asks you more information, name, file to add to, package…etc. I still use this quite often.<br>you can consider Ctrl+T 6 (Refactor this) as a shortcut for Extract interface</p><h2 id="live-templates"><a class="markdownIt-Anchor" href="#live-templates"></a> Live Templates</h2><p>Live templates are awesome for quickly generating some code that you commonly use. In general, you type in a few characters and then hit tab. Some built in live templates are forr which generates a for range loop (you need the extra “r”) and err which allow you to handle errors quickly. These are really powerful because you can also create your own live templates. For example, if you have a common logging framework when you logged “info” you could create logi as your own template which would generate your “<a href="http://log.info" target="_blank" rel="noopener">log.info</a>” statement. If you have a hard time remembering these, just remember one keyboard combo: ⌘ (Command) + j — this will show you all available templates within the context of the block of code where your cursor is at. Enjoy these examples below:</p><p>forr — for range loop<br>To execute this live template, just type “forr” + tab</p><p>3b. err — check for error and handle<br>To execute this live template, just type “err” + tab</p><h2 id="fill-struct"><a class="markdownIt-Anchor" href="#fill-struct"></a> Fill Struct</h2><p>I am not exactly sure when this was released, but it is glorious. If are familiar constructors in Java or C#, then you were used to a little IDE help when you instantiated a new class. This gives you that same power (albeit a little more clunky). In this case, if you have a struct that you are creating, then if you put your cursor between the brackets {}, then hit ⌥ (Option/Alt) + Enter, it will give you the option of “Fill Struct” or “Fill Struct Recursively”. Choose one. Save your typing for some other fun code, and let this thing do its work!</p><h2 id="generate-test-casestest-file"><a class="markdownIt-Anchor" href="#generate-test-casestest-file"></a> Generate test cases/test file</h2><p>This is probably my favorite. I am pretty passionate about writing testable code and unit testing in general. I really think that writing testable code using SOLID principles will help you design better and more maintainable code. I found this nugget pretty early in my golang learnings, but it is definitely my most used feature. If you put your cursor on a method, type  ⌘ (Command) + n , and this will bring up the “Generate” menu, and from here you can select “Test for function” or “Test for file” and if the <code>_</code>test.go file doesn’t exist, it will create it for you along with the outline of parameterized/table tests for your functions. Pretty awesome.</p><h2 id="refactorings"><a class="markdownIt-Anchor" href="#refactorings"></a> Refactorings</h2><p>Refactorings is another fundamental need one may have when making changes to a program.</p><p>With GoLand, you can extract a function from an expression at the caret, or from a group of selected statements, by using the dedicated Extract action (Alt+Ctrl+M for Windows/Linux and Alt+Cmd+M for macOS), or selecting the Method option in the generic Refactor This popup (Ctrl+T):</p><p>The same refactoring is available for variables (Alt+Ctrl+V for Windows/Linux and Alt+Cmd+V for macOS) and constants (Alt+Ctrl+V for Windows/Linux and Alt+Cmd+V for macOS).</p><p>You can inline a constant, or variable at the caret by using the dedicated Extract action (Alt+Ctrl+M for Windows/Linux and Alt+Cmd+M for macOS), or select the Inline option in the generic Refactor This popup (Ctrl+T). The IDE will update all references to the symbol and replace them with the value:</p><h2 id="navigation"><a class="markdownIt-Anchor" href="#navigation"></a> Navigation</h2><p>One thing that you do more often than write code is read code. GoLand helps here as well. For example, the IDE lets you instantly navigate to an interface implemented by the type at the caret with one click: either by clicking the icon on the left side of the editor, using the dedicated Show Interfaces (Ctrl+U for Windows/Linux and Cmd+U for macOS) action, or by using the corresponding intention action:</p><p>A similar icon, dedicated action (Show Implementations via Ctrl+B for Windows/Linux and Cmd+B for macOS) and intention action can navigate you to types that implement the interface at the caret.</p><p>Every time you see a popup with a list of symbols, be it usages, implementations, implemented interfaces or completion suggestions, you can call Quick Definition (Ctrl+Shift+I for Windows/Linux or Cmd+Y for macOS) or Quick Documentation (Ctrl+Q for Windows/Linux and Ctrl+J for macOS) to have another popup open aside it with the definition or documentation for the selected symbol:</p><p>Navigate back/forward ⌘[ ⌘]</p><p>Expand or collapse a code block in the editor ⌘+ ⌘-    shift</p><p>Show implementation ⌥⌘B    ⌘B</p><p>Quick definition ⌥Space</p><p>Search everywhere  Double Shift<br>importtant               ⌘E<br>Navigate to type hierarchy ⌃H</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://medium.com/@andrey_cheptsov/golands-take-on-go-development-7d2611b14b99" target="_blank" rel="noopener">https://medium.com/@andrey_cheptsov/golands-take-on-go-development-7d2611b14b99</a><br><a href="https://www.jetbrains.com/help/go/discover-goland.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/go/discover-goland.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;implement-interface&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#implement-interface&quot;&gt;&lt;/a&gt; Implement Interface&lt;/h2&gt;
&lt;p&gt;Implement Interface i
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[73]-context详解</title>
    <link href="https://dreamerjonson.com/2019/05/09/golang-73-context/"/>
    <id>https://dreamerjonson.com/2019/05/09/golang-73-context/</id>
    <published>2019-05-09T09:12:56.000Z</published>
    <updated>2019-05-11T03:25:56.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>golang在1.6.2的时候还没有自己的context，<a href="http://xn--1-xh0b.xn--7golang-g43kv55hkjnx5lcp6avrl.org/x/net/context%E5%8C%85%E8%A2%AB%E5%8A%A0%E5%85%A5%E5%88%B0%E4%BA%86%E5%AE%98%E6%96%B9%E7%9A%84%E5%BA%93%E4%B8%AD%E3%80%82golang" target="_blank" rel="noopener">在1.7的版本中就把golang.org/x/net/context包被加入到了官方的库中。golang</a> 的 Context包，是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。<br>比如有一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。这样的话， 我们就可以通过Context，来跟踪这些goroutine，并且通过Context来控制他们的目的，这就是Go语言为我们提供的Context，中文可以称之为“上下文”。<br>另外一个实际例子是，在Go服务器程序中，每个请求都会有一个goroutine去处理。然而，处理程序往往还需要创建额外的goroutine去访问后端资源，比如数据库、RPC服务等。由于这些goroutine都是在处理同一个请求，所以它们往往需要访问一些共享的资源，比如用户身份信息、认证token、请求截止时间等。而且如果请求超时或者被取消后，所有的goroutine都应该马上退出并且释放相关的资源。这种情况也需要用Context来为我们取消掉所有goroutine<br>如果要使用可以通过 go get <a href="http://golang.org/x/net/context" target="_blank" rel="noopener">golang.org/x/net/context</a> 命令获取这个包。</p><h2 id="context-定义"><a class="markdownIt-Anchor" href="#context-定义"></a> Context 定义</h2><p>ontext的主要数据结构是一种嵌套的结构或者说是单向的继承关系的结构，比如最初的context是一个小盒子，里面装了一些数据，之后从这个context继承下来的children就像在原本的context中又套上了一个盒子，然后里面装着一些自己的数据。或者说context是一种分层的结构，根据使用场景的不同，每一层context都具备有一些不同的特性，这种层级式的组织也使得context易于扩展，职责清晰。<br>context 包的核心是 struct Context，声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Err() error</span><br><span class="line"></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Context是一个interface，在golang里面，interface是一个使用非常广泛的结构，它可以接纳任何类型。Context定义很简单，一共4个方法，我们需要能够很好的理解这几个方法</p><p>Deadline方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</p><p>Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。</p><p>Err方法返回取消的错误原因，因为什么Context被取消。</p><p>Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。</p><h2 id="context-的实现方法"><a class="markdownIt-Anchor" href="#context-的实现方法"></a> Context 的实现方法</h2><p>Context 虽然是个接口，但是并不需要使用方实现，golang内置的context 包，已经帮我们实现了2个方法，一般在代码中，开始上下文的时候都是以这两个作为最顶层的parent context，然后再衍生出子context。这些 Context 对象形成一棵树：当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。两个实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line"></span><br><span class="line">todo = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是Background，主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。<br>一个是TODO，如果我们不知道该使用什么Context的时候，可以使用这个，但是实际应用中，暂时还没有使用过这个TODO。<br>他们两个本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="context-的-继承"><a class="markdownIt-Anchor" href="#context-的-继承"></a> Context 的 继承</h2><p>有了如上的根Context，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure><p>通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。<br>WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。<br>WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。<br>WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。<br>WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。<br>With 系列函数详解<br>WithCancel<br>context.WithCancel生成了一个withCancel的实例以及一个cancelFuc，这个函数就是用来关闭ctxWithCancel中的 Done channel 函数。<br>下面来分析下源码实现，首先看看初始化，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func newCancelCtx(parent Context) cancelCtx &#123;</span><br><span class="line">return cancelCtx&#123;</span><br><span class="line">Context: parent,</span><br><span class="line">done:    make(chan struct&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line">return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newCancelCtx返回一个初始化的cancelCtx，cancelCtx结构体继承了Context，实现了canceler方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*cancelCtx 和 *timerCtx 都实现了canceler接口，实现该接口的类型都可以被直接canceled</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed by the first cancel call.</span></span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">bool</span> <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error             <span class="comment">// 当其被cancel时将会把err设置为非nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> c.done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithCancel"</span>, c.Context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心是关闭c.done</span></span><br><span class="line"><span class="comment">//同时会设置c.err = err, c.children = nil</span></span><br><span class="line"><span class="comment">//依次遍历c.children，每个child分别cancel</span></span><br><span class="line"><span class="comment">//如果设置了removeFromParent，则将c从其parent的children中删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="built_in">close</span>(c.done)</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c) <span class="comment">// 从此处可以看到 cancelCtx的Context项是一个类似于parent的概念</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，所有的children都存在一个map中；Done方法会返回其中的done channel， 而另外的cancel方法会关闭Done channel并且逐层向下遍历，关闭children的channel，并且将当前canceler从parent中移除。<br>WithCancel初始化一个cancelCtx的同时，还执行了propagateCancel方法，最后返回一个cancel function。<br>propagateCancel 方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propagateCancel 的含义就是传递cancel，从当前传入的parent开始（包括该parent），向上查找最近的一个可以被cancel的parent， 如果找到的parent已经被cancel，则将方才传入的child树给cancel掉，否则，将child节点直接连接为找到的parent的children中（Context字段不变，即向上的父亲指针不变，但是向下的孩子指针变直接了）； 如果没有找到最近的可以被cancel的parent，即其上都不可被cancel，则启动一个goroutine等待传入的parent终止，则cancel传入的child树，或者等待传入的child终结。<br>WithDeadLine<br>在withCancel的基础上进行的扩展，如果时间到了之后就进行cancel的操作，具体的操作流程基本上与withCancel一致，只不过控制cancel函数调用的时机是有一个timeout的channel所控制的。</p><h2 id="context-使用原则-和-技巧"><a class="markdownIt-Anchor" href="#context-使用原则-和-技巧"></a> Context 使用原则 和 技巧</h2><p>不要把Context放在结构体中，要以参数的方式传递，parent Context一般为Background<br>应该要把Context作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名建议都统一，如ctx。<br>给一个函数方法传递Context的时候，不要传递nil，否则在tarce追踪的时候，就会断了连接<br>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递<br>Context是线程安全的，可以放心的在多个goroutine中传递<br>可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p><h2 id="context的常用方法实例"><a class="markdownIt-Anchor" href="#context的常用方法实例"></a> Context的常用方法实例</h2><p>调用Context Done方法取消</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, err := DoSomething(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> out &lt;- v:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、通过 context.WithValue 来传值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">valueCtx := context.WithValue(ctx, key, <span class="string">"add value"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//get value</span></span><br><span class="line">fmt.Println(ctx.Value(key), <span class="string">"is cancel"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//get value</span></span><br><span class="line">fmt.Println(ctx.Value(key), <span class="string">"int goroutine"</span>)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、超时取消 context.WithTimeout</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/net/context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"Doing some work "</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// we received the signal of cancelation in this channel</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">"Cancel the context "</span>, i)</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">4</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Hey, I'm going to do some work"</span>)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> work(ctx)</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Finished. I'm going home"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、截止时间 取消 context.WithDeadline</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := time.Now().Add(<span class="number">1</span> * time.Second)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Even though ctx will be expired, it is good practice to call its</span></span><br><span class="line"><span class="comment">// cancelation function in any case. Failure to do so may keep the</span></span><br><span class="line"><span class="comment">// context and its parent alive longer than necessary.</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"oversleep"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">go watch(ctx,&quot;【监控1】&quot;)</span><br><span class="line">go watch(ctx,&quot;【监控2】&quot;)</span><br><span class="line">go watch(ctx,&quot;【监控3】&quot;)</span><br><span class="line"></span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">fmt.Println(&quot;可以了，通知监控停止&quot;)</span><br><span class="line">cancel()</span><br><span class="line">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span><br><span class="line">time.Sleep(5 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func watch(ctx context.Context, name string) &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">fmt.Println(name,&quot;监控退出，停止了...&quot;)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">fmt.Println(name,&quot;goroutine监控中...&quot;)</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;golang在1.6.2的时候还没有自己的context，&lt;a href=&quot;http://xn--1-xh0b.xn--7golang-g43k
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[72]-理解Go标准库中的atomic.Value类型</title>
    <link href="https://dreamerjonson.com/2019/05/09/golang-72-atomic-Value/"/>
    <id>https://dreamerjonson.com/2019/05/09/golang-72-atomic-Value/</id>
    <published>2019-05-09T05:49:43.000Z</published>
    <updated>2019-05-09T06:12:12.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在 Go 语言标准库中, <font color="#FF0000">sync/atomic</font>包将底层硬件提供的原子操作封装成了 Go 的函数。但这些操作只支持几种基本数据类型，因此为了扩大原子操作的适用范围，Go 语言在 1.4 版本的时候向sync/atomic包中添加了一个新的类型Value。此类型的值相当于一个容器，可以被用来“原子地”存储（Store）和加载（Load）任意类型的值。</p><h2 id="历史起源"><a class="markdownIt-Anchor" href="#历史起源"></a> 历史起源</h2><p>我在golang-dev邮件列表中翻到了14年的这段讨论，有人报告了encoding/gob包在多核机器上（80-core）上的性能问题，认为encoding/gob之所以不能完全利用到多核的特性是因为它里面使用了大量的互斥锁（mutex），如果把这些互斥锁换成用atomic.LoadPointer/StorePointer来做并发控制，那性能将能提升20倍。</p><p>针对这个问题，有人提议在已有的atomic包的基础上封装出一个atomic.Value类型，这样用户就可以在不依赖 Go 内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。所以我们现在看到的atomic包中除了atomic.Value外，其余都是早期由汇编写成的，并且atomic.Value类型的底层实现也是建立在已有的atomic包的基础上。</p><p>那为什么在上面的场景中，atomic会比mutex性能好很多呢？作者 Dmitry Vyukov 总结了这两者的一个区别：</p><p>Mutexes do no scale. Atomic loads do.</p><p>Mutex由操作系统实现，而atomic包中的原子操作则由底层硬件直接提供支持。在 CPU 实现的指令集里，有一些指令被封装进了atomic包，这些指令在执行的过程中是不允许中断（interrupt）的，因此原子操作可以在lock-free的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。</p><p>好了，说了这么多的原子操作，我们先来看看什么样的操作能被叫做原子操作 。</p><p>一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity） 。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。而在现实世界中，CPU 不可能不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣称他们拥有了”不可分割”的原子性。</p><p>有些朋友可能不知道，在 Go（甚至是大部分语言）中，一条普通的赋值语句其实不是一个原子操作。例如，在32位机器上写int64类型的变量有中间状态，它会被拆成两次写操作（MOV）——写低 32 位和写高 32 位，如下图所示：<br>如果一个线程刚写完低32位，还没来得及写高32位时，另一个线程读取了这个变量，那它得到的就是一个毫无逻辑的中间变量，这很有可能使我们的程序出现诡异的 Bug。</p><p>这还只是一个基础类型，如果我们对一个结构体进行赋值，那它出现并发问题的概率就更高了。很可能写线程刚写完一小半的字段，读线程就来读取这个变量，那么就只能读到仅修改了一部分的值。这显然破坏了变量的完整性，读出来的值也是完全错误的。</p><p>面对这种多线程下变量的读写问题，我们的主角——atomic.Value登场了，它使得我们可以不依赖于不保证兼容性的unsafe.Pointer类型，同时又能将任意数据类型的读写操作封装成原子性操作（让中间状态对外不可见）。</p><h2 id="使用姿势"><a class="markdownIt-Anchor" href="#使用姿势"></a> 使用姿势</h2><p>atomic.Value类型对外暴露的方法就两个：</p><p>v.Store© - 写操作，将原始的变量c存放到一个atomic.Value类型的v里。<br>c = v.Load() - 读操作，从线程安全的v中读取上一步存放的内容。<br>简洁的接口使得它的使用也很简单，只需将需要作并发保护的变量读取和赋值操作用Load()和Store()代替就行了。</p><p>下面是一个常见的使用场景。应用程序定期的从外界获取最新的配置信息，然后更改自己内存中维护的配置变量。工作线程根据最新的配置来处理请求。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"sync/atomic"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从数据库或者文件系统中读取配置信息，然后以map的形式存放在内存里</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requests</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将从外界中接受到的请求放入到channel里</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// config变量用来存放该服务的配置信息</span></span><br><span class="line">  <span class="keyword">var</span> config atomic.Value</span><br><span class="line">  <span class="comment">// 初始化时从别的地方加载配置文件，并存到config变量里</span></span><br><span class="line">  config.Store(loadConfig())</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 每10秒钟定时的拉取最新的配置信息，并且更新到config变量里</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">      <span class="comment">// 对应于赋值操作 config = loadConfig()</span></span><br><span class="line">      config.Store(loadConfig())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// 创建工作线程，每个工作线程都会根据它所读取到的最新的配置信息来处理请求</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> r := <span class="keyword">range</span> requests() &#123;</span><br><span class="line">        <span class="comment">// 对应于取值操作 c := config</span></span><br><span class="line">        <span class="comment">// 由于Load()返回的是一个interface&#123;&#125;类型，所以我们要先强制转换一下</span></span><br><span class="line">        c := config.Load().(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">        <span class="comment">// 这里是根据配置信息处理请求的逻辑...</span></span><br><span class="line">        _, _ = r, c</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><p>atomic.Value被设计用来存储任意类型的数据，所以它内部的字段是一个interface{}类型，非常的简单粗暴。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">  v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了Value外，这个文件里还定义了一个ifaceWords类型，这其实是一个空interface (interface{}）的内部表示格式（参见runtime/runtime2.go中eface的定义）。它的作用是将interface{}类型分解，得到其中的两个字段。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ifaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  unsafe.Pointer</span><br><span class="line">  data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写入store操作"><a class="markdownIt-Anchor" href="#写入store操作"></a> 写入（Store）操作</h2><p>在介绍写入之前，我们先来看一下 Go 语言内部的unsafe.Pointer类型。</p><p>unsafe.Pointer<br>出于安全考虑，Go 语言并不支持直接操作内存，但它的标准库中又提供一种不安全（不保证向后兼容性） 的指针类型unsafe.Pointer，让程序可以灵活的读取/操作内存。</p><p>unsafe.Pointer的特别之处在于，它可以绕过 Go 语言类型系统的检查，与任意的指针类型互相转换。也就是说，如果两种类型具有相同的内存结构，我们可以将unsafe.Pointer当做桥梁，让这两种类型的指针相互转换，从而实现同一份内存拥有两种不同的解读方式。</p><p>比如说，[]byte和string其实内部的存储结构都是一样的，但 Go 语言的类型系统禁止他俩互换。如果借助unsafe.Pointer，我们就可以实现在零拷贝的情况下，将[]byte数组直接转换成string类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bytes := []<span class="keyword">byte</span>&#123;<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>&#125;</span><br><span class="line"></span><br><span class="line">p := unsafe.Pointer(&amp;bytes) <span class="comment">//强制转换成unsafe.Pointer，编译器不会报错</span></span><br><span class="line">str := *(*<span class="keyword">string</span>)(p) <span class="comment">//然后强制转换成string类型的指针，再将这个指针的值当做string类型取出来</span></span><br><span class="line">fmt.Println(str) <span class="comment">//输出 "hello"</span></span><br></pre></td></tr></table></figure><p>知道了unsafe.Pointer的作用，我们可以直接来看代码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Store</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"sync/atomic: store of nil value into Value"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  vp := (*ifaceWords)(unsafe.Pointer(v))  <span class="comment">// Old value</span></span><br><span class="line">  xp := (*ifaceWords)(unsafe.Pointer(&amp;x)) <span class="comment">// New value</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">    <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to start first store.</span></span><br><span class="line">      <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">      <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">      <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">      runtime_procPin()</span><br><span class="line">      <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(^<span class="keyword">uintptr</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">        runtime_procUnpin()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Complete first store.</span></span><br><span class="line">      StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">      StorePointer(&amp;vp.typ, xp.typ)</span><br><span class="line">      runtime_procUnpin()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(typ) == ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">      <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">      <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">    <span class="keyword">if</span> typ != xp.typ &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"sync/atomic: store of inconsistently typed value into Value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概的逻辑：</p><p>第5~6行 - 通过unsafe.Pointer将现有的和要写入的值分别转成ifaceWords类型，这样我们下一步就可以得到这两个interface{}的原始类型（typ）和真正的值（data）。<br>从第7行开始就是一个无限 for 循环。配合CompareAndSwap食用，可以达到乐观锁的功效。<br>第8行，我们可以通过LoadPointer这个原子操作拿到当前Value中存储的类型。下面根据这个类型的不同，分3种情况处理。<br>第一次写入（第9~24行） - 一个Value实例被初始化后，它的typ字段会被设置为指针的零值 nil，所以第9行先判断如果typ是 nil 那就证明这个Value还未被写入过数据。那之后就是一段初始写入的操作：<br>runtime_procPin()这是runtime中的一段函数，具体的功能我不是特别清楚，也没有找到相关的文档。这里猜测一下，一方面它禁止了调度器对当前 goroutine 的抢占（preemption），使得它在执行当前逻辑的时候不被打断，以便可以尽快地完成工作，因为别人一直在等待它。另一方面，在禁止抢占期间，GC 线程也无法被启用，这样可以防止 GC 线程看到一个莫名其妙的指向^uintptr(0)的类型（这是赋值过程中的中间状态）。<br>使用CAS操作，先尝试将typ设置为^uintptr(0)这个中间状态。如果失败，则证明已经有别的线程抢先完成了赋值操作，那它就解除抢占锁，然后重新回到 for 循环第一步。<br>如果设置成功，那证明当前线程抢到了这个”乐观锁”，它可以安全的把v设为传入的新值了（19~23行）。注意，这里是先写data字段，然后再写typ字段。因为我们是以typ字段的值作为写入完成与否的判断依据的。<br>第一次写入还未完成（第25~30行）- 如果看到typ字段还是^uintptr(0)这个中间类型，证明刚刚的第一次写入还没有完成，所以它会继续循环，”忙等”到第一次写入完成。<br>第一次写入已完成（第31行及之后） - 首先检查上一次写入的类型与这一次要写入的类型是否一致，如果不一致则抛出异常。反之，则直接把这一次要写入的值写入到data字段。</p><embed id="embed" src="atomic-value.svg" type="image/svg+xml"><h2 id="读取load操作"><a class="markdownIt-Anchor" href="#读取load操作"></a> 读取（Load）操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Load</span><span class="params">()</span> <span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  vp := (*ifaceWords)(unsafe.Pointer(v))</span><br><span class="line">  typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">  <span class="keyword">if</span> typ == <span class="literal">nil</span> || <span class="keyword">uintptr</span>(typ) == ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// First store not yet completed.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  data := LoadPointer(&amp;vp.data)</span><br><span class="line">  xp := (*ifaceWords)(unsafe.Pointer(&amp;x))</span><br><span class="line">  xp.typ = typ</span><br><span class="line">  xp.data = data</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取相对就简单很多了，它有两个分支：</p><p>如果当前的typ是 nil 或者^uintptr(0)，那就证明第一次写入还没有开始，或者还没完成，那就直接返回 nil （不对外暴露中间状态）。<br>否则，根据当前看到的typ和data构造出一个新的interface{}返回出去。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文从邮件列表中的一段讨论开始，介绍了atomic.Value的被提出来的历史缘由。然后由浅入深的介绍了它的使用姿势，以及内部实现。让大家不仅知其然，还能知其所以然。</p><p>另外，再强调一遍，原子操作由底层硬件支持，而锁则由操作系统提供的 API 实现。若实现相同的功能，前者通常会更有效率，并且更能利用计算机多核的优势。所以，以后当我们想并发安全的更新一些变量的时候，我们应该优先选择用atomic.Value来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;在 Go 语言标准库中, &lt;font color=&quot;#FF0000&quot;&gt;sync/atomic&lt;/font&gt;包将底层硬件提供的原子操作封装成了 G
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac远程windwos</title>
    <link href="https://dreamerjonson.com/2019/05/02/windwos%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/"/>
    <id>https://dreamerjonson.com/2019/05/02/windwos远程登陆/</id>
    <published>2019-05-02T13:47:12.000Z</published>
    <updated>2019-05-02T13:48:07.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windwos设置"><a class="markdownIt-Anchor" href="#windwos设置"></a> windwos设置</h2><p>windows远程登时，如果同一个用户名远程登录用户名或密码不正确，但是直接在机器上却登陆正常。<br>有可能是用户名错误了，有可能是密码错误。<br>当用户名和你的全称不一样时，就很容易出现这种情况。<br>解决方法：<br>直接在命令行输入lusrmgr.msc或者右键点击我的电脑选择管理,选择本地用户和组.右键点击你的用户名，选择修改密码。或者尝试一下使用户名与全称一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;windwos设置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windwos设置&quot;&gt;&lt;/a&gt; windwos设置&lt;/h2&gt;
&lt;p&gt;windows远程登时，如果同一个用户名远程登录用户名或密码不正确，但是直接在机器上却登陆正常。&lt;br
      
    
    </summary>
    
      <category term="智能合约 solidity语法" scheme="https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="mac环境配置" scheme="https://dreamerjonson.com/tags/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>MAC环境配置</title>
    <link href="https://dreamerjonson.com/2019/04/25/tmux/"/>
    <id>https://dreamerjonson.com/2019/04/25/tmux/</id>
    <published>2019-04-25T05:44:19.000Z</published>
    <updated>2019-04-29T13:21:39.924Z</updated>
    
    <content type="html"><![CDATA[<p>注意：本文内容适用于 Tmux 2.3 及以上的版本，但是绝大部分的特性低版本也都适用，鼠标支持、VI 模式、插件管理在低版本可能会与本文不兼容。</p><h2 id="tmux-快捷键-速查表"><a class="markdownIt-Anchor" href="#tmux-快捷键-速查表"></a> Tmux 快捷键 &amp; 速查表</h2><p>启动新会话：</p><pre><code>tmux [new -s 会话名 -n 窗口名]</code></pre><p>恢复会话：</p><pre><code>tmux at [-t 会话名]</code></pre><p>列出所有会话：</p><pre><code>tmux ls</code></pre><p><a name="killSessions"></a>关闭会话：</p><pre><code>tmux kill-session -t 会话名</code></pre><p><a name="killAllSessions"></a>关闭所有会话：</p><pre><code>tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill</code></pre><h3 id="在-tmux-中按下-tmux-前缀-ctrlb然后"><a class="markdownIt-Anchor" href="#在-tmux-中按下-tmux-前缀-ctrlb然后"></a> 在 Tmux 中，按下 Tmux 前缀 <code>ctrl+b</code>，然后：</h3><h3 id="会话"><a class="markdownIt-Anchor" href="#会话"></a> 会话</h3><pre><code>:new&lt;回车&gt;  启动新会话s           列出所有会话$           重命名当前会话</code></pre><h3 id="a-namewindowstabsa窗口-标签页"><a class="markdownIt-Anchor" href="#a-namewindowstabsa窗口-标签页"></a> <a name="WindowsTabs"></a>窗口 (标签页)</h3><pre><code>c  创建新窗口w  列出所有窗口n  后一个窗口p  前一个窗口f  查找窗口,  重命名当前窗口&amp;  关闭当前窗口</code></pre><h2 id="调整窗口排序"><a class="markdownIt-Anchor" href="#调整窗口排序"></a> 调整窗口排序</h2><pre><code>swap-window -s 3 -t 1  交换 3 号和 1 号窗口swap-window -t 1       交换当前和 1 号窗口move-window -t 1       移动当前窗口到 1 号</code></pre><h3 id="a-namepanessplitsa窗格分割窗口"><a class="markdownIt-Anchor" href="#a-namepanessplitsa窗格分割窗口"></a> <a name="PanesSplits"></a>窗格（分割窗口）</h3><pre><code>%  垂直分割&quot;  水平分割o  交换窗格x  关闭窗格⍽  左边这个符号代表空格键 - 切换布局q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格{ 与上一个窗格交换位置} 与下一个窗格交换位置z 切换窗格最大化/最小化</code></pre><h3 id="a-namesyncpanesa同步窗格"><a class="markdownIt-Anchor" href="#a-namesyncpanesa同步窗格"></a> <a name="syncPanes"></a>同步窗格</h3><p>这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setw synchronize-panes</span><br></pre></td></tr></table></figure><p>你可以指定开或关，否则重复执行命令会在两者间切换。<br>这个选项值针对某个窗口有效，不会影响别的会话和窗口。<br>完事儿之后再次执行命令来关闭。<a href="http://blog.sanctum.geek.nz/sync-tmux-panes/" target="_blank" rel="noopener">帮助</a></p><h3 id="调整窗格尺寸"><a class="markdownIt-Anchor" href="#调整窗格尺寸"></a> 调整窗格尺寸</h3><p>如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：</p><pre><code>PREFIX : resize-pane -D          当前窗格向下扩大 1 格PREFIX : resize-pane -U          当前窗格向上扩大 1 格PREFIX : resize-pane -L          当前窗格向左扩大 1 格PREFIX : resize-pane -R          当前窗格向右扩大 1 格PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格</code></pre><h3 id="文本复制模式"><a class="markdownIt-Anchor" href="#文本复制模式"></a> 文本复制模式：</h3><p>按下 <code>PREFIX-[</code> 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：</p><pre><code>setw -g mode-keys vi</code></pre><p>启用这条配置后，就可以使用 h、j、k、l 来移动光标了。</p><p>想要退出文本复制模式的话，按下回车键就可以了。然后按下 <code>PREFIX-]</code> 粘贴刚才复制的文本。</p><p>一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p><p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。</p><pre><code>vi             emacs        功能^              M-m          反缩进Escape         C-g          清除选定内容Enter          M-w          复制选定内容j              Down         光标下移h              Left         光标左移l              Right        光标右移L                           光标移到尾行M              M-r          光标移到中间行H              M-R          光标移到首行k              Up           光标上移d              C-u          删除整行D              C-k          删除到行末$              C-e          移到行尾:              g            前往指定行C-d            M-Down       向下滚动半屏C-u            M-Up         向上滚动半屏C-f            Page down    下一页w              M-f          下一个词p              C-y          粘贴C-b            Page up      上一页b              M-b          上一个词q              Escape       退出C-Down or J    C-Down       向下翻C-Up or K      C-Up         向下翻n              n            继续搜索?              C-r          向前搜索/              C-s          向后搜索0              C-a          移到行首Space          C-Space      开始选中               C-t          字符调序</code></pre><h3 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项：</h3><pre><code>d  退出 tmux（tmux 仍在后台运行）t  窗口中央显示一个数字时钟?  列出所有快捷键:  命令提示符</code></pre><h3 id="配置选项"><a class="markdownIt-Anchor" href="#配置选项"></a> 配置选项：</h3><pre><code># 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page)* set -g mouse on# 设置默认终端模式为 256colorset -g default-terminal &quot;screen-256color&quot;# 启用活动警告setw -g monitor-activity onset -g visual-activity on# 居中窗口列表set -g status-justify centre# 最大化/恢复窗格unbind Up bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmpunbind Downbind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp</code></pre><h3 id="参考配置文件~tmuxconf"><a class="markdownIt-Anchor" href="#参考配置文件~tmuxconf"></a> 参考配置文件（~/.tmux.conf）：</h3><p>下面这份配置是我使用 Tmux 几年来逐渐精简后的配置，请自取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Tmux 基本配置 - 要求 Tmux &gt;= 2.3</span></span><br><span class="line"><span class="comment"># 如果不想使用插件，只需要将此节的内容写入 ~/.tmux.conf 即可</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近</span></span><br><span class="line"><span class="built_in">set</span> -g prefix C-z</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g base-index         1     <span class="comment"># 窗口编号从 1 开始计数</span></span><br><span class="line"><span class="built_in">set</span> -g display-panes-time 10000 <span class="comment"># PREFIX-Q 显示编号的驻留时长，单位 ms</span></span><br><span class="line"><span class="built_in">set</span> -g mouse              on    <span class="comment"># 开启鼠标</span></span><br><span class="line"><span class="built_in">set</span> -g pane-base-index    1     <span class="comment"># 窗格编号从 1 开始计数</span></span><br><span class="line"><span class="built_in">set</span> -g renumber-windows   on    <span class="comment"># 关掉某个窗口后，编号重排</span></span><br><span class="line"></span><br><span class="line">setw -g allow-rename      off   <span class="comment"># 禁止活动进程修改窗口名</span></span><br><span class="line">setw -g automatic-rename  off   <span class="comment"># 禁止自动命名新窗口</span></span><br><span class="line">setw -g mode-keys         vi    <span class="comment"># 进入复制模式的时候使用 vi 键位（默认是 EMACS）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 使用插件 - via tpm</span></span><br><span class="line"><span class="comment">#   1. 执行 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</span></span><br><span class="line"><span class="comment">#   2. 执行 bash ~/.tmux/plugins/tpm/bin/install_plugins</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">setenv -g TMUX_PLUGIN_MANAGER_PATH <span class="string">'~/.tmux/plugins'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐的插件（请去每个插件的仓库下读一读使用教程）</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'seebi/tmux-colors-solarized'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-pain-control'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-prefix-highlight'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-resurrect'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-sensible'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-yank'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tpm'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux-resurrect</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-dir <span class="string">'~/.tmux/resurrect'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux-prefix-highlight</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">'#&#123;prefix_highlight&#125; #H | %a %Y-%m-%d %H:%M'</span></span><br><span class="line"><span class="built_in">set</span> -g @prefix_highlight_show_copy_mode <span class="string">'on'</span></span><br><span class="line"><span class="built_in">set</span> -g @prefix_highlight_copy_mode_attr <span class="string">'fg=white,bg=blue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 TPM 插件管理器 (放在配置文件的最后)</span></span><br><span class="line">run <span class="string">'~/.tmux/plugins/tpm/tpm'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 结束</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="fzf"><a class="markdownIt-Anchor" href="#fzf"></a> fzf</h2><p>官方文档给的基本操作是 cd<code>**</code>+Tab生成列表+Enter生成命令+Enter执行 快捷键可以把4步变成两步 还是很Nice<br>ctrl+R<br>ctrl+T</p><p>特别介绍一下Preview 功能</p><p>我们知道在Unix环境下 我们要看文件的时候 必须一个个打开 当文件数量较大的场景</p><p>比如说 我们调了10个参数 做了20组实验 每组实验拿到30轮结果 这时候 一个个vim开 怕不是要吐了 这时候你是不是开始怀念有GUI的世界</p><p>当然 你可以写个bash脚本 把所有的文件合到一个文件 然后 只看一个file就行了</p><p>fzf给出了另外一个炫酷的解决方案</p><h1 id="set-alias"><a class="markdownIt-Anchor" href="#set-alias"></a> set alias</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.zshrc</span><br><span class="line">alias pp=&apos;fzf --preview &apos;&quot;&apos;&quot;&apos;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || rougify &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&apos;&quot;&apos;&quot;</span><br><span class="line">alias oo=&apos;fzf --preview &apos;&quot;&apos;&quot;&apos;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || rougify &#123;&#125; || tac &#123;&#125;) 2&gt; /dev/null | head -500&apos;&quot;&apos;&quot;  # flashback</span><br><span class="line">$ source ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="iterm2"><a class="markdownIt-Anchor" href="#iterm2"></a> ITerm2</h2><p>可定制化Hotkey, 一键召出iTerm2 (不再需要⌘+Tab 或者 通过spotlight切换)<br>快捷的组合键<br>⌘+Shift+E 召唤时间线<br>⌘+Option+b 时光机<br>⌘+T 新Tab<br>⌘+D 水平分屏<br>⌘+← 切换Tab / ⌘+shift+← 切换分屏<br>关闭panel：⌘ + w</p><p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次还原</p><p>按下 Command + T 可以新建一个 Tab，每个标签页的后面都会标记一个序号，通过 Command + 序号 就可以在多个页面之间切换了，或者用 Command + [ 和 Command + ] 来切换到左侧或者右侧的标签页。</p><p>同一个 Tab 内，还可以切分出多个 Pane，有两种切分方式：</p><p>Command + D：水平切分，切分出一左一右两个 Pane<br>Command + Shift + D：垂直切分，切分出一上一下两个 Pane<br>通过 Command + Ctrl + 方向键 可以调整每个 Pane 的大小，通过 Command + Option + 方向键 可以切换 Pane。</p><h2 id="mac系统快捷键进阶"><a class="markdownIt-Anchor" href="#mac系统快捷键进阶"></a> MAC系统快捷键进阶</h2><p>除了 Command + C/V 这种入门必备的快捷键，还有一些系统级的常用快捷键是有必要掌握一下的。</p><p>光标移动<br>这里比较推荐使用 Emacs 系的快捷键而不是传统的 Command + ←/→/Delete之类的。因为后者并不通用，比如在终端中就无法使用，而 Emacs 系的快捷键则在几乎所有系统级别的输入框内都通用。</p><p>常见的几个行级别操作有：</p><p>Ctrl + A：移动到行首<br>Ctrl + E：移动到行尾<br>Ctrl + K：删除到行尾<br>Ctrl + N：移动到下一行<br>Ctrl + P：移动到上一行<br>前三个命令在终端中非常常用，能大幅度提高工作效率。后两个命令则在 Vim 系列中很常见，多用于上下切换列表中的选项。</p><p>几个比较常见的字母级别操作有：</p><p>Ctrl + F：向右（Forward）移动一个字母，等价于方向键 →<br>Ctrl + B：向左（Backward）移动一个字母，等价于方向键 ←<br>Ctrl + D：向右删除一个字母，等价于 → + Delete这个快捷键也很常用<br>Ctrl + H：向左删除一个字母，等价于 Delete<br>使用 Option 键<br>如果觉得按字母操作太过于细粒度，按行操作又太粗粒度，那么 Option 键绝对算得上神器，因为它可以按单词操作。</p><p>Option + ←：光标向左移动一个单词<br>Option + →：光标向右移动一个单词<br>Option + Delete：删除一个单词<br>使用 Shift 键<br>Shift 键类似于可视模式，比如在某个位置点击光标并按住 shift 键不松开，再去另一个位置点击一次，就可以选中两次点击位置之间的文本内容。</p><p>注意，shift 键可视模式还可以和 Option 键一起合用，感兴趣的读者可以自行尝试。</p><h2 id="max连接-visulbox中的ubuntu-使用ssh服务器"><a class="markdownIt-Anchor" href="#max连接-visulbox中的ubuntu-使用ssh服务器"></a> max连接 visulBOX中的Ubuntu   使用ssh服务器</h2><p>在ubuntu中使用桥接模式</p><p>步骤             命令                         说明<br>步骤1            sudo su             切换至root用户，ubuntu缺省下root用户有所限制，使用sudo su可以使用当前管理用户的密码切换至root用户，也可以在需要安装权限的命令前加sudo<br>步骤2            apt install openssh-server安装openssh-server<br>步骤3            ssh -V                 确认openssh-server版本<br>步骤4           /etc/init.d/ssh status确认openssh-server状态<br>步骤5            /etc/init.d/ssh restart重新启动 openssh-server</p><p>vim  /etc/ssh/sshd.config</p><p>permisionRootLogin YES<br>修改unixpassword</p><p>ifconfig获取ip<br>从终端使用ssh命令连接确认ssh -p 22 <a href="mailto:userkunyu@119.29.37.63" target="_blank" rel="noopener">userkunyu@119.29.37.63</a>  输入密码：</p><h2 id="virsualbox共享文件夹"><a class="markdownIt-Anchor" href="#virsualbox共享文件夹"></a> virsualBox共享文件夹</h2><p>共享文件夹为：go文件<br>sudo su<br>挂载：mount -t vboxsf go /mnt<br>软连接：ln -s   /mnt/go /home/jackson/go</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：本文内容适用于 Tmux 2.3 及以上的版本，但是绝大部分的特性低版本也都适用，鼠标支持、VI 模式、插件管理在低版本可能会与本文不兼容。&lt;/p&gt;
&lt;h2 id=&quot;tmux-快捷键-速查表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#t
      
    
    </summary>
    
      <category term="开发配置" scheme="https://dreamerjonson.com/categories/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="开发配置" scheme="https://dreamerjonson.com/tags/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>git操作github-gitlab</title>
    <link href="https://dreamerjonson.com/2019/04/02/connect-github-gitlab/"/>
    <id>https://dreamerjonson.com/2019/04/02/connect-github-gitlab/</id>
    <published>2019-04-02T07:43:32.000Z</published>
    <updated>2019-05-15T07:19:05.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="克隆"><a class="markdownIt-Anchor" href="#克隆"></a> 克隆</h2><p>有两种方式，一种是通过ssh,一种是通过http</p><p>使用ssh的方式需要在本机生成ssh文件，<br>参考资料：<a href="https://gitlab.followme.com/help/ssh/README#generating-a-new-ssh-key-pair" target="_blank" rel="noopener">https://gitlab.followme.com/help/ssh/README#generating-a-new-ssh-key-pair</a></p><h3 id="产生ssh"><a class="markdownIt-Anchor" href="#产生ssh"></a> 产生SSH</h3><p>To create a new SSH key pair:<br>Open a terminal on Linux or macOS, or Git Bash / WSL on Windows.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Generate a new ED25519 SSH key pair:</span><br><span class="line">ssh-keygen -t ed25519 -C &quot;email@example.com&quot;</span><br><span class="line"></span><br><span class="line">Or, if you want to use RSA:</span><br><span class="line">ssh-keygen -o -t rsa -b 4096 -C &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="adding-an-ssh-key-to-your-gitlab-account"><a class="markdownIt-Anchor" href="#adding-an-ssh-key-to-your-gitlab-account"></a> Adding an SSH key to your GitLab account</h3><p>Copy your public SSH key to the clipboard by using one of the commands below<br>depending on your Operating System:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">macOS:</span><br><span class="line">pbcopy &lt; ~/.ssh/id_ed25519.pub</span><br><span class="line"></span><br><span class="line">WSL / GNU/Linux (requires the xclip package):</span><br><span class="line">xclip -sel clip &lt; ~/.ssh/id_ed25519.pub</span><br><span class="line"></span><br><span class="line">Git Bash on Windows:</span><br><span class="line">cat ~/.ssh/id_ed25519.pub | clip</span><br></pre></td></tr></table></figure><h3 id="go-mod-中下载依赖包时可以使用"><a class="markdownIt-Anchor" href="#go-mod-中下载依赖包时可以使用"></a> go mod 中下载依赖包时，可以使用</h3><p>go build  .<br>但是下载有时候会出现问题，例如：<br>我运行go mod download 提示 fatal: could not read Username for ‘<a href="https://gitlab.XXX.com" target="_blank" rel="noopener">https://gitlab.XXX.com</a>’: terminal prompts disabled</p><p>这时，需要通过ssh的方式下载gitlab中的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure><p>添加：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;ssh://git@gitlab.XXX.com/&quot;]</span><br><span class="line">insteadOf = https://gitlab.XXX.com/</span><br></pre></td></tr></table></figure><h2 id="查看分支"><a class="markdownIt-Anchor" href="#查看分支"></a> 查看分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="将远程分支-dev-到本地dev-并切换到dev分支"><a class="markdownIt-Anchor" href="#将远程分支-dev-到本地dev-并切换到dev分支"></a> 将远程分支 dev 到本地dev 并切换到dev分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git fetch origin dev  存疑</span><br><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br><span class="line"></span><br><span class="line">git push -f origin dev 强制更新</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r .idea</span><br></pre></td></tr></table></figure><h2 id="添加远程"><a class="markdownIt-Anchor" href="#添加远程"></a> 添加远程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add camel-snipet git@gitlab.followme.com:camel/go-snipet.git</span><br><span class="line"></span><br><span class="line"> git remote -v</span><br><span class="line"></span><br><span class="line"> git push camel-snipet dev</span><br></pre></td></tr></table></figure><h2 id="回退"><a class="markdownIt-Anchor" href="#回退"></a> 回退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard a7e1d279</span><br></pre></td></tr></table></figure><h2 id="mac添加环境变量"><a class="markdownIt-Anchor" href="#mac添加环境变量"></a> mac添加环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">操作步骤:</span><br><span class="line">1、打开Terminal（终端）</span><br><span class="line">2、输入：vim ~/.bash_profile</span><br><span class="line">3、设置PATH：export PATH=/usr/local/mysql/bin:$PATH</span><br><span class="line">4、输入：:wq    //保存并退出vi</span><br><span class="line">5、修改立即生效：source ~/.bash_profile</span><br><span class="line">6、查看环境变量的值：echo $PATH</span><br></pre></td></tr></table></figure><p>go run main.go --registry=consul  --registry_address=“127.0.0.1:8500”</p><p>consul：<br>自动将服务添加到consul<br>UI ：<a href="http://localhost:8500" target="_blank" rel="noopener">http://localhost:8500</a></p><p>##gitlab Runner</p><p>To install GitLab Runner using Homebrew:</p><p>Install the GitLab Runner.</p><p>brew install gitlab-runner</p><p>Install the Runner as a service and start it.</p><p>brew services start gitlab-runner</p><p>Runner is installed and running.</p><p>gitlab-runner register<br>gitlab-runner stop<br>gitlab-runner register<br>gitlab-runner unregister --all-runners</p><p>./gitlab-runner run</p><h2 id="当远程分支有冲突强制"><a class="markdownIt-Anchor" href="#当远程分支有冲突强制"></a> 当远程分支有冲突，强制</h2><p>git fetch --all<br>git reset --hard origin/master</p><h2 id="merge"><a class="markdownIt-Anchor" href="#merge"></a> merge</h2><p>git merge -Xtheirs dev<br>git merge -Xours dev</p><h2 id="工作区回到最后一次提交的状态"><a class="markdownIt-Anchor" href="#工作区回到最后一次提交的状态"></a> 工作区回到最后一次提交的状态。</h2><p>git checkout .</p><p>git log --pretty=oneline</p><p>但最有意思的是 format，可以定制要显示的记录格式，这样的输出便于后期编程提取分析，像这样：</p><p>$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;<br>ca82a6d - Scott Chacon, 11 months ago : changed the version number<br>085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code<br>a11bef0 - Scott Chacon, 11 months ago : first commit</p><h2 id="makefile-代码片段"><a class="markdownIt-Anchor" href="#makefile-代码片段"></a> makefile 代码片段</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">proto:</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> api srv; <span class="keyword">do</span> \</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $<span class="variable">$d</span>/**/proto/*.proto; <span class="keyword">do</span> \</span><br><span class="line">protoc --proto_path=<span class="variable">$&#123;GOPATH&#125;</span>/src --micro_out=. --go_out=. $<span class="variable">$f</span>; \</span><br><span class="line"><span class="built_in">echo</span> compiled: $<span class="variable">$f</span>; \</span><br><span class="line"><span class="keyword">done</span> \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">lint:</span><br><span class="line">./bin/lint.sh</span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">./bin/build.sh</span><br><span class="line"></span><br><span class="line">data:</span><br><span class="line">go-bindata -o data/bindata.go -pkg data data/*.json</span><br><span class="line"></span><br><span class="line">run:</span><br><span class="line">docker-compose build</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;克隆&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#克隆&quot;&gt;&lt;/a&gt; 克隆&lt;/h2&gt;
&lt;p&gt;有两种方式，一种是通过ssh,一种是通过http&lt;/p&gt;
&lt;p&gt;使用ssh的方式需要在本机生成ssh文件，&lt;br&gt;
参考资料：&lt;a href=&quot;
      
    
    </summary>
    
      <category term="git" scheme="https://dreamerjonson.com/categories/git/"/>
    
      <category term="mac环境配置" scheme="https://dreamerjonson.com/categories/git/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="https://dreamerjonson.com/tags/git/"/>
    
      <category term="mac环境配置" scheme="https://dreamerjonson.com/tags/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>golang[71]-golang操作mysql数据库</title>
    <link href="https://dreamerjonson.com/2019/04/01/golang-71-sql/"/>
    <id>https://dreamerjonson.com/2019/04/01/golang-71-sql/</id>
    <published>2019-04-01T09:38:37.000Z</published>
    <updated>2019-04-28T02:47:05.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p><a href="https://dev.mysql.com/downloads" target="_blank" rel="noopener">https://dev.mysql.com/downloads</a></p><h2 id="installing-mysql-on-macos"><a class="markdownIt-Anchor" href="#installing-mysql-on-macos"></a> Installing MySQL on macOS</h2><p>推荐使用dmg文件安装<br><a href="https://dev.mysql.com/doc/refman/5.7/en/osx-installation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/osx-installation.html</a><br>安装完毕有默认密码</p><h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h2><p>PATH=&quot;$PATH&quot;:/usr/local/mysql/bin<br>sudo su<br>mysql -u root -p 123456</p><p>create database test;<br>use test;<br>create table user_info(id int(11),username varchar(20),create_time timestamp ,primary key(id));<br>INSERT INTO user_info(id,username) VALUES(5,“jonson”);<br>select * from user_info;</p><p>create table user_info(id int(11),username varchar(20),create_time timestamp ,primary key(id));</p><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(<span class="string">`INSERT user_info (id,username) values (?,?)`</span>)</span><br><span class="line">res, err := stmt.Exec(<span class="number">88</span>,<span class="string">"olaya"</span>)</span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line">fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(<span class="string">"delete from user_info where id=?"</span>)</span><br><span class="line"></span><br><span class="line">res, err := stmt.Exec(<span class="number">88</span>)</span><br><span class="line">id, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新"><a class="markdownIt-Anchor" href="#更新"></a> 更新</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(<span class="string">"update user_info set id=? where id=?"</span>)</span><br><span class="line"></span><br><span class="line">res, err := stmt.Exec(<span class="number">5</span>, <span class="number">99</span>)</span><br><span class="line">id, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := db.Query(<span class="string">"SELECT * FROM user_info"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> id <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> create_time <span class="keyword">string</span></span><br><span class="line">err = rows.Scan(&amp;id, &amp;username, &amp;create_time)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(id, username, create_time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for rows.Next() &#123;</span></span><br><span class="line"><span class="comment">//    var userId int</span></span><br><span class="line"><span class="comment">//    var userName string</span></span><br><span class="line"><span class="comment">//    var userAge int</span></span><br><span class="line"><span class="comment">//    var userSex int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    rows.Columns()</span></span><br><span class="line"><span class="comment">//    err = rows.Scan(&amp;userId, &amp;userName, &amp;userAge, &amp;userSex)</span></span><br><span class="line"><span class="comment">//    checkErr(err)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    fmt.Println(userId)</span></span><br><span class="line"><span class="comment">//    fmt.Println(userName)</span></span><br><span class="line"><span class="comment">//    fmt.Println(userAge)</span></span><br><span class="line"><span class="comment">//    fmt.Println(userSex)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>k8s</title>
    <link href="https://dreamerjonson.com/2019/03/14/k8s/"/>
    <id>https://dreamerjonson.com/2019/03/14/k8s/</id>
    <published>2019-03-14T03:29:49.000Z</published>
    <updated>2019-03-18T13:29:32.931Z</updated>
    
    <content type="html"><![CDATA[<p>mac平台</p><h2 id="安装brew"><a class="markdownIt-Anchor" href="#安装brew"></a> 安装brew</h2><p>。。。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kubectl</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install minikube</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ which minikube</span><br><span class="line">$ minikube start</span><br></pre></td></tr></table></figure><h2 id="错误提示"><a class="markdownIt-Anchor" href="#错误提示"></a> 错误提示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stderr: failed to pull image &quot;k8s.gcr.io/kube-apiserver:v1.13.4&quot;: output: Error response from daemon: Get https://k8s.gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br></pre></td></tr></table></figure><p>打印日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube logs</span><br></pre></td></tr></table></figure><h2 id="使用代理"><a class="markdownIt-Anchor" href="#使用代理"></a> 使用代理：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ minikube delete</span><br><span class="line">$ minikube start --docker-env HTTP_PROXY=http://10.0.2.2:1087 --docker-env HTTPS_PROXY=http://10.0.2.2:1087</span><br></pre></td></tr></table></figure><h2 id="代理参考资料"><a class="markdownIt-Anchor" href="#代理参考资料"></a> 代理参考资料</h2><p><a href="https://github.com/kubernetes/minikube/blob/master/docs/http_proxy.md" target="_blank" rel="noopener">https://github.com/kubernetes/minikube/blob/master/docs/http_proxy.md</a><br><a href="https://my.oschina.net/csq/blog/3014879" target="_blank" rel="noopener">https://my.oschina.net/csq/blog/3014879</a></p><h2 id="配置pod"><a class="markdownIt-Anchor" href="#配置pod"></a> 配置pod</h2><p>client-pod.yaml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">client-pod</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    component:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">client</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">stephengrider/multi-worker</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><h2 id="配置server"><a class="markdownIt-Anchor" href="#配置server"></a> 配置server</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">client-node-port</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">3050</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">31515</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    component:</span> <span class="string">web</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f client-pod.yaml</span><br><span class="line">$ kubectl apply -f client-node-port.yaml</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl get services</span><br></pre></td></tr></table></figure><p>修改client-pod.yaml中的images,重新执行配置文件即可更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f client-pod.yaml</span><br></pre></td></tr></table></figure><h2 id="获取ip"><a class="markdownIt-Anchor" href="#获取ip"></a> 获取ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ minikube ip</span><br></pre></td></tr></table></figure><h2 id="获取pod详细描述"><a class="markdownIt-Anchor" href="#获取pod详细描述"></a> 获取pod详细描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod client-pod</span><br></pre></td></tr></table></figure><h2 id="删除pod"><a class="markdownIt-Anchor" href="#删除pod"></a> 删除pod</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f client-pod.yaml</span><br></pre></td></tr></table></figure><h2 id="书写deployment"><a class="markdownIt-Anchor" href="#书写deployment"></a> 书写deployment</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: client-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      component: web</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        component: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: client</span><br><span class="line">          image: stephengrider/multi-client</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: 3000</span><br><span class="line">```         </span><br><span class="line"></span><br><span class="line">## 应用deployment</span><br></pre></td></tr></table></figure><p>$ kubectl apply -f client-deployment.yaml<br>$ kubectl get pods<br>$ kubectl get deployments<br>NAME                DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br>client-deployment   1         1         1            1           30s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果image有更新，可以采取下面的方式强制更新：</span><br></pre></td></tr></table></figure><p>docker  build -t stephengrider/multi-client:v5 .<br>docker push  stephengrider/multi-client:v5<br>$ kubectl set image deployment/client-deployment client=stephengrider/multi-client:v5</p><pre class="highlight"><code class="">## docker ps 得到k8s虚拟机的信息</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac平台&lt;/p&gt;
&lt;h2 id=&quot;安装brew&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装brew&quot;&gt;&lt;/a&gt; 安装brew&lt;/h2&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-数据结构[15]-归并排序</title>
    <link href="https://dreamerjonson.com/2019/03/11/go-struture-15-merge-sort/"/>
    <id>https://dreamerjonson.com/2019/03/11/go-struture-15-merge-sort/</id>
    <published>2019-03-11T14:01:51.000Z</published>
    <updated>2019-03-11T14:19:02.441Z</updated>
    
    <content type="html"><![CDATA[<style>pre,code {     font-family: "Source Code Pro", Consolas, Monaco, Menlo, Consolas, monospace !important; }</style><p>归并排序（Merge Sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>归并操作(Merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序 , 可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。</p><p>算法思路：<br>1、把 n 个记录看成 n 个长度为 l 的有序子表<br>2、进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表<br>3、重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</p><p>实例分析<br>以数组 array = [6, 5, 3, 1, 8, 7, 2, 4] 为例，首先将数组分为长度为 2 的子数组，并使每个子数组有序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[6, 5]  [3, 1]  [8, 7]  [2, 4]</span><br><span class="line">   ↓       ↓       ↓       ↓</span><br><span class="line">[5, 6]  [1, 3]  [7, 8]  [2, 4]</span><br></pre></td></tr></table></figure><p>然后再两两合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 3, 1]  [8, 7, 2, 4]</span><br><span class="line">      ↓             ↓</span><br><span class="line">[1, 3, 5, 6]  [2, 4, 7, 8]</span><br></pre></td></tr></table></figure><p>最后将两个子数组合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[6, 5, 3, 1, 8, 7, 2, 4]</span><br><span class="line">            ↓</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><p>排序过程动画演示如下：</p><img src="/2019/03/11/go-struture-15-merge-sort/merge.gif" title="compile">]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;
pre,code {
     font-family: &quot;Source Code Pro&quot;, Consolas, Monaco, Menlo, Consolas, monospace !important;
 }
&lt;/style&gt;
&lt;p&gt;归并排序（Merge S
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-数据结构[14]-希尔排序</title>
    <link href="https://dreamerjonson.com/2019/03/11/go-struture-14-shell-sort/"/>
    <id>https://dreamerjonson.com/2019/03/11/go-struture-14-shell-sort/</id>
    <published>2019-03-11T10:25:53.000Z</published>
    <updated>2019-03-11T14:19:14.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h2><p>希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布，是插入排序的一种更高效的改进版本。它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置；然后增量缩小；最后增量为 1 ，这样记录移动次数大大减少，提高了排序效率。希尔排序对增量序列的选择没有严格规定。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><p>1、插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率<br>2、但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位<br>算法思路：</p><p>先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序<br>然后取 d2(d2 &lt; d1)<br>重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。</p><h2 id="实例分析"><a class="markdownIt-Anchor" href="#实例分析"></a> 实例分析</h2><img src="/2019/03/11/go-struture-14-shell-sort/shell.png" title="compile"><h2 id="go语言实现"><a class="markdownIt-Anchor" href="#go语言实现"></a> go语言实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  _,data := <span class="keyword">range</span> arr&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>,data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr:= []int&#123;8, 5, 2, 6, 9, 3, 1, 4, 0, 7,6,3,10&#125;</span></span><br><span class="line">arr:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line">shellsort(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shellsort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">gap:=<span class="number">4</span></span><br><span class="line">length:= <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> gap &gt;<span class="number">0</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=gap;i&lt;length;i+=<span class="number">1</span>&#123;</span><br><span class="line">j:= i</span><br><span class="line">temp:= arr[i]</span><br><span class="line"><span class="keyword">for</span>;j&gt;<span class="number">0</span>;j-=gap&#123;</span><br><span class="line"><span class="keyword">if</span> j-gap&gt;=<span class="number">0</span> &amp;&amp;  arr[j] &lt; arr[j-gap]&#123;</span><br><span class="line">tmp:= arr[j]</span><br><span class="line">arr[j] = arr[j-gap]</span><br><span class="line">arr[j-gap] = tmp</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gap = gap/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javascript实现"><a class="markdownIt-Anchor" href="#javascript实现"></a> javascript实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = array[i];</span><br><span class="line">        array[i] = array[k];</span><br><span class="line">        array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> length = array.length,</span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; <span class="number">0</span> &lt; j; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j - gap] &gt; array[j]) &#123;</span><br><span class="line">                    swap(array, j - gap, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gap = <span class="built_in">Math</span>.floor(gap / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;希尔排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#希尔排序&quot;&gt;&lt;/a&gt; 希尔排序&lt;/h2&gt;
&lt;p&gt;希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布，是插入排序的一种更高效的改进版本。它的作
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-数据结构[13]-二分插入排序</title>
    <link href="https://dreamerjonson.com/2019/03/11/go-struture-13-binary-sort/"/>
    <id>https://dreamerjonson.com/2019/03/11/go-struture-13-binary-sort/</id>
    <published>2019-03-11T10:14:01.000Z</published>
    <updated>2019-03-18T13:30:01.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分插入排序-go实现"><a class="markdownIt-Anchor" href="#二分插入排序-go实现"></a> 二分插入排序 go实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  _,data := <span class="keyword">range</span> arr&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>,data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">arr:= []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>,<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>,<span class="number">8</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>,<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>,<span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="comment">//arr:=[]int&#123;1,3,2,4,9,2,6,5,4,8&#125;</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line">binarysort(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarysort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print(arr)</span></span><br><span class="line">length := <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span>;i&lt;length;i++&#123;</span><br><span class="line"></span><br><span class="line">tmp:= arr[i]</span><br><span class="line"> j:= i<span class="number">-1</span></span><br><span class="line"> <span class="keyword">if</span> arr[j] &gt; arr[i]&#123;</span><br><span class="line">  index:= binarysearch(arr,<span class="number">0</span>,i<span class="number">-1</span>,arr[i])</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> k:= i<span class="number">-1</span>;k&gt;=index;k--&#123;</span><br><span class="line">  arr[k+<span class="number">1</span>] =arr[k]</span><br><span class="line"> &#125;</span><br><span class="line"> arr[index] = tmp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarysearch</span><span class="params">(arr []<span class="keyword">int</span>, low <span class="keyword">int</span>, high <span class="keyword">int</span>, data <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt;=high&#123;</span><br><span class="line"></span><br><span class="line">mid:= low + (high-low)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data &gt; arr[mid]&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  mid+<span class="number">1</span>&lt; <span class="built_in">len</span>(arr) &amp;&amp; data &lt;=arr[mid+<span class="number">1</span>]&#123;</span><br><span class="line"><span class="keyword">return</span> mid+<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> mid == <span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javascript实现"><a class="markdownIt-Anchor" href="#javascript实现"></a> JavaScript实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort2(array) &#123;</span><br><span class="line">  function binarySearch(array, start, end, temp) &#123;</span><br><span class="line">    <span class="keyword">var</span> middle;</span><br><span class="line">    while (start &lt;= end) &#123;</span><br><span class="line">      middle = Math.floor((start + end) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (array[middle] &lt; temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= array[middle + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">return</span> middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          end = middle;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function binarySort(array) &#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length,</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        k,</span><br><span class="line">        temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">      temp = array[i];</span><br><span class="line">      <span class="keyword">if</span> (array[i - <span class="number">1</span>] &lt;= temp) &#123;</span><br><span class="line">        k = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        k = binarySearch(array, <span class="number">0</span>, i - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; k; j--) &#123;</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binarySort(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分插入排序-go实现&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#二分插入排序-go实现&quot;&gt;&lt;/a&gt; 二分插入排序 go实现&lt;/h2&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>kali-科学—上网</title>
    <link href="https://dreamerjonson.com/2019/03/10/kali-shadow/"/>
    <id>https://dreamerjonson.com/2019/03/10/kali-shadow/</id>
    <published>2019-03-10T13:19:38.000Z</published>
    <updated>2019-03-10T13:32:02.118Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">root@kali:# sudo rm /var/lib/dpkg/lock-frontend</span><br><span class="line">root@kali:# sudo apt-get install shadowsocks -y</span><br><span class="line">root@kali:/etc# sudo apt-get install privoxy</span><br><span class="line">root@kali:~# vim /etc/privoxy/config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置Privoxy, 打开 /etc/privoxy/config,</span><br><span class="line">注释掉</span><br><span class="line">listen-address  localhost:8118</span><br><span class="line">#listen-address  localhost:8118</span><br><span class="line">在最后一行后边加上</span><br><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br><span class="line">listen-address 127.0.0.1:8118</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@kali:/etc# cd shadowsocks/</span><br><span class="line">root@kali:/etc/shadowsocks# cp local.json US.json</span><br><span class="line"></span><br><span class="line">配置ss服务器地址、服务器端口、密码、ss监听端口</span><br><span class="line">root@kali:/etc/shadowsocks# vim US.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;&quot;,</span><br><span class="line">&quot;server_port&quot;:,</span><br><span class="line">&quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">&quot;local_port&quot;:9050,  </span><br><span class="line">&quot;password&quot;:&quot;&quot;,</span><br><span class="line">&quot;timeout&quot;:300,</span><br><span class="line">&quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">&quot;fast_open&quot;: false,</span><br><span class="line">&quot;workers&quot;: 1,</span><br><span class="line">&quot;prefer_ipv6&quot;: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开启</span><br><span class="line">root@kali:/etc/shadowsocks# systemctl start privoxy.service</span><br><span class="line">root@kali:/etc/shadowsocks# sslocal -c US.json</span><br></pre></td></tr></table></figure><h2 id="设置系统代理"><a class="markdownIt-Anchor" href="#设置系统代理"></a> 设置系统代理</h2><p>socket与配置&quot;local_port&quot;:9050,相同</p><img src="/2019/03/10/kali-shadow/shadow.png" title="compile">]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="kali" scheme="https://dreamerjonson.com/categories/kali/"/>
    
    
      <category term="kali" scheme="https://dreamerjonson.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>go-数据结构[12]-二分查找</title>
    <link href="https://dreamerjonson.com/2019/03/10/go-struture-12-binary-search/"/>
    <id>https://dreamerjonson.com/2019/03/10/go-struture-12-binary-search/</id>
    <published>2019-03-10T10:30:27.000Z</published>
    <updated>2019-03-11T10:28:17.806Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/10/go-struture-12-binary-search/bsearch.png" title="compile"><h2 id="go语言实现二分查找"><a class="markdownIt-Anchor" href="#go语言实现二分查找"></a> go语言实现二分查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">arr:= []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  index,data:= <span class="keyword">range</span> arr&#123;</span><br><span class="line">i:= binarySearch(arr,data)</span><br><span class="line">fmt.Printf(<span class="string">"实际序号：%d,找到序号为：%d\n"</span>,index,i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"-------------------------"</span>)</span><br><span class="line"><span class="keyword">for</span>  index,data:= <span class="keyword">range</span> arr&#123;</span><br><span class="line">i:= binarySearch2(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)<span class="number">-1</span>,data)</span><br><span class="line">fmt.Printf(<span class="string">"实际序号：%d,找到序号为：%d\n"</span>,index,i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">( arr []<span class="keyword">int</span>, data <span class="keyword">int</span> )</span> <span class="title">int</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">low:= <span class="number">0</span></span><br><span class="line">high:= <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt;= high&#123;</span><br><span class="line">mid:= low + (high-low)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data &gt; arr[mid]&#123;</span><br><span class="line">low= mid+<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> data &lt; arr[mid]&#123;</span><br><span class="line">high= mid - <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch2</span><span class="params">( arr []<span class="keyword">int</span>,low,high, data <span class="keyword">int</span> )</span> <span class="title">int</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ret:= <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> low &lt;= high&#123;</span><br><span class="line">mid := low + (high-low)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data &gt; arr[mid]&#123;</span><br><span class="line">ret = binarySearch2(arr,mid+<span class="number">1</span>,high,data)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> data &lt; arr[mid]&#123;</span><br><span class="line">ret = binarySearch2(arr,low,mid<span class="number">-1</span>,data)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2019/03/10/go-struture-12-binary-search/bsearch.png&quot; title=&quot;compile&quot;&gt;
&lt;h2 id=&quot;go语言实现二分查找&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go语
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-数据结构[11]-直接插入排序</title>
    <link href="https://dreamerjonson.com/2019/03/10/go-struture-11-Insertion-Sort/"/>
    <id>https://dreamerjonson.com/2019/03/10/go-struture-11-Insertion-Sort/</id>
    <published>2019-03-10T06:04:58.000Z</published>
    <updated>2019-03-10T09:48:53.868Z</updated>
    
    <content type="html"><![CDATA[<style>pre,code {     font-family: "Source Code Pro", Consolas, Monaco, Menlo, Consolas, monospace !important; }</style><h2 id="具体算法描述"><a class="markdownIt-Anchor" href="#具体算法描述"></a> 具体算法描述</h2><p>设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K3 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 Kn 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。</p><p>具体算法描述如下：</p><p>从第一个元素开始，该元素可以认为已经被排序<br>取出下一个元素，在已经排序的元素序列中从后向前扫描<br>如果该元素（已排序）大于新元素，将该元素移到下一位置<br>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置<br>将新元素插入到该位置后<br>重复步骤 2~5<br>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找排序。</p><p>二分查找法，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><h2 id="实例分析"><a class="markdownIt-Anchor" href="#实例分析"></a> 实例分析</h2><p>现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]，共有八个记录，排序过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[5]   6   3   1   8   7   2   4</span><br><span class="line">  ↑   │</span><br><span class="line">  └───┘</span><br><span class="line">[5, 6]   3   1   8   7   2   4</span><br><span class="line">↑        │</span><br><span class="line">└────────┘</span><br><span class="line">[3, 5, 6]  1   8   7   2   4</span><br><span class="line">↑          │</span><br><span class="line">└──────────┘</span><br><span class="line">[1, 3, 5, 6]  8   7   2   4</span><br><span class="line">           ↑  │</span><br><span class="line">           └──┘</span><br><span class="line">[1, 3, 5, 6, 8]  7   2   4</span><br><span class="line">            ↑    │</span><br><span class="line">            └────┘</span><br><span class="line">[1, 3, 5, 6, 7, 8]  2   4</span><br><span class="line">   ↑                │</span><br><span class="line">   └────────────────┘</span><br><span class="line">[1, 2, 3, 5, 6, 7, 8]  4</span><br><span class="line">         ↑             │</span><br><span class="line">         └─────────────┘</span><br><span class="line"></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure><h2 id="动画演示"><a class="markdownIt-Anchor" href="#动画演示"></a> 动画演示</h2><img src="/2019/03/10/go-struture-11-Insertion-Sort/insert.gif" title="compile"><h2 id="go语言实现"><a class="markdownIt-Anchor" href="#go语言实现"></a> go语言实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  _,data := <span class="keyword">range</span> arr&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>,data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">arr:= []<span class="keyword">int</span>&#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="comment">//arr:=[]int&#123;1,3,2,4,9,2,6,5,4,8&#125;</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line">insertsort2(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertsort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print(arr)</span></span><br><span class="line">length := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span>;i&lt;length;i++&#123;</span><br><span class="line">temp := arr[i]</span><br><span class="line">index:=i</span><br><span class="line"><span class="keyword">for</span> j:= i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--&#123;</span><br><span class="line"><span class="keyword">if</span> arr[j] &gt;temp&#123;</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">index--</span><br><span class="line">&#125;</span><br><span class="line">arr[index] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertsort2</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print(arr)</span></span><br><span class="line">length := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span>;i&lt;length;i++&#123;</span><br><span class="line">temp := arr[i]</span><br><span class="line">j:=i<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j&gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; temp&#123;</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javascript-语言实现"><a class="markdownIt-Anchor" href="#javascript-语言实现"></a> JavaScript 语言实现</h2><p>直接插入排序 JavaScript 实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> length = array.length,</span><br><span class="line">      i,</span><br><span class="line">      j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">        swap(array, j - <span class="number">1</span>, j);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这种方式可以减少交换次数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = array.length,</span><br><span class="line">    i,</span><br><span class="line">    j,</span><br><span class="line">    temp;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    temp = array[i];</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">        array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        array[j] = temp;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用二分查找法实现的插入排序，二分查找排序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort2</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">array, start, end, temp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> middle;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (array[middle] &lt; temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= array[middle + <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">return</span> middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          end = middle;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">binarySort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = array.length,</span><br><span class="line">        i,</span><br><span class="line">        j,</span><br><span class="line">        k,</span><br><span class="line">        temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">      temp = array[i];</span><br><span class="line">      <span class="keyword">if</span> (array[i - <span class="number">1</span>] &lt;= temp) &#123;</span><br><span class="line">        k = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        k = binarySearch(array, <span class="number">0</span>, i - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; k; j--) &#123;</span><br><span class="line">          array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      array[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> binarySort(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h2><ul><li><a href="http://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="external">Wikipedia</a></li><li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科 - 插入排序</a></li><li><a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="external">维基百科 - 二分查找法</a></li><li><a href="http://hualang.iteye.com/blog/1187110" target="_blank" rel="external">排序算法–折半插入排序（二分查找排序）</a></li><li><a href="http://sjjg.js.zwu.edu.cn/SFXX/paixu/paixu6.2.1.html" target="_blank" rel="external">直接插入排序</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.2.1.1.htm" target="_blank" rel="external">直接插入排序基本思想</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;
pre,code {
     font-family: &quot;Source Code Pro&quot;, Consolas, Monaco, Menlo, Consolas, monospace !important;
 }
&lt;/style&gt;
&lt;h2 id=&quot;具体算法描述&quot;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-数据结构[10]-快速排序</title>
    <link href="https://dreamerjonson.com/2019/03/10/go-struture-10-quicksort/"/>
    <id>https://dreamerjonson.com/2019/03/10/go-struture-10-quicksort/</id>
    <published>2019-03-10T04:29:02.000Z</published>
    <updated>2019-03-10T05:35:30.288Z</updated>
    
    <content type="html"><![CDATA[<style>pre,code {     font-family: "Source Code Pro", Consolas, Monaco, Menlo, Consolas, monospace !important; }</style><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><p>快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p><p>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p><p>利用分治法可将快速排序的分为三步：</p><p>在数据集之中，选择一个元素作为”基准”（pivot）。<br>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。<br>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p><p>分区是快速排序的主要内容，用伪代码可以表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function partition(a, left, right, pivotIndex)</span><br><span class="line">     pivotValue := a[pivotIndex]</span><br><span class="line">     swap(a[pivotIndex], a[right]) // 把 pivot 移到結尾</span><br><span class="line">     storeIndex := left</span><br><span class="line">     for i from left to right-1</span><br><span class="line">         if a[i] &lt; pivotValue</span><br><span class="line">             swap(a[storeIndex], a[i])</span><br><span class="line">             storeIndex := storeIndex + 1</span><br><span class="line">     swap(a[right], a[storeIndex]) // 把 pivot 移到它最後的地方</span><br><span class="line">     return storeIndex // 返回 pivot 的最终位置</span><br></pre></td></tr></table></figure><p>首先，把基准元素移到結尾（如果直接选择最后一个元素为基准元素，那就不用移动），然后从左到右（除了最后的基准元素），循环移动小于等于基准元素的元素到数组的开头，每次移动 storeIndex 自增 1，表示下一个小于基准元素将要移动到的位置。循环结束后 storeIndex 所代表的的位置就是基准元素的所有摆放的位置。所以最后将基准元素所在位置（这里是 right）与 storeIndex 所代表的的位置的元素交换位置。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。</p><p>一旦我们有了这个分区算法，要写快速排列本身就很容易：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure quicksort(a, left, right)</span><br><span class="line">    if right &gt; left</span><br><span class="line">        select a pivot value a[pivotIndex]</span><br><span class="line">        pivotNewIndex := partition(a, left, right, pivotIndex)</span><br><span class="line">        quicksort(a, left, pivotNewIndex-1)</span><br><span class="line">        quicksort(a, pivotNewIndex+1, right)</span><br></pre></td></tr></table></figure><h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2><p>举例来说，现有数组 arr = [3,7,8,5,2,1,9,5,4]，分区可以分解成以下步骤：</p><p>首先选定一个基准元素，这里我们元素 5 为基准元素（基准元素可以任意选择）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          pivot</span><br><span class="line">            ↓</span><br><span class="line">3   7   8   5   2   1   9   5   4</span><br></pre></td></tr></table></figure><p>将基准元素与数组中最后一个元素交换位置，如果选择最后一个元素为基准元素可以省略该步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                              pivot</span><br><span class="line">                                ↓</span><br><span class="line">3   7   8   4   2   1   9   5   5</span><br></pre></td></tr></table></figure><p>从左到右（除了最后的基准元素），循环移动小于基准元素 5 的所有元素到数组开头，留下大于等于基准元素的元素接在后面。在这个过程它也为基准元素找寻最后摆放的位置。循环流程如下：</p><p>循环 i == 0 时，storeIndex == 0，找到一个小于基准元素的元素 3，那么将其与 storeIndex 所在位置的元素交换位置，这里是 3 自身，交换后将 storeIndex 自增 1，storeIndex == 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                                pivot</span><br><span class="line">                                  ↓</span><br><span class="line">  3   7   8   4   2   1   9   5   5</span><br><span class="line">  ↑</span><br><span class="line">storeIndex</span><br></pre></td></tr></table></figure><p>循环 i == 3 时，storeIndex == 1，找到一个小于基准元素的元素 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     ┌───────┐                 pivot</span><br><span class="line">     ↓       ↓                   ↓</span><br><span class="line"> 3   7   8   4   2   1   9   5   5</span><br><span class="line">     ↑       ↑</span><br><span class="line">storeIndex   i</span><br></pre></td></tr></table></figure><p>交换位置后，storeIndex 自增 1，storeIndex == 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                              pivot</span><br><span class="line">                                ↓</span><br><span class="line">3   4   8   7   2   1   9   5   5</span><br><span class="line">        ↑           </span><br><span class="line">   storeIndex</span><br></pre></td></tr></table></figure><p>循环 i == 4 时，storeIndex == 2，找到一个小于基准元素的元素 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        ┌───────┐             pivot</span><br><span class="line">        ↓       ↓               ↓</span><br><span class="line">3   4   8   7   2   1   9   5   5</span><br><span class="line">        ↑       ↑</span><br><span class="line">   storeIndex   i</span><br></pre></td></tr></table></figure><p>交换位置后，storeIndex 自增 1，storeIndex == 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                              pivot</span><br><span class="line">                                ↓</span><br><span class="line">3   4   2   7   8   1   9   5   5</span><br><span class="line">            ↑           </span><br><span class="line">       storeIndex</span><br></pre></td></tr></table></figure><p>循环 i == 5 时，storeIndex == 3，找到一个小于基准元素的元素 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            ┌───────┐         pivot</span><br><span class="line">            ↓       ↓           ↓</span><br><span class="line">3   4   2   7   8   1   9   5   5</span><br><span class="line">            ↑       ↑</span><br><span class="line">       storeIndex   i</span><br></pre></td></tr></table></figure><p>交换后位置后，storeIndex 自增 1，storeIndex == 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                              pivot</span><br><span class="line">                                ↓</span><br><span class="line">3   4   2   1   8   7   9   5   5</span><br><span class="line">                ↑           </span><br><span class="line">           storeIndex</span><br></pre></td></tr></table></figure><p>循环 i == 7 时，storeIndex == 4，找到一个小于等于基准元素的元素 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                ┌───────────┐ pivot</span><br><span class="line">                ↓           ↓   ↓</span><br><span class="line">3   4   2   1   8   7   9   5   5</span><br><span class="line">                ↑           ↑</span><br><span class="line">           storeIndex       i</span><br></pre></td></tr></table></figure><p>交换后位置后，storeIndex 自增 1，storeIndex == 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                              pivot</span><br><span class="line">                                ↓</span><br><span class="line">3   4   2   1   5   7   9   8   5</span><br><span class="line">                    ↑           </span><br><span class="line">               storeIndex</span><br></pre></td></tr></table></figure><p>循环结束后交换基准元素和 storeIndex 位置的元素的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                  pivot</span><br><span class="line">                    ↓</span><br><span class="line">3   4   2   1   5   5   9   8   7</span><br><span class="line">                    ↑           </span><br><span class="line">               storeIndex</span><br></pre></td></tr></table></figure><p>那么 storeIndex 的值就是基准元素的最终位置，这样整个分区过程就完成了。</p><h2 id="go语言实现1"><a class="markdownIt-Anchor" href="#go语言实现1"></a> go语言实现1</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  _,data := <span class="keyword">range</span> arr&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>,data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr:= []int&#123;8, 5, 2, 6, 9, 3, 1, 4, 0, 7&#125;</span></span><br><span class="line">arr:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line">quicksort(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//print(arr)</span></span><br><span class="line">length := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> length &lt;<span class="number">2</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">index:= <span class="number">0</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;length;i++&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arr[i] &lt;= arr[start]&#123;</span><br><span class="line">index++</span><br><span class="line">temp:= arr[index]</span><br><span class="line">arr[index] = arr[i]</span><br><span class="line">arr[i] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp:= arr[index]</span><br><span class="line">arr[index] = arr[start]</span><br><span class="line">arr[start] = tmp</span><br><span class="line"></span><br><span class="line">quicksort(arr[start:index])</span><br><span class="line">quicksort(arr[index+<span class="number">1</span>:length])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序第二种方式"><a class="markdownIt-Anchor" href="#快速排序第二种方式"></a> 快速排序第二种方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright © 2018 jonson</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(arr);i++&#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"----------------------------------------------"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   k := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>&#125;</span><br><span class="line">show(k)</span><br><span class="line">quicksort(k)</span><br><span class="line">show(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt;<span class="number">1</span>&#123;<span class="comment">//必须要长度大于1才有意义。</span></span><br><span class="line"></span><br><span class="line">end := <span class="built_in">len</span>(arr)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i&lt;j&#123;</span><br><span class="line"><span class="keyword">for</span> i &lt; end<span class="number">-1</span>&#123;</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">if</span> arr[i] &lt;= arr[<span class="number">0</span>]&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j&gt;<span class="number">0</span>&#123;</span><br><span class="line">j--</span><br><span class="line"><span class="keyword">if</span> arr[j]&gt;=arr[<span class="number">0</span>]&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果i&lt;j，说明要将这两个元素交换</span></span><br><span class="line"><span class="keyword">if</span> i &lt; j&#123;</span><br><span class="line">temp :=arr[i]</span><br><span class="line">arr[i] = arr[j]</span><br><span class="line">arr[j] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换start和 j  。 到此为止， j之前为小于start元素的，j之后为大于start元素的。</span></span><br><span class="line">tmp := arr[j]</span><br><span class="line">arr[j] = arr[<span class="number">0</span>]</span><br><span class="line">arr[<span class="number">0</span>] = tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归下去</span></span><br><span class="line"><span class="keyword">if</span> j &gt;<span class="number">0</span> &#123;</span><br><span class="line">quicksort(arr[<span class="number">0</span>:j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j+<span class="number">1</span> &lt; end&#123;</span><br><span class="line">quicksort(arr[j+<span class="number">1</span>:end])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c语言实现1"><a class="markdownIt-Anchor" href="#c语言实现1"></a> c语言实现1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序,不仅要写出来，而且要优美</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arr 为数组</span></span><br><span class="line"><span class="comment">//start 为开始的元素的下标</span></span><br><span class="line"><span class="comment">//end  为结束的元素的下标+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) <span class="comment">//必须要开始的元素 &lt;结束的元素才有意义。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">int</span> i = start;</span><br><span class="line"><span class="keyword">int</span> j = end;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i在++，j在--。第一个do为当i&lt;j时就继续下去。</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> <span class="comment">//此do一直让i++，直到，发现大于start的</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; end  &amp;&amp; arr[i] &lt; arr[start]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span><span class="comment">//此do一直让j--，直到，发现小于start的元素</span></span><br><span class="line">&#123;</span><br><span class="line">j--;</span><br><span class="line">&#125; <span class="keyword">while</span> (j&gt;start &amp;&amp; arr[j]&gt;arr[start]);</span><br><span class="line"><span class="comment">//如果i&lt;j，说明要将这两个元素交换</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (i&lt;j);</span><br><span class="line"><span class="comment">//交换start和 j  。 到此为止， j之前为小于start元素的，j之后为大于start元素的。</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[start];</span><br><span class="line">arr[start] = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归下去</span></span><br><span class="line">quick_sort(arr, start, j);</span><br><span class="line">quick_sort(arr, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span> &#125;;</span><br><span class="line">show(a, <span class="number">10</span>);</span><br><span class="line">quick_sort(a, <span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">show(a, <span class="number">10</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c语言实现2"><a class="markdownIt-Anchor" href="#c语言实现2"></a> c语言实现2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速排序,不仅要写出来，而且要优美</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//arr 为数组</span></span><br><span class="line"><span class="comment">//start 为开始的元素的下标</span></span><br><span class="line"><span class="comment">//end  为结束的元素的下标+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) &#123; <span class="comment">//start &lt; end 才有进新下去的意义。</span></span><br><span class="line"><span class="comment">//i从第一个开始，记录下标。</span></span><br><span class="line"><span class="keyword">int</span>  i = start;</span><br><span class="line"><span class="comment">//从第二个元素开始，循环到末尾</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = start+<span class="number">1</span>; j &lt; end; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//一旦发现比其start小的</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[start])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//i++,很重要的一步，也就是让发现的小于start的数，依次放置在第2个，第3个....位置上。</span></span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////交换start和i  。 到此为止， i之前为小于start元素的，i之后为大于start元素的。</span></span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[start];</span><br><span class="line">arr[start] = temp;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">quick_sort2(arr, start, i);</span><br><span class="line">quick_sort2(arr, i+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span> &#125;;</span><br><span class="line">show(a, <span class="number">10</span>);</span><br><span class="line">quick_sort2(a, <span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">show(a, <span class="number">10</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javascript-语言实现"><a class="markdownIt-Anchor" href="#javascript-语言实现"></a> JavaScript 语言实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;　　</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;　　</span><br><span class="line">    <span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);　　</span><br><span class="line">    <span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];　　</span><br><span class="line">    <span class="keyword">var</span> left = [];　　</span><br><span class="line">    <span class="keyword">var</span> right = [];　　</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;　　　　</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;　　　　　　</span><br><span class="line">            left.push(arr[i]);　　　　</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;　　　　　　</span><br><span class="line">            right.push(arr[i]);　　　　</span><br><span class="line">        &#125;　　</span><br><span class="line">    &#125;　　</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javascript-语言实现2"><a class="markdownIt-Anchor" href="#javascript-语言实现2"></a> JavaScript 语言实现2</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面简单版本的缺点是，它需要Ω(n)的额外存储空间，也就跟归并排序一样不好。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和高速缓存的性能。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 交换元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, i, k</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> temp = array[i];</span><br><span class="line">array[i] = array[k];</span><br><span class="line">array[k] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组分区，左小右大</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> storeIndex = left;        </span><br><span class="line"><span class="keyword">var</span> pivot = array[right]; <span class="comment">// 直接选最右边的元素为基准元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">swap(array, storeIndex, i);</span><br><span class="line">storeIndex++; <span class="comment">// 交换位置后，storeIndex 自增 1，代表下一个可能要交换的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(array, right, storeIndex); <span class="comment">// 将基准元素放置到最后的正确位置上</span></span><br><span class="line"><span class="keyword">return</span> storeIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> storeIndex = partition(array, left, right);</span><br><span class="line">sort(array, left, storeIndex - <span class="number">1</span>);</span><br><span class="line">sort(array, storeIndex + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="javascript-语言实现3"><a class="markdownIt-Anchor" href="#javascript-语言实现3"></a> JavaScript 语言实现3</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[k];</span><br><span class="line">        arr[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, k</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            arr[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr, start, end</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> pivot = arr[start],</span><br><span class="line">                i = start + <span class="number">1</span>,</span><br><span class="line">                k = end;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (arr[k] &gt; pivot) &#123;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(arr, i, k);</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, start, k);</span><br><span class="line">            sort(arr, start, <span class="built_in">Math</span>.max(<span class="number">0</span>, k - <span class="number">1</span>));</span><br><span class="line">            sort(arr, <span class="built_in">Math</span>.min(end, k + <span class="number">1</span>), end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h2><ul><li><a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">wiki Quicksort</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科 - 快速排序</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="external">快速排序（Quicksort）的Javascript实现</a></li><li><a href="http://www.cnblogs.com/ethanzheng/archive/2013/02/20/quicksort-in-javascript.html" target="_blank" rel="external">Quicksort in JavaScript</a></li><li><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260270.html" target="_blank" rel="external">经典排序算法 - 快速排序Quick sort</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.1.htm" target="_blank" rel="external">快速排序(QuickSort)</a></li><li><a href="http://jsdo.it/norahiko/oxIy/fullscreen" target="_blank" rel="external">ソートアルゴリズムを映像化してみた</a></li><li><a href="http://acatalept.com/blog/2008/10/28/stable-quicksort-in-javascript/" target="_blank" rel="external">Stable quicksort in Javascript</a></li><li><a href="http://www.stoimen.com/blog/2010/06/11/friday-algorithms-quicksort-difference-between-php-and-javascript/" target="_blank" rel="external">Friday Algorithms: Quicksort – Difference Between PHP and JavaScript</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;style&gt;
pre,code {
     font-family: &quot;Source Code Pro&quot;, Consolas, Monaco, Menlo, Consolas, monospace !important;
 }
&lt;/style&gt;
&lt;h2 id=&quot;快速排序&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-数据结构[9]-冒泡排序</title>
    <link href="https://dreamerjonson.com/2019/03/09/go-struture-8-select/"/>
    <id>https://dreamerjonson.com/2019/03/09/go-struture-8-select/</id>
    <published>2019-03-09T12:26:33.000Z</published>
    <updated>2019-03-10T04:30:01.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2><p>冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。复杂度o(n2)<br>Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list, compares adjacent pairs and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements “bubble” to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort.[2] Bubble sort can be practical if the input is in mostly sorted order with some out-of-order elements nearly in position.<br>冒泡排序算法的流程如下：</p><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p><p>Google CEO Eric Schmidt asked president Barack Obama once during an interview about the best way to sort one million integers – and Obama, pausing for a moment, then replied: “I think the bubble sort would be the wrong way to go.”</p><h2 id="实现过程"><a class="markdownIt-Anchor" href="#实现过程"></a> 实现过程</h2><p>以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字：</p><p>第一次外循环</p><p>( <strong>5</strong> <strong>1</strong> 4 2 8 ) → ( <strong>1</strong> <strong>5</strong> 4 2 8 )， 5 &gt; 1 交换位置<br>( 1 <strong>5</strong> <strong>4</strong> 2 8 ) → ( 1 <strong>4</strong> <strong>5</strong> 2 8 )， 5 &gt; 4 交换位置<br>( 1 4 <strong>5</strong> <strong>2</strong> 8 ) → ( 1 4 <strong>2</strong> <strong>5</strong> 8 )， 5 &gt; 2 交换位置<br>( 1 4 2 <strong>5</strong> <strong>8</strong> ) → ( 1 4 2 <strong>5</strong> <strong>8</strong> )， 5 &lt; 8 位置不变</p><p>第二次外循环（除开最后一个元素8，对剩余的序列）</p><p>( <strong>1</strong> <strong>4</strong> 2 5 8 ) → ( <strong>1</strong> <strong>4</strong> 2 5 8 )， 1 &lt; 4 位置不变<br>( 1 <strong>4</strong> <strong>2</strong> 5 8 ) → ( 1 <strong>2</strong> <strong>4</strong> 5 8 )， 4 &gt; 2 交换位置<br>( 1 2 <strong>4</strong> <strong>5</strong> 8 ) → ( 1 2 <strong>4</strong> <strong>5</strong> 8 )， 4 &lt; 5 位置不变</p><p>第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1）</p><p>( <strong>1</strong> <strong>2</strong> 4 5 8 )  →  ( <strong>1</strong> <strong>2</strong> 4 5 8 )<br>( 1 <strong>2</strong> <strong>4</strong> 5 8 )  →  ( 1 <strong>2</strong> <strong>4</strong> 5 8 )</p><p>第四次外循环（最后一次）<br>( <strong>1</strong> <strong>2</strong> 4 5 8 )  →  ( <strong>1</strong> <strong>2</strong> 4 5 8 )</p><h2 id="go语言实现"><a class="markdownIt-Anchor" href="#go语言实现"></a> Go语言实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  _,data := <span class="keyword">range</span> arr&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d "</span>,data)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">arr:= []<span class="keyword">int</span>&#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line">maopao2(arr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maopao</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">length:= <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="comment">//循环的次数，只用循环 length-1次，即最后只用判断两个数就可以了。</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++&#123;</span><br><span class="line"><span class="comment">//将数冒到最后，冒完后就不管了，因此每一次需要判断的是length - 1 - i长度。</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;length<span class="number">-1</span>-i;j++&#123;</span><br><span class="line"><span class="comment">//如果前面的数大于后面的数，交换顺序。</span></span><br><span class="line"><span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]&#123;</span><br><span class="line">temp:= arr[j]</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">arr[j+<span class="number">1</span>] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//明白了冒泡的原理，就很容易写出一了倒叙的冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maopao2</span><span class="params">(arr []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">length:= <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="comment">//和正序一样，倒叙的第一个循环的次数必须是length -1</span></span><br><span class="line"><span class="keyword">for</span> i:=length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--&#123;</span><br><span class="line"><span class="comment">//第二个循环从最后一个元素开始，一直到只剩下最后一个元素。</span></span><br><span class="line"><span class="comment">//也就是说，最后一次判断为最后两个数之间的判断。</span></span><br><span class="line"><span class="keyword">for</span> j:= length <span class="number">-1</span>; j&gt;length <span class="number">-1</span> - i  ;j--&#123;</span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span> arr[j] &gt; arr[j<span class="number">-1</span>]&#123;</span><br><span class="line">temp:= arr[j]</span><br><span class="line">arr[j] = arr[j<span class="number">-1</span>]</span><br><span class="line">arr[j<span class="number">-1</span>] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c语言实现"><a class="markdownIt-Anchor" href="#c语言实现"></a> c语言实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> length)</span></span>;<span class="comment">//正序冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> length)</span></span>;<span class="comment">//倒序冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span> &#125;;</span><br><span class="line">show(a, <span class="number">10</span>);</span><br><span class="line">maopao2(a, <span class="number">10</span>);</span><br><span class="line">show(a, <span class="number">10</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序，a为数组，length为其长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//循环的次数，只用循环 length-1次，即最后只用判断两个数就可以了。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将数冒到最后，冒完后就不管了，因此每一次需要判断的是length - 1 - i长度。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果前面的数大于后面的数，交换顺序。</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[j];</span><br><span class="line">a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//明白了冒泡的原理，就很容易写出一了倒叙的冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maopao2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//和正序一样，倒叙的第一个循环的次数必须是length -1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第二个循环从最后一个元素开始，一直到只剩下最后一个元素。</span></span><br><span class="line"><span class="comment">//也就是说，最后一次判断为最后两个数之间的判断。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = length - <span class="number">1</span>; j &gt; length-i; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js实现"><a class="markdownIt-Anchor" href="#js实现"></a> js实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> length = array.length,</span><br><span class="line">       i,</span><br><span class="line">       j,</span><br><span class="line">       temp;</span><br><span class="line">   <span class="keyword">for</span> (i = length - <span class="number">1</span>; <span class="number">0</span> &lt; i; i--) &#123;</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">               temp = array[j];</span><br><span class="line">               array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">               array[j + <span class="number">1</span>] = temp;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h2><ul><li><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="external">en.wikipedia.org</a></li><li><a href="http://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科，自由的百科全书</a></li><li><a href="http://www.sorting-algorithms.com/bubble-sort" target="_blank" rel="external">Bubble Sort</a></li><li><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/2260280.html" target="_blank" rel="external">经典排序算法 - 冒泡排序Bubble sort</a></li><li><a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.1.1.htm" target="_blank" rel="external">冒泡排序</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#冒泡排序&quot;&gt;&lt;/a&gt; 冒泡排序&lt;/h2&gt;
&lt;p&gt;冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，
      
    
    </summary>
    
      <category term="go 数据结构" scheme="https://dreamerjonson.com/categories/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="go 数据结构" scheme="https://dreamerjonson.com/tags/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
