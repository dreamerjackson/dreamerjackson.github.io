<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jonson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreamerjonson.com/"/>
  <updated>2019-12-05T14:20:01.631Z</updated>
  <id>https://dreamerjonson.com/</id>
  
  <author>
    <name>Jonson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang[105]-stack-trace</title>
    <link href="https://dreamerjonson.com/2019/12/05/golang-105-stack-trace/"/>
    <id>https://dreamerjonson.com/2019/12/05/golang-105-stack-trace/</id>
    <published>2019-12-05T14:10:18.000Z</published>
    <updated>2019-12-05T14:20:01.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p>Having some basic skills in debugging Go programs can save any programmer a good amount of time trying to identify problems. I believe in logging as much information as you can, but sometimes a panic occurs and what you logged is not enough. Understanding the information in a stack trace can sometimes mean the difference between finding the bug now or needing to add more logging and waiting for it to happen again</p><p>I have been seeing stack traces since I started writing Go. At some point we all do something silly that causes the runtime to kill our program and throw a stack trace. I am going to show you the information the stack trace provides, including how to identify the value for each parameter that was passed into each function.</p><p>Functions<br>Let’s start with a small piece of code that will produce a stack trace:</p><h2 id="listing-1"><a class="markdownIt-Anchor" href="#listing-1"></a> Listing 1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">    slice := make([]string, 2, 4)</span><br><span class="line">    Example(slice, “hello”, 10)</span><br><span class="line">&#125;</span><br><span class="line">func Example(slice []string, str string, i int) &#123;</span><br><span class="line">    panic(“Want stack trace”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 1 shows a program where the main function calls the Example function on line 05. The Example function is declared on line 08 and accepts three parameters, a slice of strings, a string and an integer. The only code Example executes is a call to the built-in function panic on line 09, which immediately produces a stack trace:</p><h2 id="listing-2"><a class="markdownIt-Anchor" href="#listing-2"></a> Listing 2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Panic: Want stack trace</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:9 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:5 +0x85</span><br><span class="line"></span><br><span class="line">goroutine 2 [runnable]:</span><br><span class="line">runtime.forcegchelper()</span><br><span class="line">        /Users/bill/go/src/runtime/proc.go:90</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1</span><br><span class="line"></span><br><span class="line">goroutine 3 [runnable]:</span><br><span class="line">runtime.bgsweep()</span><br><span class="line">        /Users/bill/go/src/runtime/mgc0.go:82</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The stack trace in listing 2 shows all the goroutines that existed at the time of the panic, the status of each routine and the call stack under that respective goroutine. The goroutines that were running and the one that caused the stack trace will be at the top. Let’s focus on the goroutine that panicked.</span><br><span class="line"></span><br><span class="line">## list3</span><br></pre></td></tr></table></figure><p>goroutine 1 [running]:<br>main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)<br>/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/<br>temp/main.go:9 +0x64<br>main.main()<br>/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/<br>temp/main.go:5 +0x85</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The stack trace on line 01 in listing 3 is showing that goroutine 1 was running prior to the panic. On line 02, we see that the code that panicked was in the Example function in package main. The line indented shows the code file and path this function is located in, plus the line of code that was executing. In this case, the code on line 09 was running which is the call to panic.</span><br><span class="line"></span><br><span class="line">Line 03 shows the name of the function that called Example. This is the main function in the main package. Underneath the function name once again, the line that is indented shows the code file, path and line of code where the call to Example was made.</span><br><span class="line"></span><br><span class="line">The stack trace is showing the chain of function calls in the scope of that goroutine up to the time the panic occurred. Now, let’s focus on the values for each parameter that was passed into the Example function:</span><br><span class="line"></span><br><span class="line">## Listing 4</span><br></pre></td></tr></table></figure><p>// Declaration<br>main.Example(slice []string, str string, i int)</p><p>// Call to Example by main.<br>slice := make([]string, 2, 4)<br>Example(slice, “hello”, 10)</p><p>// Stack trace<br>main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Listing 4 shows the values from the stack trace that were passed into the Example function when the call was made by main and the declaration of the function. When you compare the values from the stack trace with the function declaration, it doesn’t seem to match up. The declaration of the Example function accepts three parameters but the stack trace is showing six hexadecimal values. The key to understanding how the values do match up with the parameters requires knowing the implementation for each parameter type.</span><br><span class="line"></span><br><span class="line">Let’s start with the first parameter which is a slice of strings. A slice is a reference type in Go. This means the value for a slice is a header value with a pointer to some underlying data. In the case of a slice, the header value is a three word structure that contains a pointer to an underlying array, the length of the slice and the capacity. The values associated with the slice header are represented by the first three values in the stack trace:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Listing 5  </span><br><span class="line"></span><br><span class="line">// Slice parameter value</span><br><span class="line">slice := make([]string, 2, 4)</span><br><span class="line"></span><br><span class="line">// Slice header values</span><br><span class="line">Pointer:  0x2080c3f50</span><br><span class="line">Length:   0x2</span><br><span class="line">Capacity: 0x4</span><br><span class="line"></span><br><span class="line">// Declaration</span><br><span class="line">main.Example(slice []string, str string, i int)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Listing 5 shows how the first three values in the stack trace do match up with the slice parameter. The first value represents the pointer to the underlying array of strings. The length and capacity numbers used to initialize the slice match with the second and third values. Those three values represent each value of the slice header, the first parameter.</span><br><span class="line"></span><br><span class="line">Now let’s look at the second parameter which is a string. A string is also a reference type but this header value is immutable. The header value for a string is declared as a two word structure that contains a pointer to an underlying byte array and the length of the string:</span><br><span class="line"></span><br><span class="line">## Listing 6</span><br></pre></td></tr></table></figure><p>// String parameter value<br>“hello”</p><p>// String header values<br>Pointer: 0x425c0<br>Length:  0x5</p><p>// Declaration<br>main.Example(slice []string, str string, i int)</p><p>// Stack trace<br>main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Listing 6 shows how the fourth and fifth values in the stack trace do match up with the string parameter. The fourth value represents the pointer to the underlying array of bytes and the fifth value is the length of the string which was 5. The string &quot;hello&quot; requires 5 bytes. Those two values represent each value of the string header, the second parameter.</span><br><span class="line"></span><br><span class="line">The third parameter is an integer which is a single word value:</span><br><span class="line"></span><br><span class="line">## Listing 7</span><br></pre></td></tr></table></figure><p>// Integer parameter value<br>10</p><p>// Integer value<br>Base 16: 0xa</p><p>// Declaration<br>main.Example(slice []string, str string, i int)</p><p>// Stack trace<br>main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Listing 7 shows how the last value in the stack trace matches up with the integer parameter. The very last value in the trace is hexadecimal number 0xa, which is the value of 10. The same value that was passed in for that parameter. That value represents the third parameter.</span><br><span class="line">Methods</span><br><span class="line">Let’s change the program so the Example function is now a method:</span><br><span class="line"></span><br><span class="line">## Listing 8</span><br></pre></td></tr></table></figure><p>package main<br>import “fmt”<br>type trace struct{}<br>func main() {<br>slice := make([]string, 2, 4)<br>var t trace<br>t.Example(slice, “hello”, 10)<br>}<br>func (t *trace) Example(slice []string, str string, i int) {<br>fmt.Printf(“Receiver Address: %p\n”, t)<br>panic(“Want stack trace”)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Listing 8 changes the original program by declaring a new type named trace on line 05 and converting the Example function into a method on line 14. The conversion is accomplished by re-declaring the function with a pointer receiver of type trace. Then on line 10, a variable named t is declared of type trace and the method call is made with the variable on line 11.</span><br><span class="line"></span><br><span class="line">Since the method is declared with a pointer receiver, Go will take the address of the t variable to support the receiver type, even though the method call is made with a value. This time when the program is run, the stack trace is a little different:</span><br><span class="line"></span><br><span class="line">##  Listing 9</span><br></pre></td></tr></table></figure><p>Receiver Address: 0x1553a8<br>panic: Want stack trace<br>goroutine 1 [running]:<br>main.(*trace).Example(0x1553a8, 0x2081b7f50, 0x2, 0x4, 0xdc1d0, 0x5, 0xa)<br>/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/<br>temp/main.go:16 +0x116<br>main.main()<br>/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/<br>temp/main.go:11 +0xae</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">The first thing you should notice in listing 9 is that the stack trace on line 02 is making it clear this was a method call using a pointer receiver. The name of the function is now displayed with (*trace) between the package name and the method name. The second thing to notice is how the value list now shows the value of the receiver first. Method calls are really function calls with the first parameter being the receiver value. We are seeing this implementation detail in action from the stack trace.</span><br><span class="line"></span><br><span class="line">Since nothing else changed with the declaration or call to the Example method, all the other values remain the same. The line numbers where the call to Example is made and where the panic occurred changed and reflects the new code.</span><br><span class="line"></span><br><span class="line">Packing</span><br><span class="line">When you have multiple parameters that fit inside of a single word, then the values for the parameters in the stack trace will be packed together:</span><br><span class="line"></span><br><span class="line">## Listing 10</span><br></pre></td></tr></table></figure><p>package main<br>func main() {<br>Example(true, false, true, 25)<br>}<br>func Example(b1, b2, b3 bool, i uint8) {<br>panic(“Want stack trace”)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Listing 10 shows a new sample program that changes the Example function to accept four parameters. The first three are booleans and the last one is an eight bit unsigned integer. A boolean value is also an eight bit value, so all four parameters fit inside of a single word on both 32 and 64 bit architectures. When the program runs, it produces an interesting stack trace:</span><br><span class="line"></span><br><span class="line">##  Listing 11</span><br></pre></td></tr></table></figure><p>goroutine 1 [running]:<br>main.Example(0x19010001)<br>/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/<br>temp/main.go:8 +0x64<br>main.main()<br>/Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/<br>temp/main.go:4 +0x32</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Instead of there being four values in the stack trace for the call to Example, there is a single value. All four individual 8 bit values were packed together into a single word:</span><br></pre></td></tr></table></figure><p>// Parameter values<br>true, false, true, 25</p><p>// Word value<br>Bits    Binary      Hex   Value<br>00-07   0000 0001   01    true<br>08-15   0000 0000   00    false<br>16-23   0000 0001   01    true<br>24-31   0001 1001   19    25</p><p>// Declaration<br>main.Example(b1, b2, b3 bool, i uint8)</p><p>// Stack trace<br>main.Example(0x19010001)</p><pre class="highlight"><code class="">Listing 12 shows how the value in the stack trace matches up with all four parameter values that were passed in. The value of true is an 8 bit value that is represented with the value of 1 and the value of false is represented with the value of 0. The value of 25 in binary is 11001 which converts to 19 in hexadecimal. Now when we look at the hexadecimal value represented in the stack trace, we see how it does represent the values that were passed in.## ConclusionThe Go runtime provides a great deal of information to help us debug our programs. In this post we concentrated on stack traces. The ability to decode the values that were passed into each function throughout the call stack is huge. It has helped me more than once to identify my bug very quickly. Now that you know how to read stack traces, hopefully you can leverage this knowledge the next time a stack trace happens to you.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#introduction&quot;&gt;&lt;/a&gt; Introduction&lt;/h2&gt;
&lt;p&gt;Having some basic skills in debugging Go p
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[104]-go语言渐入佳境-网络[16]-获取本机地址</title>
    <link href="https://dreamerjonson.com/2019/12/04/golang-104-go%E8%AF%AD%E8%A8%80%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83-%E7%BD%91%E7%BB%9C-16-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%9C%B0%E5%9D%80/"/>
    <id>https://dreamerjonson.com/2019/12/04/golang-104-go语言渐入佳境-网络-16-获取本机地址/</id>
    <published>2019-12-04T06:15:17.000Z</published>
    <updated>2019-12-04T06:26:43.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是外网ip和内网ip"><a class="markdownIt-Anchor" href="#什么是外网ip和内网ip"></a> 什么是外网IP和内网IP?</h2><p>tcp/ip协议中，专门保留了三个IP地址区域作为私有地址，其地址范围如下：<br>10.0.0.0/8：10.0.0.0～10.255.255.255<br>172.16.0.0/12：172.16.0.0～172.31.255.255<br>192.168.0.0/16：192.168.0.0～192.168.255.255</p><p>什么是内网IP</p><p>一些小型企业或者学校，通常都是申请一个固定的IP地址，然后通过IP共享（IP Sharing），使用整个公司或学校的机器都能够访问互联网。而这些企业或学校的机器使用的IP地址就是内网IP，内网IP是在规划IPv4协议时，考虑到IP地址资源可能不足，就专门为内部网设计私有IP地址（或称之为保留地址），一般常用内网IP地址都是这种形式的：10.X.X.X、172.16.X.X-172.31.X.X、192.168.X.X等。需要注意的是，内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他的计算机无法向内网的计算机发送连接请求。我们平时可能在内网机器上搭建过网站或者FTP服务器，而在外网是不能访问该网站和FTP服务器的，原因就在于此。</p><p>什么是公网IP</p><p>公网IP就是除了保留IP地址以外的IP地址，可以与Internet上的其他计算机随意互相访问。我们通常所说的IP地址，其实就是指的公网IP。互联网上的每台计算机都有一个独立的IP地址，该IP地址唯一确定互联网上的一台计算机。这里的IP地址就是指的公网IP地址。</p><p>怎样理解互联网上的每台计算机都有一个唯一的IP地址</p><p>其实，互联网上的计算机是通过“公网IP＋内网IP”来唯一确定的，就像很多大楼都是201房间一样，房间号可能一样，但是大楼肯定是唯一的。公网IP地址和内网IP地址也是同样，不同企业或学校的机器可能有相同的内网IP地址，但是他们的公网IP地址肯定不同。那么这些企业或学校的计算机是怎样IP地址共享的呢？这就需要使用NAT（Network Address Translation,网络地址转换）功能。当内部计算机要连接互联网时，首先需要通过NAT技术，将内部计算机数据包中有关IP地址的设置都设成NAT主机的公共IP地址，然后再传送到Internet，虽然内部计算机使用的是私有IP地址，但在连接Internet时，就可以通过NAT主机的NAT技术，将内网我IP地址修改为公网IP地址，如此一来，内网计算机就可以向Internet请求数据了。<br>————————————————</p><h2 id="what-is-a-network-interface"><a class="markdownIt-Anchor" href="#what-is-a-network-interface"></a> What Is a Network Interface?</h2><p>A network interface is the point of interconnection between a computer and a private or public network. A network interface is generally a network interface card (NIC), but does not have to have a physical form. Instead, the network interface can be implemented in software. For example, the loopback interface (127.0.0.1 for IPv4 and ::1 for IPv6) is not a physical device but a piece of software simulating a network interface. The loopback interface is commonly used in test environments.</p><h2 id="获取本地ip"><a class="markdownIt-Anchor" href="#获取本地ip"></a> 获取本地ip</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ip, err := externalIP()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ip)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">externalIP</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// get all interface.</span></span><br><span class="line">    ifaces, err := net.Interfaces()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, iface := <span class="keyword">range</span> ifaces &#123;</span><br><span class="line"><span class="keyword">if</span> iface.Flags&amp;net.FlagUp == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// interface down</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> iface.Flags&amp;net.FlagLoopback != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// loopback interface</span></span><br><span class="line">&#125;</span><br><span class="line">addrs, err := iface.Addrs()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> addrs &#123;</span><br><span class="line"><span class="keyword">var</span> ip net.IP</span><br><span class="line"><span class="keyword">switch</span> v := addr.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *net.IPNet:</span><br><span class="line">ip = v.IP</span><br><span class="line"><span class="keyword">case</span> *net.IPAddr:</span><br><span class="line">ip = v.IP</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ip == <span class="literal">nil</span> || ip.IsLoopback() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ip = ip.To4()</span><br><span class="line"><span class="keyword">if</span> ip == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// not an ipv4 address</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">" ip.String()"</span>, ip.String())</span><br><span class="line"><span class="comment">// return ip.String(), nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"are you connected to the network?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取外网ip"><a class="markdownIt-Anchor" href="#获取外网ip"></a> 获取外网ip</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_external</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"http://myexternalip.com/raw"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">content, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">buf.ReadFrom(resp.Body)</span><br><span class="line"><span class="comment">//s := buf.String()</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10进制与ip相互转换"><a class="markdownIt-Anchor" href="#10进制与ip相互转换"></a> 10进制与ip相互转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func inet_ntoa(ipnr int64) net.IP &#123;</span><br><span class="line">var bytes [4]byte</span><br><span class="line">bytes[0] = byte(ipnr &amp; 0xFF)</span><br><span class="line">bytes[1] = byte((ipnr &gt;&gt; 8) &amp; 0xFF)</span><br><span class="line">bytes[2] = byte((ipnr &gt;&gt; 16) &amp; 0xFF)</span><br><span class="line">bytes[3] = byte((ipnr &gt;&gt; 24) &amp; 0xFF)</span><br><span class="line"></span><br><span class="line">return net.IPv4(bytes[3], bytes[2], bytes[1], bytes[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func inet_aton(ipnr net.IP) int64 &#123;</span><br><span class="line">bits := strings.Split(ipnr.String(), &quot;.&quot;)</span><br><span class="line"></span><br><span class="line">b0, _ := strconv.Atoi(bits[0])</span><br><span class="line">b1, _ := strconv.Atoi(bits[1])</span><br><span class="line">b2, _ := strconv.Atoi(bits[2])</span><br><span class="line">b3, _ := strconv.Atoi(bits[3])</span><br><span class="line"></span><br><span class="line">var sum int64</span><br><span class="line"></span><br><span class="line">sum += int64(b0) &lt;&lt; 24</span><br><span class="line">sum += int64(b1) &lt;&lt; 16</span><br><span class="line">sum += int64(b2) &lt;&lt; 8</span><br><span class="line">sum += int64(b3)</span><br><span class="line"></span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否公网ip"><a class="markdownIt-Anchor" href="#判断是否公网ip"></a> 判断是否公网ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func IsPublicIP(IP net.IP) bool &#123;</span><br><span class="line">if IP.IsLoopback() || IP.IsLinkLocalMulticast() || IP.IsLinkLocalUnicast() &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">if ip4 := IP.To4(); ip4 != nil &#123;</span><br><span class="line">switch true &#123;</span><br><span class="line">case ip4[0] == 10:</span><br><span class="line">return false</span><br><span class="line">case ip4[0] == 172 &amp;&amp; ip4[1] &gt;= 16 &amp;&amp; ip4[1] &lt;= 31:</span><br><span class="line">return false</span><br><span class="line">case ip4[0] == 192 &amp;&amp; ip4[1] == 168:</span><br><span class="line">return false</span><br><span class="line">default:</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ip在区间内"><a class="markdownIt-Anchor" href="#ip在区间内"></a> ip在区间内</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IpBetween</span><span class="params">(from net.IP, to net.IP, test net.IP)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> from == <span class="literal">nil</span> || to == <span class="literal">nil</span> || test == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"An ip input is nil"</span>) <span class="comment">// or return an error!?</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from16 := from.To16()</span><br><span class="line">to16 := to.To16()</span><br><span class="line">test16 := test.To16()</span><br><span class="line"><span class="keyword">if</span> from16 == <span class="literal">nil</span> || to16 == <span class="literal">nil</span> || test16 == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"An ip did not convert to a 16 byte"</span>) <span class="comment">// or return an error!?</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bytes.Compare(test16, from16) &gt;= <span class="number">0</span> &amp;&amp; bytes.Compare(test16, to16) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是外网ip和内网ip&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是外网ip和内网ip&quot;&gt;&lt;/a&gt; 什么是外网IP和内网IP?&lt;/h2&gt;
&lt;p&gt;tcp/ip协议中，专门保留了三个IP地址区域作为私有地址，其地址范围如下：&lt;br
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[103]-ldflags技巧</title>
    <link href="https://dreamerjonson.com/2019/12/03/golang-103-ldflags%E6%8A%80%E5%B7%A7/"/>
    <id>https://dreamerjonson.com/2019/12/03/golang-103-ldflags技巧/</id>
    <published>2019-12-03T08:27:35.000Z</published>
    <updated>2019-12-03T12:47:15.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="x"><a class="markdownIt-Anchor" href="#x"></a> +X</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServerBaseURL <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(ServerBaseURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中-w为去掉调试信息（无法使用gdb调试），-s为去掉符号表（暂未清楚具体作用）。<br>go build --ldflags “-s -w  -X main.ServerBaseURL=http://localhost:8080 -X main.UseTor=” -o test main.go<br>./test:<br>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br></pre></td></tr></table></figure><h2 id="打印日期"><a class="markdownIt-Anchor" href="#打印日期"></a> 打印日期</h2><p>go build --ldflags “-s -w  -X ‘main.ServerBaseURL=<code>date</code>’” -o test6 main.go</p><p>output：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tue Dec  3 16:37:08 CST 2019</span><br></pre></td></tr></table></figure><h2 id="打印go语言版本"><a class="markdownIt-Anchor" href="#打印go语言版本"></a> 打印go语言版本</h2><p>go build --ldflags “-s -w  -X ‘main.ServerBaseURL=$(go version)’” -o test7 main.go<br>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.12.9 darwin/amd64</span><br></pre></td></tr></table></figure><h2 id="link"><a class="markdownIt-Anchor" href="#link"></a> link</h2><p><a href="https://github.com/golang/go/wiki/GcToolchainTricks" target="_blank" rel="noopener">https://github.com/golang/go/wiki/GcToolchainTricks</a><br><a href="https://ms2008.github.io/2018/10/08/golang-build-version/" target="_blank" rel="noopener">https://ms2008.github.io/2018/10/08/golang-build-version/</a></p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>可以使用 go tool link --help 查看 ldflags 各参数含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-B note</span><br><span class="line">      add an ELF NT_GNU_BUILD_ID note when using ELF</span><br><span class="line">-D address</span><br><span class="line">      set data segment address (default -1)</span><br><span class="line">-E entry</span><br><span class="line">      set entry symbol name</span><br><span class="line">-H type</span><br><span class="line">      set header type</span><br><span class="line">-I linker</span><br><span class="line">      use linker as ELF dynamic linker</span><br><span class="line">-L directory</span><br><span class="line">      add specified directory to library path</span><br><span class="line">-R quantum</span><br><span class="line">      set address rounding quantum (default -1)</span><br><span class="line">-T address</span><br><span class="line">      set text segment address (default -1)</span><br><span class="line">-V    print version and exit</span><br><span class="line">-X definition</span><br><span class="line">      add string value definition of the form importpath.name=value</span><br><span class="line">-a    disassemble output</span><br><span class="line">-buildid id</span><br><span class="line">      record id as Go toolchain build id</span><br><span class="line">-buildmode mode</span><br><span class="line">      set build mode</span><br><span class="line">-c    dump call graph</span><br><span class="line">-compressdwarf</span><br><span class="line">      compress DWARF if possible (default true)</span><br><span class="line">-cpuprofile file</span><br><span class="line">      write cpu profile to file</span><br><span class="line">-d    disable dynamic executable</span><br><span class="line">-debugtramp int</span><br><span class="line">      debug trampolines</span><br><span class="line">-dumpdep</span><br><span class="line">      dump symbol dependency graph</span><br><span class="line">-extar string</span><br><span class="line">      archive program for buildmode=c-archive</span><br><span class="line">-extld linker</span><br><span class="line">      use linker when linking in external mode</span><br><span class="line">-extldflags flags</span><br><span class="line">      pass flags to external linker</span><br><span class="line">-f    ignore version mismatch</span><br><span class="line">-g    disable go package data checks</span><br><span class="line">-h    halt on error</span><br><span class="line">-importcfg file</span><br><span class="line">      read import configuration from file</span><br><span class="line">-installsuffix suffix</span><br><span class="line">      set package directory suffix</span><br><span class="line">-k symbol</span><br><span class="line">      set field tracking symbol</span><br><span class="line">-libgcc string</span><br><span class="line">      compiler support lib for internal linking; use &quot;none&quot; to disable</span><br><span class="line">-linkmode mode</span><br><span class="line">      set link mode</span><br><span class="line">-linkshared</span><br><span class="line">      link against installed Go shared libraries</span><br><span class="line">-memprofile file</span><br><span class="line">      write memory profile to file</span><br><span class="line">-memprofilerate rate</span><br><span class="line">      set runtime.MemProfileRate to rate</span><br><span class="line">-msan</span><br><span class="line">      enable MSan interface</span><br><span class="line">-n    dump symbol table</span><br><span class="line">-o file</span><br><span class="line">      write output to file</span><br><span class="line">-pluginpath string</span><br><span class="line">      full path name for plugin</span><br><span class="line">-r path</span><br><span class="line">      set the ELF dynamic linker search path to dir1:dir2:...</span><br><span class="line">-race</span><br><span class="line">      enable race detector</span><br><span class="line">-s    disable symbol table</span><br><span class="line">-tmpdir directory</span><br><span class="line">      use directory for temporary files</span><br><span class="line">-u    reject unsafe packages</span><br><span class="line">-v    print link trace</span><br><span class="line">-w    disable DWARF generation</span><br></pre></td></tr></table></figure><p>禁止gc优化和内联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &apos;-N -l&apos;</span><br></pre></td></tr></table></figure><p>说明:<br>-N 禁止编译优化<br>-l 禁止内联,禁止内联也可以一定程度上减小可执行程序大小<br>可以使用 go tool compile --help 查看 gcflags 各参数含义</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;x&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#x&quot;&gt;&lt;/a&gt; +X&lt;/h2&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[102]-assembly-汇编教程</title>
    <link href="https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/"/>
    <id>https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/</id>
    <published>2019-11-30T05:15:47.000Z</published>
    <updated>2019-12-04T10:43:49.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduce"><a class="markdownIt-Anchor" href="#introduce"></a> introduce</h2><p>golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编主要了解各种寄存器的使用跟寻址方式。根据汇编我们能够一探golang的底层实现。比如内存如何分配，栈如何扩张。接口如何转变。</p><h2 id="register"><a class="markdownIt-Anchor" href="#register"></a> register</h2><p>各种伪计数器:</p><ul><li>FP: Frame pointer: arguments and locals.(指向当前栈帧)</li><li>PC: Program counter: jumps and branches.(指向指令地址)</li><li>SB: Static base pointer: global symbols.(指向全局符号表)</li><li>SP: Stack pointer: top of stack.(指向当前栈顶部)</li><li>注意: 栈是向下整长 golang的汇编是调用者维护参数返回值跟返回地址。所以FP的值小于参数跟返回值。</li></ul><h2 id="analysis-for-add"><a class="markdownIt-Anchor" href="#analysis-for-add"></a> analysis for add</h2><p>think about this simple program:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="params">(<span class="keyword">int32</span>, <span class="keyword">bool</span>)</span></span> &#123; <span class="keyword">return</span> a + b, <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; add(<span class="number">10</span>, <span class="number">32</span>) &#125;</span><br></pre></td></tr></table></figure><p>generate assemly  code in linux:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go tool compile -S main.go</span><br></pre></td></tr></table></figure><p>this is the logic of add function</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 0x0000: Offset of the current instruction, relative to the start of the function.</span><br><span class="line">// TEXT &quot;&quot;.add: The TEXT directive declares the &quot;&quot;.add symbol as part of the .text section (i.e. runnable code) and indicates that the instructions that follow are the body of the function.</span><br><span class="line">// The empty string &quot;&quot; will be replaced by the name of the current package at link-time: i.e., &quot;&quot;.add will become main.add once linked into our final binary.</span><br><span class="line">// (SB): SB is the virtual register that holds the &quot;static-base&quot; pointer, i.e. the address of the beginning of the address-space of our program.</span><br><span class="line">// &quot;&quot;.add(SB) declares that our symbol is located at some constant offset (computed by the linker) from the start of our address-space. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// NOSPLIT: Indicates to the compiler that it should not insert the stack-split preamble, which checks whether the current stack needs to be grown.</span><br><span class="line">// In the case of our add function, the compiler has set the flag by itself: it is smart enough to figure that, since add has no local variables and no stack-frame of its own, it simply cannot outgrow the current stack; thus it&apos;d be a complete waste of CPU cycles to run these checks at each call site.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// $0-16: $0 denotes the size in bytes of the stack-frame that will be allocated; while $16 specifies the size of the arguments passed in by the caller.</span><br><span class="line">// In the general case, the frame size is followed by an argument size, separated by a minus sign. (It&apos;s not a subtraction, just idiosyncratic syntax.)</span><br><span class="line">// The frame size $24-8 states that the function has a 24-byte frame and is called with 8 bytes of argument, which live on the caller&apos;s frame.</span><br><span class="line">// If NOSPLIT is not specified for the TEXT, the argument size must be provided. For assembly functions with Go prototypes, go vet will check that the argument size is correct.</span><br><span class="line"></span><br><span class="line">0x0000 00000 (main.go:4)TEXT&quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-16</span><br><span class="line"></span><br><span class="line">//for GOLANG GC</span><br><span class="line">0x0000 00000 (main.go:4)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 00000 (main.go:4)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 00000 (main.go:4)FUNCDATA$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">  0x0000 00000 (main.go:4)PCDATA$2, $0</span><br><span class="line">  0x0000 00000 (main.go:4)PCDATA$0, $0</span><br><span class="line">  </span><br><span class="line">//   The Go calling convention mandates that every argument must be passed on the stack, using the pre-reserved space on the caller&apos;s stack-frame.</span><br><span class="line">//   It is the caller&apos;s responsibility to grow (and shrink back) the stack appropriately so that arguments can be passed to the callee, and potential return-values passed back to the caller.</span><br><span class="line">//   The Go compiler never generates instructions from the PUSH/POP family: the stack is grown or shrunk by respectively decrementing or incrementing the virtual hardware stack pointer SP.</span><br><span class="line">//   The SP pseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls.</span><br><span class="line">//   It points to the top of the local stack frame, so references should use negative offsets in the range [−framesize, 0): x-8(SP), y-4(SP), and so on.</span><br><span class="line"></span><br><span class="line">// &quot;&quot;.b+12(SP) and &quot;&quot;.a+8(SP) respectively refer to the addresses 12 bytes and 8 bytes below the top of the stack (remember: it grows downwards!).</span><br><span class="line">// .a and .b are arbitrary aliases given to the referred locations; although they have absolutely no semantic meaning whatsoever, they are mandatory when using relative addressing on virtual registers. The documentation about the virtual frame-pointer has some to say about this:</span><br><span class="line"></span><br><span class="line">// The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset —offset from the frame pointer— distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument&apos;s name.</span><br><span class="line"></span><br><span class="line">//  The first argument a is not located at 0(SP), but rather at 8(SP); that&apos;s because the caller stores its return-address in 0(SP) via the CALL pseudo-instruction.</span><br><span class="line">// Arguments are passed in reverse-order; i.e. the first argument is the closest to the top of the stack.</span><br><span class="line"></span><br><span class="line">0x0000 00000 (main.go:4)MOVL&quot;&quot;.b+12(SP), AX</span><br><span class="line">0x0004 00004 (main.go:4)MOVL&quot;&quot;.a+8(SP), CX</span><br><span class="line"></span><br><span class="line">// ADDL does the actual addition of the two Long-words (i.e. 4-byte values) stored in AX and CX, then stores the final result in AX.</span><br><span class="line">0x0008 00008 (main.go:4)ADDLCX, AX</span><br><span class="line">// That result is then moved over to &quot;&quot;.~r2+16(SP), where the caller had previously reserved some stack space and expects to find its return values. Once again, &quot;&quot;.~r2 has no semantic meaning here.</span><br><span class="line">0x000a 00010 (main.go:4)MOVLAX, &quot;&quot;.~r2+16(SP)</span><br><span class="line">0x000e 00014 (main.go:4)MOVB$1, &quot;&quot;.~r3+20(SP)</span><br><span class="line">// A final RET pseudo-instruction tells the Go assembler to insert whatever instructions are required by the calling convention of the target platform in order to properly return from a subroutine call.</span><br><span class="line">// Most likely this will cause the code to pop off the return-address stored at 0(SP) then jump back to it.</span><br><span class="line">0x0013 00019 (main.go:4)RET</span><br></pre></td></tr></table></figure><p>look at more concise version：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;; Declare global function symbol &quot;&quot;.add (actually main.add once linked)</span><br><span class="line">;; Do not insert stack-split preamble</span><br><span class="line">;; 0 bytes of stack-frame, 16 bytes of arguments passed in</span><br><span class="line">;; func add(a, b int32) (int32, bool)</span><br><span class="line">0x0000 TEXT&quot;&quot;.add(SB), NOSPLIT, $0-16</span><br><span class="line">  ;; ...omitted FUNCDATA stuff...</span><br><span class="line">  0x0000 MOVL&quot;&quot;.b+12(SP), AX    ;; move second Long-word (4B) argument from caller&apos;s stack-frame into AX</span><br><span class="line">  0x0004 MOVL&quot;&quot;.a+8(SP), CX    ;; move first Long-word (4B) argument from caller&apos;s stack-frame into CX</span><br><span class="line">  0x0008 ADDLCX, AX    ;; compute AX=CX+AX</span><br><span class="line">  0x000a MOVLAX, &quot;&quot;.~r2+16(SP)   ;; move addition result (AX) into caller&apos;s stack-frame</span><br><span class="line">  0x000e MOVB$1, &quot;&quot;.~r3+20(SP)   ;; move `true` boolean (constant) into caller&apos;s stack-frame</span><br><span class="line">  0x0013 RET    ;; jump to return address stored at 0(SP)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   |    +-------------------------+ &lt;-- 32(SP)              </span><br><span class="line">   |    |                         |                         </span><br><span class="line"> G |    |                         |                         </span><br><span class="line"> R |    |                         |                         </span><br><span class="line"> O |    | main.main&apos;s saved       |                         </span><br><span class="line"> W |    |     frame-pointer (BP)  |                         </span><br><span class="line"> S |    |-------------------------| &lt;-- 24(SP)              </span><br><span class="line">   |    |      [alignment]        |                         </span><br><span class="line"> D |    | &quot;&quot;.~r3 (bool) = 1/true  | &lt;-- 21(SP)              </span><br><span class="line"> O |    |-------------------------| &lt;-- 20(SP)              </span><br><span class="line"> W |    |                         |                         </span><br><span class="line"> N |    | &quot;&quot;.~r2 (int32) = 42     |                         </span><br><span class="line"> W |    |-------------------------| &lt;-- 16(SP)              </span><br><span class="line"> A |    |                         |                         </span><br><span class="line"> R |    | &quot;&quot;.b (int32) = 32       |                         </span><br><span class="line"> D |    |-------------------------| &lt;-- 12(SP)              </span><br><span class="line"> S |    |                         |                         </span><br><span class="line">   |    | &quot;&quot;.a (int32) = 10       |                         </span><br><span class="line">   |    |-------------------------| &lt;-- 8(SP)               </span><br><span class="line">   |    |                         |                         </span><br><span class="line">   |    |                         |                         </span><br><span class="line">   |    |                         |                         </span><br><span class="line"> \ | /  | return address to       |                         </span><br><span class="line">  \|/   |     main.main + 0x30    |                         </span><br><span class="line">   -    +-------------------------+ &lt;-- 0(SP) (TOP OF STACK)</span><br><span class="line"></span><br><span class="line">(diagram made with https://textik.com)</span><br></pre></td></tr></table></figure><h2 id="analysis-for-main"><a class="markdownIt-Anchor" href="#analysis-for-main"></a> analysis for main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    // &quot;&quot;.main (main.main once linked) is a global function symbol in the .text section, whose address is some constant offset from the beginning of our address-space.</span><br><span class="line">// It allocates a 24 bytes stack-frame and doesn&apos;t receive any argument nor does it return any value</span><br><span class="line"></span><br><span class="line">    // As we mentioned above, the Go calling convention mandates that every argument must be passed on the stack.</span><br><span class="line"></span><br><span class="line">// Our caller, main, grows its stack-frame by 24 bytes (remember that the stack grows downwards, so SUBQ here actually makes the stack-frame bigger) by decrementing the virtual stack-pointer. Of those 24 bytes:</span><br><span class="line"></span><br><span class="line">// 8 bytes (16(SP)-24(SP)) are used to store the current value of the frame-pointer BP (the real one!) to allow for stack-unwinding and facilitate debugging</span><br><span class="line">// 1+3 bytes (12(SP)-16(SP)) are reserved for the second return value (bool) plus 3 bytes of necessary alignment on amd64</span><br><span class="line">// 4 bytes (8(SP)-12(SP)) are reserved for the first return value (int32)</span><br><span class="line">// 4 bytes (4(SP)-8(SP)) are reserved for the value of argument b (int32)</span><br><span class="line">// 4 bytes (0(SP)-4(SP)) are reserved for the value of argument a (int32).</span><br><span class="line">0x0000 00000 (main.go:6)TEXT&quot;&quot;.main(SB), ABIInternal, $24-0</span><br><span class="line">//   ;; stack-split prologue...</span><br><span class="line">    // The prologue checks whether the goroutine is running out of space and, if it&apos;s the case, jumps to the epilogue.</span><br><span class="line">    // TLS is a virtual register maintained by the runtime that holds a pointer to the current g, i.e. the data-structure that keeps track of all the state of a goroutine.</span><br><span class="line"> // Looking at the definition of g from the source code of the runtime:</span><br><span class="line"> //   type g struct &#123;</span><br><span class="line">//stack       stack   // 16 bytes</span><br><span class="line">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span><br><span class="line">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span><br><span class="line">//stackguard0 uintptr</span><br><span class="line">//stackguard1 uintptr</span><br><span class="line"></span><br><span class="line">// ...omitted dozens of fields...</span><br><span class="line">//    &#125;</span><br><span class="line">    // We can see that 16(CX) corresponds to g.stackguard0, which is the threshold value maintained by the runtime that, when compared to the stack-pointer, indicates whether or not a goroutine is about to run out of space.</span><br><span class="line">// The prologue thus checks if the current SP value is less than or equal to the stackguard0 threshold (that is, it&apos;s bigger), then jumps to the epilogue if it happens to be the case.</span><br><span class="line">  </span><br><span class="line">0x0000 00000 (main.go:6)MOVQ(TLS), CX ;; store current *g in CX</span><br><span class="line">0x0009 00009 (main.go:6)CMPQSP, 16(CX) ;; compare SP and g.stackguard0</span><br><span class="line">0x000d 00013 (main.go:6)JLS58 ;; jumps to 0x3a if SP &lt;= g.stackguard0</span><br><span class="line">// 把栈减了24个字节。增大了栈空间。</span><br><span class="line">    0x000f 00015 (main.go:6)SUBQ$24, SP</span><br><span class="line">    // 保存老的bp设置新的bp。这里的bp是真实的寄存器</span><br><span class="line">0x0013 00019 (main.go:6)MOVQBP, 16(SP)</span><br><span class="line">0x0018 00024 (main.go:6)LEAQ16(SP), BP</span><br><span class="line">    //  ;; ... PCDATA stuff...</span><br><span class="line">0x001d 00029 (main.go:6)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)FUNCDATA$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)PCDATA$2, $0</span><br><span class="line">0x001d 00029 (main.go:6)PCDATA$0, $0</span><br><span class="line">//Finally, following the growth of the stack, LEAQ computes the new address of the frame-pointer and stores it in BP.</span><br><span class="line">    // The caller pushes the arguments for the callee as a Quad word (i.e. an 8-byte value) at the top of the stack that it has just grown.</span><br><span class="line">// Although it might look like random garbage at first, 137438953482 actually corresponds to the 10 and 32 4-byte values concatenated into one 8-byte value:</span><br><span class="line">    </span><br><span class="line">// $ echo &apos;obase=2;137438953482&apos; | bc</span><br><span class="line">//10000000000000000000000000000000001010</span><br><span class="line">// \____/\______________________________/</span><br><span class="line">//    32                              10</span><br><span class="line">    </span><br><span class="line">0x001d 00029 (main.go:6)MOVQ$137438953482, AX</span><br><span class="line">0x0027 00039 (main.go:6)MOVQAX, (SP)</span><br><span class="line">0x002b 00043 (main.go:6)CALL&quot;&quot;.add(SB)</span><br><span class="line">   // 恢复BP寄存器，缩减栈空间</span><br><span class="line">0x0030 00048 (main.go:6)MOVQ16(SP), BP</span><br><span class="line">0x0035 00053 (main.go:6)ADDQ$24, SP</span><br><span class="line">0x0039 00057 (main.go:6)RET</span><br><span class="line">  ;; ... stack-split epilogue...</span><br><span class="line">      // The epilogue, on the other hand, triggers the stack-growth machinery and then jumps back to the prologue.</span><br><span class="line">  // This creates a feedback loop that goes on for as long as a large enough stack hasn&apos;t been allocated for our starved goroutine.</span><br><span class="line"></span><br><span class="line">    // The body of the epilogue is pretty straightforward: it calls into the runtime, which will do the actual work of growing the stack, then jumps back to the first instruction of the function (i.e. to the prologue).</span><br><span class="line"></span><br><span class="line">// The NOP instruction just before the CALL exists so that the prologue doesn&apos;t jump directly onto a CALL instruction. On some platforms, doing so can lead to very dark places; it&apos;s a common pratice to set-up a noop instruction right before the actual call and land on this NOP instead.</span><br><span class="line"> 0x003a 00058 (main.go:6)NOP</span><br><span class="line">0x003a 00058 (main.go:6)PCDATA$0, $-1</span><br><span class="line">0x003a 00058 (main.go:6)PCDATA$2, $-1</span><br><span class="line">0x003a 00058 (main.go:6)CALLruntime.morestack_noctxt(SB)</span><br><span class="line">0x003f 00063 (main.go:6)JMP0</span><br></pre></td></tr></table></figure><h2 id="reciever-method"><a class="markdownIt-Anchor" href="#reciever-method"></a> reciever method</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; id int32 &#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder *Adder) AddPtr(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) AddVal(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">Add(10, 32) // direct call of top-level function</span><br><span class="line"></span><br><span class="line">adder := Adder&#123;id: 6754&#125;</span><br><span class="line">adder.AddPtr(10, 32) // direct call of method with pointer receiver</span><br><span class="line">adder.AddVal(10, 32) // direct call of method with value receiver</span><br><span class="line"></span><br><span class="line">(&amp;adder).AddVal(10, 32) // implicit dereferencing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (main.go:14)TEXT&quot;&quot;.main(SB), ABIInternal, $40-0</span><br><span class="line">0x0000 00000 (main.go:14)MOVQ(TLS), CX </span><br><span class="line">0x0009 00009 (main.go:14)CMPQSP, 16(CX)</span><br><span class="line">0x000d 00013 (main.go:14)JLS161</span><br><span class="line">    // 把栈减了40个字节。增大了栈空间。</span><br><span class="line">0x0013 00019 (main.go:14)SUBQ$40, SP</span><br><span class="line">0x0017 00023 (main.go:14)MOVQBP, 32(SP)</span><br><span class="line">0x001c 00028 (main.go:14)LEAQ32(SP), BP</span><br><span class="line">0x0021 00033 (main.go:14)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0021 00033 (main.go:14)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0021 00033 (main.go:14)FUNCDATA$3, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)</span><br><span class="line">0x0021 00033 (main.go:15)PCDATA$2, $0</span><br><span class="line">0x0021 00033 (main.go:15)PCDATA$0, $0</span><br><span class="line">// move (10,32) to </span><br><span class="line">    0x0021 00033 (main.go:15)MOVQ$137438953482, AX</span><br><span class="line">0x002b 00043 (main.go:15)MOVQAX, (SP)</span><br><span class="line">0x002f 00047 (main.go:15)CALL&quot;&quot;.Add(SB)</span><br><span class="line"></span><br><span class="line">   // First things first, the receiver is initialized via adder := Adder&#123;id: 6754&#125;:</span><br><span class="line">    0x0034 00052 (main.go:17)MOVL$0, &quot;&quot;.adder+28(SP)</span><br><span class="line">0x003c 00060 (main.go:17)MOVL$6754, &quot;&quot;.adder+28(SP)</span><br><span class="line">0x0044 00068 (main.go:18)PCDATA$2, $1</span><br><span class="line">    // recieve address to the AX,8 bytes.</span><br><span class="line">    0x0044 00068 (main.go:18)LEAQ&quot;&quot;.adder+28(SP), AX</span><br><span class="line">0x0049 00073 (main.go:18)PCDATA$2, $0</span><br><span class="line">0x0049 00073 (main.go:18)MOVQAX, (SP)</span><br><span class="line">0x004d 00077 (main.go:18)MOVQ$137438953482, AX</span><br><span class="line">0x0057 00087 (main.go:18)MOVQAX, 8(SP)</span><br><span class="line">0x005c 00092 (main.go:18)CALL&quot;&quot;.(*Adder).AddPtr(SB)</span><br><span class="line"></span><br><span class="line">    // value to the AX.</span><br><span class="line">    0x0061 00097 (main.go:19)MOVL&quot;&quot;.adder+28(SP), AX</span><br><span class="line">0x0065 00101 (main.go:19)MOVLAX, (SP)</span><br><span class="line">0x0068 00104 (main.go:19)MOVQ$137438953482, AX</span><br><span class="line">0x0072 00114 (main.go:19)MOVQAX, 4(SP)</span><br><span class="line">0x0077 00119 (main.go:19)CALL&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line"></span><br><span class="line">    // Somehow, Go automagically dereferences our pointer and manages to make the call. How so?</span><br><span class="line"></span><br><span class="line">// How the compiler handles this kind of situation depends on whether or not the receiver being pointed to has escaped to the heap or not.</span><br><span class="line">  </span><br><span class="line">// Case A: The receiver is on the stack</span><br><span class="line"></span><br><span class="line">// If the receiver is still on the stack and its size is sufficiently small that it can be copied in a few instructions, as is the case here, the compiler simply copies its value over to the top of the stack then does a straightforward method call to &quot;&quot;.Adder.AddVal (i.e. the one with a value receiver).</span><br><span class="line"></span><br><span class="line">// (&amp;adder).AddVal(10, 32) thus looks like this in this situation:</span><br><span class="line"></span><br><span class="line">// 0x0074 MOVL&quot;&quot;.adder+28(SP), AX;; move (i.e. copy) adder (note the MOV instead of a LEA) to..</span><br><span class="line">// 0x0078 MOVLAX, (SP);; ..the top of the stack (argument #1)</span><br><span class="line">// 0x007b MOVQ$137438953482, AX;; move (32,10) to..</span><br><span class="line">// 0x0085 MOVQAX, 4(SP);; ..the top of the stack (arguments #3 &amp; #2)</span><br><span class="line">// 0x008a CALL&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line">// Boring (although efficient). Let&apos;s move on to case B.</span><br><span class="line"></span><br><span class="line">// Case B: The receiver is on the heap</span><br><span class="line"></span><br><span class="line">// If the receiver has escaped to the heap then the compiler has to take a cleverer route: it generates a new method (with a pointer receiver, this time) that wraps &quot;&quot;.Adder.AddVal, and replaces the original call to &quot;&quot;.Adder.AddVal (the wrappee) with a call to &quot;&quot;.(*Adder).AddVal (the wrapper).</span><br><span class="line">// The wrapper&apos;s sole mission, then, is to make sure that the receiver gets properly dereferenced before being passed to the wrappee, and that any arguments and return values involved are properly copied back and forth between the caller and the wrappee.</span><br><span class="line"></span><br><span class="line">// (NOTE: In assembly outputs, these wrapper methods are marked as &lt;autogenerated&gt;.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x007c 00124 (main.go:21)MOVL&quot;&quot;.adder+28(SP), AX</span><br><span class="line">0x0080 00128 (main.go:21)MOVLAX, (SP)</span><br><span class="line">0x0083 00131 (main.go:21)MOVQ$137438953482, AX</span><br><span class="line">0x008d 00141 (main.go:21)MOVQAX, 4(SP)</span><br><span class="line">0x0092 00146 (main.go:21)CALL&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line">0x0097 00151 (main.go:22)MOVQ32(SP), BP</span><br><span class="line">0x009c 00156 (main.go:22)ADDQ$40, SP</span><br><span class="line">0x00a0 00160 (main.go:22)RET</span><br><span class="line">0x00a1 00161 (main.go:22)NOP</span><br><span class="line">0x00a1 00161 (main.go:14)PCDATA$0, $-1</span><br><span class="line">0x00a1 00161 (main.go:14)PCDATA$2, $-1</span><br><span class="line">0x00a1 00161 (main.go:14)CALLruntime.morestack_noctxt(SB)</span><br><span class="line">0x00a6 00166 (main.go:14)JMP0</span><br></pre></td></tr></table></figure><p>Here’s an annotated listing of the generated wrapper that should hopefully clear things up a bit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0x0000 TEXT&quot;&quot;.(*Adder).AddVal(SB), DUPOK|WRAPPER, $32-24</span><br><span class="line">  ;; ...omitted preambles...</span><br><span class="line"></span><br><span class="line">  0x0026 MOVQ&quot;&quot;..this+40(SP), AX ;; check whether the receiver..</span><br><span class="line">  0x002b TESTQAX, AX    ;; ..is nil</span><br><span class="line">  0x002e JEQ92    ;; if it is, jump to 0x005c (panic)</span><br><span class="line"></span><br><span class="line">  0x0030 MOVL(AX), AX            ;; dereference pointer receiver..</span><br><span class="line">  0x0032 MOVLAX, (SP)            ;; ..and move (i.e. copy) the resulting value to argument #1</span><br><span class="line"></span><br><span class="line">  ;; forward (copy) arguments #2 &amp; #3 then call the wrappee</span><br><span class="line">  0x0035 MOVL&quot;&quot;.a+48(SP), AX</span><br><span class="line">  0x0039 MOVLAX, 4(SP)</span><br><span class="line">  0x003d MOVL&quot;&quot;.b+52(SP), AX</span><br><span class="line">  0x0041 MOVLAX, 8(SP)</span><br><span class="line">  0x0045 CALL&quot;&quot;.Adder.AddVal(SB) ;; call the wrapped method</span><br><span class="line"></span><br><span class="line">  ;; copy return value from wrapped method then return</span><br><span class="line">  0x004a MOVL16(SP), AX</span><br><span class="line">  0x004e MOVLAX, &quot;&quot;.~r2+56(SP)</span><br><span class="line">  ;; ...omitted frame-pointer stuff...</span><br><span class="line">  0x005b RET</span><br><span class="line"></span><br><span class="line">  ;; throw a panic with a detailed error</span><br><span class="line">  0x005c CALLruntime.panicwrap(SB)</span><br><span class="line"></span><br><span class="line">  ;; ...omitted epilogues...</span><br></pre></td></tr></table></figure><p>Obviously, this kind of wrapper can induce quite a bit of overhead considering all the copying that needs to be done in order to pass the arguments back and forth; especially if the wrappee is just a few instructions.<br>Fortunately, in practice, the compiler would have inlined the wrappee directly into the wrapper to amortize these costs (when feasible, at least).</p><p>Note the WRAPPER directive in the definition of the symbol, which indicates that this method shouldn’t appear in backtraces (so as not to confuse the end-user), nor should it be able to recover from panics that might be thrown by the wrappee.</p><p>WRAPPER: This is a wrapper function and should not count as disabling recover.</p><p>The runtime.panicwrap function, which throws a panic if the wrapper’s receiver is nil, is pretty self-explanatory; here’s its complete listing for reference (src/runtime/error.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// panicwrap generates a panic for a call to a wrapped value method</span><br><span class="line">// with a nil pointer receiver.</span><br><span class="line">//</span><br><span class="line">// It is called from the generated wrapper code.</span><br><span class="line">func panicwrap() &#123;</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    name := funcname(findfunc(pc))</span><br><span class="line">    // name is something like &quot;main.(*T).F&quot;.</span><br><span class="line">    // We want to extract pkg (&quot;main&quot;), typ (&quot;T&quot;), and meth (&quot;F&quot;).</span><br><span class="line">    // Do it by finding the parens.</span><br><span class="line">    i := stringsIndexByte(name, &apos;(&apos;)</span><br><span class="line">    if i &lt; 0 &#123;</span><br><span class="line">        throw(&quot;panicwrap: no ( in &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    pkg := name[:i-1]</span><br><span class="line">    if i+2 &gt;= len(name) || name[i-1:i+2] != &quot;.(*&quot; &#123;</span><br><span class="line">        throw(&quot;panicwrap: unexpected string after package name: &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    name = name[i+2:]</span><br><span class="line">    i = stringsIndexByte(name, &apos;)&apos;)</span><br><span class="line">    if i &lt; 0 &#123;</span><br><span class="line">        throw(&quot;panicwrap: no ) in &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    if i+2 &gt;= len(name) || name[i:i+2] != &quot;).&quot; &#123;</span><br><span class="line">        throw(&quot;panicwrap: unexpected string after type name: &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    typ := name[:i]</span><br><span class="line">    meth := name[i+2:]</span><br><span class="line">    panic(plainError(&quot;value method &quot; + pkg + &quot;.&quot; + typ + &quot;.&quot; + meth + &quot; called using nil *&quot; + typ + &quot; pointer&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="anatomy-of-an-interface"><a class="markdownIt-Anchor" href="#anatomy-of-an-interface"></a> Anatomy of an interface</h2><h3 id="overview-of-the-datastructures"><a class="markdownIt-Anchor" href="#overview-of-the-datastructures"></a> Overview of the datastructures</h3><p>Before we can understand how they work, we first need to build a mental model of the datastructures that make up interfaces and how they’re laid out in memory.<br>To that end, we’ll have a quick peek into the runtime package to see what an interface actually looks like from the standpoint of the Go implementation.</p><h3 id="the-iface-structure"><a class="markdownIt-Anchor" href="#the-iface-structure"></a> The iface structure</h3><p>iface is the root type that represents an interface within the runtime (src/runtime/runtime2.go).<br>Its definition goes like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123; // 16 bytes on a 64bit arch</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An interface is thus a very simple structure that maintains 2 pointers:</p><ul><li>tab holds the address of an itab object, which embeds the datastructures that describe both the type of the interface as well as the type of the data it points to.</li><li>data is a raw (i.e. unsafe) pointer to the value held by the interface.</li></ul><p>More often than not, this will result in a heap allocation as the compiler takes the conservative route and forces the receiver to escape.<br>This holds true even for scalar types!</p><p>We can prove that with a few lines of code (escape.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Addifier interface&#123; Add(a, b int32) int32 &#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; name string &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    adder := Adder&#123;name: &quot;myAdder&quot;&#125;</span><br><span class="line">    adder.Add(10, 32)      // doesn&apos;t escape</span><br><span class="line">    Addifier(adder).Add(10, 32) // escapes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One could even visualize the resulting heap allocation using a simple benchmark (escape_test.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkDirect(b *testing.B) &#123;</span><br><span class="line">    adder := Adder&#123;id: 6754&#125;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        adder.Add(10, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkInterface(b *testing.B) &#123;</span><br><span class="line">    adder := Adder&#123;id: 6754&#125;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        Addifier(adder).Add(10, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ GOOS=linux GOARCH=amd64 go test -bench=. -benchmem ./escape_test.go</span><br><span class="line">BenchmarkDirect-8      2000000000         1.60 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkInterface-8   100000000         15.0 ns/op       4 B/op       1 allocs/op</span><br></pre></td></tr></table></figure><p>We can clearly see how each time we create a new Addifier interface and initialize it with our adder variable, a heap allocation of sizeof(Adder) actually takes place. Later in this chapter, we’ll see how even simple scalar types can lead to heap allocations when used with interfaces.</p><p>Let’s turn our attention towards the next datastructure: itab.</p><h3 id="the-itab-structure"><a class="markdownIt-Anchor" href="#the-itab-structure"></a> The itab structure</h3><p>itab is defined thusly (src/runtime/runtime2.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123; // 40 bytes on a 64bit arch</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">    _     [4]byte</span><br><span class="line">    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An itab is the heart &amp; brain of an interface.</p><p>First, it embeds a _type, which is the internal representation of any Go type within the runtime.<br>A _type describes every facets of a type: its name, its characteristics (e.g. size, alignment…), and to some extent, even how it behaves (e.g. comparison, hashing…)!<br>In this instance, the _type field describes the type of the value held by the interface, i.e. the value that the data pointer points to.</p><p>Second, we find a pointer to an interfacetype, which is merely a wrapper around _type with some extra information that are specific to interfaces.<br>As you’d expect, the inter field describes the type of the interface itself.</p><p>Finally, the fun array holds the function pointers that make up the virtual/dispatch table of the interface.<br>Notice the comment that says // variable sized, meaning that the size with which this array is declared is irrelevant.<br>We’ll see later in this chapter that the compiler is responsible for allocating the memory that backs this array, and does so independently of the size indicated here. Likewise, the runtime always accesses this array using raw pointers, thus bounds-checking does not apply here.</p><p>The _type structure</p><p>As we said above, the _type structure gives a complete description of a Go type.<br>It’s defined as such (src/runtime/type.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type _type struct &#123; // 48 bytes on a 64bit arch</span><br><span class="line">    size       uintptr</span><br><span class="line">    ptrdata    uintptr // size of memory prefix holding all pointers</span><br><span class="line">    hash       uint32</span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      uint8</span><br><span class="line">    fieldalign uint8</span><br><span class="line">    kind       uint8</span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    // gcdata stores the GC type data for the garbage collector.</span><br><span class="line">    // If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">    gcdata    *byte</span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thankfully, most of these fields are quite self-explanatory.</p><p>The nameOff &amp; typeOff types are int32 offsets into the metadata embedded into the final executable by the linker. This metadata is loaded into runtime.moduledata structures at run time (src/runtime/symtab.go), which should look fairly similar if you’ve ever had to look at the content of an ELF file.<br>The runtime provide helpers that implement the necessary logic for following these offsets through the moduledata structures, such as e.g. resolveNameOff (src/runtime/type.go) and resolveTypeOff (src/runtime/type.go):</p><p>func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {}<br>func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {}</p><p>I.e., assuming t is a _type, calling resolveTypeOff(t, t.ptrToThis) returns a copy of t.</p><p>The interfacetype structure</p><p>Finally, here’s the interfacetype structure (src/runtime/type.go):</p><p>type interfacetype struct { // 80 bytes on a 64bit arch<br>typ     _type<br>pkgpath name<br>mhdr    []imethod<br>}</p><p>type imethod struct {<br>name nameOff<br>ityp typeOff<br>}<br>As mentioned, an interfacetype is just a wrapper around a _type with some extra interface-specific metadata added on top.<br>In the current implementation, this metadata is mostly composed of a list of offsets that points to the respective names and types of the methods exposed by the interface ([]imethod).</p><p>Conclusion</p><p>Here’s an overview of what an iface looks like when represented with all of its sub-types inlined; this hopefully should help connect all the dots:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// `iface`</span></span><br><span class="line">    tab *<span class="keyword">struct</span> &#123; <span class="comment">// `itab`</span></span><br><span class="line">        inter *<span class="keyword">struct</span> &#123; <span class="comment">// `interfacetype`</span></span><br><span class="line">            typ <span class="keyword">struct</span> &#123; <span class="comment">// `_type`</span></span><br><span class="line">                size       <span class="keyword">uintptr</span></span><br><span class="line">                ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">                hash       <span class="keyword">uint32</span></span><br><span class="line">                tflag      tflag</span><br><span class="line">                align      <span class="keyword">uint8</span></span><br><span class="line">                fieldalign <span class="keyword">uint8</span></span><br><span class="line">                kind       <span class="keyword">uint8</span></span><br><span class="line">                alg        *typeAlg</span><br><span class="line">                gcdata     *<span class="keyword">byte</span></span><br><span class="line">                str        nameOff</span><br><span class="line">                ptrToThis  typeOff</span><br><span class="line">            &#125;</span><br><span class="line">            pkgpath name</span><br><span class="line">            mhdr    []<span class="keyword">struct</span> &#123; <span class="comment">// `imethod`</span></span><br><span class="line">                name nameOff</span><br><span class="line">                ityp typeOff</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _type *<span class="keyword">struct</span> &#123; <span class="comment">// `_type`</span></span><br><span class="line">            size       <span class="keyword">uintptr</span></span><br><span class="line">            ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">            hash       <span class="keyword">uint32</span></span><br><span class="line">            tflag      tflag</span><br><span class="line">            align      <span class="keyword">uint8</span></span><br><span class="line">            fieldalign <span class="keyword">uint8</span></span><br><span class="line">            kind       <span class="keyword">uint8</span></span><br><span class="line">            alg        *typeAlg</span><br><span class="line">            gcdata     *<span class="keyword">byte</span></span><br><span class="line">            str        nameOff</span><br><span class="line">            ptrToThis  typeOff</span><br><span class="line">        &#125;</span><br><span class="line">        hash <span class="keyword">uint32</span></span><br><span class="line">        _    [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">        fun  [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">    &#125;</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This section glossed over the different data-types that make up an interface to help us to start building a mental model of the various cogs involved in the overall machinery, and how they all work with each other.</p><p>Creating an interface<br>Now that we’ve had a quick look at all the datastructures involved, we’ll focus on how they actually get allocated and initiliazed.</p><p>Consider the following program (iface.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Mather interface &#123;</span><br><span class="line">    Add(a, b int32) int32</span><br><span class="line">    Sub(a, b int64) int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; id int32 &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Sub(a, b int64) int64 &#123; return a - b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := Mather(Adder&#123;id: 6754&#125;)</span><br><span class="line"></span><br><span class="line">    // This call just makes sure that the interface is actually used.</span><br><span class="line">    // Without this call, the linker would see that the interface defined above</span><br><span class="line">    // is in fact never used, and thus would optimize it out of the final</span><br><span class="line">    // executable.</span><br><span class="line">    m.Add(10, 32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NOTE: For the remainder of this chapter, we will denote an interface I that holds a type T as &lt;I,T&gt;. E.g. Mather(Adder{id: 6754}) instantiates an iface&lt;Mather, Adder&gt;.</p><p>Let’s zoom in on the instantiation of iface&lt;Mather, Adder&gt;:</p><p>m := Mather(Adder{id: 6754})<br>This single line of Go code actually sets off quite a bit of machinery, as the assembly listing generated by the compiler can attest:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;; part 1: allocate the receiver</span><br><span class="line">;; A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame.</span><br><span class="line">;; It&apos;s stored there so that the compiler will later be able to reference it by its address;</span><br><span class="line">0x001d MOVL$6754, &quot;&quot;..autotmp_1+36(SP)</span><br><span class="line">;; part 2: set up the itab</span><br><span class="line">;; Semantically, this gives us something along the lines of the following pseudo-code:</span><br><span class="line"></span><br><span class="line">;; tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line">;; That&apos;s half of our interface right there!</span><br><span class="line"></span><br><span class="line">;; Now, while we&apos;re at it, let&apos;s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol.</span><br><span class="line">;; As usual, the -S flag of the compiler can tell us a lot:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0025 LEAQgo.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX</span><br><span class="line">0x002c MOVQAX, (SP)</span><br><span class="line">;; part 3: set up the data</span><br><span class="line">0x0030 LEAQ&quot;&quot;..autotmp_1+36(SP), AX</span><br><span class="line">0x0035 MOVQAX, 8(SP)</span><br><span class="line">0x003a CALLruntime.convT2I32(SB)</span><br><span class="line">0x003f MOVQ16(SP), AX</span><br><span class="line">0x0044 MOVQ24(SP), CX</span><br></pre></td></tr></table></figure><p>Part 1: Allocate the receiver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x001d MOVL$6754, &quot;&quot;..autotmp_1+36(SP)</span><br></pre></td></tr></table></figure><p>A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame.<br>It’s stored there so that the compiler will later be able to reference it by its address; we’ll see why in part 3.</p><p>Part 2: Set up the itab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0025 LEAQgo.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX</span><br><span class="line">0x002c MOVQAX, (SP)</span><br></pre></td></tr></table></figure><p>It looks like the compiler has already created the necessary itab for representing our iface&lt;Mather, Adder&gt; interface, and made it available to us via a global symbol: go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather.</p><p>We’re in the process of building an iface&lt;Mather, Adder&gt; interface and, in order to do so, we’re loading the effective address of this global go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol at the top of the current stack-frame.<br>Once again, we’ll see why in part 3.<br>Semantically, this gives us something along the lines of the following pseudo-code:<br>tab := getSymAddr(<code>go.itab.main.Adder,main.Mather</code>).(*itab)<br>That’s half of our interface right there!</p><p>Now, while we’re at it, let’s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol.<br>As usual, the -S flag of the compiler can tell us a lot:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ GOOS=linux GOARCH=amd64 go tool compile -S iface.go | grep -A 7 &apos;^go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&apos;</span><br><span class="line">go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40</span><br><span class="line">    0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">    0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............</span><br><span class="line">    0x0020 00 00 00 00 00 00 00 00                          ........</span><br><span class="line">    rel 0+8 t=1 type.&quot;&quot;.Mather+0</span><br><span class="line">    rel 8+8 t=1 type.&quot;&quot;.Adder+0</span><br><span class="line">    rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0</span><br><span class="line">    rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0</span><br></pre></td></tr></table></figure><p>Neat. Let’s analyze this piece by piece.</p><p>The first piece declares the symbol and its attributes:</p><p>go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40<br>As usual, since we’re looking directly at the intermediate object file generated by the compiler (i.e. the linker hasn’t run yet), symbol names are still missing package names. Nothing new on that front.<br>Other than that, what we’ve got here is a 40-byte global object symbol that will be stored in the .rodata section of our binary.</p><p>Note the dupok directive, which tells the linker that it is legal for this symbol to appear multiple times at link-time: the linker will have to arbitrarily choose one of them over the others.</p><p>The second piece is a hexdump of the 40 bytes of data associated with the symbol. I.e., it’s a serialized representation of an itab structure:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............</span><br><span class="line">0x0020 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>As you can see, most of this data is just a bunch of zeros at this point. The linker will take care of filling them up, as we’ll see in a minute.</p><p>Notice how, among all these zeros, 4 bytes actually have been set though, at offset 0x10+4.<br>If we take a look back at the declaration of the itab structure and annotate the respective offsets of its fields:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123; // 40 bytes on a 64bit arch</span><br><span class="line">    inter *interfacetype // offset 0x00 ($00)</span><br><span class="line">    _type *_type // offset 0x08 ($08)</span><br><span class="line">    hash  uint32 // offset 0x10 ($16)</span><br><span class="line">    _     [4]byte // offset 0x14 ($20)</span><br><span class="line">    fun   [1]uintptr // offset 0x18 ($24)</span><br><span class="line"> // offset 0x20 ($32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We see that offset 0x10+4 matches the hash uint32 field: i.e., the hash value that corresponds to our main.Adder type is already right there in our object file.</p><p>The third and final piece lists a bunch of relocation directives for the linker:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rel 0+8 t=1 type.&quot;&quot;.Mather+0</span><br><span class="line">rel 8+8 t=1 type.&quot;&quot;.Adder+0</span><br><span class="line">rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0</span><br><span class="line">rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0</span><br></pre></td></tr></table></figure><p>rel 0+8 t=1 type.&quot;&quot;.Mather+0 tells the linker to fill up the first 8 bytes (0+8) of the contents with the address of the global object symbol type.&quot;&quot;.Mather.<br>rel 8+8 t=1 type.&quot;&quot;.Adder+0 then fills the next 8 bytes with the address of type.&quot;&quot;.Adder, and so on and so forth.</p><p>Once the linker has done its job and followed all of these directives, our 40-byte serialized itab will be complete.<br>Overall, we’re now looking at something akin to the following pseudo-code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line"></span><br><span class="line">// NOTE: The linker strips the `type.` prefix from these symbols when building</span><br><span class="line">// the executable, so the final symbol names in the .rodata section of the</span><br><span class="line">// binary will actually be `main.Mather` and `main.Adder` rather than</span><br><span class="line">// `type.main.Mather` and `type.main.Adder`.</span><br><span class="line">// Don&apos;t get tripped up by this when toying around with objdump.</span><br><span class="line">tab.inter = getSymAddr(`type.main.Mather`).(*interfacetype)</span><br><span class="line">tab._type = getSymAddr(`type.main.Adder`).(*_type)</span><br><span class="line"></span><br><span class="line">tab.fun[0] = getSymAddr(`main.(*Adder).Add`).(uintptr)</span><br><span class="line">tab.fun[1] = getSymAddr(`main.(*Adder).Sub`).(uintptr)</span><br></pre></td></tr></table></figure><p>We’ve got ourselves a ready-to-use itab, now if we just had some data to along with it, that’d make for a nice, complete interface.</p><p>Remember from part 1 that the top of the stack (SP) currently holds the address of go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather (argument #1).<br>Also remember from part 2 that we had stored a $6754 decimal constant in “”…autotmp_1+36(SP): we now load the effective address of this constant just below the top of the stack-frame, at 8(SP) (argument #2).</p><p>These two pointers are the two arguments that we pass into runtime.convT2I32, which will apply the final touches of glue to create and return our complete interface.<br>Let’s have a closer look at it (src/runtime/iface.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func convT2I32(tab *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">    t := tab._type</span><br><span class="line">    /* ...omitted debug stuff... */</span><br><span class="line">    var x unsafe.Pointer</span><br><span class="line">    if *(*uint32)(elem) == 0 &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[0])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        x = mallocgc(4, t, false)</span><br><span class="line">        *(*uint32)(x) = *(*uint32)(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So runtime.convT2I32 does 4 things:</p><p>It creates a new iface structure i (to be pedantic, its caller creates it… same difference).<br>It assigns the itab pointer we just gave it to i.tab.<br>It allocates a new object of type i.tab._type on the heap, then copy the value pointed to by the second argument elem into that new object.<br>It returns the final interface.</p><p>This process is quite straightforward overall, although the 3rd step does involve some tricky implementation details in this specific case, which are caused by the fact that our Adder type is effectively a scalar type.<br>We’ll look at the interactions of scalar types and interfaces in more details in the section about the special cases of interfaces.</p><p>Conceptually, we’ve now accomplished the following (pseudo-code):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line">elem := getSymAddr(`&quot;&quot;..autotmp_1+36(SP)`).(*int32)</span><br><span class="line"></span><br><span class="line">i := runtime.convTI32(tab, unsafe.Pointer(elem))</span><br><span class="line"></span><br><span class="line">assert(i.tab == tab)</span><br><span class="line">assert(*(*int32)(i.data) == 6754) // same value..</span><br><span class="line">assert((*int32)(i.data) != elem)  // ..but different (al)locations!</span><br></pre></td></tr></table></figure><p>To summarize all that just went down, here’s a complete, annotated version of the assembly code for all 3 parts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x001d MOVL$6754, &quot;&quot;..autotmp_1+36(SP)         ;; create an addressable $6754 value at 36(SP)</span><br><span class="line">0x0025 LEAQgo.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX  ;; set up go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather..</span><br><span class="line">0x002c MOVQAX, (SP)                            ;; ..as first argument (tab *itab)</span><br><span class="line">0x0030 LEAQ&quot;&quot;..autotmp_1+36(SP), AX            ;; set up &amp;36(SP)..</span><br><span class="line">0x0035 MOVQAX, 8(SP)                           ;; ..as second argument (elem unsafe.Pointer)</span><br><span class="line">0x003a CALLruntime.convT2I32(SB)               ;; call convT2I32(go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather, &amp;$6754)</span><br><span class="line">0x003f MOVQ16(SP), AX                          ;; AX now holds i.tab (go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather)</span><br><span class="line">0x0044 MOVQ24(SP), CX                          ;; CX now holds i.data (&amp;$6754, somewhere on the heap)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;introduce&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#introduce&quot;&gt;&lt;/a&gt; introduce&lt;/h2&gt;
&lt;p&gt;golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>emacs-package-for-golang</title>
    <link href="https://dreamerjonson.com/2019/11/24/emacs-package-for-golang/"/>
    <id>https://dreamerjonson.com/2019/11/24/emacs-package-for-golang/</id>
    <published>2019-11-24T01:15:15.000Z</published>
    <updated>2019-12-04T09:13:17.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ivy-mode"><a class="markdownIt-Anchor" href="#ivy-mode"></a> ivy-mode</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; ivy mode</span><br><span class="line">;;</span><br><span class="line">(use-package ivy</span><br><span class="line">  :ensure t</span><br><span class="line">  :diminish (ivy-mode . &quot;&quot;)</span><br><span class="line">  :config</span><br><span class="line">  (ivy-mode 1)</span><br><span class="line">  (setq ivy-use-virutal-buffers t)</span><br><span class="line">  (setq enable-recursive-minibuffers t)</span><br><span class="line">  (setq ivy-height 10)</span><br><span class="line">  (setq ivy-initial-inputs-alist nil)</span><br><span class="line">  (setq ivy-count-format &quot;%d/%d&quot;)</span><br><span class="line">  (setq ivy-re-builders-alist</span><br><span class="line">        `((t . ivy--regex-ignore-order)))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; counsel</span><br><span class="line">;;</span><br><span class="line">(use-package counsel</span><br><span class="line">  :ensure t</span><br><span class="line">  :bind ((&quot;M-x&quot; . counsel-M-x)</span><br><span class="line">         (&quot;\C-x \C-f&quot; . counsel-find-file)))</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; swiper</span><br><span class="line">;;</span><br><span class="line">(use-package swiper</span><br><span class="line">  :ensure t</span><br><span class="line">  :bind ((&quot;\C-s&quot; . swiper))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="gomode-goimport自动导入-godef跳转"><a class="markdownIt-Anchor" href="#gomode-goimport自动导入-godef跳转"></a> gomode + goimport自动导入 + godef跳转</h2><p>go get -u <a href="http://github.com/rogpeppe/godef" target="_blank" rel="noopener">github.com/rogpeppe/godef</a><br>go get -u <a href="http://golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">golang.org/x/tools/cmd/goimports</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-mode</span><br><span class="line">  ;; :load-path &quot;~/.emacs.d/vendor/go-mode&quot;</span><br><span class="line">  :mode (&quot;\\.go\\&apos;&quot; . go-mode)</span><br><span class="line">  :ensure-system-package</span><br><span class="line">  ((goimports . &quot;go get -u golang.org/x/tools/cmd/goimports&quot;)</span><br><span class="line">   (godef . &quot;go get -u github.com/rogpeppe/godef&quot;))</span><br><span class="line">  :init</span><br><span class="line">  (setq gofmt-command &quot;goimports&quot;</span><br><span class="line">        indent-tabs-mode t)</span><br><span class="line">  :config</span><br><span class="line">  (add-hook &apos;before-save-hook &apos;gofmt-before-save)</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;\C-c \C-c&quot; . compile)</span><br><span class="line">              (&quot;\C-c \C-g&quot; . go-goto-imports)</span><br><span class="line">              (&quot;\C-c \C-k&quot; . godoc)</span><br><span class="line">              (&quot;M-j&quot; . godef-jump)))</span><br></pre></td></tr></table></figure><p>M-n find引用 M-x lsp-find-ref<br>M-. find 实现</p><h2 id="gocodecompany-自动补全"><a class="markdownIt-Anchor" href="#gocodecompany-自动补全"></a> gocode+company 自动补全</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;;</span><br><span class="line">;; company</span><br><span class="line">;;</span><br><span class="line">(use-package company</span><br><span class="line">  :ensure t</span><br><span class="line">  :config</span><br><span class="line">  (global-company-mode t)</span><br><span class="line">  (setq company-idle-delay 0)</span><br><span class="line">  (setq company-minimum-prefix-length 3)</span><br><span class="line">  (setq company-backends</span><br><span class="line">        &apos;((company-files</span><br><span class="line">           company-yasnippet</span><br><span class="line">           company-keywords</span><br><span class="line">           company-capf</span><br><span class="line">           )</span><br><span class="line">          (company-abbrev company-dabbrev))))</span><br><span class="line"></span><br><span class="line">(add-hook &apos;emacs-lisp-mode-hook (lambda ()</span><br><span class="line">                                  (add-to-list  (make-local-variable &apos;company-backends)</span><br><span class="line">                                                &apos;(company-elisp))))</span><br></pre></td></tr></table></figure><p>gocode<br>go get -u <a href="http://github.com/stamblerre/gocode" target="_blank" rel="noopener">github.com/stamblerre/gocode</a> # for go-eldoc/company-go // this feel better than nsf/gocde</p><p>gocode 是守护进程，查看是否在后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep gocode</span><br></pre></td></tr></table></figure><h2 id="语法检查"><a class="markdownIt-Anchor" href="#语法检查"></a> 语法检查</h2><p>C-c ! l<br>C-c ! v</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package flycheck</span><br><span class="line">  :ensure t</span><br><span class="line">  :config</span><br><span class="line">  (global-flycheck-mode t)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="gotest"><a class="markdownIt-Anchor" href="#gotest"></a> gotest</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(use-package gotest</span><br><span class="line">  :after go-mode</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;C-c C-f&quot; . go-test-current-file)</span><br><span class="line">              (&quot;C-c C-t&quot; . go-test-current-test)</span><br><span class="line">              (&quot;C-c C-p&quot; . go-test-current-project)</span><br><span class="line">              (&quot;C-c C-b&quot; . go-test-current-benchmark)</span><br><span class="line">              (&quot;C-x x&quot; . go-run))</span><br><span class="line">  :config</span><br><span class="line">  (setq go-test-verbose t))</span><br></pre></td></tr></table></figure><h2 id="gorename"><a class="markdownIt-Anchor" href="#gorename"></a> gorename</h2><p>go get -u  <a href="http://golang.org/x/tools/cmd/gorename" target="_blank" rel="noopener">golang.org/x/tools/cmd/gorename</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-rename</span><br><span class="line">  :after go-mode</span><br><span class="line">  :ensure-system-package (gorename . &quot;go get -u golang.org/x/tools/cmd/gorename&quot;)</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;C-c C-r&quot; . go-rename)))</span><br></pre></td></tr></table></figure><h2 id="errorcheck"><a class="markdownIt-Anchor" href="#errorcheck"></a> errorcheck</h2><p>go get -u <a href="http://github.com/kisielk/errcheck" target="_blank" rel="noopener">github.com/kisielk/errcheck</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-errcheck</span><br><span class="line">  :after go-mode</span><br><span class="line">  :ensure-system-package (errcheck . &quot;go get -u github.com/kisielk/errcheck&quot;)</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;C-c C-e&quot; . go-errcheck)))</span><br></pre></td></tr></table></figure><h2 id="go-imenu"><a class="markdownIt-Anchor" href="#go-imenu"></a> go-imenu</h2><p>go get -u <a href="http://github.com/lukehoban/go-outline" target="_blank" rel="noopener">github.com/lukehoban/go-outline</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-imenu</span><br><span class="line">  :ensure-system-package (go-outline . &quot;go get -u github.com/lukehoban/go-outline&quot;)</span><br><span class="line">  :after go-mode</span><br><span class="line">  :config</span><br><span class="line">  (add-hook &apos;go-mode-hook &apos;go-imenu-setup))</span><br></pre></td></tr></table></figure><h2 id="gtags"><a class="markdownIt-Anchor" href="#gtags"></a> gtags</h2><p>安装GUN global though source code 注意不要用brew安装，因为必须要配置sqlite3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://tamacom.com/global/global-6.5.7.tar.gz</span><br><span class="line">tar xvf global-6.5.7.tar.gz</span><br><span class="line">cd global-6.5.7</span><br><span class="line">./configure --with-sqlite3</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/juntaki/gogtags</span><br></pre></td></tr></table></figure><p>在项目目录中输入：<br>gogtags -v<br>会生成GTAGS等文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(use-package helm-gtags</span><br><span class="line">  :config</span><br><span class="line">  (setq helm-gtags-ignore-case t</span><br><span class="line">        helm-gtags-auto-update t</span><br><span class="line">        helm-gtags-use-input-at-cursor t</span><br><span class="line">        helm-gtags-pulse-at-cursor t</span><br><span class="line">        helm-gtags-prefix-key &quot;\C-cg&quot;</span><br><span class="line">        helm-gtags-suggested-key-mapping t)</span><br><span class="line">  :bind (:map helm-gtags-mode-map</span><br><span class="line">              (&quot;C-c g a&quot; . helm-gtags-tags-in-this-function)</span><br><span class="line">              (&quot;C-j&quot; . helm-gtags-select)</span><br><span class="line">              (&quot;M-.&quot; . helm-gtags-dwim)</span><br><span class="line">              (&quot;M-,&quot; . helm-gtags-pop-stack)</span><br><span class="line">              (&quot;C-c &lt;&quot; . helm-gtags-previous-history)</span><br><span class="line">              (&quot;C-c &gt;&quot; . helm-gtags-next-history))</span><br><span class="line">  :hook ((dired-mode eshell-mode c-mode c++-mode asm-mode) . helm-gtags-mode))</span><br></pre></td></tr></table></figure><p>这时候再项目中即可使用<br>M-x helm-gtags finn partern 等查找tags</p><h2 id="projecttle-在项目中切换"><a class="markdownIt-Anchor" href="#projecttle-在项目中切换"></a> projecttle 在项目中切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(use-package dumb-jump</span><br><span class="line">  :bind ((&quot;M-g o&quot; . dumb-jump-go-other-window)</span><br><span class="line">         (&quot;M-g j&quot; . dumb-jump-go)</span><br><span class="line">         (&quot;M-g x&quot; . dumb-jump-go-prefer-external)</span><br><span class="line">         (&quot;M-g z&quot; . dumb-jump-go-prefer-external-other-window))</span><br><span class="line">  :config </span><br><span class="line">  ;; (setq dumb-jump-selector &apos;ivy) ;; (setq dumb-jump-selector &apos;helm)</span><br><span class="line">:initny</span><br><span class="line">(dumb-jump-mode)</span><br><span class="line">  :ensure</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="dumb-jump-跳转ob"><a class="markdownIt-Anchor" href="#dumb-jump-跳转ob"></a> dumb-jump 跳转OB</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(use-package dumb-jump</span><br><span class="line">  :bind ((&quot;M-g o&quot; . dumb-jump-go-other-window)</span><br><span class="line">         (&quot;M-g j&quot; . dumb-jump-go)</span><br><span class="line">         (&quot;M-g x&quot; . dumb-jump-go-prefer-external)</span><br><span class="line">         (&quot;M-g z&quot; . dumb-jump-go-prefer-external-other-window))</span><br><span class="line">  :config </span><br><span class="line">  ;; (setq dumb-jump-selector &apos;ivy) ;; (setq dumb-jump-selector &apos;helm)</span><br><span class="line">:init</span><br><span class="line">(dumb-jump-mode)</span><br><span class="line">  :ensure</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ivy-mode&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ivy-mode&quot;&gt;&lt;/a&gt; ivy-mode&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac install tor</title>
    <link href="https://dreamerjonson.com/2019/11/18/mac-install-tor/"/>
    <id>https://dreamerjonson.com/2019/11/18/mac-install-tor/</id>
    <published>2019-11-18T04:27:45.000Z</published>
    <updated>2019-11-20T02:58:54.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="install"><a class="markdownIt-Anchor" href="#install"></a> install</h2><p>brew install tor</p><h2 id="config"><a class="markdownIt-Anchor" href="#config"></a> config</h2><p>You will find a sample Tor configuration file at /usr/local/etc/tor/torrc.sample. Remove the .sample extension to make it effective.</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>man tor</p><h2 id="simple-excute"><a class="markdownIt-Anchor" href="#simple-excute"></a> simple excute</h2><p>tor</p><h2 id="github-though-socket"><a class="markdownIt-Anchor" href="#github-though-socket"></a> github though socket</h2><p>测试通过之后，你可以修改 SSH 的配置文件，就不用每次都在命令行参数中指定密钥文件的路径了。如果你用 SSH 方式操作2个以上的项目，很有必要进行如下定制，可以节省很多命令行输入。<br>　　SSH 配置文件的路径是： ~/.ssh/config<br>　　如果你系统中没有这个文件，就创建一个。然后用你熟悉的文本编辑器修改这个文件。<br>　　下面俺给出一个示例：<br>你需要把示例中的“别名”改为你自己起的名字（用一个可读性好点的名字）；<br>把“私钥文件路径”也同样替换为你本机所使用的文件路径。<br>其它部分【不要】改动。<br>Host 别名<br>HostName                  <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>Port                      443<br>User                      git<br>PreferredAuthentications  publickey<br>IdentityFile              私钥文件路径</p><p>所谓的“别名”，用来替换 URL 中的主机名。比如俺那个 zhao 项目，俺在 ~/.ssh/config 中使用的别名就是 zhao<br>　　之后俺如果要 clone 该项目，只需用如下命令：<br>git clone ssh://zhao/programthink/zhao<br>看到没？俺在 URL 中就不写 <a href="http://github.com" target="_blank" rel="noopener">github.com</a> 而改为 zhao，那么 openssh 就会去 ~/.ssh/config 中找到 zhao 这个配置项，然后用对应的私钥文件进行 SSH 连接，</p><p>★针对不同的 Git 使用方式，如何配置代理？</p><h2 id="bs-方式web-方式"><a class="markdownIt-Anchor" href="#bs-方式web-方式"></a> B/S 方式（Web 方式）</h2><p>这种方式最简单——就跟你翻墙访问其它网站类似——只需要让你的浏览器通过 Tor 的线路访问 GitHub 的页面，就 OK 了。<br>　　没用过 Tor 的同学，先去看俺的扫盲教程《戴“套”翻墻的方法》。</p><h2 id="cs-方式-下的-https-协议"><a class="markdownIt-Anchor" href="#cs-方式-下的-https-协议"></a> C/S 方式 下的 HTTPS 协议</h2><p>对于这种方式，你需要修改 Git 的配置参数，让 Git 知道 Tor 代理的 IP 和 端口。<br>　　具体的配置命令如下：<br>git config --global http.proxy SOCKS5h://代理地址:端口号<br>注意1：<br>假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为： 127.0.0.1<br>否则就替换为：运行 Tor 客户端的主机的 IP 地址。<br>注意2：<br>如果你的 Tor 客户端用的是【Tor Browser】，“端口号”必须用 9150<br>如果你用的是 Tor 的其它软件包（比如：Tor Expert Bundle），则“端口号”使用 9050</p><h2 id="cs-方式下的-ssh-协议"><a class="markdownIt-Anchor" href="#cs-方式下的-ssh-协议"></a> C/S 方式下的 SSH 协议</h2><p>要让 SSH 通过 Tor 的代理，稍微麻烦一点。因为 Tor 默认提供的是 SOCKS 代理，而 OpenSSH 客户端默认又【不】支持 SOCKS 代理。<br>　　因此，得依靠第三方的工具，来实现“SSH through SOCKS”。<br>　　这里要提醒一下列位看官：<br>　　俺说的是“SSH through SOCKS”，而【不是】“SOCKS through SSH”（这两者完全不同）</p><p>为了搞定“SSH through SOCKS”，俺选用大名鼎鼎的 netcat（俗称“网猫”）。<br>　　由于这个 netcat 名气很大，主流 Linux 发行版的软件仓库中都有它。你只需要用发行版自带的软件包管理器，把 netcat 装上。<br>　　说到 netcat，有一个“原版的”以及非常多的【变种】。“原版的 netcat”【不】支持代理，必须用某些支持代理的【变种】。俺推荐的是 OpenBSD 社区开发的 netcat 变种（也叫“OpenBSD netcat”或“netcat-openbsd”）。<br>　　如何判断你是否装对了捏？<br>　　在装好 netcat 之后，先运行如下命令（命令中的 nc 就是 netcat 的缩写）。如果输出的第一行能看到 OpenBSD 这个单词，就说明你装对了。<br>nc -h</p><p>接下来，用如下命令测试“SSH through Tor SOCKS”是否成功。<br>ssh -o “ProxyCommand=nc -X 5 -x 代理地址:端口号 %h %p” -T <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>注意1：<br>假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为 127.0.0.1<br>否则就替换为：运行 Tor 客户端的主机的 IP 地址。<br>注意2：<br>如果你的 Tor 客户端用的是 Tor Browser，“端口号”必须用 9150<br>如果你用的是 Tor 的其它软件包（比如：Tor Expert Bundle），则“端口号”使用 9050</p><p>上述测试命令如果最终显示 Permession denied 就说明已经通过 SOCKS 代理连接到 GitHub 了（也就是说，你的 SSH 已经能够走 SOCKS 代理联网了）。<br>　　如果没有显示这个信息，而是显示了其它其它信息，你再用如下命令重新试一次<br>ssh -o “ProxyCommand=nc -X 5 -x 代理地址:端口号 %h %p” -Tv <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>这次俺加了一个 v 选项，可以打印出详细的诊断信息（不过都是洋文）。如果你略懂洋文并略懂网络技术，或许能判断出错的原因所在。</p><p>搞定之后，为了方便起见，同样可以把 SSH 的这个 ProxyCommand 命令行选项加入到 SSH 的配置文件。如此一来，以后每次你要连接 GitHub 的服务器，都会自动走 Tor 提供的 SOCKS 代理。<br>　　前面俺已经给出了 SSH 配置文件的示例，俺把之前那个示例文件，加上 ProxyCommand 选项之后，变为如下<br>Host 别名<br>HostName                  <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>Port                      443<br>User                      git<br>PreferredAuthentications  publickey<br>IdentityFile              私钥文件路径<br>ProxyCommand              nc -X 5 -x 代理地址:端口号 %h %p<br>　　注意1：<br>　　假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为 127.0.0.1<br>　　否则就替换为：Tor 客户端所在主机的 IP 地址。<br>　　注意2：<br>　　如果你的 Tor 客户端用的是 Tor Browser，“端口号”必须是 9150<br>　　如果你用的是 Tor 的其它软件包，则“端口号”使用 9050</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;install&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#install&quot;&gt;&lt;/a&gt; install&lt;/h2&gt;
&lt;p&gt;brew install tor&lt;/p&gt;
&lt;h2 id=&quot;config&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>扫盲 netcat（网猫）的 N 种用法——从网络诊断”到“系统入侵</title>
    <link href="https://dreamerjonson.com/2019/11/14/%E6%89%AB%E7%9B%B2-netcat%EF%BC%88%E7%BD%91%E7%8C%AB%EF%BC%89%E7%9A%84-N-%E7%A7%8D%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E2%80%9D%E5%88%B0%E2%80%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5/"/>
    <id>https://dreamerjonson.com/2019/11/14/扫盲-netcat（网猫）的-N-种用法——从网络诊断”到“系统入侵/</id>
    <published>2019-11-14T15:49:56.000Z</published>
    <updated>2019-11-29T13:11:27.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="招数1网络诊断测试某个远程主机的监听端口是否可达"><a class="markdownIt-Anchor" href="#招数1网络诊断测试某个远程主机的监听端口是否可达"></a> ★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达</h2><p>◇使用场景</p><p>经常有这种需求，要判断某个主机的监听端口是否能连上。<br>　　导致监听端口【无法】，通常有两种原因：<br>其一，这个监听端口根本就【没开启】；<br>其二，监听端口虽然开启，但是被防火墙阻拦了。<br>　　对第1个原因，（如果你能在该主机上运行命令）可以直接用 netstat 这个命令查看监听端口是否开启（不懂 netstat 命令的同学，可以看这篇博文）<br>　　但对于第2个原因，netstat 就用不上了。这时候就可以用 nc 来帮你搞定。</p><p>◇方法</p><p>用如下命令可以测试某个 IP 地址（x.x.x.x）上的某个监听端口（xx）是否开启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nv x.x.x.x xx</span><br></pre></td></tr></table></figure><p>上述命令用到了如下几个选项：</p><p>选项 -v<br>　　如果你是 nc 的新手，俺建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。<br>　　在本文后续的举例中，俺会尽量都加上这个选项（但这段话就不再重复唠叨啦）</p><p>选项 -n<br>　　由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；<br>　　反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”。</p><h2 id="补充说明超时设置"><a class="markdownIt-Anchor" href="#补充说明超时设置"></a> ◇补充说明：超时设置</h2><p>在测试链接的时候，如果你【没】使用 -w 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。<br>　　如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“-w 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。<br>nc -nv -w 3 x.x.x.x xx</p><h2 id="招数2网络诊断判断防火墙是否允许-or-禁止某个端口"><a class="markdownIt-Anchor" href="#招数2网络诊断判断防火墙是否允许-or-禁止某个端口"></a> ★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口</h2><p>◇使用场景</p><p>前一个章节（招数1）的场景是——已经有某个网络软件开启了监听端口，然后用 nc 测试端口是否可达。<br>　　现在换另一个场景：<br>　　假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何【验证】自己的配置是 OK 滴？<br>　　更进一步说：如果当前【没有】任何软件开启 8080 这个监听端口，你如何判断：该端口号是否会被防火墙阻拦？<br>　　为了叙述方便，设想如下场景：<br>有两台主机——“主机C”充当客户端，“主机S”充当服务端。<br>然后要判断“主机S”上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。</p><p>◇方法</p><p>在“主机S”上运行 nc，让它在 8080 端口，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lv -p 8080</span><br></pre></td></tr></table></figure><p>选项 -l<br>　　这个选项会让 nc 进入监听模式。</p><p>选项 -p<br>　　这个选项有“选项值”，也就是具体端口号。</p><p>然后在“主机C”上运行 nc，测试“主机S”上的 8080 端口是否可达（具体的命令行参见前一章节“招数1”）</p><p>◇补充说明：如何让 nc 的监听端口【持续开启】</p><p>在默认情况下，nc 开启 listen 模式充当服务端，在接受【第一次】客户端连接之后，就会把监听端口关闭。<br>　　为啥会这样捏？因为当年设计 nc 更多的是作为某种网络诊断/配置工具，并【不是】真拿它当服务端软件来用的。<br>　　如果你想要让 nc 始终监听模式，使之能【重复】接受客户端发起的连接，可以追加 -k 选项。</p><p>◇补充说明：UDP</p><p>上述举例是基于 TCP 协议。如果你要测试 UDP 协议，要记得【两边】的 nc 都要追加 -u 选项。</p><h2 id="招数3渗透测试用-nc-玩端口扫描"><a class="markdownIt-Anchor" href="#招数3渗透测试用-nc-玩端口扫描"></a> ★招数3：（渗透测试）用 nc 玩“端口扫描”</h2><p>◇使用场景</p><p>在“招数1”里面介绍了：如何测试【单个】端口是否可达。<br>　　扩展一下：如果你要测试的不止一个端口，而是某个【范围】的端口。这种行为有个专门的术语叫【端口扫描】。<br>　　“端口扫描”是一把双刃剑——“黑帽子”用这招进行信息收集，为后续的入侵做铺垫；“白帽子”用这招来进行“渗透测试”，以排查自己系统中【尚未屏蔽】的对外监听端口。<br>　　作为一款牛逼的网络瑞士军刀，nc 当然可以用来干这事儿啦。<br>　　顺便说一下：<br>不论是 TCP 还是 UDP，协议规定的【有效】端口号范围都是：1 ~ 65535</p><p>◇方法</p><p>下面这个命令，用来扫描 IP 地址为 x.x.x.x 的主机，扫描的端口范围从 1 到 1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -znv x.x.x.x 1-1024</span><br></pre></td></tr></table></figure><p>选项 -z<br>　　意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。<br>　　选项 -n<br>　　（前面已聊过，参见“招数1”）<br>　　选项 -v<br>　　-v 选项前面也聊过，这里要特地强调一下。<br>　　对 nc 的其它用法，-v 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果。</p><p>◇补充说明：优化输出</p><p>玩“端口扫描”的时候，“-v 选项”会把“成功/失败”的结果统统打印出来。<br>　　通常大伙儿关注的都是“扫描成功”的那些端口。因此，可以用如下命令过滤一下，只打印扫出来的端口。<br>nc -znv x.x.x.x 1-1024  2&gt;&amp;1 | grep succeeded<br>　　由于“-v 选项”产生的输出位于【stderr】，上述命令中的 2&gt;&amp;1 用来把【stderr】合并到【stdout】（注：这种写法只适用于 POSIX 系统上的 shell）<br>　　grep 命令用来进行【过滤】。对于 Windows 系统，默认【没有】grep 命令，需改用 find 命令过滤。</p><p>◇补充说明：超时设置</p><p>如果你要扫描的端口范围，跨度比较大，超时值要【恰到好处】——<br>超时值太大，会浪费时间；超时值太小，可能会遗漏某些端口（端口本身开放，但 nc 还没来得及连上就超时了）<br>　　具体如何设置，参见“招数1”的“补充说明”。</p><p>◇补充说明：【并发】扫描</p><p>如果你设置了较小的超时值，依然嫌慢，还可以用【并发】扫描的方式，进一步提升效率。<br>　　简而言之就是：同时运行多个 nc，分别扫描不同的端口范围。</p><h2 id="招数4隐匿性如何让-nc-走暗网以-tor-为例"><a class="markdownIt-Anchor" href="#招数4隐匿性如何让-nc-走暗网以-tor-为例"></a> ★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）</h2><p>◇方法</p><p>为了支持代理，nc 的“OpenBSD 变种”增加了两个选项：-X 与 -x</p><p>选项 -x<br>　　该选项表示【代理的位置】，以 x.x.x.x:xxx 的形式表示（中间是【半角冒号】）。</p><p>选项 -X<br>　　该选项表示【代理的类型】，含义如下：<br>选项值含义<br>5SOCKS5 代理<br>4SOCKS4 代理<br>connectCONNECT 型的 HTTP 代理<br>　　上述这几种类型的代理，功能上有啥差异，参见下面这篇博文开头部分的★预备知识章节。<br>《如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）》</p><p>首先，确保你本机已经运行了 Tor；<br>　　然后，拿俺的域名测试一下。如果 nc 的输出中包含 succeeded（参见下面的第2行），说明 OK 啦——nc 已经能通过 Tor 联网。<br>nc -X 5 -x 127.0.0.1:9050 -q 3 -v <a href="http://program-think.blogspot.com" target="_blank" rel="noopener">program-think.blogspot.com</a> 443</p><p>Connection to <a href="http://program-think.blogspot.com" target="_blank" rel="noopener">program-think.blogspot.com</a> 443 port [tcp/https] succeeded!<br>◇补充说明：Tor 暗网的好处</p><p>关于 Tor 的用处/好处，俺在博客上重复唠叨的次数，已经数不清了。<br>　　（简而言之）由于 Tor 暗网的线路会经历“三级跳”＆“三重套”，而且其线路每隔10分钟就会【随机】变换一次。这种变态的玩法，可以让【网络层面】的逆向追溯变得非常非常困难。<br>　　对这方面的更多介绍，参见：《关于 Tor 的常见问题解答》</p><p>◇补充说明：域名解析</p><p>当你用刚才的招数做到【nc over Tor】之后，一旦 nc 的网络行为需要解析域名，会自动通过 Tor 的 SOCKS 代理进行【远程域名解析】。<br>　　也就是说，“DNS 协议”相关数据流也经过 Tor 暗网——这样既可以【防止】“域名解析”暴露你的网络行为，还可以避免 GFW 的“域名污染”。<br>　　关于“DNS 协议”的引申阅读，可以看如下几篇：<br>《扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗／域名污染”》<br>《对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS》</p><p>◇补充说明：设置别名（alias）</p><p>如果你比较懒，觉得每次都输入上述两个代理选项太麻烦，可以为 nc 设置一个【别名】（命令如下）<br>alias nc-tor=‘nc -X 5 -x 127.0.0.1:9050’<br>　　设置好之后，你只要用 nc-tor 就可以自动追加代理选项。<br>　　如果想让别名【永久】生效，要把上述命令加入到：你当前使用的 shell 的启动文件中。<br>　　再次唠叨：“裸 Tor”与“Tor Browser”的监听端口有差异。俺上述命令的 9050 是用于“裸 Tor”。</p><h2 id="招数5信息收集用-nc-探测服务器类型和软件版本以-ssh-为例"><a class="markdownIt-Anchor" href="#招数5信息收集用-nc-探测服务器类型和软件版本以-ssh-为例"></a> ★招数5（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）</h2><p>如今要【远程管理】服务器，最常用的大概就是 SSH 这种方式了。<br>　　如果某个服务器运行了 SSH 服务端（默认监听端口是 22），那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection to 192.168.1.25 port 22 [tcp/*] succeeded!</span><br><span class="line">SSH-2.0-OpenSSH_for_Windows_7.7</span><br></pre></td></tr></table></figure><p>◇补充说明：批处理 ＆ 自动化</p><p>某些“有心人”甚至可以搞一个脚本，批量探测某个 IP 地址段的 22 端口，然后把找到的服务器信息保存在某个文件中。<br>　　另外，<br>　　有的系统管理员会把 sshd 的监听端口从 22 改为其它数值，想要迷惑攻击者。但这么干，【效果不大】。<br>　　攻击者可以先进行端口扫描，拿到所有已开启的 TCP 监听端口；然后利用上述方法，对这些 TCP 端口进行【自动化】探测，从而判断出哪个端口是 SSH Server。</p><p>◇补充说明：防范措施</p><p>本章节以“SSH Server”举例来说明入侵者如何探测服务端的软件版本。<br>　　除了“SSH Server”，很多其它的服务端软件，也存在类似的【信息暴露】。<br>　　一个谨慎的系统管理员，应该通过定制，【消除 or 伪造】这些信息，从而增加入侵者的攻击成本。</p><h2 id="招数7网络配置基于-nc-的端口转发port-forward"><a class="markdownIt-Anchor" href="#招数7网络配置基于-nc-的端口转发port-forward"></a> ★招数7：（网络配置）基于 nc 的端口转发（Port Forward）</h2><p>◇原理</p><p>用 nc 进行端口转发，需要运行【两个】nc 进程，一个充当“服务端”，另一个是“客户端”，然后用【管道】让把两个进程的“标准输入输出”交叉配对。所谓的“交叉配对”就是——每一个 nc 进程的“标准输出”都【对接】到另一个 nc 进程的“标准输入”。如此一来，就可以完美地建立【双向通讯】。<br>　　玩过命令行的同学，应该都知道：大部分 shell 都支持【管道符】（就是那个竖线符号 |），可以把某个进程的标准输出，重定向给另一个进程的标准输入。但是 shell 的“管道符”只能做到“单向配对”，【无法】做到“交叉配对”。所以还需要再借助另一个管道——也就是“命名管道”。<br>　　“命名管道”洋文叫做“named pipe”，是一种进程间通讯（IPC）的机制。顾名思义，“命名管道”就是有名号滴，而 shell 中使用的那个【管道符】，其本质上是“匿名管道”（无名管道）。<br>　　主流的操作系统（Windows、Linux、UNIX）都支持“命名管道”这种机制。由于俺本人的环境是 Linux，下面只以 Linux 举例。</p><p>◇方法</p><p>步骤1：创建命名管道<br>　　用下面这个简单的命令创建一个“命名管道”，其名称叫做 nc_pipe。（俺用这个名称只是为了举例，你也可以用别的名称）<br>mkfifo nc_pipe</p><p>步骤2：同时启动两个 nc<br>nc -l -p 1234 &lt; nc_pipe | nc 127.0.0.1 5678 &gt; nc_pipe<br>　　运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。</p><p>这个命令有点复杂。技术菜鸟如果看不懂，就算了（没关系滴，不影响你看后续的章节）。<br>　　如果你比较喜欢刨根问底，俺稍微解释一下：<br>　　上述命令行中，前一个 nc 充当【服务端】，后一个 nc 充当【客户端】。命令行中的“管道符”使得“服务端 nc”的输出绑定到“客户端 nc”的输入。然后再用 nc_pipe 这个命名管道做中转，使得“客户端 nc”的输出绑定到“服务端 nc”的输入。从而完成了【交叉配对】。</p><p>◇补充说明：如何让 nc 的监听端口【持续开启】</p><p>参见“招数2”章节中的“补充说明”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep &quot;LISTEN&quot;</span><br></pre></td></tr></table></figure><h2 id="招数9系统管理用-nc-传输文件"><a class="markdownIt-Anchor" href="#招数9系统管理用-nc-传输文件"></a> 招数9：（系统管理）用 nc 传输文件</h2><p>◇使用场景</p><p>有时候，你需要在两台电脑之间传输文件。也可以用 nc 搞定。<br>　　俺猜到某些技术小白会问：为啥不用 Windows 的共享目录？<br>　　反驳的理由很多——<br>反驳1：这个玩意儿只能在 Windows 上用。<br>反驳2：为了使用“共享目录”，需要启用（Enable）系统中的好几个 service，这会增加你系统的【攻击面】。<br>反驳3：启用的 service 越多，占用的内容也越多，影响性能。<br>…<br>　　还有些同学会问：为啥不用 FTP、SSH（或诸如此类的东东）？<br>　　俺觉得：<br>1、如果只是临时传一个文件，还要额外再去装某某软件的客户端/服务端，岂不是很蛋疼？<br>2、任何服务端软件，（从某种意义上说）都是在【增加攻击面】。</p><p>◇方法</p><p>为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p><p>你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号）<br>nc -l -p xxx &gt; file2</p><p>然后在【发送端】（A 主机）运行如下命令。<br>nc x.x.x.x xxx &lt; file1<br>　　第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。</p><p>◇补充说明：nc 的性能优势</p><p>用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。<br>　　（不熟悉网络分层的同学，再去复习一下本文开头的 OSI 模型）<br>　　如果你传输的文件【超级大】或者文件数量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言）</p><h2 id="招数10系统管理用-nc-远程备份整个磁盘"><a class="markdownIt-Anchor" href="#招数10系统管理用-nc-远程备份整个磁盘"></a> 招数10：（系统管理）用 nc 远程备份整个磁盘</h2><p>◇使用场景</p><p>当你学会“用 nc 传输文件”，还可以用 nc【复制整个硬盘】。<br>　　无论是对“系统管理员”，还是对“入侵者”甚至是“数据取证人员”，这招都是蛮有用滴。</p><p>考虑到某些读者是“技术菜鸟”，俺稍微说明一下。<br>　　“磁盘复制”【不同于】“在两块磁盘之间复制文件”。两者之间有很多差别，至少包括：<br>　　性能差异——如果“源盘”上有非常多的小文件，“在两块磁盘之间复制文件”就会【非常慢】。<br>　　完整性差异——“磁盘复制”可以确保两块盘的内容是完全一致滴。而如果你仅仅在两块磁盘之间复制文件，很多信息都损失掉了。<br>　　一般来说，“系统管理员”和“入侵者”更看重第1个差异（性能）；而“数据取证人员”更看重第2个差异（完整性）。</p><p>◇原理</p><p>为了传输整个磁盘，你需要用到 dd 命令。这玩意儿源自 UNIX，后来也移植到 Linux 和 Windows。<br>　　俺曾经在如下博文中稍微介绍过 dd 命令的使用。<br>《如何用 ISO 镜像制作 U 盘安装盘（通用方法、无需 WinPE）》<br>　　关于 dd 命令的更详细介绍，可以参见“维基百科”（这里）或“Gnu 官网”（这里）。</p><p>通过 dd 命令，你可以把“整个硬盘”（或者硬盘上的某个“物理分区”、“逻辑分区”）dump 成一个文件。<br>　　在本章节，由于最终目的是要【跨主机备份磁盘】，所以并【不】需要真的把 dd 命令的输出保存成文件，而是把 dd 的输出通过管道符（|）重定向给【本机】的 nc，然后让【本机】的 nc 发送到另一台主机的 nc（参见前一个招数）。</p><p>◇方法</p><p>由于操作物理磁盘会涉及到操作系统的差异，下面俺以 Linux 举例。<br>　　假设你要把 A 主机 /dev/sda 磁盘的【原始数据】整个复制到 B 主机的 /dev/sdb 磁盘。</p><p>你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号）<br>nc -l -p xxx | dd of=/dev/sdb</p><p>然后在【发送端】（A 主机）运行如下命令。<br>dd if=/dev/sda | nc x.x.x.x xxx<br>　　第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。</p><p>◇补充说明：nc 的性能优势</p><p>如今的存储设备越来越大了。“磁盘”或者“分区”，动不动都是几百个 GB，这时候 nc 的【性能优势】就体现出来啦。<br>　　（具体的原因，前一个章节已经分析过了）</p><h2 id="招数11入侵手法用-nc-开启被动连接型后门"><a class="markdownIt-Anchor" href="#招数11入侵手法用-nc-开启被动连接型后门"></a> 招数11：（入侵手法）用 nc 开启【被动】连接型后门</h2><p>既然聊 netcat，很自然地会聊到“黑客/骇客”的入侵招数。<br>　　做这方面的介绍，并【不是】为了传授入侵技巧；而是为了——让那些注重安全性的同学，能做到“知己知彼”。</p><p>◇使用场景</p><p>假设1：你使用的浏览器存在某个安全漏洞，并且该漏洞会让攻击者获得【执行代码】的机会。<br>　　假设2：你在某个公共场合使用某个 wifi 热点上网。遗憾的是，这个热点是攻击者设置的陷阱。<br>　　假设3：设置该陷阱的攻击者，正好也知道：如何利用上述漏洞。<br>　　当这三个假设都成立，攻击者就可以获得在你【本机】执行代码的机会。这时候，攻击者可以下载一个 nc 到你本机，然后用 nc 开启一个【被动】连接型后门。所谓的“【被动】连接型”就是指——nc 开启对外监听端口。<br>　　在该场景中，因为攻击者与你处于【同一个局域网】，攻击者自然能从自己的机器访问到你本机的 nc 后门。</p><p>◇原理</p><p>为了让后门能工作，通常会使用 nc 的 -e 选项，该选项的“选项值”是一个可执行文件的路径。<br>　　设置了该选项之后，当处于监听状态的 nc 接受到某个连接，会启动“选项值”对应的可执行文件（并得到某个进程），nc 会把该进程的“标准输入输出”与网络通讯【对接】。<br>　　为了让这个后门用起来足够爽，攻击者通常会让 nc 去启动一个【shell 进程】。对 Windows 系统而言，就是 cmd.exe；对 POSIX 系统（Linux or UNIX）而言，就是 /bin/sh<br>　　在这种情况下（nc 挂载 shell），攻击者远程连入 nc 的端口，就可以直接在这个 shell 上进行各种操作，其效果类似于 SSH 或（老式的）telnet。</p><p>◇入侵方法</p><p>步骤1<br>　　如果受害者是 Windows 系统，只须如下命令就可以开启一个后门（其中的 xxx 是端口号）<br>nc.exe -l -p xxx -e cmd.exe<br>　　如果受害者是 POSIX 系统（Linux or UNIX），则用如下命令：<br>nc -l -p xxx -e /bin/sh</p><p>步骤2<br>　　后门创建好之后，攻击者在自己机器上也运行 nc（客户端 nc），然后连接到作为后门的 nc（服务端 nc）。一旦连上之后，攻击者就可以在自己的 nc 上看到对方（受害者机器）的 shell 提示符。</p><p>◇补充说明：-e 选项</p><p>据说是考虑到 -e 选项太过危险，nc 的 OpenBSD 变种（在多年前）已经【移除】了该选项。但其实捏，还是可以用间接的方式达到同样的效果（具体如何做，俺就不透露啦）。<br>　　另，“原版 nc”依然有这个选项；nc 的很多其它变种，也依然有这个选项。</p><p>◇【不够】靠谱的防范措施</p><p>在这个场景中，大伙儿可能会想到三个值得改进之处：<br>1、浏览器的漏洞<br>2、使用公共 wifi 热点的习惯<br>3、防火墙的设置</p><p>对第1点<br>　　其实是【无解】滴！因为任何人都无法确保浏览器是【零漏洞】；</p><p>对第2点<br>　　要看每个人的具体情况而定。对有些人而言，“用公共热点上网”属于【刚需】。那就没办法了。</p><p>对第3点<br>　　“防火墙”这招，似乎是比较通用的解决之道。对大部分人而言，桌面 PC 根本就【不必】开启对外监听端口。因此，你可以配置操作系统自带防火墙，禁止【所有的】对外监听端口。<br>　　但是！（俺要开始说【但是】了）<br>　　操作系统自带的防火墙，本身也运行在操作系统【之内】。如果你是以【管理员身份】遭遇入侵，入侵者在进行【代码执行】的时候，就已经具有了【管理员权限】。在这个权限下，入侵者完全有可能“搞定”防火墙。方法有很多种——<br>比如说：把用作后门的端口号，悄悄加入到防火墙的白名单中；<br>再比如说：直接把防火墙的过滤模块干掉；<br>更牛逼的入侵者，甚至可以在【网卡驱动】上做文章——因为网卡驱动位于防火墙的过滤模块【之下】（比防火墙更底层）</p><p>◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS）</p><p>首先，这里所说的“NAT 模式”指的是【虚拟机的网卡模式】。如果你不熟悉虚拟机的网卡模式，建议先看俺写的《扫盲操作系统虚拟机》系列教程。</p><p>要想用这招，步骤如下：<br>1、当然先要安装【虚拟化软件】（VBox、VMware …），<br>2、安装一个虚拟的操作系统（洋文叫“Guest OS”）<br>3、虚拟系统的网卡设置为【NAT】模式</p><p>完成上述步骤后，你就可以在这个虚拟系统中上网。<br>　　NAT 的好处在于【单向可见】。也就是说，Guest OS 可以访问到物理系统（Host OS）【外部】的网络环境；但外部网络环境只能看到 Host OS，看不到 Guest OS。<br>　　在这种配置下，就算某个入侵者完全控制了你的 Guest OS，他/她也【没】办法在 Guest OS 中搭建“被动连接型后门”。换句话说，即使入侵者运行了这种后门，（但由于 NAT 的缘故）后门【无法】接受外部网络的连接，这个后门就【失去意义】啦。</p><p>◇补充说明：“NAT 模式”如何搭配“系统防火墙”？</p><p>上述“NAT 招数”与“系统防火墙”并【不】矛盾。<br>　　也就是说，即使你用了这招，你的物理系统（Host OS）还是要配置系统防火墙，并禁止【所有的】对外监听端口。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h2><p><a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2019/09/Netcat-Tricks.html</a><br><a href="https://program-think.blogspot.com/2016/03/GitHub-Security-Tips.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2016/03/GitHub-Security-Tips.html</a><br><a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2019/09/Netcat-Tricks.html</a><br><a href="https://program-think.blogspot.com/2013/11/tor-faq.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2013/11/tor-faq.html</a><br><a href="https://program-think.blogspot.com/2009/09/break-through-gfw-with-tor.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2009/09/break-through-gfw-with-tor.html</a><br><a href="https://program-think.blogspot.com/2019/04/Proxy-Tricks.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2019/04/Proxy-Tricks.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;招数1网络诊断测试某个远程主机的监听端口是否可达&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#招数1网络诊断测试某个远程主机的监听端口是否可达&quot;&gt;&lt;/a&gt; ★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达&lt;/h2&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[101]-redis</title>
    <link href="https://dreamerjonson.com/2019/11/07/golang-101-redis/"/>
    <id>https://dreamerjonson.com/2019/11/07/golang-101-redis/</id>
    <published>2019-11-07T10:46:19.000Z</published>
    <updated>2019-11-09T13:50:07.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>Redis is an “advanced key-value store”</p><h2 id="redis-data-types"><a class="markdownIt-Anchor" href="#redis-data-types"></a> Redis Data Types</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Strings</span><br><span class="line">Lists</span><br><span class="line">Sets</span><br><span class="line">Sorted/Scored Sets</span><br><span class="line">Hashes</span><br></pre></td></tr></table></figure><h2 id="type"><a class="markdownIt-Anchor" href="#type"></a> type</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> string:                 page:index.html   -&gt; &lt;html&gt;&lt;head&gt;[...]   login_count -&gt; 7464</span><br><span class="line"> set:                    users_logged_in_today  -&gt; &#123; 1, 2, 3, 4, 5 &#125;</span><br><span class="line">List:                          latest_post_ids -&gt;  [201, 204, 209,..]</span><br><span class="line">Hashes                     user:123:session      : time =&gt; 10927353      username =&gt; joe</span><br><span class="line">Sorted Set               joe ~ 1.3483  bert ~ 93.4 fred ~ 283.22 chris ~ 23774.17</span><br></pre></td></tr></table></figure><h2 id="golang-redis-helloworld"><a class="markdownIt-Anchor" href="#golang-redis-helloworld"></a> golang redis helloworld</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/go-redis/redis&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Go Redis Tutorial&quot;)</span><br><span class="line"></span><br><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr: &quot;localhost:6379&quot;,</span><br><span class="line">Password: &quot;&quot;,</span><br><span class="line">DB: 0,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pong, err := client.Ping().Result()</span><br><span class="line">fmt.Println(pong, err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-docker-配置-redis-主从复制"><a class="markdownIt-Anchor" href="#使用-docker-配置-redis-主从复制"></a> 使用 Docker 配置 Redis 主从复制</h2><p>配置 master 节点<br>编辑 redis-master.conf，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 监听来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br></pre></td></tr></table></figure><p>配置 slave 节点<br>创建 redis-slave1.conf，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 监听来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br><span class="line"></span><br><span class="line"># 配置master节点信息</span><br><span class="line"># 格式：</span><br><span class="line">#slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 此处masterip所指定的redis-server-master是运行master节点的容器名</span><br><span class="line"># Docker容器间可以使用容器名代替实际的IP地址来通信</span><br><span class="line">slaveof redis-server-master 6379</span><br><span class="line"></span><br><span class="line"># 设定连接主节点所使用的密码</span><br><span class="line">masterauth &quot;redis&quot;</span><br></pre></td></tr></table></figure><p>创建 redis-slave2.conf，修改监听端口号为 6381，其余配置与 redis-slave1.conf 相同。</p><h2 id="编写-docker-composeyml"><a class="markdownIt-Anchor" href="#编写-docker-composeyml"></a> 编写 docker-compose.yml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  # 主节点的容器</span><br><span class="line">  redis-server-master:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-server-master</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    networks:</span><br><span class="line">      redis-cluster:</span><br><span class="line">        # 为容器指定一个静态IP</span><br><span class="line">        ipv4_address: 10.1.0.2</span><br><span class="line">    environment:</span><br><span class="line">      TZ: &quot;Asia/Shanghai&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      # 映射配置文件和数据目录</span><br><span class="line">      - ./redis-master.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">      - ../data/redis-master:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      # 必要的内核参数</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line">  # 从节点1的容器</span><br><span class="line">  redis-server-slave-1:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-server-slave-1</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis-server-master</span><br><span class="line">    ports:</span><br><span class="line">      - 6380:6380</span><br><span class="line">    networks:</span><br><span class="line">      redis-cluster:</span><br><span class="line">        ipv4_address: 10.1.0.3</span><br><span class="line">    environment:</span><br><span class="line">      TZ: &quot;Asia/Shanghai&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-slave1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">      - ../data/redis-slave-1:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line">  # 从节点2的容器</span><br><span class="line">  redis-server-slave-2:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-server-slave-2</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis-server-master</span><br><span class="line">    ports:</span><br><span class="line">      - 6381:6381</span><br><span class="line">    networks:</span><br><span class="line">      redis-cluster:</span><br><span class="line">        ipv4_address: 10.1.0.4</span><br><span class="line">    environment:</span><br><span class="line">      TZ: &quot;Asia/Shanghai&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-slave2.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">      - ../data/redis-slave-2:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  redis-cluster:</span><br><span class="line">    # IP Address Management</span><br><span class="line">    ipam:</span><br><span class="line">      config:</span><br><span class="line">        # 为容器分配一个独立的子网，用来方便为容器指定静态IP</span><br><span class="line">        # 使用独立的子网可以避免IP地址冲突的问题</span><br><span class="line">        - subnet: 10.1.0.0/16</span><br></pre></td></tr></table></figure><p>启动容器<br>在 docker-compose.yml 所在位置执行 docker-compose up 即可启动上述三个容器，docker-compose 会将容器日志打印到终端，在日志中可以看到三个 Redis 服务器在启动过程中的动作，以及从节点加入主节点的信息。</p><p>启动成功后，可以在本机使用 redis-cli 连接至主节点。连接成功后，可以使用 info replication 命令检查主从复制的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=10.1.0.3,port=6380,state=online,offset=476,lag=1</span><br><span class="line">slave1:ip=10.1.0.4,port=6381,state=online,offset=476,lag=0</span><br><span class="line">master_replid:f29d9059a286deb4bbe5360f9c673a2484370205</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:476</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:476</span><br></pre></td></tr></table></figure><p>启动容器<br>在 docker-compose.yml 所在位置执行 docker-compose up 即可启动上述三个容器，docker-compose 会将容器日志打印到终端，在日志中可以看到三个 Redis 服务器在启动过程中的动作，以及从节点加入主节点的信息。</p><p>启动成功后，可以在本机使用 redis-cli 连接至主节点。连接成功后，可以使用 info replication 命令检查主从复制的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379         &gt; redis-cli -h 127.0.0.1  -p 6379 -a redis</span><br><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=10.1.0.3,port=6380,state=online,offset=476,lag=1</span><br><span class="line">slave1:ip=10.1.0.4,port=6381,state=online,offset=476,lag=0</span><br><span class="line">master_replid:f29d9059a286deb4bbe5360f9c673a2484370205</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:476</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:476</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">测试一下</span><br><span class="line">光是启动成功还不够，还需要测试一下从节点是否能同步主节点的数据。</span><br><span class="line"></span><br><span class="line">首先连接到主节点，新增一个 set：</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">好的，在主节点里面成功添加了一条数据。那么接下来连接到 slave-1，看一下数据有没有同步过去：</span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6380&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br><span class="line">看来 slave-1 成功的从主节点同步了数据，并且这个节点也按照设定，是一个只读的节点。那么 slave-2 呢？</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6381&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br><span class="line">OK，slave-2 也成功的同步了数据，并且正在作为一个只读节点运行着。</span><br></pre></td></tr></table></figure><h2 id="使用-docker-配置-redis-哨兵"><a class="markdownIt-Anchor" href="#使用-docker-配置-redis-哨兵"></a> 使用 Docker 配置 Redis 哨兵</h2><p>编辑 redis-sentinel.conf，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 接受来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 哨兵的端口号</span><br><span class="line"># 因为各个哨兵节点会运行在单独的Docker容器中</span><br><span class="line"># 所以无需担心端口重复使用</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 配置哨兵的监控参数</span><br><span class="line"># 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># master-name是为这个被监控的master起的名字</span><br><span class="line"># ip是被监控的master的IP或主机名。因为Docker容器之间可以使用容器名访问，所以这里写master节点的容器名</span><br><span class="line"># redis-port是被监控节点所监听的端口号</span><br><span class="line"># quorom设定了当几个哨兵判定这个节点失效后，才认为这个节点真的失效了</span><br><span class="line">sentinel monitor local-master redis-server-master 6379 2</span><br><span class="line"></span><br><span class="line"># 连接主节点的密码</span><br><span class="line"># 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass local-master redis</span><br></pre></td></tr></table></figure><p>配置及启动容器<br>编写 docker-compose.yml<br>这里继续使用 docker-compose 管理容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  # 哨兵的数量应是奇数，以便于哨兵通过投票来作出决策</span><br><span class="line">  redis-sentinel-1:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-sentinel-1</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      # 向外暴露26379端口</span><br><span class="line">      - 26379:26379</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        ipv4_address: 10.1.0.5</span><br><span class="line">    volumes:</span><br><span class="line">      # 将哨兵配置文件和存放数据的文件夹挂载到容器内</span><br><span class="line">      - ./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span><br><span class="line">      - ../data/redis-sentinel-1:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      # 设定容器的内核参数，以消除Redis启动过程中的一个warning</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    # 根据指定的配置文件来启动Redis哨兵</span><br><span class="line">    command: [&quot;redis-sentinel&quot;, &quot;/usr/local/etc/redis/redis-sentinel.conf&quot;]</span><br><span class="line">  redis-sentinel-2:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-sentinel-2</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 26380:26379</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        ipv4_address: 10.1.0.6</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span><br><span class="line">      - ../data/redis-sentinel-2:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-sentinel&quot;, &quot;/usr/local/etc/redis/redis-sentinel.conf&quot;]</span><br><span class="line">  redis-sentinel-3:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-sentinel-3</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 26381:26379</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        ipv4_address: 10.1.0.7</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span><br><span class="line">      - ../data/redis-sentinel-3:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-sentinel&quot;, &quot;/usr/local/etc/redis/redis-sentinel.conf&quot;]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      # 因为哨兵容器需要与服务端容器运行在同一网络内</span><br><span class="line">      # 所以这里指定了一个外部的网络</span><br><span class="line">      # 网络名参考《使用Docker配置Redis主从复制》中的注释</span><br><span class="line">      name: server_redis-cluster</span><br></pre></td></tr></table></figure><p>启动容器<br>这里同样使用 docker-compose up -d 启动容器，然后使用 redis-cli 连接到哨兵节点，连接成功后，可以使用 info sentinel 检查哨兵的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379&gt; info sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=local-master,status=ok,address=10.1.0.2:6379,slaves=2,sentinels=1</span><br></pre></td></tr></table></figure><p>其中，sentinel_masters:1 说明这个哨兵在监控一个 master，最后一行中写明了 master0 这个节点别名为 local-master，状态为 OK，地址是 10.1.0.2:6379，有 2 个从节点。</p><h2 id="测试一下"><a class="markdownIt-Anchor" href="#测试一下"></a> 测试一下</h2><p>哨兵光是启动了还是不够的，还需要测试一下当被监控节点下线之后，哨兵是否能作出反应。</p><p>首先，停掉 master，slave-1，slave-2，然后观察哨兵的日志，在经过一段时间之后，哨兵宣布有节点下线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:13.581 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:13.582 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:14.429 # +sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:14.439 # +sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:14.470 # +sdown master local-master 10.1.0.2 6379</span><br></pre></td></tr></table></figure><p>然后再启动 master，slave-1，slave-2，并观察哨兵的日志，在节点上线之后，哨兵宣布了节点重启，并解除了节点的下线状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.040 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.082 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.140 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.141 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.231 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.960 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.963 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:46.043 # -sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:46.046 # -sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:46.054 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:46.144 # -sdown master local-master 10.1.0.2 6379</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;p&gt;Redis is an “advanced key-value store”&lt;/p&gt;
&lt;h2 id=&quot;redis-data-types&quot;&gt;&lt;a class=
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[100]-jaeger</title>
    <link href="https://dreamerjonson.com/2019/11/04/golang-100-jaeger/"/>
    <id>https://dreamerjonson.com/2019/11/04/golang-100-jaeger/</id>
    <published>2019-11-04T09:33:50.000Z</published>
    <updated>2019-11-05T14:54:56.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jaeger"><a class="markdownIt-Anchor" href="#jaeger"></a> jaeger</h2><p>1、jaeger是uber公司开发的一种链路追踪工具，是为了应对当前微服务的架构而设计。<br>2、jaeger是opentracing协议的一种实现，opentracing对链路追踪定义了协议。</p><p>要使用jaeger的第一步是搭建jager服务</p><h2 id="docker安装jaeger-server"><a class="markdownIt-Anchor" href="#docker安装jaeger-server"></a> docker安装jaeger server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --rm \</span><br><span class="line">  -p 6831:6831/udp \</span><br><span class="line">  -p 6832:6832/udp \</span><br><span class="line">  -p 16686:16686 \</span><br><span class="line">  jaegertracing/all-in-one:1.7 \</span><br><span class="line">  --log-level=debug</span><br></pre></td></tr></table></figure><h2 id="ui界面"><a class="markdownIt-Anchor" href="#ui界面"></a> UI界面</h2><p><a href="http://localhost:16686/" target="_blank" rel="noopener">http://localhost:16686/</a></p><h2 id="jaeger的使用"><a class="markdownIt-Anchor" href="#jaeger的使用"></a> jaeger的使用</h2><p>trace： 需要首先初始化trace，trace可以理解为span构成的有向无环图。<br>span： span是具体业务的一种抽象<br>A trace is a directed acyclic graph of spans.<br>A span is a logical representation of some work done in your application.<br>Each span has these minimum attributes: an operation name, a start time, and a finish time.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tp, error := jaeger.NewUDPTransport(cfg.JaegerUrl, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"jaeger NewUDPTransport error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">tracer, <span class="built_in">close</span> := jaeger.NewTracer(</span><br><span class="line">serviceName,</span><br><span class="line">jaeger.NewConstSampler(<span class="literal">true</span>),</span><br><span class="line">jaeger.NewRemoteReporter(tp),</span><br><span class="line">jaeger.TracerOptions.MaxTagValueLength(<span class="number">1024</span>),</span><br><span class="line">)</span><br><span class="line">cl.AppendCloser(<span class="built_in">close</span>)</span><br><span class="line">opentracing.InitGlobalTracer(tracer)</span><br></pre></td></tr></table></figure><p>可以通过多种方式创建jaeger，StartSpan(serviceName)创建一个root span<br>我们也可以通过下面的方法创建一个child span。child span 可以理解为父节点的子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartSpanFromContext、</span><br><span class="line">opentracing.GlobalTracer().StartSpan(req.Method(), ext.RPCServerOption(spCtx))</span><br></pre></td></tr></table></figure><h3 id="jaeger要实现不同程序之间的链路关系需要主动推送信息到server"><a class="markdownIt-Anchor" href="#jaeger要实现不同程序之间的链路关系需要主动推送信息到server"></a> jaeger要实现不同程序之间的链路关系，需要主动推送信息到server</h3><p>In order to continue the trace over the process boundaries and RPC calls, we need a way to propagate the span context over the wire. The OpenTracing API provides two functions in the Tracer interface to do that, Inject(spanContext, format, carrier) and Extract(format, carrier).</p><p>format 和 carrier 就是附带的一些参数，这些参数会被下一个程序接收到。<br>format是这些参数的格式，在openntraceing中有3个标准的格式。<br>The format parameter refers to one of the three standard encodings the OpenTracing API defines:<br>TextMap where span context is encoded as a collection of string key-value pairs,<br>Binary where span context is encoded as an opaque byte array,<br>HTTPHeaders, which is similar to TextMap except that the keys must be safe to be used as HTTP headers.<br>carrier是附带的内容<br>The carrier is an abstraction over the underlying RPC framework. For example, a carrier for TextMap format is an interface that allows the tracer to write key-value pairs via Set(key, value) function, while a carrier for Binary format is simply an io.Writer.</p><h3 id="extract"><a class="markdownIt-Anchor" href="#extract"></a> Extract</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">carrier := opentracing.TextMapCarrier(md)</span><br><span class="line">clientContext, err := tracer.Extract(opentracing.TextMap, carrier)</span><br></pre></td></tr></table></figure><h3 id="inject"><a class="markdownIt-Anchor" href="#inject"></a> Inject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := make(map[string]string)</span><br><span class="line">carrier := opentracing.TextMapCarrier(hash)</span><br><span class="line">e := tracer.Inject(</span><br><span class="line">sp.Context(),</span><br><span class="line">opentracing.TextMap,</span><br><span class="line">carrier)</span><br></pre></td></tr></table></figure><p>在golang中，大量使用了context来进行操作。 在golang实现的jaeger客户端和opentracing中，需要注意span与context的大量api。<br>例如StartSpanFromContext会从context中读取父节点，并生成一个子节点。<br>在opentracing.StartSpan中</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> example</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/log"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"ERROR: Expecting one argument"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer := tracing.Init(<span class="string">"hello-world"</span>)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"></span><br><span class="line">helloTo := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">span := tracer.StartSpan(<span class="string">"say-hello"</span>)</span><br><span class="line">span.SetTag(<span class="string">"hello-to"</span>, helloTo)</span><br><span class="line"></span><br><span class="line">helloStr := fmt.Sprintf(<span class="string">"Hello, %s!"</span>, helloTo)</span><br><span class="line">span.LogFields(</span><br><span class="line">log.String(<span class="string">"event"</span>, <span class="string">"string-format"</span>),</span><br><span class="line">log.String(<span class="string">"value"</span>, helloStr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(helloStr)</span><br><span class="line">span.LogKV(<span class="string">"event"</span>, <span class="string">"println"</span>)</span><br><span class="line"></span><br><span class="line">span.Finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-子关系的span"><a class="markdownIt-Anchor" href="#2-子关系的span"></a> 2、子关系的span</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go"</span></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/log"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"ERROR: Expecting one argument"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer := tracing.Init(<span class="string">"hello-world"</span>)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br><span class="line"></span><br><span class="line">helloTo := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">span := tracer.StartSpan(<span class="string">"say-hello"</span>)</span><br><span class="line">span.SetTag(<span class="string">"hello-to"</span>, helloTo)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">ctx := opentracing.ContextWithSpan(context.Background(), span)</span><br><span class="line"></span><br><span class="line">helloStr := formatString(ctx, helloTo)</span><br><span class="line">printHello(ctx, helloStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StartSpanFromContext 建立一个span，是父亲节点的一个child。</span></span><br><span class="line"><span class="comment">// If we think of the trace as a directed acyclic graph where nodes are the spans and edges are the causal relationships between them, then the ChildOf option is used to create one such edge between span and rootSpan. In the API the edges are represented by SpanReference type that consists of a SpanContext and a label. The SpanContext represents an immutable, thread-safe portion of the span that can be used to establish references or to propagate it over the wire. The label, or ReferenceType, describes the nature of the relationship. ChildOf relationship means that the rootSpan has a logical dependency on the child span before rootSpan can complete its operation. Another standard reference type in OpenTracing is FollowsFrom, which means the rootSpan is the ancestor in the DAG, but it does not depend on the completion of the child span, for example if the child represents a best-effort, fire-and-forget cache write.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatString</span><span class="params">(ctx context.Context, helloTo <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"formatString"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">helloStr := fmt.Sprintf(<span class="string">"Hello, %s!"</span>, helloTo)</span><br><span class="line">span.LogFields(</span><br><span class="line">log.String(<span class="string">"event"</span>, <span class="string">"string-format"</span>),</span><br><span class="line">log.String(<span class="string">"value"</span>, helloStr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> helloStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(ctx context.Context, helloStr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"printHello"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(helloStr)</span><br><span class="line">span.LogKV(<span class="string">"event"</span>, <span class="string">"println"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-模拟rpc-跨程序进行追踪"><a class="markdownIt-Anchor" href="#3-模拟rpc-跨程序进行追踪"></a> 3、 模拟rpc， 跨程序进行追踪。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先启动publisher与formatter，接着执行master</span><br></pre></td></tr></table></figure><p>master</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go"</span></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/ext"</span></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/log"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/http"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"ERROR: Expecting one argument"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer := tracing.Init(<span class="string">"hello-world"</span>)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br><span class="line"></span><br><span class="line">helloTo := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">span := tracer.StartSpan(<span class="string">"say-hello"</span>)</span><br><span class="line">span.SetTag(<span class="string">"hello-to"</span>, helloTo)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">ctx := opentracing.ContextWithSpan(context.Background(), span)</span><br><span class="line"></span><br><span class="line">helloStr := formatString(ctx, helloTo)</span><br><span class="line">printHello(ctx, helloStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatString</span><span class="params">(ctx context.Context, helloTo <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"formatString"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">v := url.Values&#123;&#125;</span><br><span class="line">v.Set(<span class="string">"helloTo"</span>, helloTo)</span><br><span class="line">url := <span class="string">"http://localhost:8081/format?"</span> + v.Encode()</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext.SpanKindRPCClient.Set(span)</span><br><span class="line">ext.HTTPUrl.Set(span, url)</span><br><span class="line">ext.HTTPMethod.Set(span, <span class="string">"GET"</span>)</span><br><span class="line">span.Tracer().Inject(</span><br><span class="line">span.Context(),</span><br><span class="line">opentracing.HTTPHeaders,</span><br><span class="line">opentracing.HTTPHeadersCarrier(req.Header),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">resp, err := xhttp.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">helloStr := <span class="keyword">string</span>(resp)</span><br><span class="line"></span><br><span class="line">span.LogFields(</span><br><span class="line">log.String(<span class="string">"event"</span>, <span class="string">"string-format"</span>),</span><br><span class="line">log.String(<span class="string">"value"</span>, helloStr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> helloStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(ctx context.Context, helloStr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"printHello"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">v := url.Values&#123;&#125;</span><br><span class="line">v.Set(<span class="string">"helloStr"</span>, helloStr)</span><br><span class="line">url := <span class="string">"http://localhost:8082/publish?"</span> + v.Encode()</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext.SpanKindRPCClient.Set(span)</span><br><span class="line">ext.HTTPUrl.Set(span, url)</span><br><span class="line">ext.HTTPMethod.Set(span, <span class="string">"GET"</span>)</span><br><span class="line">span.Tracer().Inject(span.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := xhttp.Do(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>formatter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">opentracing &quot;github.com/opentracing/opentracing-go&quot;</span><br><span class="line">&quot;github.com/opentracing/opentracing-go/ext&quot;</span><br><span class="line">otlog &quot;github.com/opentracing/opentracing-go/log&quot;</span><br><span class="line">&quot;github.com/yurishkuro/opentracing-tutorial/go/lib/tracing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">tracer, closer := tracing.Init(&quot;formatter&quot;)</span><br><span class="line">defer closer.Close()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(&quot;/format&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">spanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))</span><br><span class="line">span := tracer.StartSpan(&quot;format&quot;, ext.RPCServerOption(spanCtx))</span><br><span class="line">defer span.Finish()</span><br><span class="line"></span><br><span class="line">helloTo := r.FormValue(&quot;helloTo&quot;)</span><br><span class="line">helloStr := fmt.Sprintf(&quot;Hello, %s!&quot;, helloTo)</span><br><span class="line">span.LogFields(</span><br><span class="line">otlog.String(&quot;event&quot;, &quot;string-format&quot;),</span><br><span class="line">otlog.String(&quot;value&quot;, helloStr),</span><br><span class="line">)</span><br><span class="line">w.Write([]byte(helloStr))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(&quot;:8081&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>publisher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">opentracing &quot;github.com/opentracing/opentracing-go&quot;</span><br><span class="line">&quot;github.com/opentracing/opentracing-go/ext&quot;</span><br><span class="line">&quot;github.com/yurishkuro/opentracing-tutorial/go/lib/tracing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">tracer, closer := tracing.Init(&quot;publisher&quot;)</span><br><span class="line">defer closer.Close()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(&quot;/publish&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">spanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))</span><br><span class="line">span := tracer.StartSpan(&quot;publish&quot;, ext.RPCServerOption(spanCtx))</span><br><span class="line">defer span.Finish()</span><br><span class="line"></span><br><span class="line">helloStr := r.FormValue(&quot;helloStr&quot;)</span><br><span class="line">println(helloStr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(&quot;:8082&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>jaeger github ：<a href="http://github.com/uber/jaeger-client-go" target="_blank" rel="noopener">github.com/uber/jaeger-client-go</a><br>opentracing   ：<a href="http://github.com/opentracing/opentracing-go" target="_blank" rel="noopener">github.com/opentracing/opentracing-go</a><br>tutorial：      <a href="http://github.com/yurishkuro/opentracing-tutorial" target="_blank" rel="noopener">github.com/yurishkuro/opentracing-tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jaeger&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jaeger&quot;&gt;&lt;/a&gt; jaeger&lt;/h2&gt;
&lt;p&gt;1、jaeger是uber公司开发的一种链路追踪工具，是为了应对当前微服务的架构而设计。&lt;br&gt;
2、jaeger是op
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>emacs-studynode</title>
    <link href="https://dreamerjonson.com/2019/10/29/emacs-studynode/"/>
    <id>https://dreamerjonson.com/2019/10/29/emacs-studynode/</id>
    <published>2019-10-29T02:03:35.000Z</published>
    <updated>2019-11-19T06:25:15.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="quit-emacs"><a class="markdownIt-Anchor" href="#quit-emacs"></a> QUIT EMACS</h2><p>To quit Emacs, press: <control-x> <control-c>. (Be sure to use <control>,<br>not <command> .)</control></control-c></control-x></p><h2 id="在item2中设置meta键"><a class="markdownIt-Anchor" href="#在item2中设置meta键"></a> 在item2中设置meta键</h2><h3 id="开启"><a class="markdownIt-Anchor" href="#开启"></a> 开启</h3><p>emacs</p><h3 id="开启-不显示splash-screen"><a class="markdownIt-Anchor" href="#开启-不显示splash-screen"></a> 开启-不显示splash screen</h3><p>emacs -Q</p><h3 id="开启特定的文件"><a class="markdownIt-Anchor" href="#开启特定的文件"></a> 开启特定的文件</h3><p>emacs XXX<br>emacs -Q XXX</p><h2 id="stopping-emacs"><a class="markdownIt-Anchor" href="#stopping-emacs"></a> Stopping Emacs</h2><p>C-x C-c</p><h2 id="save-files"><a class="markdownIt-Anchor" href="#save-files"></a> save files</h2><p>press y to save and n to not <a href="http://save.To" target="_blank" rel="noopener">save.To</a> save all of the files at once and then quit, press ! (exclamation mark). To quit<br>immediately, without saving anything more, press q . To save the current file only, but<br>quit without saving anything else, press . (period).</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>c-p  previous-line<br>c-n next-line<br>c-f 向后移动一个字符<br>M-f  向后移动一个word<br>C-x C-b   display a list of all your buffers<br>C-x h C-w .清空buffer ( C-x h selects the entire buffer; C-w erases the<br>selection.)<br>C-g 退出指令<br>C-x k kills (deletes) the current buffer</p><p>C-x b  Switch to buffer</p><p>C-x 0 (the number zero). This tells Emacs to kill (get rid of) the selected window<br>C-v to scroll down one screenful<br>M-v to scroll up one screenful<br>M-x 输入命令<br>C-d 消除右边得一个字符<br>C-o open the new line</p><p>C-k   删除后面的所有字符<br>Here are the details for using C-o . If you are at the beginning of a line, C-o<br>creates a new, empty line above the current line. If you are at the end of a line, C-o<br>creates a new, empty line below the current line. If you are within a line, C-o breaks it<br>into two separate lines</p><p>To insert one of these characters into your text, first press C-q . This tells Emacs<br>that the next character is to be taken literally. (Think of the q as meaning “quote”; that<br>is, to take the next key you type literally.) Thus, to insert a <ctrl-c> character, type<br>C-q C-c . To insert a <ctrl-q>, type C-q C-q . To insert a tab, use C-q TAB</ctrl-q></ctrl-c></p><p>C-x BS delete from the current position, backwards, to the beginning of the sentence.(从当前点删到尾)</p><h2 id="撤销-反撤销"><a class="markdownIt-Anchor" href="#撤销-反撤销"></a> 撤销 &amp; 反撤销</h2><p>C-x u  撤销<br>C--  撤销<br>C-/  撤销<br>在撤销的时候如果撤销多了需要进行反撤销<br>具体是用C-f等打断当前撤销操作，接着进行的撤销动作就是反撤销。<br>C-x z 重复之前的操作 重复多次可以只按zzzz</p><h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2><p>C-x 0  delete the select window<br>C-x 1  delete all windows excpet select window<br>C-x 2 Split select window verticall<br>C-x 3 Split select window horizontally<br>C-x o move cursor to the next (other) Windows<br>C-x } Make selected windows wider<br>C-x { Make selected windows narrower<br>C-x ^ Make selected windows narrower</p><h2 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> buffer</h2><p>C-x b When you press C-x b , Emacs will wait for you to enter the name of the buffer with<br>which you want to work. If this buffer already exists, Emacs will just move it into the<br>window. Otherwise, Emacs will create a brand new empty buffer in the window using<br>the name you specified. Thus, C-x b is the command to use when you want to create a<br>new buffer.<br>C-x 4 b tells Emacs to display whichever buffer you specify in a different window<br>C-x 4 C-o command. This is similar to the C-x 4 b command, except that the selected window does not change<br>C-x k  kill a buffer</p><h2 id="file"><a class="markdownIt-Anchor" href="#file"></a> file</h2><p>C-x C-f 打开一个文件的buffer<br>C-x C-v replace buffer contents with specified file<br>C-x C-s Save a buffer to file<br>C-x C-w Save a buffer to special file<br>C-x i insert contents of a file into buffer 把文件插入到此buffer中<br>C-x 4 C-f read a file into next window<br>C-x 4 f   same as C-x 4 C-f<br>C-x 4 r  same as C-x 4 C-f read-only</p><h2 id="cursor"><a class="markdownIt-Anchor" href="#cursor"></a> cursor</h2><p>C-f 后一个字符   C-b  前一个字符<br>M-f 后一个word   M-b 前一个word<br>C-p 前一line    C-n 后一line<br>M-a            M-e    sentence  ？<br>M-{            M-}    paragraph 空格分隔段落<br>C-a            C-e  当前行</p><h2 id="重复一个命令多次"><a class="markdownIt-Anchor" href="#重复一个命令多次"></a> 重复一个命令多次</h2><p>M-number C-p   重复一个命令多次<br>C-u number   重复一个命令多次<br>C-u    repeat the command 4 times<br>C-u C-u    repeat the command 16 times<br>C-u C-u C-u    repeat the command 64 times</p><h2 id="scroll"><a class="markdownIt-Anchor" href="#scroll"></a> scroll</h2><p>C-v scroll down<br>M-v scroll up<br>M-C-v scroll down in next windows<br>M- &lt;  jump to start of the buffer<br>M- &gt;  jump to end of the buffer<br>C-l 将当前行放置在屏幕的中间。<br>M-g g 跳到指定行<br>M-x line-number-mode toggle miinbuf下方显示行</p><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h2><p>C-SPC  标记<br>M-= 统计字符多少<br>C-x C-x  curson到mark的位置。 再次按C-x C-x 交换位置<br>M-@ 设置当前curson的单词末尾<br>M-number M-@ 设置当前curson的number个word后<br>M-h Put region arounnd paragraph<br>C-x h Put region arounnd entire buffer</p><h2 id="operating-the-region"><a class="markdownIt-Anchor" href="#operating-the-region"></a> operating the region</h2><p>C-w kill all the characters<br>C-x C-l Convert the characters to lower<br>C-x C-u Convert the characters to lower<br>M-=   count<br>M-|    Run the shell command use the characters as data    example:M -| sort -u</p><h2 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h2><p>delete不会保存</p><p>ESC number<br>M-:<br>删除空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To continue, the M-\ (&lt;Meta-Backslash&gt;) command erases any space or tab</span><br><span class="line">characters that happen to be on either side of point. This command provides a quick</span><br><span class="line">way to clean up a section of whitespace. For example, say that you have typed the</span><br><span class="line">following text and the cursor is under one of the spaces between tea and ch :</span><br><span class="line">Everything we tea ch you is true.</span><br><span class="line">If you press M-\ , Emacs will erase all the surrounding spaces. The line now</span><br><span class="line">looks like:</span><br><span class="line">Everything we teach you is true.</span><br></pre></td></tr></table></figure><p>M-SPC： 删除空格 保留一个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The M-SPC (&lt;Meta-Space&gt;) command is similar, except that it leaves exactly</span><br><span class="line">one space. Here is an example. You have just typed the line:</span><br><span class="line">The sentence above is only partially correct.</span><br><span class="line">You would like to erase the extra spaces. Move the cursor to one of the spaces</span><br><span class="line">between is and only and press M-SPC . The line is changed to the following:</span><br><span class="line">The sentence above is only partially correct.</span><br></pre></td></tr></table></figure><p>C-x C-o:<br>删除紧临的空行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The C-x C-o command performs the analogous operation for blank lines</span><br></pre></td></tr></table></figure><p>M-^<br>合并到一行，注意curson要放在第二行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Finally, the M-^ command joins two lines into one long one. This command</span><br><span class="line">joins the current line to the one immediately above it, while leaving a single space</span><br><span class="line">between the two groups of text. Any extra spaces (at the end of the first line or at</span><br><span class="line">the beginning of the second line) are removed. For example, say that you have the</span><br><span class="line">following lines of text:</span><br><span class="line">This is the first sentence.</span><br><span class="line">This is the second sentence.</span><br><span class="line">You want to join these two lines. Move the cursor to the second line and press M-^ .</span><br><span class="line">You will now have one long line:</span><br><span class="line">This is the first sentence. This is the second sentence.</span><br><span class="line">The cursor will be at the place where the lines were joined, in this case, at the space</span><br><span class="line">between the two sentences.</span><br></pre></td></tr></table></figure><h2 id="kill-text"><a class="markdownIt-Anchor" href="#kill-text"></a> Kill Text</h2><p>会保留删除的文本<br>C-k     删除后面的文本<br>M-d    kill word<br>M-BS   kill word Forward<br>C-w    kill the region<br>M-z    char</p><p>To erase an entire line: if you are at the beginning of the line, press C -k C-k . If you<br>are not at the beginning of the line, press C-a C-k C-k .</p><h2 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> COPY</h2><p>C-y yank most recently killed text<br>C-u C-y same as .  curson at the beging<br>M-y replace the yank test with previous killed Text<br>M-w Copy region to kill ring,without erasing<br>M-C-W Apend next kill to newest kill ring entry</p><h2 id="correcting"><a class="markdownIt-Anchor" href="#correcting"></a> correcting</h2><p>M - BS  kill the previous word<br>C-x BS kill backwards to beginning of sentence<br>M–M-l change previous word to lower<br>M–M-u change previous word to upper<br>M–M-c change previous word to lower,initial cap<br>M-l change follow  word to lower<br>M-u change follow  word to upper<br>M-c change follow word to lower,initial Cap<br>ESC 10 M-- M-c chage many times<br>C-t transport two adjaent charactors<br>M-t transport two adjaent words<br>C-x C-t transport two adjaen lin</p><h2 id="search"><a class="markdownIt-Anchor" href="#search"></a> search</h2><p>C-s  foword: Incremental search<br>C-s RET foword: no-Incremental search<br>M-s w Foward Non-increment word search<br>M-C-s foword: Incremental regexp  search<br>M-C-s RET  foword: No-Incremental regexp  search</p><p>The basic type of Emacs search is called an INCREMENTAL SEARCH. That<br>means Emacs starts searching as soon as you type a single character. With each<br>character you type, Emacs refines its search.</p><p>C-r  foword: Incremental search<br>C-r RET foword: no-Incremental search<br>M-r w Foward Non-increment word search<br>M-C-r foword: Incremental regexp  search<br>M-C-r  foword: No-Incremental regexp  search</p><p>when you searchig:<br>C-s if you do again . search next<br>C-r  same as<br>C-w Copy the word afer point to search string<br>C-y Copy  kill ring  afer point to search string<br>M-y replace next kill ring</p><h2 id="replace"><a class="markdownIt-Anchor" href="#replace"></a> replace</h2><p>M - %  search and replace<br>M-C- % search and replace regexp<br>M-x replace-string<br>M-x replace-regexp</p><p>• SPC (<space>) to make a replacement and continue.<br>• BS (<backspace>) to skip a replacement and continue.<br>• ! (exclamation mark) to make all the rest of the replacements automatically with<br>no more questions.<br>• RET (<enter>) to quit immediately<br>M-x replace-string makes all the replacements automatically without<br>asking you any questions.</enter></backspace></space></p><p>M-x replace-regexp makes all the replacements automatically, while<br>allowing you to use a regular expression for the search pattern.</p><h2 id="recursive-editing"><a class="markdownIt-Anchor" href="#recursive-editing"></a> Recursive Editing</h2><p>C-r  when you searing and  want interrupt to do other things<br>M-C-c This will stop recursive editing and return you to the search and replace operation, exactly where you left off.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;quit-emacs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#quit-emacs&quot;&gt;&lt;/a&gt; QUIT EMACS&lt;/h2&gt;
&lt;p&gt;To quit Emacs, press: &lt;control-x&gt; &lt;control-c&gt;. (
      
    
    </summary>
    
      <category term="mac" scheme="https://dreamerjonson.com/categories/mac/"/>
    
    
      <category term="mac" scheme="https://dreamerjonson.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>mac item2-skill</title>
    <link href="https://dreamerjonson.com/2019/10/28/item2-skill/"/>
    <id>https://dreamerjonson.com/2019/10/28/item2-skill/</id>
    <published>2019-10-28T09:55:13.000Z</published>
    <updated>2019-10-28T10:26:50.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="item2技巧"><a class="markdownIt-Anchor" href="#item2技巧"></a> item2技巧</h2><p>清屏1command + r<br>清屏2ctrl + l<br>删除到文本末尾ctrl + k<br>搜索命令历史ctrl + r<br>清除当前行ctrl + u</p><p>可定制化Hotkey, 一键召出iTerm2 (不再需要⌘+Tab 或者 通过spotlight切换)<br>快捷的组合键<br>⌘+Shift+E 召唤时间线<br>⌘+Option+b 时光机<br>⌘+T 新Tab<br>⌘+D 水平分屏<br>⌘+← 切换Tab / ⌘+shift+← 切换分屏<br>关闭panel：⌘ + w</p><p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次还原</p><p>按下 Command + T 可以新建一个 Tab，每个标签页的后面都会标记一个序号，通过 Command + 序号 就可以在多个页面之间切换了，或者用 Command + [ 和 Command + ] 来切换到左侧或者右侧的标签页。</p><p>同一个 Tab 内，还可以切分出多个 Pane，有两种切分方式：</p><p>Command + D：水平切分，切分出一左一右两个 Pane<br>Command + Shift + D：垂直切分，切分出一上一下两个 Pane<br>通过 Command + Ctrl + 方向键 可以调整每个 Pane 的大小，通过 Command + Option + 方向键 可以切换 Pane。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;item2技巧&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#item2技巧&quot;&gt;&lt;/a&gt; item2技巧&lt;/h2&gt;
&lt;p&gt;清屏1	command + r&lt;br&gt;
清屏2	ctrl + l&lt;br&gt;
删除到文本末尾	ctrl + k&lt;br&gt;
      
    
    </summary>
    
      <category term="mac" scheme="https://dreamerjonson.com/categories/mac/"/>
    
    
      <category term="mac" scheme="https://dreamerjonson.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>golang[99]-mapReduce</title>
    <link href="https://dreamerjonson.com/2019/10/28/golang-99-mapReduce/"/>
    <id>https://dreamerjonson.com/2019/10/28/golang-99-mapReduce/</id>
    <published>2019-10-28T04:09:25.000Z</published>
    <updated>2019-10-28T06:19:26.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mapreduce简介"><a class="markdownIt-Anchor" href="#mapreduce简介"></a> mapReduce简介</h2><p>MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。概念“Map（映射）”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。<br>当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><p>上面的说法来自维基百科，mapReduce作为一个成熟、可靠、简单、高效的分布式架构，可以在并行计算上提供超强悍的性能。</p><h2 id="抽象表示"><a class="markdownIt-Anchor" href="#抽象表示"></a> 抽象表示</h2><p>map (k1,v1) → list(k2,v2)<br>reduce (k2,list(v2)) → list(v2)</p><h2 id="示意图"><a class="markdownIt-Anchor" href="#示意图"></a> 示意图</h2><img src="/2019/10/28/golang-99-mapReduce/mapreduce.png" title="deploy"><p>如上图所示是一个mapReduce模型的示意图，Input files 代表原始数据， Output files 代表最后输出的数据。<br>worker 既可以执行map,也可以执行reduce,具体依赖master的分配。<br>在输入输出之间，经历了两个过程。一个是map  一个是reduce。<br>map的过程是将一个复杂的问题 处理后转换为许多个小文件。例如map是对原始数据按照某种规律进行分类。 a类一个文件，b类一个文件…<br>reduce是对一个分类的问题进行计算的过程。<br>master是主调度器，例如将map生成的a类文件交由reduce worker去处理。而reduce函数处理的可能就是对a类文件中所有数据进行汇总。</p><h2 id="example-伪代码"><a class="markdownIt-Anchor" href="#example-伪代码"></a> example 伪代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">// key: document name</span><br><span class="line">// value: document contents</span><br><span class="line">for each word w in value:</span><br><span class="line">EmitIntermediate(w, &quot;1&quot;);</span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">// key: a word</span><br><span class="line">// values: a list of counts</span><br><span class="line">int result = 0;</span><br><span class="line">for each v in values:</span><br><span class="line">result += ParseInt(v);</span><br><span class="line">Emit(AsString(result));</span><br></pre></td></tr></table></figure><h2 id="golang简单实现"><a class="markdownIt-Anchor" href="#golang简单实现"></a> golang简单实现</h2><h3 id="master"><a class="markdownIt-Anchor" href="#master"></a> master</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Master holds all the state that the master needs to keep track of.</span></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line"></span><br><span class="line">address     <span class="keyword">string</span></span><br><span class="line">doneChannel <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// protected by the mutex</span></span><br><span class="line">newCond *sync.Cond <span class="comment">// signals when Register() adds to workers[]</span></span><br><span class="line">workers []<span class="keyword">string</span>   <span class="comment">// each worker's UNIX-domain socket name -- its RPC address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-task information</span></span><br><span class="line">jobName <span class="keyword">string</span>   <span class="comment">// Name of currently executing job</span></span><br><span class="line">files   []<span class="keyword">string</span> <span class="comment">// Input files</span></span><br><span class="line">nReduce <span class="keyword">int</span>      <span class="comment">// Number of reduce partitions</span></span><br><span class="line"></span><br><span class="line">shutdown <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">l        net.Listener</span><br><span class="line">stats    []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="master的-rpc方法-注册worker"><a class="markdownIt-Anchor" href="#master的-rpc方法-注册worker"></a> master的 rpc方法 注册worker</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register is an RPC method that is called by workers after they have started</span></span><br><span class="line"><span class="comment">// up to report that they are ready to receive tasks.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *Master)</span> <span class="title">Register</span><span class="params">(args *RegisterArgs, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">mr.Lock()</span><br><span class="line"><span class="keyword">defer</span> mr.Unlock()</span><br><span class="line">debug(<span class="string">"Register: worker %s\n"</span>, args.Worker)</span><br><span class="line">mr.workers = <span class="built_in">append</span>(mr.workers, args.Worker)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tell forwardRegistrations() that there's a new workers[] entry.</span></span><br><span class="line">mr.newCond.Broadcast()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="master-schedule-调度"><a class="markdownIt-Anchor" href="#master-schedule-调度"></a> master schedule 调度。</h3><p>1、维护是否有任务 以及 空闲worker<br>2、调用失败会分配给其他worker</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// schedule() starts and waits for all tasks in the given phase (Map</span></span><br><span class="line"><span class="comment">// or Reduce). the mapFiles argument holds the names of the files that</span></span><br><span class="line"><span class="comment">// are the inputs to the map phase, one per map task. nReduce is the</span></span><br><span class="line"><span class="comment">// number of reduce tasks. the registerChan argument yields a stream</span></span><br><span class="line"><span class="comment">// of registered workers; each item is the worker's RPC address,</span></span><br><span class="line"><span class="comment">// suitable for passing to call(). registerChan will yield all</span></span><br><span class="line"><span class="comment">// existing registered workers (if any) and new ones as they register.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line">ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">n_other = nReduce</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line">ntasks = nReduce</span><br><span class="line">n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// All ntasks tasks have to be scheduled on workers, and only once all of</span></span><br><span class="line"><span class="comment">// them have been completed successfully should the function return.</span></span><br><span class="line"><span class="comment">// Remember that workers may fail, and that any given worker may finish</span></span><br><span class="line"><span class="comment">// multiple tasks.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// schedule will wait until all worker has done their jobs</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC call parameter</span></span><br><span class="line"><span class="keyword">var</span> task DoTaskArgs</span><br><span class="line">task.JobName = jobName</span><br><span class="line">task.NumOtherPhase = n_other</span><br><span class="line">task.Phase = phase</span><br><span class="line"></span><br><span class="line"><span class="comment">// task id will get from this channel</span></span><br><span class="line"><span class="keyword">var</span> taskChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">taskChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait all workers have done their job, then close taskChan</span></span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(taskChan)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign all task to worker</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> taskChan &#123;</span><br><span class="line"><span class="comment">// get a worker from register channel</span></span><br><span class="line">worker := &lt;-registerChan</span><br><span class="line"></span><br><span class="line">task.TaskNumber = i</span><br><span class="line"><span class="keyword">if</span> phase == mapPhase &#123;</span><br><span class="line">task.File = mapFiles[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: must use parameter</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(worker <span class="keyword">string</span>, task DoTaskArgs)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> call(worker, <span class="string">"Worker.DoTask"</span>, &amp;task, <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="comment">// only successful call will call wg.Done()</span></span><br><span class="line">wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="comment">// put idle worker back to register channel</span></span><br><span class="line">registerChan &lt;- worker;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Schedule: assign %s task %v to %s failed"</span>, phase,</span><br><span class="line">task.TaskNumber, worker)</span><br><span class="line"></span><br><span class="line"><span class="comment">// put failed task back to task channel</span></span><br><span class="line">taskChan &lt;- task.TaskNumber</span><br><span class="line">&#125;</span><br><span class="line">&#125;(worker, task)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v phase done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="worker"><a class="markdownIt-Anchor" href="#worker"></a> worker</h3><p>worker是一个rpc服务，DoTask is called by the master when a new task is being scheduled on this worker.<br>worker可以是map worker  也可以是reduce worker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Worker holds the state for a server waiting for DoTask or Shutdown RPCs</span><br><span class="line">type Worker struct &#123;</span><br><span class="line">sync.Mutex</span><br><span class="line"></span><br><span class="line">name       string</span><br><span class="line">Map        func(string, string) []KeyValue</span><br><span class="line">Reduce     func(string, []string) string</span><br><span class="line">nRPC       int // quit after this many RPCs; protected by mutex</span><br><span class="line">nTasks     int // total tasks executed; protected by mutex</span><br><span class="line">concurrent int // number of parallel DoTasks in this worker; mutex</span><br><span class="line">l          net.Listener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DoTask is called by the master when a new task is being scheduled on this</span><br><span class="line">// worker.</span><br><span class="line">func (wk *Worker) DoTask(arg *DoTaskArgs, _ *struct&#123;&#125;) error &#123;</span><br><span class="line">fmt.Printf(&quot;%s: given %v task #%d on file %s (nios: %d)\n&quot;,</span><br><span class="line">wk.name, arg.Phase, arg.TaskNumber, arg.File, arg.NumOtherPhase)</span><br><span class="line"></span><br><span class="line">wk.Lock()</span><br><span class="line">wk.nTasks += 1</span><br><span class="line">wk.concurrent += 1</span><br><span class="line">nc := wk.concurrent</span><br><span class="line">wk.Unlock()</span><br><span class="line"></span><br><span class="line">if nc &gt; 1 &#123;</span><br><span class="line">// schedule() should never issue more than one RPC at a</span><br><span class="line">// time to a given worker.</span><br><span class="line">log.Fatal(&quot;Worker.DoTask: more than one DoTask sent concurrently to a single worker\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch arg.Phase &#123;</span><br><span class="line">case mapPhase:</span><br><span class="line">doMap(arg.JobName, arg.TaskNumber, arg.File, arg.NumOtherPhase, wk.Map)</span><br><span class="line">case reducePhase:</span><br><span class="line">doReduce(arg.JobName, arg.TaskNumber, mergeName(arg.JobName, arg.TaskNumber), arg.NumOtherPhase, wk.Reduce)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wk.Lock()</span><br><span class="line">wk.concurrent -= 1</span><br><span class="line">wk.Unlock()</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%s: %v task #%d done\n&quot;, wk.name, arg.Phase, arg.TaskNumber)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的mapreduce实现"><a class="markdownIt-Anchor" href="#简单的mapreduce实现"></a> 简单的mapreduce实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduceName constructs the name of the intermediate file which map task</span></span><br><span class="line"><span class="comment">// &lt;mapTask&gt; produces for reduce task &lt;reduceTask&gt;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceName</span><span class="params">(jobName <span class="keyword">string</span>, mapTask <span class="keyword">int</span>, reduceTask <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"mrtmp."</span> + jobName + <span class="string">"-"</span> + strconv.Itoa(mapTask) + <span class="string">"-"</span> + strconv.Itoa(reduceTask)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mergeName constructs the name of the output file of reduce task &lt;reduceTask&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeName</span><span class="params">(jobName <span class="keyword">string</span>, reduceTask <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"mrtmp."</span> + jobName + <span class="string">"-res-"</span> + strconv.Itoa(reduceTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doMap manages one map task: it reads one of the input files</span></span><br><span class="line"><span class="comment">// (inFile), calls the user-defined map function (mapF) for that file's</span></span><br><span class="line"><span class="comment">// contents, and partitions the output into nReduce intermediate files.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>,    // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">mapTaskNumber <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">mapF <span class="function"><span class="keyword">func</span><span class="params">(file <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You will need to write this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The intermediate output of a map task is stored as multiple</span></span><br><span class="line"><span class="comment">// files, one per destination reduce task. The file name includes</span></span><br><span class="line"><span class="comment">// both the map task number and the reduce task number. Use the</span></span><br><span class="line"><span class="comment">// filename generated by reduceName(jobName, mapTaskNumber, r) as</span></span><br><span class="line"><span class="comment">// the intermediate file for reduce task r. Call ihash() (see below)</span></span><br><span class="line"><span class="comment">// on each key, mod nReduce, to pick r for a key/value pair.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mapF() is the map function provided by the application. The first</span></span><br><span class="line"><span class="comment">// argument should be the input file name, though the map function</span></span><br><span class="line"><span class="comment">// typically ignores it. The second argument should be the entire</span></span><br><span class="line"><span class="comment">// input file contents. mapF() returns a slice containing the</span></span><br><span class="line"><span class="comment">// key/value pairs for reduce; see common.go for the definition of</span></span><br><span class="line"><span class="comment">// KeyValue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Look at Go's ioutil and os packages for functions to read</span></span><br><span class="line"><span class="comment">// and write files.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Coming up with a scheme for how to format the key/value pairs on</span></span><br><span class="line"><span class="comment">// disk can be tricky, especially when taking into account that both</span></span><br><span class="line"><span class="comment">// keys and values could contain newlines, quotes, and any other</span></span><br><span class="line"><span class="comment">// character you can think of.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// One format often used for serializing data to a byte stream that the</span></span><br><span class="line"><span class="comment">// other end can correctly reconstruct is JSON. You are not required to</span></span><br><span class="line"><span class="comment">// use JSON, but as the output of the reduce tasks *must* be JSON,</span></span><br><span class="line"><span class="comment">// familiarizing yourself with it here may prove useful. You can write</span></span><br><span class="line"><span class="comment">// out a data structure as a JSON string to a file using the commented</span></span><br><span class="line"><span class="comment">// code below. The corresponding decoding functions can be found in</span></span><br><span class="line"><span class="comment">// common_reduce.go.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   enc := json.NewEncoder(file)</span></span><br><span class="line"><span class="comment">//   for _, kv := ... &#123;</span></span><br><span class="line"><span class="comment">//     err := enc.Encode(&amp;kv)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Remember to close the file after you have written all the values!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">contents, err := ioutil.ReadFile(inFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"read file %s failed"</span>, inFile)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">kvs := mapF(inFile, <span class="keyword">string</span>(contents))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imm = <span class="built_in">make</span>([]*os.File, nReduce)</span><br><span class="line"><span class="keyword">var</span> enc = <span class="built_in">make</span>([]*json.Encoder, nReduce)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduce; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> f, err := os.Create(reduceName(jobName, mapTaskNumber, i)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"create file %s failed"</span>, reduceName(jobName, mapTaskNumber, i))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">imm[i] = f</span><br><span class="line">enc[i] = json.NewEncoder(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">r := ihash(kv.Key) % nReduce</span><br><span class="line"><span class="keyword">if</span> enc[r] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := enc[r].Encode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"wirte %v to file %s failed"</span>, kv, reduceName(jobName, mapTaskNumber, r))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// close immediate files</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduce; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> imm[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">imm[i].Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">h := fnv.New32a()</span><br><span class="line">h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduce"><a class="markdownIt-Anchor" href="#reduce"></a> reduce</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doReduce manages one reduce task: it reads the intermediate</span></span><br><span class="line"><span class="comment">// key/value pairs (produced by the map phase) for this task, sorts the</span></span><br><span class="line"><span class="comment">// intermediate key/value pairs by key, calls the user-defined reduce function</span></span><br><span class="line"><span class="comment">// (reduceF) for each key, and writes the output to disk.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>,       // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">reduceTaskNumber <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">outFile <span class="keyword">string</span>,       // write the output here</span></span></span><br><span class="line">nMap int,             // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">reduceF <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You will need to write this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You'll need to read one intermediate file from each map task;</span></span><br><span class="line"><span class="comment">// reduceName(jobName, m, reduceTaskNumber) yields the file</span></span><br><span class="line"><span class="comment">// name from map task m.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your doMap() encoded the key/value pairs in the intermediate</span></span><br><span class="line"><span class="comment">// files, so you will need to decode them. If you used JSON, you can</span></span><br><span class="line"><span class="comment">// read and decode by creating a decoder and repeatedly calling</span></span><br><span class="line"><span class="comment">// .Decode(&amp;kv) on it until it returns an error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may find the first example in the golang sort package</span></span><br><span class="line"><span class="comment">// documentation useful.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// reduceF() is the application's reduce function. You should</span></span><br><span class="line"><span class="comment">// call it once per distinct key, with a slice of all the values</span></span><br><span class="line"><span class="comment">// for that key. reduceF() returns the reduced value for that key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You should write the reduce output as JSON encoded KeyValue</span></span><br><span class="line"><span class="comment">// objects to the file named outFile. We require you to use JSON</span></span><br><span class="line"><span class="comment">// because that is what the merger than combines the output</span></span><br><span class="line"><span class="comment">// from all the reduce tasks expects. There is nothing special about</span></span><br><span class="line"><span class="comment">// JSON -- it is just the marshalling format we chose to use. Your</span></span><br><span class="line"><span class="comment">// output code will look something like this:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// enc := json.NewEncoder(file)</span></span><br><span class="line"><span class="comment">// for key := ... &#123;</span></span><br><span class="line"><span class="comment">// enc.Encode(KeyValue&#123;key, reduceF(...)&#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// file.Close()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">string</span>                   <span class="comment">// store all keys in this partition</span></span><br><span class="line"><span class="keyword">var</span> kvs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>) <span class="comment">// store all key-value pairs from nMap imm files</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// read nMap imm files from map workers</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line">fn := reduceName(jobName, i, reduceTaskNumber)</span><br><span class="line">fmt.Println(<span class="string">"reduce fn"</span>,fn)</span><br><span class="line">imm, err := os.Open(fn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"open immediate file %s failed"</span>, fn)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line">dec := json.NewDecoder(imm)</span><br><span class="line">err = dec.Decode(&amp;kv)</span><br><span class="line"><span class="keyword">for</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// is this key seen?</span></span><br><span class="line"><span class="keyword">if</span> _, ok := kvs[kv.Key]; !ok &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, kv.Key)</span><br><span class="line">&#125;</span><br><span class="line">kvs[kv.Key] = <span class="built_in">append</span>(kvs[kv.Key], kv.Value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// decode repeatedly until an error</span></span><br><span class="line">err = dec.Decode(&amp;kv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Original MapReduce Paper 4.2 Ordering Guarantees</span></span><br><span class="line"><span class="comment">// Keys in one partition are processed in increasing key order</span></span><br><span class="line">sort.Strings(keys)</span><br><span class="line">out, err := os.Create(outFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"create output file %s failed"</span>, outFile)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(out)</span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line"><span class="keyword">if</span> err = enc.Encode(KeyValue&#123;key, reduceF(key, kvs[key])&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"write [key: %s] to file %s failed"</span>, key, outFile)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整例子"><a class="markdownIt-Anchor" href="#完整例子"></a> 完整例子</h2><p><a href="https://github.com/dreamerjackson/theWayToGolang" target="_blank" rel="noopener">https://github.com/dreamerjackson/theWayToGolang</a></p><h2 id="原始论文-参考资料"><a class="markdownIt-Anchor" href="#原始论文-参考资料"></a> 原始论文 参考资料</h2><p><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf</a><br><a href="https://pdos.csail.mit.edu/6.824/labs/lab-1.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.824/labs/lab-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mapreduce简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mapreduce简介&quot;&gt;&lt;/a&gt; mapReduce简介&lt;/h2&gt;
&lt;p&gt;MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[98]-拉取gitlab中的merge代码</title>
    <link href="https://dreamerjonson.com/2019/10/25/golang-98-%E6%8B%89%E5%8F%96gitlab%E4%B8%AD%E7%9A%84merge%E4%BB%A3%E7%A0%81/"/>
    <id>https://dreamerjonson.com/2019/10/25/golang-98-拉取gitlab中的merge代码/</id>
    <published>2019-10-25T07:15:06.000Z</published>
    <updated>2019-10-28T04:07:56.913Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，需要拉取gitlab上的merge代码。而这些merge常常是私人分支合并过来的，不能直接拉取。那么如何在本地pull这些分支的代码呢？</p><p>例如PR是/merge_requests/6 那么git pull remote refs/merge-requests/6/head 即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候，需要拉取gitlab上的merge代码。而这些merge常常是私人分支合并过来的，不能直接拉取。那么如何在本地pull这些分支的代码呢？&lt;/p&gt;
&lt;p&gt;例如PR是/merge_requests/6 那么git pull remote refs/merge-reque
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[97]-http-client-keeplive</title>
    <link href="https://dreamerjonson.com/2019/10/20/golang-97-http-client-keeplive/"/>
    <id>https://dreamerjonson.com/2019/10/20/golang-97-http-client-keeplive/</id>
    <published>2019-10-20T06:04:27.000Z</published>
    <updated>2019-10-20T06:08:45.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go-http-client-持久连接"><a class="markdownIt-Anchor" href="#go-http-client-持久连接"></a> Go HTTP Client 持久连接</h2><p>调用 Go 的 HTTP Client 的 Get\Post 之类的方法时，默认是开启 HTTP keepalive 的，不过直接使用还是会遇到一些情况导致持久连接失效。首先，Client 构造好 HTTP 请求后，利用 Transport 来发送请求并等待结果，默认使用 DefaultTransport 来实现，大多数情况下，自定义 Client 时，配置一下自带的 Transport 即可。</p><p>transport 主要围绕着 persistConn 来实现，通过当前请求的 proxy, scheme, addr 作为 Key，对已经建立的连接进行缓存，新的请求来时，先从缓存中取一个连接，如果没有，再新发起一个连接。按照 Go 的基本法，毫无疑问会有两个 goroutine 来分别处理连接上的读和写，然后各种 channel 就开始飞来飞去，于是便让人深思这真的会比基于事件回调的实现简单吗。</p><p>好了，这里还是简单写点代码浅显的试验一下可能会导致持久连接失效的一些情况。</p><h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>在发送请求建立 TCP 连接时输出一些提示消息，这样便可以确定是否发起了新连接。自定义一个 Transport 的 Dial 方法就好了。这里输出连接的 LocalAddr，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintLocalDial</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">    dial := net.Dialer&#123;</span><br><span class="line">        Timeout:   <span class="number">30</span> * time.Second,</span><br><span class="line">        KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err := dial.Dial(network, addr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conn, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"connect done, use"</span>, conn.LocalAddr().String())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地起了个在 8888 端口监听的 Web Server。好了，现在使用的 http.Client 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">    Transport: &amp;http.Transport&#123;</span><br><span class="line">        Dial: PrintLocalDial,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发起请求<br>一个三观正确的，具有普遍意义的请求步骤如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func doGet(client *http.Client, url string, id int) &#123;</span><br><span class="line">    resp, err := client.Get(url)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Printf(&quot;%d: %s -- %v\n&quot;, id, string(buf), err)</span><br><span class="line">    if err := resp.Body.Close(); err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Get 进入 RoundTrip，首先会找到个 persistConn (从缓存中找个已经存在的或者新建一个)，再调用它的 roundTrip，这时会把这个请求发送到 writeLoop，然后等待响应的到来，当 readLoop 中读到响应数据时，便会把响应 Response 发到 roundTrip，自此，Get 方法返回，不过事情还没有结束，响应的 Body 还没有读取，readLoop 会一直阻塞等待读取数据，也就是当前这个 persistConn 一直被占用着，当读取完 resp.Body，readLoop 就会把 persistConn 放回连接缓存中，以便下个请求继续使用。</p><p>持续发几个请求试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const URL = &quot;http://localhost:8888/&quot;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">    go doGet(client, URL, 1)</span><br><span class="line">    go doGet(client, URL, 2)</span><br><span class="line">    time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次同时发送两个请求，并等待请求完成，输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run client.go</span><br><span class="line">connect done, use [::1]:57571</span><br><span class="line">connect done, use [::1]:57570</span><br><span class="line">2: Hello, world -- &lt;nil&gt;</span><br><span class="line">1: Hello, world -- &lt;nil&gt;</span><br><span class="line">2: Hello, world -- &lt;nil&gt;</span><br><span class="line">1: Hello, world -- &lt;nil&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可见此时建立了两条 TCP 持久连接，后面的请求都复用了一开始建立好的连接。如果再加一个请求呢，每次同时发送三个请求，输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run client.<span class="keyword">go</span></span><br><span class="line">connect done, use [::<span class="number">1</span>]:<span class="number">57582</span></span><br><span class="line">connect done, use [::<span class="number">1</span>]:<span class="number">57583</span></span><br><span class="line">connect done, use [::<span class="number">1</span>]:<span class="number">57584</span></span><br><span class="line"><span class="number">2</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">1</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">3</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">connect done, use [::<span class="number">1</span>]:<span class="number">57585</span></span><br><span class="line"><span class="number">2</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">1</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">3</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">connect done, use [::<span class="number">1</span>]:<span class="number">57586</span></span><br><span class="line"><span class="number">1</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">2</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">3</span>: Hello, world -- &lt;<span class="literal">nil</span>&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可见每次都会有一个请求是新建了个 TCP 连接的，也就是说默认只保持两条持久连接，这是因为这里自定义的的 http.Transport 没有设置 MaxIdleConnsPerHost，于是便采用了默认的 DefaultMaxIdleConnsPerHost，这个值是 2，这是 RFC2616 建议的单个客户端发起的持久连接数，不过在大部分情况下，这个值有点过于保守了。如果把 MaxIdleConnsPerHost 设置为 3，结果便和第一种情况一样。</p><h2 id="三观不正的请求"><a class="markdownIt-Anchor" href="#三观不正的请求"></a> 三观不正的请求</h2><p>这里来一个三观不正的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func doGet(client *http.Client, url string, id int) &#123;</span><br><span class="line">    resp, err := client.Get(url)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if err := resp.Body.Close(); err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;%d: done\n&quot;, id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并不读取 resp.Body，因为读来也没用，但是也没法用 HEAD 请求(当然，这只是示例)。每次同时发送两个请求，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go run client.go</span><br><span class="line">connect done, use [::1]:57974</span><br><span class="line">connect done, use [::1]:57973</span><br><span class="line">2: done</span><br><span class="line">1: done</span><br><span class="line">connect done, use [::1]:57975</span><br><span class="line">connect done, use [::1]:57976</span><br><span class="line">2: done</span><br><span class="line">1: done</span><br><span class="line">connect done, use [::1]:57978</span><br><span class="line">connect done, use [::1]:57977</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>额，每次都是新建的 TCP 连接，看来持久连接没用上。考虑到 TCP 接收到的数据，应用层并没有主动去读取，如果再次复用这个连接发送数据，那么上一次的数据要怎么处理？要么 Go 在库里默默的给读了，要么直接断开连接新建一条。在 Go 1.0 中就是在库里默默的读，想象一下正在 Get 的是几个 G 的东西，调用 Close 的时候… 所以最好的方法还是断开这个没有读取 Body 就直接 Close 的连接。</p><p>这里实现上利用 bodyEOFSignal 这个数据类型来包装 readLoop 生成的响应 Body，并设置回调函数 earlyCloseFn，如果 Body 并没有读取完便 Close，这个函数将执行并通知 readLoop，然后 readLoop 关闭连接并退出。所以如果想要使用持久连接，还得处理掉 Body，这就看应用的取舍了，尽量使用 HEAD 代替，也可以读取来丢弃掉。</p><p>n, err := io.Copy(ioutil.Discard, resp.Body)<br>后话<br>当然，可以设置 http.Transport 的 DisableKeepAlives 来禁用掉持久连接。前面废话说的有点多，总结一下无非就下面几条：</p><p>Web Server 得支持持久连接<br>如果有需要，加大 DefaultMaxIdleConnsPerHost 或者设置 MaxIdleConnsPerHost<br>读完 Response Body 再 Close</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://serholiu.com/go-http-client-keepalive" target="_blank" rel="noopener">https://serholiu.com/go-http-client-keepalive</a><br><a href="https://www.cnblogs.com/gaorong/p/10887021.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaorong/p/10887021.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;go-http-client-持久连接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#go-http-client-持久连接&quot;&gt;&lt;/a&gt; Go HTTP Client 持久连接&lt;/h2&gt;
&lt;p&gt;调用 Go 的 HTTP Client 的
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[96]-http.RoundTripper</title>
    <link href="https://dreamerjonson.com/2019/10/19/golang-96-http-RoundTripper/"/>
    <id>https://dreamerjonson.com/2019/10/19/golang-96-http-RoundTripper/</id>
    <published>2019-10-19T07:54:47.000Z</published>
    <updated>2019-10-19T07:59:51.052Z</updated>
    
    <content type="html"><![CDATA[<p>I have written quite a bit on HTTP. And this blog post is just yet another one that talks about another interesting concept in the way Go deals with HTTP and how it makes HTTP related stuffs even much more fun.</p><p>In this post, I would be covering what Round tripping is, it’s applicable usecases and a tiny demo that shows it’s application.</p><p>This concept I want to talk about is called Round tripping or as the godoc describes it the ability to execute a single HTTP transaction, obtaining the Response for a given Request. Basically, what this means is being able to hook into what happens between making an HTTP request and receiving a response. In lay man terms, it’s like middleware but for an http.Client. I say this since round tripping occurs before the request is actually sent.</p><p>Although, it is possible to do anything within the RoundTrip method (as in like middleware for your HTTP handlers), it is recommended you don’t inspect the response, return an error (nil or non nil) and shouldn’t do stuffs like user auth (or cookies handling)…</p><p>Since http.RoundTripper is an interface. All you have to do to get this functionality is implement RoundTrip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type SomeClient struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *SomeClient) RoundTrip(r *http.Request)(*Response, error) &#123;</span><br><span class="line">//Something comes here...Maybe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And this is just keeping in line with other one method interfaces in the stdlib… Small and concise.</p><h2 id="usecases"><a class="markdownIt-Anchor" href="#usecases"></a> Usecases</h2><p>Caching http responses. For example, your web app has to connect to Github’s API in other to fetch stuffs (with the trending repos one of it). In real life, this changes quite often but let’s assume they rebuild that trending board once every 30 minutes and your app has tons of users. You obviously don’t want to have to hit the api every time to request for the trending leaderboard. since it is always the same in a 30 minutes window and also considering the fact that API calls are rate limited and due to the high usage of your app, you almost always hit / cross the limit.<br>A solution to this is to make use of http.RoundTripper. You could configure your http.Client with a RoundTripper that does the following :<br>Does the cache store have this item ?<br>Don’t make the HTTP request.<br>Return a new response by reading the data from the cache into the body of the response.<br>The cache store doesn’t have this item (probably because the cache is invalidated every 31 minutes)<br>Make the HTTP request to the api.<br>Cache the data received from the api.<br>You don’t have to make use of a RoundTripper for this as (inside a handler) you can check the cache for the existence of an item before you make the HTTP request at all. But with a RoundTripper implementation, you are probably distributing responsibilities properly[0]</p><p>Adding appropriate (authorization) headers to the request as need be… An example that readily comes to mind is google/go-github, a Golang client for Github’s api. Some part of Github’s api require the request be authenticated, some don’t. By default, the library doesn’t handle authentication, it uses a default HTTP client, if you need to be able to access authenticated sections of the api, you bring your own HTTP client along, for example with oauth2 protected endpoints… So how does this concern Round tripping, there is this ghinstallation that allows you authenticate Github apps with go-github. If you look at it’s codebase, all it does is provide an http.Client that implements http.RoundTripper. After which it set the appropriate headers (and values) in the RoundTrip method.</p><p>Rate limiting. This is quite similar to the above, maybe you have a bucket where you keep the number of connections you have made recently. You check if you are still in acceptable standing with the API and decide if you should make the request, pull back from making the request or scheduling it to run in future.</p><p>Whatever have you… Maybe not.</p><h2 id="real-world-usage"><a class="markdownIt-Anchor" href="#real-world-usage"></a> Real world usage</h2><p>We would be looking at caching HTTP responses with an implementation of http.RoundTripper. We would be creating a server that responds to just one route, then a client package that connects to that server. THe client would make use of it’s own implementation of http.Client so we can be able to provide our own RoundTripper, since we are trying to cache responses.</p><p>So here is what it is going to look like,</p><p>The client makes a request to the server.<br>If the response for that url exists in the cache store ?<br>Don’t make the call to the server.<br>Fetch the item from the store.<br>Write it into the response and return it straight off.<br>If the response for that url does not exist in the cache store<br>Make the request to the server.<br>Write the body of the response into the cache store.<br>Return the response.</p><p>We would be building the server first since it’s implementation is quite simple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">// server/main.go</span><br><span class="line"></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line"></span><br><span class="line">mux.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">// This is here so we can actually see that the responses that have been cached don&apos;t get here</span><br><span class="line">fmt.Println(&quot;The request actually got here&quot;)</span><br><span class="line"></span><br><span class="line">w.Write([]byte(&quot;You got here&quot;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(&quot;:8000&quot;, mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then we would build the client package. This is the most interesting part, while it is quite long (130+ LOCs), It should be relatively easy to follow.I highly recommend you head to the github repo.</p><p>First of all, we would need a cache store. Since this is a minimal project, a dictionary/map can help us get away ASAP. We would create a http.Transport that implements http.RoundTripper but is also a cache store.</p><p>In real life you’d want to separate them from each other though.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheKey</span><span class="params">(r *http.Request)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.URL.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cacheTransport <span class="keyword">struct</span> &#123;</span><br><span class="line">data              <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">mu                sync.RWMutex</span><br><span class="line">originalTransport http.RoundTripper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheTransport)</span> <span class="title">Set</span><span class="params">(r *http.Request, value <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.data[cacheKey(r)] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheTransport)</span> <span class="title">Get</span><span class="params">(r *http.Request)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">c.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val, ok := c.data[cacheKey(r)]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"key not found in cache"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the main functionality</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheTransport)</span> <span class="title">RoundTrip</span><span class="params">(r *http.Request)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if we have the response cached..</span></span><br><span class="line"><span class="comment">// If yes, we don't have to hit the server</span></span><br><span class="line"><span class="comment">// We just return it as is from the cache store.</span></span><br><span class="line"><span class="keyword">if</span> val, err := c.Get(r); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Fetching the response from the cache"</span>)</span><br><span class="line"><span class="keyword">return</span> cachedResponse([]<span class="keyword">byte</span>(val), r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ok, we don't have the response cached, the store was probably cleared.</span></span><br><span class="line"><span class="comment">// Make the request to the server.</span></span><br><span class="line">resp, err := c.originalTransport.RoundTrip(r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the body of the response so we can save it in the cache for the next request.</span></span><br><span class="line">buf, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Saving it to the cache store</span></span><br><span class="line">c.Set(r, <span class="keyword">string</span>(buf))</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Fetching the data from the real source"</span>)</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cacheTransport)</span> <span class="title">Clear</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">c.data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cachedResponse</span><span class="params">(b []<span class="keyword">byte</span>, r *http.Request)</span> <span class="params">(*http.Response, error)</span></span> &#123;</span><br><span class="line">buf := bytes.NewBuffer(b)</span><br><span class="line"><span class="keyword">return</span> http.ReadResponse(bufio.NewReader(buf), r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then the main function where we bootstrap the program. We would set a timer to clear out the cache store, so we can make requests to the server, this is to enable us view which requests are being served from the cache or the original server.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//client/main/go</span></span><br><span class="line"></span><br><span class="line">cachedTransport := newTransport()</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a custom client so we can make use of our RoundTripper</span></span><br><span class="line"><span class="comment">//If you make use of http.Get(), the default http client located at http.DefaultClient is used instead</span></span><br><span class="line"><span class="comment">//Since we have special needs, we have to make use of our own http.RoundTripper implementation</span></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">Transport: cachedTransport,</span><br><span class="line">Timeout:   time.Second * <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Time to clear the cache store so we can make request to the original server rather than fetch from the cache store</span></span><br><span class="line"><span class="comment">// This is to replicate real expiration of data in a cache store</span></span><br><span class="line">cacheClearTicker := time.NewTicker(time.Second * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Make a new request every second</span></span><br><span class="line"><span class="comment">//This would help demonstrate if the response is coming from the real server or the cache</span></span><br><span class="line">reqTicker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">terminateChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">signal.Notify(terminateChannel, syscall.SIGTERM, syscall.SIGHUP)</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(http.MethodGet, <span class="string">"http://localhost:8000"</span>, strings.NewReader(<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Whoops"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-cacheClearTicker.C:</span><br><span class="line"><span class="comment">// Clear the cache so we can hit the original server</span></span><br><span class="line">cachedTransport.Clear()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-terminateChannel:</span><br><span class="line">cacheClearTicker.Stop()</span><br><span class="line">reqTicker.Stop()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-reqTicker.C:</span><br><span class="line"></span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"An error occurred.... %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buf, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"An error occurred.... %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"The body of the response is \"%s\" \n\n"</span>, <span class="keyword">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://lanre.wtf/blog/2017/07/24/roundtripper-go/" target="_blank" rel="noopener">https://lanre.wtf/blog/2017/07/24/roundtripper-go/</a></p><h2 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h2><p><a href="https://github.com/dreamerjackson/rounder" target="_blank" rel="noopener">https://github.com/dreamerjackson/rounder</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I have written quite a bit on HTTP. And this blog post is just yet another one that talks about another interesting concept in the way Go
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[95]-golang-优秀代码赏析-检测goroutine溢出</title>
    <link href="https://dreamerjonson.com/2019/10/12/golang-95-golang-%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E8%B5%8F%E6%9E%90-%E6%A3%80%E6%B5%8Bgoroutine%E6%BA%A2%E5%87%BA/"/>
    <id>https://dreamerjonson.com/2019/10/12/golang-95-golang-优秀代码赏析-检测goroutine溢出/</id>
    <published>2019-10-12T09:12:28.000Z</published>
    <updated>2019-10-12T09:16:36.781Z</updated>
    
    <content type="html"><![CDATA[<p>在latern中看到了这段代码，防止协程溢出。</p><p>原理是利用了pprof.lookup()  此会将存在的goroutine的stacktrace打印出来。</p><p>通过对比代码前与代码后的goroutine number。  即可得知是否有新的goroutine创建出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package grtrack provides a utility that helps check for goroutine leaks.</span></span><br><span class="line"><span class="keyword">package</span> grtrack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line"><span class="string">"runtime/pprof"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">goroutineNumber = regexp.MustCompile(<span class="string">`goroutine ([0-9]+)`</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object that can be used to check whether goroutines have leaked at any point</span></span><br><span class="line"><span class="comment">// in time.</span></span><br><span class="line"><span class="keyword">type</span> Checker <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Check immediately checks whether there's been a leak</span></span><br><span class="line">Check(t *testing.T)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CheckAfter waits wait and then checks</span></span><br><span class="line">CheckAfter(t *testing.T, wait time.Duration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> checker <span class="keyword">struct</span> &#123;</span><br><span class="line">check <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Start</span><span class="params">()</span> <span class="title">Checker</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">_ = pprof.Lookup(<span class="string">"goroutine"</span>).WriteTo(&amp;buf, <span class="number">2</span>)</span><br><span class="line">before := buf.String()</span><br><span class="line"></span><br><span class="line">check := <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">_ = pprof.Lookup(<span class="string">"goroutine"</span>).WriteTo(&amp;buf, <span class="number">2</span>)</span><br><span class="line">after := buf.String()</span><br><span class="line"></span><br><span class="line">beforeGoroutines := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">beforeMatches := goroutineNumber.FindAllStringSubmatch(before, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> _, match := <span class="keyword">range</span> beforeMatches &#123;</span><br><span class="line">beforeGoroutines[match[<span class="number">1</span>]] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afterMatches := goroutineNumber.FindAllStringSubmatchIndex(after, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(afterMatches); i++ &#123;</span><br><span class="line">idx := afterMatches[i][<span class="number">0</span>]</span><br><span class="line">nextIdx := <span class="built_in">len</span>(after)</span><br><span class="line">last := i == <span class="built_in">len</span>(afterMatches)<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> !last &#123;</span><br><span class="line">nextIdx = afterMatches[i+<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">matches := goroutineNumber.FindAllStringSubmatch(after[idx:], <span class="number">1</span>)</span><br><span class="line">num := matches[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">_, exists := beforeGoroutines[num]</span><br><span class="line"><span class="keyword">if</span> !exists &#123;</span><br><span class="line">delta := after[idx:nextIdx]</span><br><span class="line"><span class="keyword">if</span> !strings.Contains(delta, <span class="string">"net/http/server.go"</span>) &#123;</span><br><span class="line">assert.Fail(t, <span class="string">"Leaked Goroutine"</span>, delta)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;checker&#123;check&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *checker)</span> <span class="title">Check</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">c.check(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *checker)</span> <span class="title">CheckAfter</span><span class="params">(t *testing.T, wait time.Duration)</span></span> &#123;</span><br><span class="line">time.Sleep(wait)</span><br><span class="line">c.check(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在latern中看到了这段代码，防止协程溢出。&lt;/p&gt;
&lt;p&gt;原理是利用了pprof.lookup()  此会将存在的goroutine的stacktrace打印出来。&lt;/p&gt;
&lt;p&gt;通过对比代码前与代码后的goroutine number。  即可得知是否有新的gorou
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[94]-golang-优秀代码赏析-eventually等待获取最后存储起来的value</title>
    <link href="https://dreamerjonson.com/2019/10/11/golang-94-golang-%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E8%B5%8F%E6%9E%90/"/>
    <id>https://dreamerjonson.com/2019/10/11/golang-94-golang-优秀代码赏析/</id>
    <published>2019-10-11T08:36:18.000Z</published>
    <updated>2019-10-12T09:10:53.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发获取最后存储起来的value如果获取不到就会陷入等待一段时间"><a class="markdownIt-Anchor" href="#并发获取最后存储起来的value如果获取不到就会陷入等待一段时间"></a> 并发获取最后存储起来的value，如果获取不到就会陷入等待一段时间。</h2><h2 id="source-源码"><a class="markdownIt-Anchor" href="#source-源码"></a> source 源码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package eventual provides values that eventually have a value.</span></span><br><span class="line"><span class="keyword">package</span> eventual</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"math"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value is an eventual value, meaning that callers wishing to access the value</span></span><br><span class="line"><span class="comment">// block until the value is available.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Set sets this Value to the given val.</span></span><br><span class="line">Set(val <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get waits up to timeout for the value to be set and returns it, or returns</span></span><br><span class="line"><span class="comment">// nil if it times out or Cancel() is called. valid will be false in latter</span></span><br><span class="line"><span class="comment">// case. If timeout is 0, Get won't wait. If timeout is -1, Get will wait</span></span><br><span class="line"><span class="comment">// forever.</span></span><br><span class="line">Get(timeout time.Duration) (ret <span class="keyword">interface</span>&#123;&#125;, valid <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel cancels this value, signaling any waiting calls to Get() that no</span></span><br><span class="line"><span class="comment">// value is coming. If no value was set before Cancel() was called, all future</span></span><br><span class="line"><span class="comment">// calls to Get() will return nil, false. Subsequent calls to Set after Cancel</span></span><br><span class="line"><span class="comment">// have no effect.</span></span><br><span class="line">Cancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter is a functional interface for the Value.Get function</span></span><br><span class="line"><span class="keyword">type</span> Getter <span class="function"><span class="keyword">func</span><span class="params">(time.Duration)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">value</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">state   atomic.Value</span><br><span class="line">waiters []<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">mutex   sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stateholder <span class="keyword">struct</span> &#123;</span><br><span class="line">val      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">set      <span class="keyword">bool</span></span><br><span class="line">canceled <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewValue creates a new Value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewValue</span><span class="params">()</span> <span class="title">Value</span></span> &#123;</span><br><span class="line">result := &amp;value&#123;waiters: <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)&#125;</span><br><span class="line">result.state.Store(&amp;stateholder&#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultGetter builds a Getter that always returns the supplied value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultGetter</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Getter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(time.Duration)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultUnsetGetter builds a Getter that always !ok.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultUnsetGetter</span><span class="params">()</span> <span class="title">Getter</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(time.Duration)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *value)</span> <span class="title">Set</span><span class="params">(val <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">v.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> v.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">state := v.getState()</span><br><span class="line">settable := !state.canceled</span><br><span class="line"><span class="keyword">if</span> settable &#123;</span><br><span class="line">v.setState(&amp;stateholder&#123;</span><br><span class="line">val:      val,</span><br><span class="line">set:      <span class="literal">true</span>,</span><br><span class="line">canceled: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v.waiters != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Notify anyone waiting for value</span></span><br><span class="line"><span class="keyword">for</span> _, waiter := <span class="keyword">range</span> v.waiters &#123;</span><br><span class="line">waiter &lt;- val</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Clear waiters</span></span><br><span class="line">v.waiters = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *value)</span> <span class="title">Cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">v.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> v.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">state := v.getState()</span><br><span class="line">v.setState(&amp;stateholder&#123;</span><br><span class="line">val:      state.val,</span><br><span class="line">set:      state.set,</span><br><span class="line">canceled: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> v.waiters != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Notify anyone waiting for value</span></span><br><span class="line"><span class="keyword">for</span> _, waiter := <span class="keyword">range</span> v.waiters &#123;</span><br><span class="line"><span class="built_in">close</span>(waiter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Clear waiters</span></span><br><span class="line">v.waiters = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *value)</span> <span class="title">Get</span><span class="params">(timeout time.Duration)</span> <span class="params">(ret <span class="keyword">interface</span>&#123;&#125;, valid <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">state := v.getState()</span><br><span class="line"></span><br><span class="line"><span class="comment">// First check for existing value using atomic operations (for speed)</span></span><br><span class="line"><span class="keyword">if</span> state.set &#123;</span><br><span class="line"><span class="comment">// Value found, use it</span></span><br><span class="line"><span class="keyword">return</span> state.val, <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> state.canceled &#123;</span><br><span class="line"><span class="comment">// Value was canceled, return false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> timeout == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Don't wait</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we didn't find an existing value, try again but this time using locking</span></span><br><span class="line">v.mutex.Lock()</span><br><span class="line">state = v.getState()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> state.set &#123;</span><br><span class="line"><span class="comment">// Value found, use it</span></span><br><span class="line">v.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> state.val, <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> state.canceled &#123;</span><br><span class="line"><span class="comment">// Value was canceled, return false</span></span><br><span class="line">v.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> timeout == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// Wait essentially forever</span></span><br><span class="line">timeout = time.Duration(math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value not found, register to be notified once value is set</span></span><br><span class="line">valCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">v.waiters = <span class="built_in">append</span>(v.waiters, valCh)</span><br><span class="line">v.mutex.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait up to timeout for value to get set</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-valCh:</span><br><span class="line"><span class="keyword">return</span> v, ok</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *value)</span> <span class="title">getState</span><span class="params">()</span> *<span class="title">stateholder</span></span> &#123;</span><br><span class="line">state := v.state.Load()</span><br><span class="line"><span class="keyword">if</span> state == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> state.(*stateholder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *value)</span> <span class="title">setState</span><span class="params">(state *stateholder)</span></span> &#123;</span><br><span class="line">v.state.Store(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="test"><a class="markdownIt-Anchor" href="#test"></a> test</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> eventual</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"sync/atomic"</span></span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/getlantern/grtrack"</span></span><br><span class="line"><span class="string">"github.com/stretchr/testify/assert"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">concurrency = <span class="number">200</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSingle</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">goroutines := grtrack.Start()</span><br><span class="line">v := NewValue()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Millisecond)</span><br><span class="line">v.Set(<span class="string">"hi"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">r, ok := v.Get(<span class="number">0</span>)</span><br><span class="line">assert.False(t, ok, <span class="string">"Get with no timeout should have failed"</span>)</span><br><span class="line"></span><br><span class="line">r, ok = v.Get(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">assert.False(t, ok, <span class="string">"Get with short timeout should have timed out"</span>)</span><br><span class="line"></span><br><span class="line">r, ok = v.Get(<span class="number">-1</span>)</span><br><span class="line">assert.True(t, ok, <span class="string">"Get with really long timeout should have succeeded"</span>)</span><br><span class="line">assert.Equal(t, <span class="string">"hi"</span>, r, <span class="string">"Wrong result"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set a different value</span></span><br><span class="line">v.Set(<span class="string">"bye"</span>)</span><br><span class="line">r, ok = v.Get(<span class="number">0</span>)</span><br><span class="line">assert.True(t, ok, <span class="string">"Subsequent get with no timeout should have succeeded"</span>)</span><br><span class="line">assert.Equal(t, <span class="string">"bye"</span>, r, <span class="string">"Value should have changed"</span>)</span><br><span class="line"></span><br><span class="line">goroutines.CheckAfter(t, <span class="number">50</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNoSet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">goroutines := grtrack.Start()</span><br><span class="line">v := NewValue()</span><br><span class="line"></span><br><span class="line">_, ok := v.Get(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">assert.False(t, ok, <span class="string">"Get before setting value should not be okay"</span>)</span><br><span class="line"></span><br><span class="line">goroutines.CheckAfter(t, <span class="number">50</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancelImmediate</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">v := NewValue()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">v.Cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">_, ok := v.Get(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">assert.False(t, ok, <span class="string">"Get after cancel should have failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancelAfterSet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">v := NewValue()</span><br><span class="line">v.Set(<span class="number">5</span>)</span><br><span class="line">r, ok := v.Get(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">assert.True(t, ok, <span class="string">"Get before cancel should have succeeded"</span>)</span><br><span class="line">assert.Equal(t, <span class="number">5</span>, r, <span class="string">"Get got wrong value before cancel"</span>)</span><br><span class="line"></span><br><span class="line">v.Cancel()</span><br><span class="line">r, ok = v.Get(<span class="number">0</span>)</span><br><span class="line">assert.True(t, ok, <span class="string">"Get after cancel should have succeeded"</span>)</span><br><span class="line">assert.Equal(t, <span class="number">5</span>, r, <span class="string">"Get got wrong value after cancel"</span>)</span><br><span class="line"></span><br><span class="line">v.Set(<span class="number">10</span>)</span><br><span class="line">r, _ = v.Get(<span class="number">0</span>)</span><br><span class="line">assert.Equal(t, <span class="number">5</span>, r, <span class="string">"Set after cancel should have no effect"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkGet</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">v := NewValue()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">20</span> * time.Millisecond)</span><br><span class="line">v.Set(<span class="string">"hi"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">v.Get(<span class="number">20</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConcurrent</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">goroutines := grtrack.Start()</span><br><span class="line">v := NewValue()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sets <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Do some concurrent setting to make sure that it works</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; concurrency; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Wait for waitGroup so that all goroutines run at basically the same</span></span><br><span class="line"><span class="comment">// time.</span></span><br><span class="line">wg.Wait()</span><br><span class="line">v.Set(<span class="string">"hi"</span>)</span><br><span class="line">atomic.AddInt32(&amp;sets, <span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; concurrency; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r, ok := v.Get(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">assert.True(t, ok, <span class="string">"Get should have succeed"</span>)</span><br><span class="line">assert.Equal(t, <span class="string">"hi"</span>, r, <span class="string">"Wrong result"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goroutines.CheckAfter(t, <span class="number">50</span>*time.Millisecond)</span><br><span class="line">assert.EqualValues(t, concurrency, atomic.LoadInt32(&amp;sets), <span class="string">"Wrong number of successful Sets"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;并发获取最后存储起来的value如果获取不到就会陷入等待一段时间&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#并发获取最后存储起来的value如果获取不到就会陷入等待一段时间&quot;&gt;&lt;/a&gt; 并发获取最后存储起来的value，如果获取不到
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[93]-golang-link</title>
    <link href="https://dreamerjonson.com/2019/10/10/golang-93-golang-link/"/>
    <id>https://dreamerjonson.com/2019/10/10/golang-93-golang-link/</id>
    <published>2019-10-10T13:34:57.000Z</published>
    <updated>2019-10-10T13:35:29.098Z</updated>
    
    <content type="html"><![CDATA[<p>Link, typically invoked as “go tool link,” reads the Go archive or object for a package main, along with its dependencies, and combines them into an executable binary.</p><p>Command Line<br>Usage:</p><p>go tool link [flags] main.a<br>Flags:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">-B note</span><br><span class="line">Add an ELF_NT_GNU_BUILD_ID note when using ELF.</span><br><span class="line">The value should start with 0x and be an even number of hex digits.</span><br><span class="line">-D address</span><br><span class="line">Set data segment address.</span><br><span class="line">-E entry</span><br><span class="line">Set entry symbol name.</span><br><span class="line">-H type</span><br><span class="line">Set executable format type.</span><br><span class="line">The default format is inferred from GOOS and GOARCH.</span><br><span class="line">On Windows, -H windowsgui writes a &quot;GUI binary&quot; instead of a &quot;console binary.&quot;</span><br><span class="line">-I interpreter</span><br><span class="line">Set the ELF dynamic linker to use.</span><br><span class="line">-L dir1 -L dir2</span><br><span class="line">Search for imported packages in dir1, dir2, etc,</span><br><span class="line">after consulting $GOROOT/pkg/$GOOS_$GOARCH.</span><br><span class="line">-R quantum</span><br><span class="line">Set address rounding quantum.</span><br><span class="line">-T address</span><br><span class="line">Set text segment address.</span><br><span class="line">-V</span><br><span class="line">Print linker version and exit.</span><br><span class="line">-X importpath.name=value</span><br><span class="line">Set the value of the string variable in importpath named name to value.</span><br><span class="line">This is only effective if the variable is declared in the source code either uninitialized</span><br><span class="line">or initialized to a constant string expression. -X will not work if the initializer makes</span><br><span class="line">a function call or refers to other variables.</span><br><span class="line">Note that before Go 1.5 this option took two separate arguments.</span><br><span class="line">-a</span><br><span class="line">Disassemble output.</span><br><span class="line">-buildid id</span><br><span class="line">Record id as Go toolchain build id.</span><br><span class="line">-buildmode mode</span><br><span class="line">Set build mode (default exe).</span><br><span class="line">-c</span><br><span class="line">Dump call graphs.</span><br><span class="line">-compressdwarf</span><br><span class="line">Compress DWARF if possible (default true).</span><br><span class="line">-cpuprofile file</span><br><span class="line">Write CPU profile to file.</span><br><span class="line">-d</span><br><span class="line">Disable generation of dynamic executables.</span><br><span class="line">The emitted code is the same in either case; the option</span><br><span class="line">controls only whether a dynamic header is included.</span><br><span class="line">The dynamic header is on by default, even without any</span><br><span class="line">references to dynamic libraries, because many common</span><br><span class="line">system tools now assume the presence of the header.</span><br><span class="line">-debugtramp int</span><br><span class="line">Debug trampolines.</span><br><span class="line">-dumpdep</span><br><span class="line">Dump symbol dependency graph.</span><br><span class="line">-extar ar</span><br><span class="line">Set the external archive program (default &quot;ar&quot;).</span><br><span class="line">Used only for -buildmode=c-archive.</span><br><span class="line">-extld linker</span><br><span class="line">Set the external linker (default &quot;clang&quot; or &quot;gcc&quot;).</span><br><span class="line">-extldflags flags</span><br><span class="line">Set space-separated flags to pass to the external linker.</span><br><span class="line">-f</span><br><span class="line">Ignore version mismatch in the linked archives.</span><br><span class="line">-g</span><br><span class="line">Disable Go package data checks.</span><br><span class="line">-importcfg file</span><br><span class="line">Read import configuration from file.</span><br><span class="line">In the file, set packagefile, packageshlib to specify import resolution.</span><br><span class="line">-installsuffix suffix</span><br><span class="line">Look for packages in $GOROOT/pkg/$GOOS_$GOARCH_suffix</span><br><span class="line">instead of $GOROOT/pkg/$GOOS_$GOARCH.</span><br><span class="line">-k symbol</span><br><span class="line">Set field tracking symbol. Use this flag when GOEXPERIMENT=fieldtrack is set.</span><br><span class="line">-libgcc file</span><br><span class="line">Set name of compiler support library.</span><br><span class="line">This is only used in internal link mode.</span><br><span class="line">If not set, default value comes from running the compiler,</span><br><span class="line">which may be set by the -extld option.</span><br><span class="line">Set to &quot;none&quot; to use no support library.</span><br><span class="line">-linkmode mode</span><br><span class="line">Set link mode (internal, external, auto).</span><br><span class="line">This sets the linking mode as described in cmd/cgo/doc.go.</span><br><span class="line">-linkshared</span><br><span class="line">Link against installed Go shared libraries (experimental).</span><br><span class="line">-memprofile file</span><br><span class="line">Write memory profile to file.</span><br><span class="line">-memprofilerate rate</span><br><span class="line">Set runtime.MemProfileRate to rate.</span><br><span class="line">-msan</span><br><span class="line">Link with C/C++ memory sanitizer support.</span><br><span class="line">-n</span><br><span class="line">Dump symbol table.</span><br><span class="line">-o file</span><br><span class="line">Write output to file (default a.out, or a.out.exe on Windows).</span><br><span class="line">-pluginpath path</span><br><span class="line">The path name used to prefix exported plugin symbols.</span><br><span class="line">-r dir1:dir2:...</span><br><span class="line">Set the ELF dynamic linker search path.</span><br><span class="line">-race</span><br><span class="line">Link with race detection libraries.</span><br><span class="line">-s</span><br><span class="line">Omit the symbol table and debug information.</span><br><span class="line">-shared</span><br><span class="line">Generated shared object (implies -linkmode external; experimental).</span><br><span class="line">-tmpdir dir</span><br><span class="line">Write temporary files to dir.</span><br><span class="line">Temporary files are only used in external linking mode.</span><br><span class="line">-u</span><br><span class="line">Reject unsafe packages.</span><br><span class="line">-v</span><br><span class="line">Print trace of linker operations.</span><br><span class="line">-w</span><br><span class="line">Omit the DWARF symbol table.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Link, typically invoked as “go tool link,” reads the Go archive or object for a package main, along with its dependencies, and combines t
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[92]-golang-实现反向代理</title>
    <link href="https://dreamerjonson.com/2019/10/07/golang-92-golang-reverse-proxy/"/>
    <id>https://dreamerjonson.com/2019/10/07/golang-92-golang-reverse-proxy/</id>
    <published>2019-10-07T07:00:26.000Z</published>
    <updated>2019-10-12T14:21:05.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理"></a> 反向代理</h2><p>反向代理在计算机网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器集群的存在</p><h2 id="golang最简单实现反向代理"><a class="markdownIt-Anchor" href="#golang最简单实现反向代理"></a> golang最简单实现反向代理</h2><p>golang源码httputils中有对于反向代理的实现，最简单的代理甚至可以一行代码实现。</p><p>1、我们首先开启一个web服务器监听127.0.0.1:8999端口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">_ <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *handle)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"> fmt.Fprint(w, <span class="string">"Welcome!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8999"</span>, h)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实现一个简单的代理服务器<br>下面的程序仍然是一个web服务器，监听8888端口，但是其使用了反向代理，因此对:8888的访问都会转发到:8999，输出“Welcome！”。<br>核心的操作在于httputil.NewSingleHostReverseProxy 具有serveHttp方法，此方法对request请求进行了重新封装，并且proxy将得到的response转发给client。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handle <span class="keyword">struct</span> &#123;</span><br><span class="line">host <span class="keyword">string</span></span><br><span class="line">port <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *handle)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"url:%+v\n"</span>,r.URL)</span><br><span class="line">remote, err := url.Parse(<span class="string">"http://"</span> + this.host + <span class="string">":"</span> + this.port)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"hosr::"</span>,remote.Host)</span><br><span class="line">proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line">proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startServer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//被代理的服务器host和port</span></span><br><span class="line">h := &amp;handle&#123;host: <span class="string">"127.0.0.1"</span>, port: <span class="string">"8999"</span>&#125;</span><br><span class="line">err := http.ListenAndServe(<span class="string">":8888"</span>, h)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">startServer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反向代理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#反向代理&quot;&gt;&lt;/a&gt; 反向代理&lt;/h2&gt;
&lt;p&gt;反向代理在计算机网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>xargs命令详解，xargs与管道的区别</title>
    <link href="https://dreamerjonson.com/2019/09/22/xargs%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%8Cxargs%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://dreamerjonson.com/2019/09/22/xargs命令详解，xargs与管道的区别/</id>
    <published>2019-09-22T15:33:30.000Z</published>
    <updated>2019-09-22T15:37:57.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读目录"><a class="markdownIt-Anchor" href="#阅读目录"></a> 阅读目录</h1><ul><li>为什么要用xargs，问题的来源</li><li>xargs是什么，与管道有什么不同</li><li>xargs的一些有用的选项</li></ul><h2 id="为什么要用xargs问题的来源"><a class="markdownIt-Anchor" href="#为什么要用xargs问题的来源"></a> 为什么要用xargs，问题的来源</h2><p>在工作中经常会接触到xargs命令，特别是在别人写的脚本里面也经常会遇到，但是却很容易与管道搞混淆，本篇会详细讲解到底什么是xargs命令，为什么要用xargs命令以及与管道的区别。为什么要用xargs呢，我们知道，linux命令可以从两个地方读取要处理的内容，一个是通过命令行参数，一个是标准输入。例如cat、grep就是这样的命令，举个例子：</p><p>echo ‘main’ | cat test.cpp<br>这种情况下cat会输出test.cpp的内容，而不是’main’字符串，如果test.cpp不存在则cat命令报告该文件不存在，并不会尝试从标准输入中读取。echo ‘main’ | 会通过管道将 echo 的标准输出(也就是字符串’main’)导入到 cat 的标准输入，也就是说此时cat的标准输入中是有内容的，其内容就是字符串’main’但是上面的内容中cat不会从它的标准输入中读入要处理的内容。(注:标准输入是有一个缓冲区的，就像我们在程序中使用scanf函数从标准输入中读取一样，实际上是从标准输入的缓冲区中读取的)。其实基本上linux的命令中很多的命令的设计是先从命令行参数中获取参数，然后从标准输入中读取，反映在程序上，命令行参数是通过main函数 int main(int argc,char*argv[]) 的函数参数获得的，而标准输入则是通过标准输入函数例如C语言中的scanf读取到的。他们获取的地方是不一样的。例如：</p><p>echo ‘main’ | cat<br>这条命令中cat会从其标准输入中读取内容并处理，也就是会输出 ‘main’ 字符串。echo命令将其标准输出的内容 ‘main’ 通过管道定向到 cat 的标准输入中。</p><p>cat<br>如果仅仅输入cat并回车，则该程序会等待输入，我们需要从键盘输入要处理的内容给cat，此时cat也是从标准输入中得到要处理的内容的，因为我们的cat命令行中也没有指定要处理的文件名。大多数命令有一个参数  -  如果直接在命令的最后指定 -  则表示从标准输入中读取，例如：</p><p>echo ‘main’ | cat -<br>这样也是可行的，会显示 ‘main’ 字符串，同样输入 cat - 直接回车与输入 cat 直接回车的效果也一样，但是如果这样呢：</p><p>echo ‘main’ | cat test.cpp -<br>同时指定test.cpp 和 - 参数，此时cat程序会先输出test.cpp的内容，然后输出标准输入’main’字符串，如果换一下顺序变成这样：</p><p>echo ‘main’ | cat - test.cpp<br>则会先输出标准输入’main’字符串，然后输出test.cpp文件的内容。如果去掉这里的 - 参数，则cat只会输出test.cpp文件的内容。另外如果同时传递标准输入和文件名，grep也会同时处理这两个输入，例如：</p><p>echo ‘main’ | grep ‘main’ test.cpp -<br>该命令的输出结果是:<br>test.cpp:int main()<br>(standard input):main</p><p>此时grep也会同时处理标准输入和文件test.cpp中的内容，也就是说会在标准输入中搜索 ‘main’ 也会在文件 test.cpp (该文件名从grep命令行参数中获得)中搜索 ‘main’。也就是说我们看到当命令行参数与标准输入同时存在的时候grep和cat是会同时处理这两个输入的，但是有很多命令并不是都处理。大多命令一般情况下是首先在命令行中查找要处理的内容的来源(是从文件还是从标准输入，还是都有)，如果在命令行中找不到与要处理的内容的来源相关的参数则默认从标准输入中读取要处理的内容了，当然这取决于命令程序的内部实现，就像cat命令，加不加 - 参数他的表现又不同。</p><p>另外很多程序是不处理标准输入的，例如 kill , rm 这些程序如果命令行参数中没有指定要处理的内容则不会默认从标准输入中读取。所以：</p><p>1<br>echo ‘516’ | kill<br>这种命里是不能执行的。</p><p>1<br>echo ‘test’ | rm -f<br>这种也是没有效果的。</p><p>这两个命令只接受命令行参数中指定的处理内容，不从标准输入中获取处理内容。想想也很正常，kill 是结束进程，rm是删除文件，如果要结束的进程pid和要删除的文件名需要从标准输入中读取，这个也很怪异吧。 但是像 cat与grep这些文字处理工具从标准输入中读取待处理的内容则很自然。</p><p>但是有时候我们的脚本却需要 echo ‘516’ | kill 这样的效果，例如 ps -ef | grep ‘ddd’ | kill 这样的效果，筛选出符合某条件的进程pid然后结束。这种需求对于我们来说是理所当然而且是很常见的，那么应该怎样达到这样的效果呢。有几个解决办法：</p><ol><li><p>通过 kill <code>ps -ef | grep 'ddd'</code><br>这种形式，这个时候实际上等同于拼接字符串得到的命令，其效果类似于  kill $pid</p></li><li><p>for procid in $(ps -aux | grep “some search” | awk ‘{print $2}’); do kill -9 $procid; done<br>其实与第一种原理一样，只不过需要多次kill的时候是循环处理的，每次处理一个</p></li><li><p>ps -ef | grep ‘ddd’ | xargs kill<br>OK，使用了xargs命令，铺垫了这么久终于铺到了主题上。xargs命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数(默认情况下是通过空格分割) 然后将参数传递给其后面的命令，作为后面命令的命令行参数</p></li></ol><p>xargs是什么，与管道有什么不同<br>xargs与管道有什么不同呢，这是两个很容易混淆的东西，看了上面的xargs的例子还是有点云里雾里的话，我们来看下面的例子弄清楚为什么需要xargs：</p><p>echo ‘–help’ | cat<br>输出：<br>–help</p><p>echo ‘–help’ | xargs cat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Usage: cat [OPTION]... [FILE]...</span><br><span class="line">Concatenate FILE(s), or standard input, to standard output.</span><br><span class="line"></span><br><span class="line">  -A, --show-all           equivalent to -vET</span><br><span class="line">  -b, --number-nonblank    number nonempty output lines</span><br><span class="line">  -e                       equivalent to -vE</span><br><span class="line">  -E, --show-ends          display $ at end of each line</span><br><span class="line">  -n, --number             number all output lines</span><br><span class="line">  -s, --squeeze-blank      suppress repeated empty output lines</span><br><span class="line">  -t                       equivalent to -vT</span><br><span class="line">  -T, --show-tabs          display TAB characters as ^I</span><br><span class="line">  -u                       (ignored)</span><br><span class="line">  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB</span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br><span class="line"></span><br><span class="line">With no FILE, or when FILE is -, read standard input.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  cat f - g  Output f&apos;s contents, then standard input, then g&apos;s contents.</span><br><span class="line">  cat        Copy standard input to standard output.</span><br><span class="line"></span><br><span class="line">Report cat bugs to bug-coreutils@gnu.org</span><br><span class="line">GNU coreutils home page: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">General help using GNU software: &lt;http://www.gnu.org/gethelp/&gt;</span><br><span class="line">For complete documentation, run: info coreutils &apos;cat invocation&apos;</span><br><span class="line">可以看到 echo &apos;--help&apos; | cat   该命令输出的是echo的内容，也就是说将echo的内容当作cat处理的文件内容了，实际上就是echo命令的输出通过管道定向到cat的输入了。然后cat从其标准输入中读取待处理的文本内容。这等价于在test.txt文件中有一行字符 &apos;--help&apos; 然后运行  cat test.txt 的效果。</span><br><span class="line"></span><br><span class="line">而 echo &apos;--help&apos; | xargs cat 等价于 cat --help 什么意思呢，就是xargs将其接受的字符串 --help 做成cat的一个命令参数来运行cat命令，同样  echo &apos;test.c test.cpp&apos; | xargs cat 等价于 cat test.c test.cpp 此时会将test.c和test.cpp的内容都显示出来。</span><br></pre></td></tr></table></figure><h2 id="xargs的一些有用的选项"><a class="markdownIt-Anchor" href="#xargs的一些有用的选项"></a> xargs的一些有用的选项</h2><p>相信到这里应该都知道xargs的作用了，那么我们看看xargs还有一些有用的选项：</p><ol><li>-d 选项<br>默认情况下xargs将其标准输入中的内容以空白(包括空格、Tab、回车换行等)分割成多个之后当作命令行参数传递给其后面的命令，并运行之，我们可以使用 -d 命令指定分隔符，例如：<br>echo ‘11@22@33’ | xargs echo<br>输出：<br>11@22@33<br>默认情况下以空白分割，那么11@22@33这个字符串中没有空白，所以实际上等价于 echo 11@22@33 其中字符串 ‘11@22@33’ 被当作echo命令的一个命令行参数</li></ol><p>echo ‘11@22@33’ | xargs -d ‘@’ echo<br>输出：<br>11 22 33<br>指定以@符号分割参数，所以等价于 echo 11 22 33 相当于给echo传递了3个参数，分别是11、22、33</p><ol start="2"><li><p>-p 选项<br>使用该选项之后xargs并不会马上执行其后面的命令，而是输出即将要执行的完整的命令(包括命令以及传递给命令的命令行参数)，询问是否执行，输入 y 才继续执行，否则不执行。这种方式可以清楚的看到执行的命令是什么样子，也就是xargs传递给命令的参数是什么，例如：<br>echo ‘11@22@33’ | xargs -p -d ‘@’  echo<br>输出：<br>echo 11 22 33<br>?..y      ==&gt;这里询问是否执行命令 echo 11 22 33 输入y并回车，则显示执行结果，否则不执行<br>11 22 33   ==&gt;执行结果</p></li><li><p>-n 选项<br>该选项表示将xargs生成的命令行参数，每次传递几个参数给其后面的命令执行，例如如果xargs从标准输入中读入内容，然后以分隔符分割之后生成的命令行参数有10个，使用 -n 3 之后表示一次传递给xargs后面的命令是3个参数，因为一共有10个参数，所以要执行4次，才能将参数用完。例如：</p></li></ol><p>echo ‘11@22@33@44@55@66@77@88@99@00’ | xargs -d ‘@’ -n 3 echo<br>输出结果：<br>11 22 33<br>44 55 66<br>77 88 99<br>00<br>等价于：<br>echo 11 22 33<br>echo 44 55 66<br>echo 77 88 99<br>echo 00<br>实际上运行了4次，每次传递3个参数，最后还剩一个，就直接传递一个参数。</p><ol start="4"><li>-E 选项，有的系统的xargs版本可能是-e  eof-str<br>该选项指定一个字符串，当xargs解析出多个命令行参数的时候，如果搜索到-e指定的命令行参数，则只会将-e指定的命令行参数之前的参数(不包括-e指定的这个参数)传递给xargs后面的命令<br>echo ‘11 22 33’ | xargs -E ‘33’ echo<br>输出：<br>11 22</li></ol><p>可以看到正常情况下有3个命令行参数 11、22、33 由于使用了-E ‘33’ 表示在将命令行参数 33 之前的参数传递给执行的命令，33本身不传递。等价于 echo 11 22 这里-E实际上有搜索的作用，表示只取xargs读到的命令行参数前面的某些部分给命令执行。</p><p>注意：-E只有在xargs不指定-d的时候有效，如果指定了-d则不起作用，而不管-d指定的是什么字符，空格也不行。</p><p>echo ‘11 22 33’ | xargs -d ’ ’ -E ‘33’ echo  =&gt; 输出 11 22 33<br>echo ‘11@22@33@44@55@66@77@88@99@00 aa 33 bb’ | xargs -E ‘33’ -d ‘@’ -p  echo  =&gt; 输出 11 22 33 44 55 66 77 88 99 00 aa 33 bb</p><h2 id="-0-选项表示以-0-为分隔符一般与find结合使用"><a class="markdownIt-Anchor" href="#-0-选项表示以-0-为分隔符一般与find结合使用"></a> -0 选项表示以 ‘\0’ 为分隔符，一般与find结合使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot;</span><br><span class="line">输出：</span><br><span class="line">./2.txt</span><br><span class="line">./3.txt</span><br><span class="line">./1.txt     =&gt; 默认情况下find的输出结果是每条记录后面加上换行，也就是每条记录是一个新行</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -print0</span><br><span class="line">输出：</span><br><span class="line">./2.txt./3.txt./1.txt     =&gt; 加上 -print0 参数表示find输出的每条结果后面加上 &apos;\0&apos; 而不是换行</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -print0 | xargs -0 echo</span><br><span class="line">输出：</span><br><span class="line">./2.txt ./3.txt ./1.txt</span><br><span class="line"></span><br><span class="line">find . -name &quot;*.txt&quot; -print0 | xargs -d &apos;\0&apos; echo</span><br><span class="line">输出：</span><br><span class="line">./2.txt ./3.txt ./1.txt</span><br><span class="line"></span><br><span class="line">xargs的 -0 和 -d &apos;\0&apos; 表示其从标准输入中读取的内容使用 &apos;\0&apos; 来分割，由于 find 的结果是使用 &apos;\0&apos; 分隔的，所以xargs使用 &apos;\0&apos; 将 find的结果分隔之后得到3个参数： ./2.txt ./3.txt ./1.txt  注意中间是有空格的。上面的结果就等价于 echo ./2.txt ./3.txt ./1.txt</span><br><span class="line"></span><br><span class="line">实际上使用xargs默认的空白分隔符也是可以的  find . -name &quot;*.txt&quot;  | xargs  echo   因为换行符也是xargs的默认空白符的一种。find命令如果不加-print0其搜索结果的每一条字符串后面实际上是加了换行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阅读目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#阅读目录&quot;&gt;&lt;/a&gt; 阅读目录&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;为什么要用xargs，问题的来源&lt;/li&gt;
&lt;li&gt;xargs是什么，与管道有什么不同&lt;/li&gt;
&lt;li&gt;xargs的一
      
    
    </summary>
    
      <category term="linux" scheme="https://dreamerjonson.com/categories/linux/"/>
    
    
      <category term="linux" scheme="https://dreamerjonson.com/tags/linux/"/>
    
  </entry>
  
</feed>
