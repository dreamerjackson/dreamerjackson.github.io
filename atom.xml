<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jonson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreamerjonson.com/"/>
  <updated>2020-01-14T04:07:05.477Z</updated>
  <id>https://dreamerjonson.com/</id>
  
  <author>
    <name>Jonson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang[112]-raft理论与实践[4]-lab2b</title>
    <link href="https://dreamerjonson.com/2020/01/12/golang-113-raft-4-log/"/>
    <id>https://dreamerjonson.com/2020/01/12/golang-113-raft-4-log/</id>
    <published>2020-01-12T13:00:32.000Z</published>
    <updated>2020-01-14T04:07:05.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>1、阅读<a href="http://nil.csail.mit.edu/6.824/2017/papers/raft-extended.pdf" target="_blank" rel="noopener">raft论文</a><br>2、阅读<a href="https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/">raft理论与实践[1]-理论篇</a><br>3、阅读<a href="https://dreamerjonson.com/2020/01/06/golang-111-raft-2/">raft理论与实践[2]-lab2a</a><br>4、阅读<a href="https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/">raft理论与实践[3]-lab2a讲解</a><br>5、查看我写的这篇文章： <a href="https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/">模拟RPC远程过程调用</a></p><h2 id="执行日志"><a class="markdownIt-Anchor" href="#执行日志"></a> 执行日志</h2><p>我们需要执行日志中的命令，因此在make函数中，新开一个协程:applyLogEntryDaemon()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Make</span><span class="params">(peers []*labrpc.ClientEnd, me <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">persister *Persister, applyCh <span class="keyword">chan</span> ApplyMsg)</span> *<span class="title">Raft</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">go</span> rf.applyLogEntryDaemon() <span class="comment">// start apply log</span></span><br><span class="line">DPrintf(<span class="string">"[%d-%s]: newborn election(%s) heartbeat(%s) term(%d) voted(%d)\n"</span>,</span><br><span class="line">rf.me, rf, rf.electionTimeout, rf.heartbeatInterval, rf.CurrentTerm, rf.VotedFor)</span><br><span class="line"><span class="keyword">return</span> rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个死循环<br>1、如果rf.lastApplied == rf.commitIndex, 意味着commit log entry命令都已经被执行了，这时用信号量陷入等待。<br>一旦收到信号，说明需要执行命令。这时会把最后执行的log entry之后，一直到最后一个commit log entry的所有log都传入通道apply中进行执行。<br>由于是测试，处理apply的逻辑会在测试代码中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// applyLogEntryDaemon exit when shutdown channel is closed</span><br><span class="line">func (rf *Raft) applyLogEntryDaemon() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">var logs []LogEntry</span><br><span class="line">// wait</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">for rf.lastApplied == rf.commitIndex &#123;</span><br><span class="line">rf.commitCond.Wait()</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down apply log entry to client daemon.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">close(rf.applyCh)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">last, cur := rf.lastApplied, rf.commitIndex</span><br><span class="line">if last &lt; cur &#123;</span><br><span class="line">rf.lastApplied = rf.commitIndex</span><br><span class="line">logs = make([]LogEntry, cur-last)</span><br><span class="line">copy(logs, rf.Logs[last+1:cur+1])</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">for i := 0; i &lt; cur-last; i++ &#123;</span><br><span class="line">// current command is replicated, ignore nil command</span><br><span class="line">reply := ApplyMsg&#123;</span><br><span class="line">CommandIndex: last + i + 1,</span><br><span class="line">Command:      logs[i].Command,</span><br><span class="line">CommandValid: true,</span><br><span class="line">&#125;</span><br><span class="line">// reply to outer service</span><br><span class="line">// DPrintf(&quot;[%d-%s]: peer %d apply %v to client.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d apply to client.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">// Note: must in the same goroutine, or may result in out of order apply</span><br><span class="line">rf.applyCh &lt;- reply</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 Start函数，此函数为leader执行从client发送过来的命令。<br>当client发送过来之后，首先需要做的就是新增entry 到leader的log中。并且将自身的nextIndex 与matchIndex 更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123;</span><br><span class="line">index := -1</span><br><span class="line">term := 0</span><br><span class="line">isLeader := false</span><br><span class="line"></span><br><span class="line">// Your code here (2B).</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">return -1, 0, false</span><br><span class="line">default:</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">// Your code here (2B).</span><br><span class="line">if rf.state == Leader &#123;</span><br><span class="line">log := LogEntry&#123;rf.CurrentTerm, command&#125;</span><br><span class="line">rf.Logs = append(rf.Logs, log)</span><br><span class="line"></span><br><span class="line">index = len(rf.Logs) - 1</span><br><span class="line">term = rf.CurrentTerm</span><br><span class="line">isLeader = true</span><br><span class="line"></span><br><span class="line">//DPrintf(&quot;[%d-%s]: client add new entry (%d-%v), logs: %v\n&quot;, rf.me, rf, index, command, rf.logs)</span><br><span class="line">DPrintf(&quot;[%d-%s]: client add new entry (%d)\n&quot;, rf.me, rf, index)</span><br><span class="line">//DPrintf(&quot;[%d-%s]: client add new entry (%d-%v)\n&quot;, rf.me, rf, index, command)</span><br><span class="line"></span><br><span class="line">// only update leader</span><br><span class="line">rf.nextIndex[rf.me] = index + 1</span><br><span class="line">rf.matchIndex[rf.me] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return index, term, isLeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来最重要的部分涉及到日志复制，这是通过AppendEntries实现的。我们知道leader会不时的调用consistencyCheck(n)进行一致性检查。<br>在给第n号节点一致性检查时，首先获取pre = rf.nextIndex，pre至少要为1。代表要给n节点发送的log index。因此AppendEntriesArgs参数中，PrevLogIndex 与 prevlogTerm 都为pre - 1位置。<br>代表leader相信PrevLogIndex及其之前的节点都是与leader相同的。<br>将pre及其之后的entry 加入到AppendEntriesArgs参数中。 这些log entry可能是与leader不相同的，或者是follower根本就没有的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">consistencyCheck</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">pre := max(<span class="number">1</span>,rf.nextIndex[n])</span><br><span class="line"><span class="keyword">var</span> args = AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.CurrentTerm,</span><br><span class="line">LeaderID:     rf.me,</span><br><span class="line">PrevLogIndex: pre - <span class="number">1</span>,</span><br><span class="line">PrevLogTerm:  rf.Logs[pre - <span class="number">1</span>].Term,</span><br><span class="line">Entries:      <span class="literal">nil</span>,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.nextIndex[n] &lt; <span class="built_in">len</span>(rf.Logs)&#123;</span><br><span class="line">args.Entries = <span class="built_in">append</span>(args.Entries, rf.Logs[pre:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">DPrintf(<span class="string">"[%d-%s]: consistency Check to peer %d.\n"</span>, rf.me, rf, n)</span><br><span class="line"><span class="keyword">var</span> reply AppendEntriesReply</span><br><span class="line"><span class="keyword">if</span> rf.sendAppendEntries(n, &amp;args, &amp;reply) &#123;</span><br><span class="line">rf.consistencyCheckReplyHandler(n, &amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来查看follower执行AppendEntries时的反应。<br>AppendEntries会新增两个返回参数：<br>ConflictTerm代表可能发生冲突的term<br>FirstIndex 代表可能发生冲突的第一个index。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type AppendEntriesReply struct &#123;</span><br><span class="line">CurrentTerm int  // currentTerm, for leader to update itself</span><br><span class="line">Success     bool // true if follower contained entry matching prevLogIndex and prevLogTerm</span><br><span class="line">// extra info for heartbeat from follower</span><br><span class="line">ConflictTerm int // term of the conflicting entry</span><br><span class="line">FirstIndex   int // the first index it stores for ConflictTerm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果args.PrevLogIndex &lt; len(rf.Logs), 表明至少当前节点的log长度是合理的。<br>令preLogIdx 与 args.PrevLogIndex相等。prelogTerm为当前follower节点preLogIdx位置的term。<br>如果拥有相同的term，说明follower与leader 在preLogIdx之前的log entry都是相同的。因此请求是成功的。<br>此时会截断follower的log，将传递过来的entry加入到follower的log之后，执行此步骤后，强制要求与leader的log相同了。<br>请求成功后，reply的ConflictTerm为最后一个log entry的term,reply的FirstIndex为最后一个log entry的index。</p><p>否则说明leader与follower的日志是有冲突的，冲突的原因可能是：<br>1、leader认为的match log entry超出了follower的log个数，或者follower 还没有任何log entry（除了index为0的entry是每一个节点都有的）。<br>2、log在相同的index下，leader的term 与follower的term确是不同的。<br>这时找到follower冲突的term即为ConflictTerm。<br>获取此term的第一个entry的index即为FirstIndex。<br>所以最后，AppendEntries会返回冲突的term以及第一个可能冲突的index。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">// AppendEntries handler, including heartbeat, must backup quickly</span><br><span class="line">func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">    ...</span><br><span class="line">    preLogIdx, preLogTerm := 0, 0</span><br><span class="line">if args.PrevLogIndex &lt; len(rf.Logs) &#123;</span><br><span class="line">preLogIdx = args.PrevLogIndex</span><br><span class="line">preLogTerm = rf.Logs[preLogIdx].Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// last log is match</span><br><span class="line">if preLogIdx == args.PrevLogIndex &amp;&amp; preLogTerm == args.PrevLogTerm &#123;</span><br><span class="line">reply.Success = true</span><br><span class="line">// truncate to known match</span><br><span class="line">rf.Logs = rf.Logs[:preLogIdx+1]</span><br><span class="line">rf.Logs = append(rf.Logs, args.Entries...)</span><br><span class="line">var last = len(rf.Logs) - 1</span><br><span class="line"></span><br><span class="line">// min(leaderCommit, index of last new entry)</span><br><span class="line">if args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">rf.commitIndex = min(args.LeaderCommit, last)</span><br><span class="line">// signal possible update commit index</span><br><span class="line">go func() &#123; rf.commitCond.Broadcast() &#125;()</span><br><span class="line">&#125;</span><br><span class="line">// tell leader to update matched index</span><br><span class="line">reply.ConflictTerm = rf.Logs[last].Term</span><br><span class="line">reply.FirstIndex = last</span><br><span class="line"></span><br><span class="line">if len(args.Entries) &gt; 0 &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: AE success from leader %d (%d cmd @ %d), commit index: l-&gt;%d, f-&gt;%d.\n&quot;,</span><br><span class="line">rf.me, rf, args.LeaderID, len(args.Entries), preLogIdx+1, args.LeaderCommit, rf.commitIndex)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: &lt;heartbeat&gt; current logs: %v\n&quot;, rf.me, rf, rf.Logs)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">reply.Success = false</span><br><span class="line"></span><br><span class="line">// extra info for restore missing entries quickly: from original paper and lecture note</span><br><span class="line">// if follower rejects, includes this in reply:</span><br><span class="line">//</span><br><span class="line">// the follower&apos;s term in the conflicting entry</span><br><span class="line">// the index of follower&apos;s first entry with that term</span><br><span class="line">//</span><br><span class="line">// if leader knows about the conflicting term:</span><br><span class="line">// move nextIndex[i] back to leader&apos;s last entry for the conflicting term</span><br><span class="line">// else:</span><br><span class="line">// move nextIndex[i] back to follower&apos;s first index</span><br><span class="line">var first = 1</span><br><span class="line">reply.ConflictTerm = preLogTerm</span><br><span class="line">if reply.ConflictTerm == 0 &#123;</span><br><span class="line">// which means leader has more logs or follower has no log at all</span><br><span class="line">first = len(rf.Logs)</span><br><span class="line">reply.ConflictTerm = rf.Logs[first-1].Term</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i := preLogIdx</span><br><span class="line">// term的第一个log entry</span><br><span class="line">for ; i &gt; 0; i-- &#123;</span><br><span class="line">if rf.Logs[i].Term != preLogTerm &#123;</span><br><span class="line">first = i + 1</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reply.FirstIndex = first</span><br><span class="line">if len(rf.Logs) &lt;= args.PrevLogIndex &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: AE failed from leader %d, leader has more logs (%d &gt; %d), reply: %d - %d.\n&quot;,</span><br><span class="line">rf.me, rf, args.LeaderID, args.PrevLogIndex, len(rf.Logs)-1, reply.ConflictTerm,</span><br><span class="line">reply.FirstIndex)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: AE failed from leader %d, pre idx/term mismatch (%d != %d, %d != %d).\n&quot;,</span><br><span class="line">rf.me, rf, args.LeaderID, args.PrevLogIndex, preLogIdx, args.PrevLogTerm, preLogTerm)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leader调用AppendEntries后，会执行回调函数consistencyCheckReplyHandler。<br>如果调用是成功的，那么正常的跟新matchIndex，nextIndex即下一个要发送的index应该为matchIndex + 1。</p><p>如果调用失败，说明有冲突。<br>如果confiicting term等于0，说明了leader认为的match log entry超出了follower的log个数，或者follower 还没有任何log entry（除了index为0的entry是每一个节点都有的）。<br>此时简单的让nextIndex 为reply.FirstIndex即可。</p><p>如果confiicting term不为0，获取leader节点confiicting term 的最后一个log index，此时nextIndex 应该为此index与reply.FirstIndex的最小值。<br>检查最小值是必须的：<br>假设<br>s1: 0-0 1-1 1-2 1-3 1-4 1-5<br>s2: 0-0 1-1 1-2 1-3 1-4 1-5<br>s3: 0-0 1-1</p><p>此时s1为leader，并一致性检查s3, 从1-5开始检查，此时由于leader有更多的log，因此检查不成功，返回confict term 1， firstindex：2<br>如果只是获取confiicting term 的最后一个log index，那么nextIndex又是1-5，陷入了死循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) consistencyCheckReplyHandler(n int, reply *AppendEntriesReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if rf.state != Leader &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.Success &#123;</span><br><span class="line">// RPC and consistency check successful</span><br><span class="line">rf.matchIndex[n] = reply.FirstIndex</span><br><span class="line">rf.nextIndex[n] = rf.matchIndex[n] + 1</span><br><span class="line">rf.updateCommitIndex() // try to update commitIndex</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// found a new leader? turn to follower</span><br><span class="line">if rf.state == Leader &amp;&amp; reply.CurrentTerm &gt; rf.CurrentTerm &#123;</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d found new term (heartbeat resp from peer %d), turn to follower.&quot;,</span><br><span class="line">rf.me, rf, rf.me, n)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Does leader know conflicting term?</span><br><span class="line">var know, lastIndex = false, 0</span><br><span class="line">if reply.ConflictTerm != 0 &#123;</span><br><span class="line">for i := len(rf.Logs) - 1; i &gt; 0; i-- &#123;</span><br><span class="line">if rf.Logs[i].Term == reply.ConflictTerm &#123;</span><br><span class="line">know = true</span><br><span class="line">lastIndex = i</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d have entry %d is the last entry in term %d.&quot;,</span><br><span class="line">rf.me, rf, rf.me, i, reply.ConflictTerm)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if know &#123;</span><br><span class="line">rf.nextIndex[n] = min(lastIndex, reply.FirstIndex)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rf.nextIndex[n] = reply.FirstIndex</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rf.nextIndex[n] = reply.FirstIndex</span><br><span class="line">&#125;</span><br><span class="line">rf.nextIndex[n] = min(rf.nextIndex[n], len(rf.Logs))</span><br><span class="line">DPrintf(&quot;[%d-%s]: nextIndex for peer %d  =&gt; %d.\n&quot;,</span><br><span class="line">rf.me, rf, n, rf.nextIndex[n])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用AppendEntry成功后，说明follower与leader的log是匹配的。此时leader会找到commited的log并且执行其命令。<br>这里有一个比较巧妙的方法，对matchIndex排序后取最中间的数。<br>由于matchIndex代表follower有多少log与leader的log匹配，因此中间的log index意味着其得到了大部分节点的认可。<br>因此会将此中间的index之前的所有log entry都执行了。<br>rf.Logs[target].Term == rf.CurrentTerm 是必要的：<br>这是由于当一个entry出现在大多数节点的log中，并不意味着其一定会成为commit。考虑下面的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S1: 1 2     1 2 4</span><br><span class="line">S2: 1 2     1 2</span><br><span class="line">S3: 1   --&gt; 1 2</span><br><span class="line">S4: 1       1</span><br><span class="line">S5: 1       1 3</span><br></pre></td></tr></table></figure><p>s1在term2成为leader，只有s1，s2添加了entry2.<br>s5变成了term3的leader，之后s1变为了term4的leader，接着继续发送entry2到s3中。<br>此时，如果s5再次变为了leader，那么即便没有S1的支持，S5任然变为了leader，并且应用entry3，覆盖掉entry2。<br>所以一个entry要变为commit，必须：<br>1、在其term周期内，就复制到大多数。<br>2、如果随后的entry被提交。在上例中，如果s1持续成为term4的leader，那么entry2就会成为commit。</p><p>这是由于以下原因造成的：<br>更高任期为最新的投票规则，以及leader将其日志强加给follower。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// updateCommitIndex find new commit id, must be called when hold lock</span><br><span class="line">func (rf *Raft) updateCommitIndex() &#123;</span><br><span class="line">match := make([]int, len(rf.matchIndex))</span><br><span class="line">copy(match, rf.matchIndex)</span><br><span class="line">sort.Ints(match)</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d try to update commit index: %v @ term %d.\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, rf.matchIndex, rf.CurrentTerm)</span><br><span class="line"></span><br><span class="line">target := match[len(rf.peers)/2]</span><br><span class="line">if rf.commitIndex &lt; target &#123;</span><br><span class="line">//fmt.Println(&quot;target:&quot;,target,match)</span><br><span class="line">if rf.Logs[target].Term == rf.CurrentTerm &#123;</span><br><span class="line">//DPrintf(&quot;[%d-%s]: leader %d update commit index %d -&gt; %d @ term %d command:%v\n&quot;,</span><br><span class="line">//rf.me, rf, rf.me, rf.commitIndex, target, rf.CurrentTerm,rf.Logs[target].Command)</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d update commit index %d -&gt; %d @ term %d\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, rf.commitIndex, target, rf.CurrentTerm)</span><br><span class="line"></span><br><span class="line">rf.commitIndex = target</span><br><span class="line">go func() &#123; rf.commitCond.Broadcast() &#125;()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d update commit index %d failed (log term %d != current Term %d)\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, rf.commitIndex, rf.Logs[target].Term, rf.CurrentTerm)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://github.com/dreamerjackson/Distributed-Systems/blob/master/Lec06_Fault_Tolerance_Raft/l-raft2.txt" target="_blank" rel="noopener">讲义</a><br><a href="https://pdos.csail.mit.edu/6.824/notes/l-raft2.txt" target="_blank" rel="noopener">讲义新</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h2&gt;
&lt;p&gt;1、阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/raft-exten
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[112]-raft理论与实践[3]-lab2a讲解</title>
    <link href="https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/"/>
    <id>https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/</id>
    <published>2020-01-06T12:15:46.000Z</published>
    <updated>2020-01-12T12:56:56.541Z</updated>
    
    <content type="html"><![CDATA[<p>1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer's state</span></span><br><span class="line">peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister *Persister          <span class="comment">// Object to hold this peer's persisted state</span></span><br><span class="line">me        <span class="keyword">int</span>                 <span class="comment">// this peer's index into peers[]</span></span><br><span class="line">dead      <span class="keyword">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line"><span class="comment">// Look at the paper's Figure 2 for a description of what</span></span><br><span class="line"><span class="comment">// state a Raft server must maintain.</span></span><br><span class="line">state             <span class="keyword">int</span>           <span class="comment">// follower, candidate or leader</span></span><br><span class="line">resetTimer        <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// for reset election timer</span></span><br><span class="line">electionTimer     *time.Timer   <span class="comment">// election timer</span></span><br><span class="line">electionTimeout   time.Duration <span class="comment">// 400~800ms</span></span><br><span class="line">heartbeatInterval time.Duration <span class="comment">// 100ms</span></span><br><span class="line"></span><br><span class="line">CurrentTerm <span class="keyword">int</span>        <span class="comment">// Persisted before responding to RPCs</span></span><br><span class="line">VotedFor    <span class="keyword">int</span>        <span class="comment">// Persisted before responding to RPCs</span></span><br><span class="line">Logs        []LogEntry <span class="comment">// Persisted before responding to RPCs</span></span><br><span class="line">commitCond  *sync.Cond <span class="comment">// for commitIndex update</span></span><br><span class="line"><span class="comment">//newEntryCond []*sync.Cond // for new log entry</span></span><br><span class="line">commitIndex <span class="keyword">int</span>           <span class="comment">// Volatile state on all servers</span></span><br><span class="line">lastApplied <span class="keyword">int</span>           <span class="comment">// Volatile state on all servers</span></span><br><span class="line">nextIndex   []<span class="keyword">int</span>         <span class="comment">// Leader only, reinitialized after election</span></span><br><span class="line">matchIndex  []<span class="keyword">int</span>         <span class="comment">// Leader only, reinitialized after election</span></span><br><span class="line">applyCh     <span class="keyword">chan</span> ApplyMsg <span class="comment">// outgoing channel to service</span></span><br><span class="line">shutdownCh  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// shutdown channel, shut raft instance gracefully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取当前raft节点的term与状态"><a class="markdownIt-Anchor" href="#获取当前raft节点的term与状态"></a> 获取当前raft节点的term与状态</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) GetState() (int, bool) &#123;</span><br><span class="line"></span><br><span class="line">var term int</span><br><span class="line">var isleader bool</span><br><span class="line">// Your code here (2A).</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">term = rf.CurrentTerm</span><br><span class="line">isleader = rf.state == Leader</span><br><span class="line">return term, isleader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-填充requestvoteargs和requestvotereply结构"><a class="markdownIt-Anchor" href="#2-填充requestvoteargs和requestvotereply结构"></a> 2、填充RequestVoteArgs和RequestVoteReply结构。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type RequestVoteArgs struct &#123;</span><br><span class="line">// Your data here (2A, 2B).</span><br><span class="line">Term         int // candidate&apos;s term</span><br><span class="line">CandidateID  int // candidate requesting vote</span><br><span class="line">LastLogIndex int // index of candidate&apos;s last log entry</span><br><span class="line">LastLogTerm  int // term of candidate&apos;s last log entry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type RequestVoteReply struct &#123;</span><br><span class="line">// Your data here (2A).</span><br><span class="line">CurrentTerm int  // currentTerm, for candidate to update itself</span><br><span class="line">VoteGranted bool // true means candidate received vote</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现rpc方法requestvote"><a class="markdownIt-Anchor" href="#实现rpc方法requestvote"></a> 实现RPC方法RequestVote</h2><p>1、获取当前节点的log个数，以及最后一个log的term 确定当前节点的term。<br>2、如果调用节点的term小于当前节点，返回当前term，并且不为其投票。<br>3、如果调用节点的term大于当前节点，修改当前节点的term，当前节点转为follower.<br>4、如果调用节点的term大于当前节点，或者等于当前节点term并且调用节点的log个数大于等于当前节点的log，则为调用节点投票。<br>5、投票后重置当前节点的选举超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">// Your code here (2A, 2B).</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down, reject RV rpc request.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">lastLogIdx, lastLogTerm := rf.lastLogIndexAndTerm()</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: rpc RV, from peer: %d, arg term: %d, my term: %d (last log idx: %d-&gt;%d, term: %d-&gt;%d)\n&quot;, rf.me, rf, args.CandidateID, args.Term, rf.CurrentTerm, args.LastLogIndex,</span><br><span class="line">lastLogIdx, args.LastLogTerm, lastLogTerm)</span><br><span class="line"></span><br><span class="line">if args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">reply.CurrentTerm = rf.CurrentTerm</span><br><span class="line">reply.VoteGranted = false</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if args.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">// convert to follower</span><br><span class="line">rf.CurrentTerm = args.Term</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.VotedFor = -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// if is null (follower) or itself is a candidate (or stale leader) with same term</span><br><span class="line">if rf.VotedFor == -1 &#123; //|| (rf.VotedFor == rf.me &amp;&amp; !sameTerm) &#123; //|| rf.votedFor == args.CandidateID &#123;</span><br><span class="line">// check whether candidate&apos;s log is at-least-as update</span><br><span class="line">if (args.LastLogTerm == lastLogTerm &amp;&amp; args.LastLogIndex &gt;= lastLogIdx) ||</span><br><span class="line">args.LastLogTerm &gt; lastLogTerm &#123;</span><br><span class="line"></span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.VotedFor = args.CandidateID</span><br><span class="line">reply.VoteGranted = true</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d vote to peer %d (last log idx: %d-&gt;%d, term: %d-&gt;%d)\n&quot;,</span><br><span class="line">rf.me, rf, rf.me, args.CandidateID, args.LastLogIndex, lastLogIdx, args.LastLogTerm, lastLogTerm)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改make"><a class="markdownIt-Anchor" href="#修改make"></a> 修改make</h2><p>除了一些基本的初始化过程,新开了一个goroutine。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func Make(peers []*labrpc.ClientEnd, me int,</span><br><span class="line">persister *Persister, applyCh chan ApplyMsg) *Raft &#123;</span><br><span class="line">rf := &amp;Raft&#123;&#125;</span><br><span class="line">rf.peers = peers</span><br><span class="line">rf.persister = persister</span><br><span class="line">rf.me = me</span><br><span class="line">rf.applyCh = applyCh</span><br><span class="line">// Your initialization code here (2A, 2B, 2C).</span><br><span class="line">rf.state = Follower</span><br><span class="line">rf.VotedFor = -1</span><br><span class="line">rf.Logs = make([]LogEntry, 1) // first index is 1</span><br><span class="line">rf.Logs[0] = LogEntry&#123;        // placeholder</span><br><span class="line">Term:    0,</span><br><span class="line">Command: nil,</span><br><span class="line">&#125;</span><br><span class="line">rf.nextIndex = make([]int, len(peers))</span><br><span class="line">rf.matchIndex = make([]int, len(peers))</span><br><span class="line"></span><br><span class="line">rf.electionTimeout = time.Millisecond * time.Duration(400+rand.Intn(100)*4)</span><br><span class="line">rf.electionTimer = time.NewTimer(rf.electionTimeout)</span><br><span class="line">rf.resetTimer = make(chan struct&#123;&#125;)</span><br><span class="line">rf.shutdownCh = make(chan struct&#123;&#125;)           // shutdown raft gracefully</span><br><span class="line">rf.commitCond = sync.NewCond(&amp;rf.mu)          // commitCh, a distinct goroutine</span><br><span class="line">rf.heartbeatInterval = time.Millisecond * 40 // small enough, not too small</span><br><span class="line"></span><br><span class="line">// initialize from state persisted before a crash</span><br><span class="line">rf.readPersist(persister.ReadRaftState())</span><br><span class="line">go rf.electionDaemon() // kick off election</span><br><span class="line">return rf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选举核心electiondaemon"><a class="markdownIt-Anchor" href="#选举核心electiondaemon"></a> 选举核心electionDaemon</h2><p>除了shutdown，还有两个通道，一个是electionTimer，用于选举超时。<br>一个是resetTimer,用于重置选举超时。<br>注意time.reset是很难正确使用的。<br>一旦选举超时，调用go rf.canvassVotes()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// electionDaemon</span><br><span class="line">func (rf *Raft) electionDaemon() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down electionDaemon.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">case &lt;-rf.resetTimer:</span><br><span class="line">if !rf.electionTimer.Stop() &#123;</span><br><span class="line">&lt;-rf.electionTimer.C</span><br><span class="line">&#125;</span><br><span class="line">rf.electionTimer.Reset(rf.electionTimeout)</span><br><span class="line">case &lt;-rf.electionTimer.C:</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d election timeout, issue election @ term %d\n&quot;, rf.me, rf, rf.me, rf.CurrentTerm)</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">go rf.canvassVotes()</span><br><span class="line">rf.electionTimer.Reset(rf.electionTimeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拉票"><a class="markdownIt-Anchor" href="#拉票"></a> 拉票</h2><p>replyHandler是进行请求返回后的处理。<br>当前节点为了成为leader，会调用每一个节点的RequestVote方法。<br>如果返回过来的term大于当前term，那么当前节点变为follower,重置选举超时时间。</p><p>否则，如果收到了超过一半节点的投票,那么其变为了leader，并立即给其他节点发送心跳检测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// canvassVotes issues RequestVote RPC</span><br><span class="line">func (rf *Raft) canvassVotes() &#123;</span><br><span class="line">var voteArgs RequestVoteArgs</span><br><span class="line">rf.fillRequestVoteArgs(&amp;voteArgs)</span><br><span class="line">peers := len(rf.peers)</span><br><span class="line"></span><br><span class="line">var votes = 1</span><br><span class="line">replyHandler := func(reply *RequestVoteReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">if rf.state == Candidate &#123;</span><br><span class="line">if reply.CurrentTerm &gt; voteArgs.Term &#123;</span><br><span class="line">rf.CurrentTerm = reply.CurrentTerm</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">//rf.persist()</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; // reset timer</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.VoteGranted &#123;</span><br><span class="line">if votes == peers/2 &#123;</span><br><span class="line">rf.state = Leader</span><br><span class="line">rf.resetOnElection()    // reset leader state</span><br><span class="line">go rf.heartbeatDaemon() // new leader, start heartbeat daemon</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d become new leader.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">votes++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for i := 0; i &lt; peers; i++ &#123;</span><br><span class="line">if i != rf.me &#123;</span><br><span class="line">go func(n int) &#123;</span><br><span class="line">var reply RequestVoteReply</span><br><span class="line">if rf.sendRequestVote(n, &amp;voteArgs, &amp;reply) &#123;</span><br><span class="line">replyHandler(&amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="心跳检测"><a class="markdownIt-Anchor" href="#心跳检测"></a> 心跳检测</h2><p>1、leader调用每一个节点的AppendEntries方法。<br>2、如果当前节点大于调用节点，那么AppendEntries失败。否则，修改当前的term为最大。<br>3、如果当前节点是leader，始终将其变为follower（为了让leader稳定）<br>4、将当前节点投票给调用者（对于落后的节点）。<br>5、重置当前节点的超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) heartbeatDaemon() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">if _, isLeader := rf.GetState(); !isLeader &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// reset leader&apos;s election timer</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">for i := 0; i &lt; len(rf.peers); i++ &#123;</span><br><span class="line">if i != rf.me &#123;</span><br><span class="line">go rf.consistencyCheck(i) // routine heartbeat</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(rf.heartbeatInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (rf *Raft) consistencyCheck(n int) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line">pre := rf.nextIndex[n] - 1</span><br><span class="line">var args = AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.CurrentTerm,</span><br><span class="line">LeaderID:     rf.me,</span><br><span class="line">PrevLogIndex: pre,</span><br><span class="line">PrevLogTerm:  rf.Logs[pre].Term,</span><br><span class="line">Entries:      nil,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line">go func() &#123;</span><br><span class="line">DPrintf(&quot;[%d-%s]: consistency Check to peer %d.\n&quot;, rf.me, rf, n)</span><br><span class="line">var reply AppendEntriesReply</span><br><span class="line">if rf.sendAppendEntries(n, &amp;args, &amp;reply) &#123;</span><br><span class="line">rf.consistencyCheckReplyHandler(n, &amp;reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-rf.shutdownCh:</span><br><span class="line">DPrintf(&quot;[%d-%s]: peer %d is shutting down, reject AE rpc request.\n&quot;, rf.me, rf, rf.me)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DPrintf(&quot;[%d-%s]: rpc AE, from peer: %d, term: %d\n&quot;, rf.me, rf, args.LeaderID, args.Term)</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">//DPrintf(&quot;[%d-%s]: AE failed from leader %d. (heartbeat: leader&apos;s term &lt; follower&apos;s term (%d &lt; %d))\n&quot;,</span><br><span class="line">//rf.me, rf, args.LeaderID, args.Term, rf.currentTerm)</span><br><span class="line">reply.CurrentTerm = rf.CurrentTerm</span><br><span class="line">reply.Success = false</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if rf.CurrentTerm &lt; args.Term &#123;</span><br><span class="line">rf.CurrentTerm = args.Term</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// for stale leader</span><br><span class="line">if rf.state == Leader &#123;</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">&#125;</span><br><span class="line">// for straggler (follower)</span><br><span class="line">if rf.VotedFor != args.LeaderID &#123;</span><br><span class="line">rf.VotedFor = args.LeaderID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// valid AE, reset election timer</span><br><span class="line">// if the node recieve heartbeat. then it will reset the election timeout</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">reply.Success = true</span><br><span class="line">reply.CurrentTerm = rf.CurrentTerm</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理心跳检测返回"><a class="markdownIt-Anchor" href="#处理心跳检测返回"></a> 处理心跳检测返回</h2><p>如果心跳检测失败了，那么变为follower，重置选举超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// n: which follower</span><br><span class="line">func (rf *Raft) consistencyCheckReplyHandler(n int, reply *AppendEntriesReply) &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line">defer rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if rf.state != Leader &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if reply.Success &#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">// found a new leader? turn to follower</span><br><span class="line">if rf.state == Leader &amp;&amp; reply.CurrentTerm &gt; rf.CurrentTerm &#123;</span><br><span class="line">rf.turnToFollow()</span><br><span class="line">rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">DPrintf(&quot;[%d-%s]: leader %d found new term (heartbeat resp from peer %d), turn to follower.&quot;,</span><br><span class="line">rf.me, rf, rf.me, n)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[111]-raft理论与实践[2]-lab2a实验说明</title>
    <link href="https://dreamerjonson.com/2020/01/06/golang-111-raft-2/"/>
    <id>https://dreamerjonson.com/2020/01/06/golang-111-raft-2/</id>
    <published>2020-01-06T06:57:48.000Z</published>
    <updated>2020-01-14T03:12:52.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2><p>1、阅读<a href="http://nil.csail.mit.edu/6.824/2017/papers/raft-extended.pdf" target="_blank" rel="noopener">raft论文</a><br>2、阅读我写的<a href="https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/">raft理论与实践[1]-理论篇</a><br>3、由于我们需要模拟rpc远程调用， 因此需要查看我写的这篇文章： <a href="https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/">模拟RPC远程过程调用</a><br>4、实验开始，我们首先需要拉取代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:dreamerjackson/golang-deep-distributed-lab.git</span><br><span class="line">git checkout --hard   4e6446c</span><br></pre></td></tr></table></figure><h2 id="实验说明"><a class="markdownIt-Anchor" href="#实验说明"></a> 实验说明</h2><p>此代码中labrpc 与 labgob 为模拟rpc的 package。<br>raft文件夹为此实验用到的代码框架。 在其中已经写好了一部分代码，还需要我们通过实验来完善它。<br>在本实验中，我们只需要关注raft.go文件，并实现选举逻辑和心跳检测逻辑。<br>本实验的目标是要保证，唯一的leader能够被选举。<br>当leader被选举后，如果没有任何失败，其将会保持leader。<br>当leader被选举后，如果leader奔溃或者to/from leader 的网络包丢失，则新的leader将会产生。<br>要验证代码的正确性，运行go test -run 2A</p><h2 id="实验提示"><a class="markdownIt-Anchor" href="#实验提示"></a> 实验提示</h2><p>1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。<br>2、填充RequestVoteArgs和RequestVoteReply结构。 修改Make()以创建一个后台goroutine，该后台goroutine将在有一段时间没有收到其他节点的请求时通过发出RequestVote RPC来定期启动领导者选举。 这样，节点将了解谁是leader（如果已经有leader），或者成为leader本身。 实现RequestVote（）RPC处理程序，以便节点之间相互投票。<br>3、要实现心跳检测，请定义AppendEntries RPC结构（尽管您可能还不需要所有参数），并让leader定期调用其他节点此方法。 编写AppendEntries RPC方法，该方法将重置选举超时，以便在已经有leader时，阻止其他节点成为leader。<br>4、确保不同对等方的选举超时不会总是同时触发，否则所有节点都只会为自己投票，而没有人会成为领导者。<br>5、测试要求leader每秒发送心跳RPC的次数不得超过十次。<br>6、测试要求在leader失败后，也能够再5秒之内选出新的leader。 您必须选择足够短的选举超时时间（以及因此产生的心跳间隔），<br>以使选举很有可能在不到五秒钟的时间内完成，即使需要进行多轮选举也是如此。<br>7、raft论文的5.2提到选举超时的范围是150到300毫秒，但是仅当领导者发送心跳的频率大大超过每150毫秒一次的频率时，此范围才有意义。<br>由于测试要求您的心跳检测为每秒10个，因此您将必须使用大于150到300毫秒的选举超时时间，但不能太大，因为那样的话，您可能会在五秒钟内无法选举领导者。<br>8、使用go的rand方法产生随机数。<br>9、go的time.Timer 和 time.Ticker 很难使用正确。<br>10、要调试代码，可以将util.go 的debug设置为1.<br>11、您应该使用go test -race检查代码，并修复它报告的所有问题。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://github.com/dreamerjackson/Distributed-Systems/blob/master/Lec05_Fault_Tolerance_Raft/l-raft.txt" target="_blank" rel="noopener">讲义</a><br><a href="https://pdos.csail.mit.edu/6.824/notes/l-raft.txt" target="_blank" rel="noopener">讲义新</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h2&gt;
&lt;p&gt;1、阅读&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2017/papers/raft-exten
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>6.s081[1]-操作系统接口</title>
    <link href="https://dreamerjonson.com/2020/01/04/6-s081-1/"/>
    <id>https://dreamerjonson.com/2020/01/04/6-s081-1/</id>
    <published>2020-01-04T06:27:36.000Z</published>
    <updated>2020-01-10T15:48:58.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>实验1需要我们调用unix操作系统保持出的接口，因此首先需要了解unix操作系统有关的知识。</p><h2 id="操作系统operating-system的功能"><a class="markdownIt-Anchor" href="#操作系统operating-system的功能"></a> 操作系统（operating system）的功能</h2><p>操作系统的任务是在多个程序之间共享一台计算机，并提供比单独的硬件所支持的更为有用的服务集。<br>操作系统管理和抽象化低级硬件，因此，例如，文字处理器不必担心自己正在使用哪种类型的硬件。<br>操作系统允许多个程序之间共享硬件，以便它们可以并发运行。<br>最后，操作系统提供了程序交互的方式，以便它们可以共享数据，协同工作。</p><p>操作系统为用户程序提供接口去调用。设计一个好的接口操作系统接口非常困难。<br>一方面希望简单，一方面又希望实现复杂的功能。<br>一种好的设计思路是接口之间可以通过某种机制组合起来以实现复杂的操作。</p><p>本实验中，使用了xv6 操作系统。其提供了unix的基本操作系统接口，并且模仿了Unix的内部设计。<br>unix提供的接口很少，但是由于其可以组合的机制，提供了难以想象的通用性。该接口非常成功，以至于现代操作系统（BSD，Linux，Mac OS X，Solaris，甚至在较小程度上是Microsoft Windows）都具有类似Unix的接口。了解xv6是了解这些系统和许多其他系统的良好起点。</p><p>内核是操作系统的核心，为运行的程序提供服务。 每个正在运行的程序（称为进程）都具有包含指令，数据和堆栈的内存。<br>指令说明了程序的运行逻辑。数据是指令运行所需要的变量。堆栈组织程序的过程调用。<br>当进程需要调用内核服务时，它将通过操作系统提供的接口进行过程调用。 这样的过程称为系统调用。<br>内核使用CPU的硬件保护机制来确保在用户空间中执行的每个进程只能访问其自己的内存。<br>用户程序调用操作系统接口后，硬件提高权限级别，并开始在内核中执行预先安排的功能。</p><p>shell是一个普通程序，可读取用户命令并执行命令。 shell是用户程序而不是内核的一部分，这一事实说明了操作系统接口的强大功能。shell没有什么特别之处，这也意味着shell易于更换；现代Unix系统有多种shell可供选择，每种shell都有其自己的用户界面和脚本功能。 xv6 shell是Unix Bourne shell的简单实现。 可以在（user / sh.c：1）中找到其实现。</p><h2 id="操作系统接口"><a class="markdownIt-Anchor" href="#操作系统接口"></a> 操作系统接口</h2><p>xv6进程由用户空间内存（指令，数据和堆栈）和内核专有的每个进程状态组成。<br>xv6保证进程的并发执行，在多个进程之间切换CPU能力。<br>当某个进程未执行时，xv6保存其CPU寄存器，并在下次运行该进程时恢复它们。 内核将进程标识符或pid与每个进程相关联。<br>进程可以使用fork系统调用来创建新进程。 Fork创建一个称为子进程的新进程，该进程与父进程的内存完全相同。<br>Fork在子进程与父进程中都会返回。<br>在父进程中，fork返回子进程的pid； 在子进程中，它返回零。<br>例如，考虑以下用C编程语言编写的程序片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int pid = fork();</span><br><span class="line">if(pid &gt; 0)&#123;</span><br><span class="line">    printf(&quot;parent: child=%d\en&quot;, pid);</span><br><span class="line">    pid = wait(0);</span><br><span class="line">    printf(&quot;child %d is done\en&quot;, pid);</span><br><span class="line">&#125; else if(pid == 0)&#123;</span><br><span class="line">    printf(&quot;child: exiting\en&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    printf(&quot;fork error\en&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exit导致调用进程停止执行并释放资源，例如内存和打开的文件。<br>exit接受一个整数状态参数，通常0表示成功，1表示失败。<br>wait系统调用返回当前进程已退出子进程的pid，并将该子进程的退出状态传递给wait。<br>如果子进程都没有退出，一直会等待。<br>如果父进程不在乎子进程的退出状态，则可以传递状态0。</p><p>在下面的例子中，输出是：<br>parent: child=1234<br>child: exiting</p><p>也可能出现另外的情况，具体取决于父进程还是子进程首先进入其printf调用。</p><p>子进程退出后，父进程的wait返回，导致父进程打印出：<br>parent: child 1234 is done。</p><p>尽管子进程最初具有与父进程相同的内存内容，但是父进程和子进程执行时使用的是不同的内存和不同的寄存器。<br>更改一个变量不会影响另一个变量。<br>例如，当wait的返回值在父进程中存储到pid中时，它不会更改子进程中的pid。 子进程中的pid的值仍为零。</p><p>exec系统调用使用从文件系统中存储的文件加载的新的内存映像替换调用进程的内存。<br>该文件必须具有特定的格式，该格式指定文件的哪一部分包含指令，哪一部分是数据，从哪条指令开始等。<br>xv6使用ELF格式，第3章将对此进行详细讨论。<br>当exec成功执行时，它不会返回到调用程序。从文件加载的指令在ELF标头中声明的入口点开始执行。<br>Exec接受两个参数：包含可执行文件的文件名和一个字符串参数数组。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char *argv[3];</span><br><span class="line">argv[0] = &quot;echo&quot;;</span><br><span class="line">argv[1] = &quot;hello&quot;;</span><br><span class="line">argv[2] = 0;</span><br><span class="line">exec(&quot;/bin/echo&quot;, argv);</span><br><span class="line">printf(&quot;exec error\en&quot;);</span><br></pre></td></tr></table></figure><p>该片段将调用程序以程序/ bin / echo的实例替换，参数列表为echo hello。 大多数程序会忽略第一个参数，这通常是程序的名称</p><p>xv6 Shell使用上述调用执行用户运行的程序。</p><p>xv6 Shell使用上述调用代表用户运行程序。<br>shell的主要结构很简单； 参见main（user / sh.c：145）。<br>主循环使用getcmd从用户读取一行输入。 然后，它将调用fork，这将创建shell进程的副本。<br>父进程调用wait，而子进程运行命令。 例如，如果用户键入“ echo hello”给shell，则将以“ echo hello”作为参数调用runcmd。 runcmd（user / sh.c：58）运行实际命令<br>对于“ echo hello”，它将调用exec（user / sh.c：78）<br>如果exec成功，则子进程将从echo执行指令，而不是runcmd。<br>在某些时候，echo将调用exit，这将导致父进程从main（user / sh.c：145）的wait中返回。</p><p>您可能想知道为什么fork和exec不能在单个调用中组合？ 稍后我们将看到，用于创建进程和加载程序的单独调用在Shell中用于I / O重定向的用法很巧妙。<br>为了避免创建重复进程然后立即替换它的浪费，运行中的内核通过使用虚拟内存技术（如copy-on-write 写时复制）来针对此用例优化fork的实现。</p><p>Xv6隐式分配了大多数用户空间内存：fork分配了子进程复制父进程所需的内存，而exec分配了足够的内存来保存可执行文件。<br>一个在运行时需要更多内存的进程（可能是malloc）可以调用sbrk（n）将其数据内存增加n个字节。 sbrk返回新内存的位置。<br>Xv6没有提供用户概念来保护一个用户免受另一个用户侵害；用Unix术语，所有xv6进程都以root身份运行。</p><h2 id="io-与文件描述符"><a class="markdownIt-Anchor" href="#io-与文件描述符"></a> I/O 与文件描述符</h2><pre><code>文件描述符是一个小的整数，表示进程可以从中读取或写入的内核管理的对象。 进程可以通过打开文件，目录或设备，或通过创建管道，或通过复制现有描述符来获取文件描述符。 为简单起见，我们通常将文件描述符所指的对象称为“文件”； 文件描述符接口抽象了文件，管道和设备之间的差异，使它们看起来都像字节流。在内部，xv6内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符专用空间。 按照惯例，进程从文件描述符0（标准输入）读取，将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。 就像我们将看到的那样，shell利用约定来实现I / O重定向(redirection)和管道(pipelines)。 shell确保始终打开三个文件描述符（user / sh.c：151），默认情况下，这三个文件描述符是控制台(console)的文件描述符。</code></pre><p>read系统调用从文件描述符读取字节。<br>write系统调用从文件描述符写入字节。<br>调用read（fd，buf，n）最多从文件描述符fd中读取n个字节，将它们复制到buf中，并返回读取的字节数。 引用文件的每个文件描述符都有一个与之关联的偏移量。read从当前文件偏移量读取数据，随着读取到的数据增加，文件的偏移量随之增加。当没有更多字节可以读取时，read将返回零以指示文件末尾。<br>调用write（fd，buf，n）将buf中的n个字节写入文件描述符fd，并返回写入的字节数。 仅在发生错误时才写入少于n个字节。 与读操作类似，写操作会在当前文件偏移量处写入数据，然后将偏移量增加写入的字节数：每次写操作都从上次中止的位置开始。</p><p>以下程序片段（cat命令的功能）将数据从其标准输入复制到其标准输出。 如果发生错误，它将向标准错误写入一条消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char buf[512];</span><br><span class="line">int n;</span><br><span class="line">for(;;)&#123;</span><br><span class="line">    n = read(0, buf, sizeof buf);</span><br><span class="line">    if(n == 0)</span><br><span class="line">    break;</span><br><span class="line">    if(n &lt; 0)&#123;</span><br><span class="line">        fprintf(2, &quot;read error\en&quot;);</span><br><span class="line">        exit();</span><br><span class="line">    &#125;</span><br><span class="line">    if(write(1, buf, n) != n)&#123;</span><br><span class="line">        fprintf(2, &quot;write error\en&quot;);</span><br><span class="line">        exit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在代码片段中要注意的重要一点是cat不知道它是从文件，控制台还是管道中读取。 同样，cat不知道它是要打印到控制台，文件还是其他地方。 使用文件描述符以及文件描述符0是标准输入和输出文件描述符是标准输出的约定可以实现cat的简单实现。close系统调用将释放文件描述符，以供将来的open，pipe或dup系统调用重用。 新分配的文件描述符始终是当前进程中编号最小的未使用的描述符。</code></pre><p>文件描述符和fork交互使I/O重定向易于实现。Fork会复制父文件的文件描述符表及其内存，以便子文件与父文件打开完全相同的文件。 exec系统调用替换了调用进程的内存，但保留了其文件表。 此行为允许Shell通过分叉，重新打开选定的文件描述符，然后exec新程序来实现I / O重定向。 这是shell为cat &lt;input.txt命令运行的代码的简化版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *argv[2];</span><br><span class="line">    argv[0] = &quot;cat&quot;;</span><br><span class="line">    argv[1] = 0;</span><br><span class="line">    if(fork() == 0) &#123;</span><br><span class="line">        close(0);</span><br><span class="line">        open(&quot;input.txt&quot;, O_RDONLY);</span><br><span class="line">        exec(&quot;cat&quot;, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当child关闭文件描述符0后，0 是最小的文件描述符。因此open操作将使文件描述符0（标准输入）指向文件input.txt.xv6 shell中的I / O重定向代码完全以这种方式工作（user / sh.c：82）。</p><p>现在应该清楚为什么将fork和exec分开调用是一个好主意？ 因为如果它们是分开的，则shell可以fork一个child，在该child中使用open，close，dup来更改标准输入和输出文件描述符，然后exec。 不需要更改正在执行的程序（在我们的示例中为cat）。 如果将fork和exec组合到单个系统调用中，则shell将需要一些其他（可能更复杂）的方案来重定向标准输入和输出，或者程序本身将必须了解如何重定向I / O。</p><p>尽管fork复制了文件描述符表，但每个潜在文件的偏移量在父级和子级之间共享。 考虑以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(fork() == 0) &#123;</span><br><span class="line">    write(1, &quot;hello &quot;, 6);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">    write(1, &quot;world\en&quot;, 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，父进程和子进程都将写入文件描述符1.最后输出的数据是&quot;hello world&quot;<br>父进程的写入会等到子进程写入后进行(由于wait)。两个文件描述符共享一个偏移量。<br>此行为有助于从Shell命令序列产生顺序输出，例如（echo hello; echo world）&gt; output.txt。<br>dup系统调用复制了一个现有的文件描述符，并返回了一个新的文件描述符，该描述符引用了相同的潜在I/O对象。两个文件描述符共享一个偏移量，就像fork所复制的文件描述符一样。这是将hello world写入文件的另一种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(1);</span><br><span class="line">write(1, &quot;hello &quot;, 6);</span><br><span class="line">write(fd, &quot;world\en&quot;, 6);</span><br></pre></td></tr></table></figure><p>如果两个文件描述符是通过fork和dup调用序列从同一原始文件描述符派生的，则它们共享一个偏移量。 否则，文件描述符不共享偏移量，即使它们是对同一文件的open产生的。 Dup允许shell执行以下命令： ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1。 2&gt;＆1告诉shell将文件描述符2与描述符1相同。已存在文件的名称和文件不存在等错误消息都将显示在文件tmp1中。 xv6 Shell不支持错误文件描述符的I / O重定向，但是现在您知道如何实现它。</p><p>文件描述符是一种强大的抽象，因为它们隐藏了它们所连接的对象的详细信息：写入文件描述符1的进程可能正在写入文件，诸如控制台的设备或管道。</p><h2 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h2><p>管道是一个小的内核缓冲区，以一对文件描述符的形式暴露给进程，一个用于读取，一个用于写入。 将数据写入管道的一端可使该数据可从管道的另一端读取。 管道为流程进行通信提供了一种方法。 以下示例代码运行程序wc,使用标准输入连接到管道的读取端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int p[2];</span><br><span class="line">char *argv[2];</span><br><span class="line">argv[0] = &quot;wc&quot;;</span><br><span class="line">argv[1] = 0;</span><br><span class="line">pipe(p);</span><br><span class="line">if(fork() == 0) &#123;</span><br><span class="line">    close(0);</span><br><span class="line">    dup(p[0]);</span><br><span class="line">    close(p[0]);</span><br><span class="line">    close(p[1]);</span><br><span class="line">    exec(&quot;/bin/wc&quot;, argv);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    close(p[0]);</span><br><span class="line">    write(p[1], &quot;hello world\en&quot;, 12);</span><br><span class="line">    close(p[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>程序调用pipe创建一个新管道，并将读取和写入文件描述符记录在数组p中。 在fork之后，父进程和子进程都具有引用管道的文件描述符。 子进程将读取端复制到文件描述符0上，关闭p中的文件描述符，然后执行wc。 当wc从其标准输入中读取时，它将从管道中读取。 父进程关闭管道的读取侧，写入管道，然后关闭写入侧。如果没有可用数据，则在管道上进行读取以等待写入数据或所有引用写入端的文件描述符被关闭； 在后一种情况下，读取将返回0，就像到达数据文件的末尾一样。 读取管道会一直堵塞直到无法接受到数据。因此，对于子进程来说，在执行上述wc之前关闭管道的写端很重要：如果wc进程的文件描述符之一引用了管道的写端，则wc将永远等不到文件末尾 。</code></pre><p>xv6 shell实现了管道，例如grep fork sh.c | wc -l 类似于上面的代码（user / sh.c：100）。 子进程创建一个管道，以将管道的左端与右端连接起来。 然后，它在管道的左端调用fork和runcmd，在右端调用fork和runcmd，并等待两者都完成。 管道的右端可能是一个命令，该命令本身包括一个管道（例如a | b | c），该管道本身派生了两个新的子进程（一个用于b，一个用于c）。 因此，shell可以创建进程树。 该树的叶子是命令，内部节点是等待左右子节点完成的进程。 原则上，您可以让内部节点在管道的左端运行，但是这样做会使实现复杂化。</p><p>管道似乎没有临时文件强大：echo hello world | wc<br>可以在没有管道的情况下实现：<br>echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</p><p>在这种情况下，管道比临时文件至少具有四个优点。 首先，管道会自动清理自己； 使用文件重定向，shell必须在完成后小心删除/ tmp / xyz。 其次，管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。 第三，管道允许并行执行管道阶段，而文件方法要求第一个程序在第二个程序启动之前完成。 第四，如果要实现进程间通信，则管道的读写锁比文件的 non-blocking语义更有效。</p><h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2><p>xv6文件系统提供了数据文件和目录，这些数据文件是原始的字节数组。目录包含对数据文件和其他目录的命名引用。 目录形成一棵树，从一个特殊的root目录开始。</p><p>类似于/a/b/c的路径是指根目录/中名为a的文件夹中名为b的文件夹中名为c的文件或文件夹。<br>不以/开头的路径是相对于调用进程的当前目录的。调用进程的当前目录可以通过chdir系统调用对其进行更改。</p><p>下面这两个程序片段都打开同一个文件（假设文件存在）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chdir(&quot;/a&quot;);</span><br><span class="line">chdir(&quot;b&quot;);</span><br><span class="line">open(&quot;c&quot;, O_RDONLY);</span><br><span class="line"></span><br><span class="line">open(&quot;/a/b/c&quot;, O_RDONLY);</span><br></pre></td></tr></table></figure><p>第一个代码片段将进程的当前目录更改为/a /b； 第二个既不引用也不更改进程的当前目录。<br>有多个操作系统接口来创建新文件或文件夹：mkdir创建新文件夹，使用O_CREATE标志调用open将创建新数据文件，而mknod将创建新设备文件。 如下例所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(&quot;/dir&quot;);</span><br><span class="line">fd = open(&quot;/dir/file&quot;, O_CREATE|O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line">mknod(&quot;/console&quot;, 1, 1);</span><br></pre></td></tr></table></figure><p>Mknod在文件系统中创建一个文件，但是该文件没有内容。 但是，文件的元数据会将其标记为设备文件，并记录主设备号和次设备号（mknod的两个参数），它们唯一地标识内核设备。 当以后有一个进程打开文件时，内核会将read和write系统调用转换到内核设备的读写实现，而不是将它们转换到文件系统。</p><p>fstat系统调用得到有关文件描述符引用的对象的信息。此对象信息返回结构体stat，定义在<br>stat.h (kernel/stat.h)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define T_DIR 1 // Directory</span><br><span class="line">#define T_FILE 2 // File</span><br><span class="line">#define T_DEVICE 3 // Device</span><br><span class="line">struct stat &#123;</span><br><span class="line">    int dev; // File system’s disk device</span><br><span class="line">    uint ino; // Inode number</span><br><span class="line">    short type; // Type of file</span><br><span class="line">    short nlink; // Number of links to file</span><br><span class="line">    uint64 size; // Size of file in bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件名与文件不同； 同一个文件（称为inode）可以具有多个名称（称为links）。<br>link系统调用将创建另一个文件名称，该名称引用与现有文件相同的inode。 下面的程序片段创建了一个名为a又为b的新文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;a&quot;, O_CREATE|O_WRONLY);</span><br><span class="line">link(&quot;a&quot;, &quot;b&quot;);</span><br></pre></td></tr></table></figure><p>读取,写入a与读取,写入到b相同。 每个inode由唯一的inode编号标识。 在上面的代码片段之后，可以通过检查fstat的结果确定a和b是否引用相同的文件：两者将返回相同的inode编号（ino），并且nlink将变为2。</p><p>unlink系统调用从文件系统中删除一个名称。 仅当文件的link计数为零且没有文件描述符引用该文件时， 才会将inode和其所在的磁盘空间清除。</p><p>因此当执行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(&quot;a&quot;);</span><br></pre></td></tr></table></figure><p>之后，使用名称b任然能够访问文件。</p><p>下面的程序片段是一种惯用的方式创建一个临时inode。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(&quot;/tmp/xyz&quot;, O_CREATE|O_RDWR);</span><br><span class="line">unlink(&quot;/tmp/xyz&quot;);</span><br></pre></td></tr></table></figure><p>当fd文件描述符被关闭后，临时的inode将会被清除。<br>用于文件系统操作的Shell命令是作为用户级程序（例如mkdir，ln，rm等）实现的。该设计允许任何人通过添加新的用户程序扩展Shell。在事后看来，似乎是理所当然的。<br>但和Unix同时期的其他系统设计，通常将这样的命令构建到shell中（并将shell构建到内核中）。<br>cd是一个例外，它内置在shell中（user / sh.c：160）。 cd必须更改shell本身的当前工作目录。 如果cd以常规命令运行，那么shell将派生一个子进程，该子进程将运行cd，而cd会更改该子进程的工作目录。 父进程(即shell)的工作目录不会更改。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>Unix结合了文件描述符，管道和方便的shell语法以对其进行操作，这是编写通用可复用程序的重大进步。这是Unix的强大功能和广泛使用的原因，外壳程序是第一种所谓的“脚本语言”。Unixit系统调用接口在BSD,Linux,和Mac OSX 上广泛使用。</p><p>Unix系统调用接口已通过可移植操作系统接口（POSIX）标准进行了标准化。 Xv6不兼容POSIX。 它抛弃一些了系统调用（包括诸如lseek之类的基本调用），仅部分实现了系统调用以及其他差异。 xv6的主要目标是简单性和清晰度，同时提供简单的类UNIX系统调用接口。 为了运行基本的Unix程序，一些人用更多的系统调用和一个简单的C库扩展了xv6。 但是，与xv6相比，现代内核提供了更多的系统调用和内核服务。 例如，它们支持联网，窗口系统，用户级线程，许多设备的驱动程序等。 现代内核不断快速发展，并提供了POSIX以外的许多功能。<br>在很大程度上，现代Unix派生的操作系统没有遵循早期的Unix模型，即将设备公开为特殊文件，例如上面讨论的控制台设备文件。Unix的作者继续构建Plan9，将“资源即文件”概念应用于现代设施，将网络，图形和其他资源表示为文件或文件树。<br>文件系统和文件描述符是强大的抽象。 即使这样，也存在其他模型。 Multics是Unix的前身，它以一种类似于内存的方式抽象了文件存储，从而产生了截然不同的界面风格。 Multics设计的复杂性直接影响了Unix的设计师，后者试图构建更简单的东西。<br>本书探讨了xv6如何实现其类似Unix的接口，但是这些思想和概念不仅适用于Unix。 任何操作系统都必须将进程多路复用到基础硬件上，将进程彼此隔离，并提供用于受控的进程间通信的机制。 研究xv6之后，您应该能够查看其他更复杂的操作系统，</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://pdos.csail.mit.edu/6.828/2019/labs/util.html" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2019/labs/util.html</a><br><a href="https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf</a><br><a href="https://pdos.csail.mit.edu/6.828/2019/lec/l-overview.txt" target="_blank" rel="noopener">https://pdos.csail.mit.edu/6.828/2019/lec/l-overview.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;实验1需要我们调用unix操作系统保持出的接口，因此首先需要了解unix操作系统有关的知识。&lt;/p&gt;
&lt;h2 id=&quot;操作系统operating
      
    
    </summary>
    
      <category term="unix" scheme="https://dreamerjonson.com/categories/unix/"/>
    
    
      <category term="unix" scheme="https://dreamerjonson.com/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>golang[110]-raft算法理论与实践[1]</title>
    <link href="https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/"/>
    <id>https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/</id>
    <published>2019-12-29T15:06:17.000Z</published>
    <updated>2020-01-04T04:42:58.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>我计划写raft的一系列文章，包含从理论到代码实践，此文章依托于MIT的研究生课程。</p><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>raft 是一种分布式的共识算法，其目的是要实现多个节点集群的容错性,一致性从而能够构建大规模的软件系统。<br>在raft之前，比较有名的是Paxos。但是paxos难于理解。<br>raft的诞生是为了让共识算法更容易理解,在工程上更容易实现。</p><p>和其他的共识算法不同的是，raft具有下面的特点：<br>1、leader：raft中会有一个领导者具有超级权限，可以把自己的log 复制到其他节点中。<br>2、leader election： raft每隔一段随机的时间就会进行leader的选举<br>3、raft允许集群配置变化时正常运行。</p><h2 id="replicated-state-machine"><a class="markdownIt-Anchor" href="#replicated-state-machine"></a> Replicated state machine</h2><p>状态机是分布式系统中的一个重要概念，任何一个系统的最终状态都可以看成是每一个操作的集合。因此，算法会维护一份replicated log，将每一份操作都存储起来。<br>每一个节点只要按顺序执行log中的命令，就会到达相同的最终状态。这样，即便是系统奔溃也可以快速的恢复。<br>共识算法需要保证relicated log的一致性,服务器收到客户端发出来的执行命令Command后，会将其加入到log中。<br>服务器之间会相互的交流，保证最后的log的一致性（即便服务器奔溃），即Command 会复制到其他服务器的log中，所有服务器的log是相同的，有序的。<br>其他服务器会执行此log，即会执行此命令。最后，所有的服务器都会到达同一个状态。</p><p>共识算法必须满足下面的属性：<br>1、在极端情况下（丢包、奔溃）任然能够保证安全性。<br>2、大多数节点正常的情况下能够保证可用。<br>3、不能依靠时间戳去保证log的一致性。<br>4、当大部分的节点通过RPC远程调用交流 达成共识后，command就可以被确认和执行。小部分节点的不稳定不会影响整个系统。</p><h2 id="raft-basic"><a class="markdownIt-Anchor" href="#raft-basic"></a> raft basic</h2><p>raft集群一般保持奇数个数量（5个节点比较普遍). 从而只要大部分节点存活，即可用。<br>raft中的节点有3种状态。 leader, Candidates, follower。<br>1、一般的状态只会存在一个leader，其余的节点都是follower。<br>2、leader会处理所有的客户端请求， 如果是客户端请求follower，也会被转发到leader处理。<br>3、Candidates 是一种选举时候的过渡状态，用于自身拉票选举leader。</p><p>在raft中会有一个叫做term的时间周期。term是以选举leader开始的，如果Candidates选举成为了leader，那么其会成为这个term剩下时间的leader。<br>有时候，在整个term周期都没有选举出leader。这时一个新的选举会在不久后开始。<br>Terms 在raft中类似于一种时间戳，后一个一定比前一个后发生，这一点和比特币中的区块链很类似。<br>每一个服务器会存储一个当前的term，其会随着时间的增加而增长。如果某一个节点的当前term小于其他节点，那么节点会更新自己的term为最大的term。<br>如果一个candidate 发现自己当前的term 过时了，那么其会立即变为follower。<br>raft节点之间通过RPC（远程过程调用）来进行通信。 RequestVote 方法用于candidate在选举时候使用，AppendEntries用于leader在通知其他节点复制log时使用。同时也用于心跳检测。<br>RPC 是并发的，并支持失败重试。</p><h2 id="选举"><a class="markdownIt-Anchor" href="#选举"></a> 选举</h2><p>在raft中会有一套心跳检测，只要follower收到来自leader或者Candidates的数据，那么其会保持follower的状态。<br>如果follower一段时间内没有收到RPC请求，这意味着选举超时（ election timeout ）。<br>这时follower会将current term 加1，过渡到Candidates状态。<br>其会给自己投票，并发送RequestVote RPC请求给其他的节点，拉票！</p><p>Candidates状态会持续，直到下面的3种情况发生:<br>1、当其获得了大部分节点的支持后，其赢得了选举，变为了leader。<br>一旦其变为了leader，其会向其他节点发送 AppendEntries RPC， 确认其leader的地位，阻止选举。<br>2、其他节点成为了leader。<br>如果其收到了其他节点的AppendEntries RPC. 并发现其他节点的current term比自己的大,则其变为follower状态。<br>3、一段时间过去任然没有参与者。<br>如果有许多的节点同时变为了candidate,则可能会出现一段时间内都没有节点能够选举成功的情况。<br>在raft中，为了快速解决并修复这个问题，规定了每一个candidate在选举前会重置一个随机的选举超时（ election timeout ）时间，此随机时间会在一个区间内（eg.150-300ms）<br>这样保证了，在大部分的情况下，有一个唯一的节点首先选举超时，其在大部分节点选举超时前发送心跳检测，赢得了选举。</p><p>当一个leader在心跳检测中发现另一个节点有更高的term时，会转变为follower。否则其将一直保持leader状态。</p><h2 id="日志复制log-replication"><a class="markdownIt-Anchor" href="#日志复制log-replication"></a> 日志复制(Log replication)</h2><p>当成为leader后，其会接受来自客户端的请求。每一个客户端请求都包含一个将要被节点的状态机执行的command。<br>leader其会将这个command 包装为一个entry放入到log中，并通过AppendEntries RPC 发送给其他节点，要求其添加此entry到log中。</p><p>当entry被 大部分的节点接受并复制后，这个entry的状态变为了committed.  raft算法保证了commited entry到最后一定能够会被所有节点的状态机执行。<br>一旦follower知道（AppendEntries RPC）某一个entry被commit之后，follower会按顺序执行log中的entry</p><img src="/2019/12/29/golang-110-lab-raft/1.png" title="类型"><center><div>entry in log</div></center>如图所示，我们可以把log 理解为entry的集合。在entry中包含了common命令、entry所在的term 以及每一个entry的顺序编号index。<p>raft的一致性保证了下面的属性：<br>1、如果在不同节点中log中的entry有相同的index 和term。 那么一定存储的是相同的command。<br>2、如果在不同节点中log中的entry有相同的index 和term。 那么此entry之前的所有entry都是相同的。</p><img src="/2019/12/29/golang-110-lab-raft/2.png" title="类型"><center><div>leader crashes</div></center>节点f可能会发生，如果其是term 2的leader, 添加entry到log中，但是没有commit时就奔溃了，其快速恢复后又变为了term 3 的leader， 添加entry到log中，没有commit又继续奔溃了。<p>在正常的情况下，上面的两个属性都能满足，但是异常情况下，这种情况会被打破，可能会出现如上图所示的情形，</p><p>在raft中，为了处理这样的不一致性，强制要求follower的log与leader的log要一致。</p><p>因此leader必须要发现一个entry，在这个entry之后的都是不相同的entry。在这个entry之前的都是一致的entry。在leader中会为每一个follower维护一份nextIndex 数组。标志了将要发送给follower的下一个index。 最后，follower会删除掉所有不同的entry，并用和leader一致的log。这一过程，都会通过AppendEntries RPC 执行完毕。当AppendEntries RPC返回success，就表明follower 与 leader的log是一致的。</p><h2 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h2><p>上面的属性还不能够充分的保证系统的安全性。 考虑下面的例子：</p><img src="/2019/12/29/golang-110-lab-raft/3.png" title="类型"><center><div>safe problem</div></center>上图要说明的是，一个已经被commit的entry 在目前的情况下是有可能被覆盖掉的。例如在a阶段s1成为了leader，其entry还没有commit。 在b阶段,s1奔溃，s5成为了leader ，添加log但是任然没有commit。 在c阶段，s5奔溃，s1成为了leader。其entry成为了commit。 在d阶段s1奔溃，s5成为了leader，其会将本已commit的entry给覆盖掉。<p>raft使用一种更简单的方式来解决这个难题，raft为leader添加了限制:<br>要成为leader 必须要包含过去所有的commit entry。<br>Candidates 要想成为leader，必须要经过大部分follower节点的同意。<br>而commit entry 也表明其已经存在于大部分的服务器中。 因此commit entry 至少会出现在这些follower节点中的至少有一个节点。因此我们可以证明，在大部分的follower中，至少有一个是包含了leader的所有commit entry的。<br>因此 如果一个candidate的log是最新的（即他与其他的节点对比时，如果term更大的，最新。如果term相同的，那么越长的那个log越新。）其才可以成为leader。</p><p>因此可知，一个leader一定包含了以前leader的commit entry。</p><h2 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> todo</h2><p>配置改变、 日志压缩快照（log compaction / snapshotting ）</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>上面对于raft的描述，保证了存在5点：<br>1、Election Safety：在一个term周期内只会存在一个leader。<br>2、Leader Append-Only： leader只会添加log，而不会删除或者覆盖log。<br>3、Log Matching：如果两个log有一个相同index与term的entry，那么他们之前的log都是相同的。<br>4、Leader Completeness：如果一个log entry在一个term周期成为commit， 那么其一定会存在于下一个leader的log中。<br>5、State Machine Safety：如果某节点已经将index A 应用于其状态机。则以后其他节点不可能在同一index A 却具有不同的log entry。 因为应用到状态机说明已经被commit，而借助于第4点得证。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="http://nil.csail.mit.edu/6.824/2017/papers/raft-extended.pdf" target="_blank" rel="noopener">raft论文</a><br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">raft可视化</a><br><a href="https://zhuanlan.zhihu.com/p/32052223" target="_blank" rel="noopener">知乎，写得一般但是有借鉴地方</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;我计划写raft的一系列文章，包含从理论到代码实践，此文章依托于MIT的研究生课程。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;mar
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>emacs--构建cc++IDE</title>
    <link href="https://dreamerjonson.com/2019/12/25/emacs-cc/"/>
    <id>https://dreamerjonson.com/2019/12/25/emacs-cc/</id>
    <published>2019-12-25T09:10:26.000Z</published>
    <updated>2019-12-25T09:28:32.400Z</updated>
    
    <content type="html"><![CDATA[<p>mac下安装依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># for cmake</span><br><span class="line">$brew install cmake</span><br><span class="line"> </span><br><span class="line"># for libclang</span><br><span class="line">$brew install llvm</span><br><span class="line">$echo &apos;export PATH=&quot;/usr/local/opt/llvm/bin:$PATH&quot;&apos; &gt;&gt; ~/.bash_profile</span><br><span class="line"> </span><br><span class="line">$echo | clang -x c++ -v -E - 2&gt;&amp;1 | sed -n &apos;/^#include &lt;/,/^End/s|^&amp;#91;^/&amp;#93;*\(&amp;#91;^ &amp;#93;*/include&amp;#91;^ &amp;#93;*\).*$|-I\1|p&apos; &gt; .clang_completion</span><br><span class="line"></span><br><span class="line">brew install rtags</span><br></pre></td></tr></table></figure><p>user-package:</p><pre class="highlight"><code class="">;;; c.el --- c/c++ mode                              -*- lexical-binding: t; -*-;; Keywords: c;;; Code:;;;; irony is for auto-complete, syntax checking and documentation;;;; You will need to install irony-server first time use;; to install irony-server, your system need to install clang, cmake and clang-devel in advance;;;; if error:Could NOT find LibClang (missing: LIBCLANG_LIBRARY LIBCLANG_INCLUDE_DIR);; cmake add this flag:;; -DLIBCLANG_LIBRARY\=/usr/local/opt/llvm/lib/libclang.dylib;; -DLIBCLANG_INCLUDE_DIR\=/usr/local/opt/llvm/include/(use-package irony  :ensure t  :hook ((c++-mode . irony-mode)         (c-mode . irony-mode))  :config  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)  (use-package company-irony-c-headers    :ensure t)  (use-package company-irony    :ensure t    :config    (add-to-list (make-local-variable 'company-backends)                 '(company-irony company-irony-c-headers)))  (use-package flycheck-irony    :ensure t    :config    (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)    )  (use-package irony-eldoc    :ensure t    :config    (add-hook 'irony-mode-hook #'irony-eldoc)    )  );;;; rtags enable jump-to-function definition;; system need to install rtags first;;;; for centos, you need llvm-devel, cppunit-devl;; install gcc-4.9, cmake 3.1 and download rtags from github and make it;;(use-package rtags  :ensure t  :config  (rtags-enable-standard-keybindings)  (setq rtags-autostart-diagnostics t)  (rtags-diagnostics)  (setq rtags-completions-enabled t)  (define-key c-mode-base-map (kbd &quot;M-.&quot;)    (function rtags-find-symbol-at-point))  (define-key c-mode-base-map (kbd &quot;M-,&quot;)    (function rtags-find-references-at-point))  );;;; cmake-ide enable rdm(rtags) auto start and rc(rtags) to watch directory;;(use-package cmake-ide  :ensure t  :config  (cmake-ide-setup)  );;;; for editting CMakeLists.txt;;(use-package cmake-mode  :ensure t  :mode ((&quot;CMakeLists\\.txt\\'&quot; . cmake-mode)         (&quot;\\.cmake\\'&quot; . cmake-mode))  :config  (add-hook 'cmake-mode-hook (lambda()                               (add-to-list (make-local-variable 'company-backends)                                            'company-cmake)))  );; for c formatting(use-package clang-format  :ensure t  :config  (setq clang-format-style-option &quot;llvm&quot;)  (add-hook 'c-mode-hook (lambda() (add-hook 'before-save-hook 'clang-format-buffer)))  (add-hook 'c++-mode-hook (lambda() (add-hook 'before-save-hook 'clang-format-buffer)))  )(provide 'c);;; c.el ends here## 参考资料https://github.com/jerryhsieh/Emacs-config/blob/c%2B%2B/custom/c.elhttps://github.com/Sarcasm/irony-mode/issues/351</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac下安装依赖:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
      <category term="emacs" scheme="https://dreamerjonson.com/categories/emacs/"/>
    
    
      <category term="emacs" scheme="https://dreamerjonson.com/tags/emacs/"/>
    
  </entry>
  
  <entry>
    <title>golang[109]-lab-模拟rpc远程过程调用</title>
    <link href="https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/"/>
    <id>https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/</id>
    <published>2019-12-25T03:24:06.000Z</published>
    <updated>2019-12-25T07:54:56.445Z</updated>
    
    <content type="html"><![CDATA[<p>为了实践分布式的第一步，需要模拟远程的过程调用，就好像程序是部署在不同的机器通过tcp进行连接。</p><h2 id="构建client"><a class="markdownIt-Anchor" href="#构建client"></a> 构建client</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ClientEnd struct &#123;</span><br><span class="line">endname interface&#123;&#125; // this end-point&apos;s name</span><br><span class="line">ch      chan reqMsg // copy of Network.endCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>endname 代表client的名字<br>ch 与network共享。用于传递请求参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> reqMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">endname  <span class="keyword">interface</span>&#123;&#125; <span class="comment">// name of sending ClientEnd</span></span><br><span class="line">svcMeth  <span class="keyword">string</span>      <span class="comment">// e.g. "Raft.AppendEntries"</span></span><br><span class="line">argsType reflect.Type</span><br><span class="line">args     []<span class="keyword">byte</span></span><br><span class="line">replyCh  <span class="keyword">chan</span> replyMsg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>svcMeth 找到要请求的service，以及调用的方法<br>argsType 存储函数请求的类型，例如要远程调用的函数是，<br>func (js *JunkServer) Handler4(args *JunkArgs, reply *JunkReply) {<br>reply.X = “pointer”<br>}<br>那么argsType存储的是<code>*JunkArgs</code><br>args 代表参数序列化后的字节数组<br>replych 接受返回字节数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type replyMsg struct &#123;</span><br><span class="line">ok    bool</span><br><span class="line">reply []byte</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="client调用"><a class="markdownIt-Anchor" href="#client调用"></a> client调用</h2><p>模拟客户端远程过程调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ClientEnd)</span> <span class="title">Call</span><span class="params">(svcMeth <span class="keyword">string</span>, args <span class="keyword">interface</span>&#123;&#125;, reply <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">req := reqMsg&#123;&#125;</span><br><span class="line">req.endname = e.endname</span><br><span class="line">req.svcMeth = svcMeth</span><br><span class="line">req.argsType = reflect.TypeOf(args)</span><br><span class="line">req.replyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> replyMsg)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// serialize</span></span><br><span class="line">qb := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">qe := gob.NewEncoder(qb)</span><br><span class="line">qe.Encode(args)</span><br><span class="line">req.args = qb.Bytes()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// request param send to network</span></span><br><span class="line">e.ch &lt;- req</span><br><span class="line"></span><br><span class="line">rep := &lt;-req.replyCh</span><br><span class="line"><span class="keyword">if</span> rep.ok &#123;</span><br><span class="line">        <span class="comment">// unserialize</span></span><br><span class="line">rb := bytes.NewBuffer(rep.reply)</span><br><span class="line">rd := gob.NewDecoder(rb)</span><br><span class="line"><span class="keyword">if</span> err := rd.Decode(reply); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"ClientEnd.Call(): decode reply: %v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="build-network"><a class="markdownIt-Anchor" href="#build-network"></a> build network</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Network struct &#123;</span><br><span class="line">mu             sync.Mutex</span><br><span class="line">reliable       bool</span><br><span class="line">longDelays     bool                        // pause a long time on send on disabled connection</span><br><span class="line">longReordering bool                        // sometimes delay replies a long time</span><br><span class="line">ends           map[interface&#123;&#125;]*ClientEnd  // ends, by name</span><br><span class="line">enabled        map[interface&#123;&#125;]bool        // by end name</span><br><span class="line">servers        map[interface&#123;&#125;]*Server     // servers, by name</span><br><span class="line">connections    map[interface&#123;&#125;]interface&#123;&#125; // endname -&gt; servername</span><br><span class="line">endCh          chan reqMsg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reliable 模拟网络的可靠性<br>longDelays 模拟网络延迟<br>enabled 网络是否可用<br>endCh 用于接收client的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func MakeNetwork() *Network &#123;</span><br><span class="line">rn := &amp;Network&#123;&#125;</span><br><span class="line">rn.reliable = true</span><br><span class="line">rn.ends = map[interface&#123;&#125;]*ClientEnd&#123;&#125;</span><br><span class="line">rn.enabled = map[interface&#123;&#125;]bool&#123;&#125;</span><br><span class="line">rn.servers = map[interface&#123;&#125;]*Server&#123;&#125;</span><br><span class="line">rn.connections = map[interface&#123;&#125;](interface&#123;&#125;)&#123;&#125;</span><br><span class="line">rn.endCh = make(chan reqMsg)</span><br><span class="line"></span><br><span class="line">// single goroutine to handle all ClientEnd.Call()s</span><br><span class="line">go func() &#123;</span><br><span class="line">for xreq := range rn.endCh &#123;</span><br><span class="line">go rn.ProcessReq(xreq)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">return rn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network添加server"><a class="markdownIt-Anchor" href="#network添加server"></a> network添加server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (rn *Network) AddServer(servername interface&#123;&#125;, rs *Server) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.servers[servername] = rs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (rn *Network) DeleteServer(servername interface&#123;&#125;) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.servers[servername] = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确保network-可用"><a class="markdownIt-Anchor" href="#确保network-可用"></a> 确保network 可用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// enable/disable a ClientEnd.</span><br><span class="line">func (rn *Network) Enable(endname interface&#123;&#125;, enabled bool) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.enabled[endname] = enabled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-add-server"><a class="markdownIt-Anchor" href="#network-add-server"></a> network add server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (rn *Network) AddServer(servername interface&#123;&#125;, rs *Server) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.servers[servername] = rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-连接client-与server"><a class="markdownIt-Anchor" href="#network-连接client-与server"></a> network 连接client 与server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// connect a ClientEnd to a server.</span><br><span class="line">// a ClientEnd can only be connected once in its lifetime.</span><br><span class="line">func (rn *Network) Connect(endname interface&#123;&#125;, servername interface&#123;&#125;) &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">rn.connections[endname] = servername</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-create-client-end"><a class="markdownIt-Anchor" href="#network-create-client-end"></a> network create client end</h3><p>在这里client的创建是通过network完成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// create a client end-point.</span><br><span class="line">// start the thread that listens and delivers.</span><br><span class="line">func (rn *Network) MakeEnd(endname interface&#123;&#125;) *ClientEnd &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if _, ok := rn.ends[endname]; ok &#123;</span><br><span class="line">log.Fatalf(&quot;MakeEnd: %v already exists\n&quot;, endname)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e := &amp;ClientEnd&#123;&#125;</span><br><span class="line">e.endname = endname</span><br><span class="line">e.ch = rn.endCh</span><br><span class="line">rn.ends[endname] = e</span><br><span class="line">rn.enabled[endname] = false</span><br><span class="line">rn.connections[endname] = nil</span><br><span class="line">return e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network-统计进入的rpc数量"><a class="markdownIt-Anchor" href="#network-统计进入的rpc数量"></a> network 统计进入的RPC数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// get a server&apos;s count of incoming RPCs.</span><br><span class="line">func (rn *Network) GetCount(servername interface&#123;&#125;) int &#123;</span><br><span class="line">rn.mu.Lock()</span><br><span class="line">defer rn.mu.Unlock()</span><br><span class="line"></span><br><span class="line">svr := rn.servers[servername]</span><br><span class="line">return svr.GetCount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="network处理client请求"><a class="markdownIt-Anchor" href="#network处理client请求"></a> network处理client请求</h3><p>ProceeReq 接受client发出的处理请求，<br>1、模拟网络的延迟，每次请求花费的时间<br>2、找到此client连接的server,调用server dispatch方法<br>3、等待返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rn *Network)</span> <span class="title">ProcessReq</span><span class="params">(req reqMsg)</span></span> &#123;</span><br><span class="line">enabled, servername, server, reliable, longreordering := rn.ReadEndnameInfo(req.endname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> enabled &amp;&amp; servername != <span class="literal">nil</span> &amp;&amp; server != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reliable == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="comment">// short delay</span></span><br><span class="line">ms := (rand.Int() % <span class="number">27</span>)</span><br><span class="line">time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reliable == <span class="literal">false</span> &amp;&amp; (rand.Int()%<span class="number">1000</span>) &lt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="comment">// drop the request, return as if timeout</span></span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute the request (call the RPC handler).</span></span><br><span class="line"><span class="comment">// in a separate thread so that we can periodically check</span></span><br><span class="line"><span class="comment">// if the server has been killed and the RPC should get a</span></span><br><span class="line"><span class="comment">// failure reply.</span></span><br><span class="line">ech := <span class="built_in">make</span>(<span class="keyword">chan</span> replyMsg)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := server.dispatch(req)</span><br><span class="line">ech &lt;- r</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for handler to return,</span></span><br><span class="line"><span class="comment">// but stop waiting if DeleteServer() has been called,</span></span><br><span class="line"><span class="comment">// and return an error.</span></span><br><span class="line"><span class="keyword">var</span> reply replyMsg</span><br><span class="line">replyOK := <span class="literal">false</span></span><br><span class="line">serverDead := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> replyOK == <span class="literal">false</span> &amp;&amp; serverDead == <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> reply = &lt;-ech:</span><br><span class="line">replyOK = <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">100</span> * time.Millisecond):</span><br><span class="line">serverDead = rn.IsServerDead(req.endname, servername, server)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do not reply if DeleteServer() has been called, i.e.</span></span><br><span class="line"><span class="comment">// the server has been killed. this is needed to avoid</span></span><br><span class="line"><span class="comment">// situation in which a client gets a positive reply</span></span><br><span class="line"><span class="comment">// to an Append, but the server persisted the update</span></span><br><span class="line"><span class="comment">// into the old Persister. config.go is careful to call</span></span><br><span class="line"><span class="comment">// DeleteServer() before superseding the Persister.</span></span><br><span class="line">serverDead = rn.IsServerDead(req.endname, servername, server)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> replyOK == <span class="literal">false</span> || serverDead == <span class="literal">true</span> &#123;</span><br><span class="line"><span class="comment">// server was killed while we were waiting; return error.</span></span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> reliable == <span class="literal">false</span> &amp;&amp; (rand.Int()%<span class="number">1000</span>) &lt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="comment">// drop the reply, return as if timeout</span></span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> longreordering == <span class="literal">true</span> &amp;&amp; rand.Intn(<span class="number">900</span>) &lt; <span class="number">600</span> &#123;</span><br><span class="line"><span class="comment">// delay the response for a while</span></span><br><span class="line">ms := <span class="number">200</span> + rand.Intn(<span class="number">1</span>+rand.Intn(<span class="number">2000</span>))</span><br><span class="line">time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">req.replyCh &lt;- reply</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">req.replyCh &lt;- reply</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// simulate no reply and eventual timeout.</span></span><br><span class="line">ms := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> rn.longDelays &#123;</span><br><span class="line"><span class="comment">// let Raft tests check that leader doesn't send</span></span><br><span class="line"><span class="comment">// RPCs synchronously.</span></span><br><span class="line">ms = (rand.Int() % <span class="number">7000</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// many kv tests require the client to try each</span></span><br><span class="line"><span class="comment">// server in fairly rapid succession.</span></span><br><span class="line">ms = (rand.Int() % <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Duration(ms) * time.Millisecond)</span><br><span class="line">req.replyCh &lt;- replyMsg&#123;<span class="literal">false</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="build-server"><a class="markdownIt-Anchor" href="#build-server"></a> build server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// a server is a collection of services, all sharing</span><br><span class="line">// the same rpc dispatcher. so that e.g. both a Raft</span><br><span class="line">// and a k/v server can listen to the same rpc endpoint.</span><br><span class="line">//</span><br><span class="line">type Server struct &#123;</span><br><span class="line">mu       sync.Mutex</span><br><span class="line">services map[string]*Service</span><br><span class="line">count    int // incoming RPCs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MakeServer() *Server &#123;</span><br><span class="line">rs := &amp;Server&#123;&#125;</span><br><span class="line">rs.services = map[string]*Service&#123;&#125;</span><br><span class="line">return rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server 是由一系列的service组成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// a server is a collection of services, all sharing</span><br><span class="line">// the same rpc dispatcher. so that e.g. both a Raft</span><br><span class="line">// and a k/v server can listen to the same rpc endpoint.</span><br><span class="line">//</span><br><span class="line">type Server struct &#123;</span><br><span class="line">mu       sync.Mutex</span><br><span class="line">services map[string]*Service</span><br><span class="line">count    int // incoming RPCs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MakeServer() *Server &#123;</span><br><span class="line">rs := &amp;Server&#123;&#125;</span><br><span class="line">rs.services = map[string]*Service&#123;&#125;</span><br><span class="line">return rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server 是由一系列的service组成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (rs *Server) AddService(svc *Service) &#123;</span><br><span class="line">rs.mu.Lock()</span><br><span class="line">defer rs.mu.Unlock()</span><br><span class="line">rs.services[svc.name] = svc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server的一个重要方法是调用dispatch ，找到client具体是调用的哪个servise的哪个方法 eg.“Raft.AppendEntries”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func (rs *Server) dispatch(req reqMsg) replyMsg &#123;</span><br><span class="line">rs.mu.Lock()</span><br><span class="line"></span><br><span class="line">rs.count += 1</span><br><span class="line"></span><br><span class="line">// split Raft.AppendEntries into service and method</span><br><span class="line">dot := strings.LastIndex(req.svcMeth, &quot;.&quot;)</span><br><span class="line">serviceName := req.svcMeth[:dot]</span><br><span class="line">methodName := req.svcMeth[dot+1:]</span><br><span class="line"></span><br><span class="line">service, ok := rs.services[serviceName]</span><br><span class="line"></span><br><span class="line">rs.mu.Unlock()</span><br><span class="line"></span><br><span class="line">if ok &#123;</span><br><span class="line">return service.dispatch(methodName, req)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">choices := []string&#123;&#125;</span><br><span class="line">for k, _ := range rs.services &#123;</span><br><span class="line">choices = append(choices, k)</span><br><span class="line">&#125;</span><br><span class="line">log.Fatalf(&quot;labrpc.Server.dispatch(): unknown service %v in %v.%v; expecting one of %v\n&quot;,</span><br><span class="line">serviceName, serviceName, methodName, choices)</span><br><span class="line">return replyMsg&#123;false, nil&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="build-service"><a class="markdownIt-Anchor" href="#build-service"></a> build service</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// an object with methods that can be called via RPC.</span><br><span class="line">// a single server may have more than one Service.</span><br><span class="line">type Service struct &#123;</span><br><span class="line">name    string</span><br><span class="line">rcvr    reflect.Value</span><br><span class="line">typ     reflect.Type</span><br><span class="line">methods map[string]reflect.Method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methods 存储所有方法<br>typ 与 rcvr 存储结构体的反射类型<br>name 是结构体的名字<br>makeServise 方法将某个结构体即service的所有方法存起来。</p><p>规定函数必须有三个参数<br>第1个是调用方法的结构体<br>第2个是request参数<br>第3个是reply参数<br>1个返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func MakeService(rcvr interface&#123;&#125;) *Service &#123;</span><br><span class="line">svc := &amp;Service&#123;&#125;</span><br><span class="line">svc.typ = reflect.TypeOf(rcvr)</span><br><span class="line">svc.rcvr = reflect.ValueOf(rcvr)</span><br><span class="line">svc.name = reflect.Indirect(svc.rcvr).Type().Name()</span><br><span class="line">svc.methods = map[string]reflect.Method&#123;&#125;</span><br><span class="line"></span><br><span class="line">for m := 0; m &lt; svc.typ.NumMethod(); m++ &#123;</span><br><span class="line">method := svc.typ.Method(m)</span><br><span class="line">mtype := method.Type</span><br><span class="line">mname := method.Name</span><br><span class="line"></span><br><span class="line">//fmt.Printf(&quot;%v pp %v ni %v 1k %v 2k %v no %v\n&quot;,</span><br><span class="line">//mname, method.PkgPath, mtype.NumIn(), mtype.In(1).Kind(), mtype.In(2).Kind(), mtype.NumOut())</span><br><span class="line"></span><br><span class="line">if method.PkgPath != &quot;&quot; || // capitalized?</span><br><span class="line">mtype.NumIn() != 3 ||</span><br><span class="line">//mtype.In(1).Kind() != reflect.Ptr ||</span><br><span class="line">mtype.In(2).Kind() != reflect.Ptr ||</span><br><span class="line">mtype.NumOut() != 0 &#123;</span><br><span class="line">// the method is not suitable for a handler</span><br><span class="line">//fmt.Printf(&quot;bad method: %v\n&quot;, mname)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// the method looks like a handler</span><br><span class="line">svc.methods[mname] = method</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return svc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>用一个简单的例子来测试并说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type JunkArgs struct &#123;</span><br><span class="line">X int</span><br><span class="line">&#125;</span><br><span class="line">type JunkReply struct &#123;</span><br><span class="line">X string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type JunkServer struct &#123;</span><br><span class="line">mu   sync.Mutex</span><br><span class="line">log1 []string</span><br><span class="line">log2 []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// args is a pointer</span><br><span class="line">func (js *JunkServer) Handler4(args *JunkArgs, reply *JunkReply) &#123;</span><br><span class="line">reply.X = &quot;pointer&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// args is a not pointer</span><br><span class="line">func (js *JunkServer) Handler5(args JunkArgs, reply *JunkReply) &#123;</span><br><span class="line">reply.X = &quot;no pointer&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestTypes(t *testing.T) &#123;</span><br><span class="line">    // 1. create network</span><br><span class="line">    rn := MakeNetwork()</span><br><span class="line">    // 2、create client</span><br><span class="line">e := rn.MakeEnd(&quot;end1-99&quot;)</span><br><span class="line">js := &amp;JunkServer&#123;&#125;</span><br><span class="line">    // 3. create service</span><br><span class="line">svc := MakeService(js)</span><br><span class="line">    // 4. create server</span><br><span class="line">rs := MakeServer()</span><br><span class="line">    // 5. service add to server </span><br><span class="line">rs.AddService(svc)</span><br><span class="line">    // 6. server add to network</span><br><span class="line">rn.AddServer(&quot;server99&quot;, rs)</span><br><span class="line">    //  7. client connect to server</span><br><span class="line">rn.Connect(&quot;end1-99&quot;, &quot;server99&quot;)</span><br><span class="line">    //  8. enable network</span><br><span class="line">rn.Enable(&quot;end1-99&quot;, true)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">var args JunkArgs</span><br><span class="line">var reply JunkReply</span><br><span class="line">// args must match type (pointer or not) of handler.</span><br><span class="line">// 9. call the service wait the reply. </span><br><span class="line">        e.Call(&quot;JunkServer.Handler4&quot;, &amp;args, &amp;reply)</span><br><span class="line">if reply.X != &quot;pointer&quot; &#123;</span><br><span class="line">t.Fatalf(&quot;wrong reply from Handler4&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">var args JunkArgs</span><br><span class="line">var reply JunkReply</span><br><span class="line">// args must match type (pointer or not) of handler.</span><br><span class="line">e.Call(&quot;JunkServer.Handler5&quot;, args, &amp;reply)</span><br><span class="line">if reply.X != &quot;no pointer&quot; &#123;</span><br><span class="line">t.Fatalf(&quot;wrong reply from Handler5&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结与使用"><a class="markdownIt-Anchor" href="#总结与使用"></a> 总结与使用</h2><p>此package很好在本地模拟了远程过程调用，为实现分布式的算法奠定了坚实的基础。<br>使用此package的9个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   // 1. create network</span><br><span class="line">   // 2、create client</span><br><span class="line">   // 3. create service</span><br><span class="line">   // 4. create server</span><br><span class="line">   // 5. service add to server </span><br><span class="line">   // 6. server add to network</span><br><span class="line">   // 7. client connect to server</span><br><span class="line">   // 8. enable network</span><br><span class="line">// 9. call the service wait the reply.</span><br></pre></td></tr></table></figure><h2 id="完整实验代码"><a class="markdownIt-Anchor" href="#完整实验代码"></a> 完整实验代码</h2><p><a href="https://github.com/dreamerjackson/golang-deep-distributed-lab" target="_blank" rel="noopener">https://github.com/dreamerjackson/golang-deep-distributed-lab</a><br>后面的测试多参考一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了实践分布式的第一步，需要模拟远程的过程调用，就好像程序是部署在不同的机器通过tcp进行连接。&lt;/p&gt;
&lt;h2 id=&quot;构建client&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#构建client&quot;&gt;&lt;/a&gt; 构建client&lt;/h2&gt;
&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[108]-2的幂</title>
    <link href="https://dreamerjonson.com/2019/12/18/golang-108-pow-of-two/"/>
    <id>https://dreamerjonson.com/2019/12/18/golang-108-pow-of-two/</id>
    <published>2019-12-17T16:41:10.000Z</published>
    <updated>2019-12-18T10:19:04.752Z</updated>
    
    <content type="html"><![CDATA[<p>单精度浮点数可以表达的范围是：2^-149 - 2^127<br>Denormalized number 从2^-149 - 2^-127<br>Normal number  2 ^-126 - 2^127</p><table><thead><tr><th>Power of Two</th><th>–</th><th>指数位Exponent</th><th>小数位Fraction</th></tr></thead><tbody><tr><td>-149</td><td>0</td><td>00000000</td><td>00000000000000000000001</td></tr><tr><td>-148</td><td>0</td><td>00000000</td><td>00000000000000000000010</td></tr><tr><td>-147</td><td>0</td><td>00000000</td><td>00000000000000000000100</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-128</td><td>0</td><td>00000000</td><td>01000000000000000000000</td></tr><tr><td>-127</td><td>0</td><td>00000000</td><td>10000000000000000000000</td></tr><tr><td>-126</td><td>0</td><td>00000001</td><td>00000000000000000000000</td></tr><tr><td>-125</td><td>0</td><td>00000010</td><td>00000000000000000000000</td></tr><tr><td>-124</td><td>0</td><td>00000011</td><td>00000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-2</td><td>0</td><td>01111101</td><td>00000000000000000000000</td></tr><tr><td>-1</td><td>0</td><td>01111110</td><td>00000000000000000000000</td></tr><tr><td>0</td><td>0</td><td>01111111</td><td>00000000000000000000000</td></tr><tr><td>1</td><td>0</td><td>10000000</td><td>00000000000000000000000</td></tr><tr><td>2</td><td>0</td><td>10000001</td><td>00000000000000000000000</td></tr><tr><td>3</td><td>0</td><td>10000010</td><td>00000000000000000000000</td></tr><tr><td>4</td><td>0</td><td>10000011</td><td>00000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>125</td><td>0</td><td>11111100</td><td>00000000000000000000000</td></tr><tr><td>126</td><td>0</td><td>11111101</td><td>00000000000000000000000</td></tr><tr><td>127</td><td>0</td><td>11111110</td><td>00000000000000000000000</td></tr></tbody></table><p>从上表中可以看出，以2为底的单精度指数有以下特点：<br>1、指数位为0，而小数位只有一个1位<br>2、指数位介于1到254之间，小数位为0.</p><table><thead><tr><th>Power of Two</th><th>–</th><th>Exponent</th><th>Fraction</th></tr></thead><tbody><tr><td>-1074</td><td>0</td><td>00000000000</td><td>0000000000000000000000000000000000000000000000000001</td></tr><tr><td>-1073</td><td>0</td><td>00000000000</td><td>0000000000000000000000000000000000000000000000000010</td></tr><tr><td>-1072</td><td>0</td><td>00000000000</td><td>0000000000000000000000000000000000000000000000000100</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-1024</td><td>0</td><td>00000000000</td><td>0100000000000000000000000000000000000000000000000000</td></tr><tr><td>-1023</td><td>0</td><td>00000000000</td><td>1000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1022</td><td>0</td><td>00000000001</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1021</td><td>0</td><td>00000000010</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1020</td><td>0</td><td>00000000011</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>-2</td><td>0</td><td>01111111101</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>-1</td><td>0</td><td>01111111110</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>0</td><td>0</td><td>01111111111</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>1</td><td>0</td><td>10000000000</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>2</td><td>0</td><td>10000000001</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>3</td><td>0</td><td>10000000010</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>4</td><td>0</td><td>10000000011</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>1021</td><td>0</td><td>11111111100</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>1022</td><td>0</td><td>11111111101</td><td>0000000000000000000000000000000000000000000000000000</td></tr><tr><td>1023</td><td>0</td><td>11111111110</td><td>0000000000000000000000000000000000000000000000000000</td></tr></tbody></table><p>从上表中可以看出，以2为底的双精度指数有以下特点：<br>1、指数位为0，而小数位只有一个1位<br>2、指数位介于1到2046之间，小数位为0.</p><h2 id="字节序"><a class="markdownIt-Anchor" href="#字节序"></a> 字节序</h2><p>指定数字二进制编码内的字节如何在内存中排序。有大端序与小端序之分。<br>大端序 ： 高位高字节<br>小端序： 高位低字节</p><p>2^-2  大端排序为 00111110100000000000000000000000<br>2^2   小端排序为 00000000000000001000000000111110</p><h2 id="判断2的幂的10种方法"><a class="markdownIt-Anchor" href="#判断2的幂的10种方法"></a> 判断2的幂的10种方法</h2><p>以单精度浮点数为例。</p><h3 id="方法1"><a class="markdownIt-Anchor" href="#方法1"></a> 方法1</h3><p>看成是10进制，不断除以2。 2的次方数除到最后为1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo</span><span class="params">( x <span class="keyword">uint64</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> x % <span class="number">2</span> ==<span class="number">0</span> &amp;&amp; x &gt; <span class="number">1</span> &#123;</span><br><span class="line">x /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法2"><a class="markdownIt-Anchor" href="#方法2"></a> 方法2</h3><p>单精度浮点数最多31个数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo2</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x == <span class="number">1</span> || x == <span class="number">2</span> || x == <span class="number">4</span> || x == <span class="number">8</span> || x == <span class="number">16</span> || x == <span class="number">32</span> ||</span><br><span class="line">x == <span class="number">64</span> || x == <span class="number">128</span> || x == <span class="number">256</span> || x == <span class="number">512</span> || x == <span class="number">1024</span> ||</span><br><span class="line">x == <span class="number">2048</span> || x == <span class="number">4096</span> || x == <span class="number">8192</span> || x == <span class="number">16384</span> ||</span><br><span class="line">x == <span class="number">32768</span> || x == <span class="number">65536</span> || x == <span class="number">131072</span> || x == <span class="number">262144</span> ||</span><br><span class="line">x == <span class="number">524288</span> || x == <span class="number">1048576</span> || x == <span class="number">2097152</span> ||</span><br><span class="line">x == <span class="number">4194304</span> || x == <span class="number">8388608</span> || x == <span class="number">16777216</span> ||</span><br><span class="line">x == <span class="number">33554432</span> || x == <span class="number">67108864</span> || x == <span class="number">134217728</span> ||</span><br><span class="line">x == <span class="number">268435456</span> || x == <span class="number">536870912</span> || x == <span class="number">1073741824</span> ||</span><br><span class="line">x == <span class="number">2147483648</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法3"><a class="markdownIt-Anchor" href="#方法3"></a> 方法3</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不断乘以2,逼近参入参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo3</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> powerOfTwo <span class="keyword">uint32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> powerOfTwo &lt; x &amp;&amp; powerOfTwo &lt; <span class="number">2147483648</span>&#123;</span><br><span class="line">powerOfTwo *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x == powerOfTwo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法4"><a class="markdownIt-Anchor" href="#方法4"></a> 方法4</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事先存好数组，遍历不断逼近参入参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo4</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"> powerOfTwo := [<span class="number">32</span>]<span class="keyword">uint32</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>,<span class="number">2048</span>,<span class="number">4096</span>,<span class="number">8192</span>,<span class="number">16384</span>,<span class="number">32768</span>,</span><br><span class="line"><span class="number">65536</span>,<span class="number">131072</span>,<span class="number">262144</span>,<span class="number">524288</span>,<span class="number">1048576</span>,<span class="number">2097152</span>,<span class="number">4194304</span>,<span class="number">8388608</span>,</span><br><span class="line"><span class="number">16777216</span>,<span class="number">33554432</span>,<span class="number">67108864</span>,<span class="number">134217728</span>,<span class="number">268435456</span>,<span class="number">536870912</span>,</span><br><span class="line"><span class="number">1073741824</span>,<span class="number">2147483648</span>&#125;</span><br><span class="line"><span class="keyword">var</span>  exponent = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> powerOfTwo[exponent] &lt; x &amp;&amp; exponent &lt; <span class="number">31</span>&#123;</span><br><span class="line">exponent++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (x == powerOfTwo[exponent])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法5"><a class="markdownIt-Anchor" href="#方法5"></a> 方法5</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo5</span><span class="params">( x <span class="keyword">uint32</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">powerOfTwo := [<span class="number">32</span>]<span class="keyword">uint32</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>,<span class="number">1024</span>,<span class="number">2048</span>,<span class="number">4096</span>,<span class="number">8192</span>,<span class="number">16384</span>,<span class="number">32768</span>,</span><br><span class="line"><span class="number">65536</span>,<span class="number">131072</span>,<span class="number">262144</span>,<span class="number">524288</span>,<span class="number">1048576</span>,<span class="number">2097152</span>,<span class="number">4194304</span>,<span class="number">8388608</span>,</span><br><span class="line"><span class="number">16777216</span>,<span class="number">33554432</span>,<span class="number">67108864</span>,<span class="number">134217728</span>,<span class="number">268435456</span>,<span class="number">536870912</span>,</span><br><span class="line"><span class="number">1073741824</span>,<span class="number">2147483648</span>&#125;</span><br><span class="line">isAPowerOfTwo  := <span class="literal">false</span></span><br><span class="line">interval := <span class="number">16</span>;</span><br><span class="line">exponent := interval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">isAPowerOfTwo = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">isAPowerOfTwo = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">for</span> x != powerOfTwo[exponent] &amp;&amp;  interval&gt;<span class="number">1</span>&#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; powerOfTwo[exponent]&#123;</span><br><span class="line">exponent -= interval / <span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">exponent += interval / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">interval /= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">isAPowerOfTwo = (x == powerOfTwo[exponent])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isAPowerOfTwo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法6"><a class="markdownIt-Anchor" href="#方法6"></a> 方法6</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// math.log函数求出2的幂,与2的次方作对比</span><br><span class="line">func isPowerOfTwo6( x uint32) bool &#123;</span><br><span class="line">powerOfTwo := [32]uint32&#123;1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,</span><br><span class="line">65536,131072,262144,524288,1048576,2097152,4194304,8388608,</span><br><span class="line">16777216,33554432,67108864,134217728,268435456,536870912,</span><br><span class="line">1073741824,2147483648&#125;</span><br><span class="line">isAPowerOfTwo  := false</span><br><span class="line">if  x&gt;0 &amp;&amp; x &lt; 2147483648&#123;</span><br><span class="line">exponent := uint32(math.Log2(float64(x)))</span><br><span class="line">isAPowerOfTwo = (x == powerOfTwo[exponent] ||</span><br><span class="line">x == powerOfTwo[exponent+1])</span><br><span class="line">&#125;</span><br><span class="line">return isAPowerOfTwo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法7"><a class="markdownIt-Anchor" href="#方法7"></a> 方法7</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 统计2进制位的个数,2的次方只有1个2进制位</span><br><span class="line">func isPowerOfTwo7( x uint32) bool &#123;</span><br><span class="line">numberOfOneBits := 0</span><br><span class="line"></span><br><span class="line">for x &gt; 0  &amp;&amp; numberOfOneBits &lt;=1&#123;</span><br><span class="line">if  ( x &amp; 1 ) == 1 &#123;</span><br><span class="line">numberOfOneBits++</span><br><span class="line">&#125;</span><br><span class="line">x &gt;&gt;= 1</span><br><span class="line">&#125;</span><br><span class="line">return numberOfOneBits == 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法8"><a class="markdownIt-Anchor" href="#方法8"></a> 方法8</h3><p>2的次方第一位是1，其他位为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func isPowerOfTwo8( x uint32) bool &#123;</span><br><span class="line">for (x &amp; 1) == 0 &amp;&amp; x &gt; 1&#123;</span><br><span class="line"> x &gt;&gt;= 1</span><br><span class="line">&#125;</span><br><span class="line">return x == 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法9"><a class="markdownIt-Anchor" href="#方法9"></a> 方法9</h3><p>malloc.c in the GNU C Library 中的实现方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isPowerOfTwo9( x uint32) bool &#123;</span><br><span class="line">return (x != 0) &amp;&amp; x &amp; (x - 1) == 0 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面简单说明一下x &amp; (x - 1) == 0 的原理。<br>x的二进制从左到右 至少有一个为1的位，标记为i。如果i右边的位都为0，正好是2的次方数。那么 x - 1 在i处为0，在 i右边都为1，这时满足 (x &amp; x - 1) ==0<br>假设 i右边至少有一位不为0， 那么 x  - 1 在i 位仍然为 1 ，这时不满足 (x &amp; x -1) == 0<br>得证。</p><h3 id="方法10"><a class="markdownIt-Anchor" href="#方法10"></a> 方法10</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isPowerOfTwo10( x uint32) bool &#123;</span><br><span class="line">return ((x != 0) &amp;&amp; ((x &amp; (^x + 1)) == x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明方法和方法9相似。</p><h2 id="10的正次方数与2进制之间的有趣性质"><a class="markdownIt-Anchor" href="#10的正次方数与2进制之间的有趣性质"></a> 10的正次方数与2进制之间的有趣性质</h2><p>从下表中我们能够发现，10的正次方数转换为2的次方数后，末尾都是相同的。<br>原因在于  10^n = 2^n * 5^n  5的次方数总是以1结尾的。 而2^n 相当于左移n位</p><table><thead><tr><th>Power of Ten (in Decimal)</th><th>Power of Ten (in Binary)</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>10</td><td>10 10</td></tr><tr><td>100</td><td>1100 100</td></tr><tr><td>1000</td><td>111110 1000</td></tr><tr><td>10000</td><td>100111000 10000</td></tr><tr><td>100000</td><td>11000011010 100000</td></tr></tbody></table><p>因此10^n - 1 有如下性质:</p><table><thead><tr><th>n</th><th>10n-1 (in decimal)</th><th>10n-1 (in binary)</th></tr></thead><tbody><tr><td>1</td><td>9</td><td>1001</td></tr><tr><td>2</td><td>99</td><td>1100011</td></tr><tr><td>3</td><td>999</td><td>1111100111</td></tr><tr><td>4</td><td>9999</td><td>10011100001111</td></tr><tr><td>5</td><td>99999</td><td>11000011010011111</td></tr><tr><td>6</td><td>999999</td><td>11110100001000111111</td></tr><tr><td>7</td><td>9999999</td><td>100110001001011001111111</td></tr><tr><td>8</td><td>99999999</td><td>101111101011110000011111111</td></tr><tr><td>9</td><td>999999999</td><td>111011100110101100100111111111</td></tr><tr><td>10</td><td>9999999999</td><td>1001010100000010111110001111111111</td></tr><tr><td>11</td><td>99999999999</td><td>1011101001000011101101110011111111111</td></tr><tr><td>12</td><td>999999999999</td><td>1110100011010100101001010000111111111111</td></tr></tbody></table><h2 id="在google中做计算"><a class="markdownIt-Anchor" href="#在google中做计算"></a> 在google中做计算</h2><table><thead><tr><th>Expression</th><th>Result</th><th>Notes</th></tr></thead><tbody><tr><td>2^32</td><td>4 294 967 296</td><td>Positive power of two</td></tr><tr><td>2^-6</td><td>0.015625</td><td>Negative power of two</td></tr><tr><td>1/2^6</td><td>0.015625</td><td>Negative power of two</td></tr><tr><td>(2<sup>2)</sup>3</td><td>64</td><td>Composed power of two</td></tr><tr><td>8^7</td><td>2 097 152</td><td>Power of eight</td></tr><tr><td>7<em>16^2 + 13</em>16 + 9</td><td>2 009</td><td>Convert 0x7D9 to decimal by hand</td></tr><tr><td>lg(256)/lg(16)</td><td>2</td><td>Change of base computes log16(256) = 2</td></tr><tr><td>15/2^6</td><td>0.234375</td><td>Dyadic fraction</td></tr><tr><td>lg(65536)</td><td>16</td><td>log2(216) = 16</td></tr><tr><td>log(2^32)</td><td>9.63295986</td><td>232 is 10 digits long in base 10</td></tr></tbody></table><h3 id="10进制转2进制"><a class="markdownIt-Anchor" href="#10进制转2进制"></a> 10进制转2进制</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>2009 to binary</td><td>0b11111011001</td></tr><tr><td>0x07D9 to binary</td><td>0b11111011001</td></tr><tr><td>0o3731 to binary</td><td>0b11111011001</td></tr></tbody></table><h3 id="10进制转16净值"><a class="markdownIt-Anchor" href="#10进制转16净值"></a> 10进制转16净值</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>2009 to hex</td><td>0x7D9</td></tr><tr><td>0b11111011001 to hex</td><td>0x7D9</td></tr><tr><td>0o3731 to hex</td><td>0x7D9</td></tr></tbody></table><h3 id="10进制转16进制"><a class="markdownIt-Anchor" href="#10进制转16进制"></a> 10进制转16进制</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>2009 to octal</td><td>0o3731</td></tr><tr><td>0b11111011001 to octal</td><td>0o3731</td></tr><tr><td>0x07D9 to octal</td><td>0o3731</td></tr></tbody></table><h3 id="转10进制"><a class="markdownIt-Anchor" href="#转10进制"></a> 转10进制</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>0b11111011001 to decimal</td><td>2009</td></tr><tr><td>0x07D9 to decimal</td><td>2009</td></tr><tr><td>0o3731 to decimal</td><td>2009</td></tr></tbody></table><h3 id="计算加进制转换"><a class="markdownIt-Anchor" href="#计算加进制转换"></a> 计算加进制转换</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td>0b1010 + 0b1011 to decimal</td><td>21</td></tr><tr><td>0xA * 0xF to binary</td><td>0b10010110</td></tr><tr><td>0o24 / 0o12 to hex</td><td>0x2</td></tr><tr><td>2^10 + 2^8 + 2^1 to binary</td><td>0b10100000010</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单精度浮点数可以表达的范围是：2^-149 - 2^127&lt;br&gt;
Denormalized number 从2^-149 - 2^-127&lt;br&gt;
Normal number  2 ^-126 - 2^127&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Po
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[107]-约瑟夫问题与2的次方的特性</title>
    <link href="https://dreamerjonson.com/2019/12/14/golang-107-Josephus-problem/"/>
    <id>https://dreamerjonson.com/2019/12/14/golang-107-Josephus-problem/</id>
    <published>2019-12-14T13:12:12.000Z</published>
    <updated>2019-12-25T03:18:08.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。</p><p>人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。</p><p>问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。</p><center><img src="/2019/12/14/golang-107-Josephus-problem/1.png"></center><center><div>13人的例子，最后赢家为11号</div></center><p>我们以k = 2 即跳过1人后 执行下一个人为例，来探讨一个有趣的性质。</p><h3 id="假设参与人数为2的次方数"><a class="markdownIt-Anchor" href="#假设参与人数为2的次方数"></a> 假设参与人数为2的次方数。</h3><center><img src="/2019/12/14/golang-107-Josephus-problem/2.png"></center><center><div>参与人数为8人的情形</div></center><p>每回合消除的人数与二叉树类似。<br>Pass 1  four people: 2, 4, 6, 8.<br>Pass 2  two people: 3, 7<br>Pass 3  one person: 5</p><p>最后剩下的人数为1号，这不是偶然的。<br>我们可以用归纳法证明：<br>当参与人数是2^m+1, 经过一轮后，减少人数到2^m，并且减少的都是偶数的编号，编号1保留。<br>因此总会到达上面我们讨论的8人数，得证。</p><h3 id="当参与人数不是2的幂"><a class="markdownIt-Anchor" href="#当参与人数不是2的幂"></a> 当参与人数不是2的幂</h3><p>有一点我们是肯定的，当参数人数不是2的幂后，编号1一定不是最后的幸存者。<br>这是由于总有一次参数会是一个奇数，编号1就会被下一轮干掉。</p><center><img src="/2019/12/14/golang-107-Josephus-problem/3.png"></center><center><div>参数人数不是2的幂</div></center><p>Pass 1 eliminates six people: 2, 4, 6, 8, 10, 12.<br>Pass 2 eliminates four people: 1, 5, 9, 13.<br>Pass 3 eliminates one person: 7.<br>Pass 4 eliminates one person: 3.</p><p>分析：当参与人数不是2的幂时, 到某一时刻总会变为2的幂。<br>变为2的幂后就会符合上面我们指出的规律。</p><center><img src="/2019/12/14/golang-107-Josephus-problem/4.png"></center><center><div>分析</div></center><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>假设参数人数是n = 2^m + k</p><p>那么 在 k 次消除后， n = 2 ^ m  次数编码到达了2k + 1。<br>因此可以证明编号2k + 1 就是幸存者。</p><p>假设n = 2^m + k<br>m = 2k + 1</p><p>可证 w = 2（n - 2^m）+1<br>即 w  =  2（n - 2^(log2(n))）+1</p><h3 id="编程求最后一个安全数"><a class="markdownIt-Anchor" href="#编程求最后一个安全数"></a> 编程求最后一个安全数</h3><p>编程求最后一个安全数的最快方法是<br>假设 n  = 0x1 0 1 0 0 1<br>则安全数为 = 0x010011<br>即将最前面的1移动到最后方。</p><p>(bits.Len64(x) 计算x的最高位。<br>( 1 &lt;&lt; (bits.Len64(x)) -1 ) 最高位变为0<br>(x &lt;&lt; 1 | 1) 最低位加1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func calEndVal(x uint64) uint64&#123;</span><br><span class="line">return   ( 1 &lt;&lt; (bits.Len64(x)) -1 )  &amp;   (x &lt;&lt; 1 | 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h2&gt;
&lt;p&gt;约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。&lt;/p&gt;

      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[106]-深入浮点数</title>
    <link href="https://dreamerjonson.com/2019/12/11/golang-106-IEE754-float/"/>
    <id>https://dreamerjonson.com/2019/12/11/golang-106-IEE754-float/</id>
    <published>2019-12-11T07:49:51.000Z</published>
    <updated>2020-01-10T10:13:17.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>下面的一段简单程序 0.3 + 0.6 结果是什么？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 <span class="keyword">float64</span> = <span class="number">0.3</span></span><br><span class="line"><span class="keyword">var</span> f2 <span class="keyword">float64</span> = <span class="number">0.6</span></span><br><span class="line">fmt.Println(f1 + f2)</span><br></pre></td></tr></table></figure><p>有人会天真的认为是0.9，但实际输出却是0.8999999999999999（go 1.13.5）</p><p>问题在于大多数小数表示成二进制之后是近似且无限的。<br>以0.1为例。它可能是你能想到的最简单的十进制之一，但是二进制看起来却非常复杂：0.0001100110011001100…<br>其是一串连续循环无限的数字（涉及到10进制转换为2进制,暂不介绍）。<br>结果的荒诞性告诉我们，必须深入理解浮点数在计算机中的存储方式及其性质，才能正确处理数字的计算。<br>golang 与其他很多语言（C、C++、Python…）一样，使用了IEEE-754标准存储浮点数。</p><h2 id="ieee-754-如何存储浮点数"><a class="markdownIt-Anchor" href="#ieee-754-如何存储浮点数"></a> IEEE-754 如何存储浮点数</h2><p>IEEE-754规范使用特殊的以2为基数的科学表示法表示浮点数。</p><table><thead><tr><th>基本的10进制数字</th><th>科学计数法表示</th><th>指数表示</th><th>系数</th><th>底数</th><th>指数</th><th>小数</th></tr></thead><tbody><tr><td>700</td><td>7e+2</td><td>7 * 10^2</td><td>7</td><td>10</td><td>2</td><td>0</td></tr><tr><td>4,900,000,000</td><td>4.9e+9</td><td>4.9 * 10^9</td><td>4.9</td><td>10</td><td>9</td><td>.9</td></tr><tr><td>5362.63</td><td>5.36263e+3</td><td>5.36263 * 10^3</td><td>5.36263</td><td>10</td><td>3</td><td>.36263</td></tr><tr><td>-0.00345</td><td>3.45e-3</td><td>3.45 * 10^-3</td><td>3.45</td><td>10</td><td>-3</td><td>.45</td></tr><tr><td>0.085</td><td>1.36e-4</td><td>1.36 * 2^-4</td><td>1.36</td><td>2</td><td>-4</td><td>.36</td></tr></tbody></table><p>32位的单精度浮点数 与 64位的双精度浮点数的差异</p><table><thead><tr><th>精度</th><th>符号位</th><th>指数位</th><th>小数位</th><th>偏移量</th></tr></thead><tbody><tr><td>Single (32 Bits)</td><td>1 [31]</td><td>8 [30-23]</td><td>23 [22-00]</td><td>127</td></tr><tr><td>Double (64 Bits)</td><td>1 [63]</td><td>11 [62-52]</td><td>52 [51-00]</td><td>1023</td></tr></tbody></table><p>符号位： 1 为 负数， 0 为正数。<br>指数位： 存储 指数加上偏移量，偏移量是为了表达负数而设计的。<br>小数位： 存储系数的小数位的准确或者最接近的值。</p><p>以 数字 0.085 为例。</p><table><thead><tr><th>符号位</th><th>指数位(123)</th><th>小数位 (.36)</th></tr></thead><tbody><tr><td>0</td><td>0111 1011</td><td>010 1110 0001 0100 0111 1011</td></tr></tbody></table><h2 id="小数位的表达方式"><a class="markdownIt-Anchor" href="#小数位的表达方式"></a> 小数位的表达方式</h2><p>以0.36 为例:<br>010 1110 0001 0100 0111 1011 = 0.36  (第一位数字代表1/2,第二位数字是1/4…，0.36 是所有位相加)<br>分解后的计算步骤为:</p><table><thead><tr><th>第n位</th><th>2的幂</th><th>分数</th><th>10进制</th><th>求和</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>1⁄4</td><td>0.25</td><td>0.25</td></tr><tr><td>4</td><td>16</td><td>1⁄16</td><td>0.0625</td><td>0.3125</td></tr><tr><td>5</td><td>32</td><td>1⁄32</td><td>0.03125</td><td>0.34375</td></tr><tr><td>6</td><td>64</td><td>1⁄64</td><td>0.015625</td><td>0.359375</td></tr><tr><td>11</td><td>2048</td><td>1⁄2048</td><td>0.00048828125</td><td>0.35986328125</td></tr><tr><td>13</td><td>8192</td><td>1⁄8192</td><td>0.0001220703125</td><td>0.3599853515625</td></tr><tr><td>17</td><td>131072</td><td>1⁄131072</td><td>0.00000762939453</td><td>0.35999298095703</td></tr><tr><td>18</td><td>262144</td><td>1⁄262144</td><td>0.00000381469727</td><td>0.3599967956543</td></tr><tr><td>19</td><td>524288</td><td>1⁄524288</td><td>0.00000190734863</td><td>0.35999870300293</td></tr><tr><td>20</td><td>1048576</td><td>1⁄1048576</td><td>0.00000095367432</td><td>0.35999965667725</td></tr><tr><td>22</td><td>4194304</td><td>1⁄4194304</td><td>0.00000023841858</td><td>0.35999989509583</td></tr><tr><td>23</td><td>8388608</td><td>1⁄8388608</td><td>0.00000011920929</td><td>0.36000001430512</td></tr></tbody></table><h2 id="go语言显示浮点数-验证之前的理论"><a class="markdownIt-Anchor" href="#go语言显示浮点数-验证之前的理论"></a> go语言显示浮点数 -  验证之前的理论</h2><p>接下来用一个案例有助于我们理解并验证IEEE-754 浮点数的表示方式。<br>math.Float32bits 可以为我们打印出32位数据的二进制表示。(注：math.Float64bits可以打印64位数据的二进制)<br>下面的go代码将输出0.085的浮点数二进制表达，并且为了验证之前理论的正确性，根据二进制表示反向推导出其所表示的原始十进制0.085</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="keyword">float32</span> = <span class="number">0.085</span></span><br><span class="line"><span class="comment">// 打印出32位数据的二进制表示。</span></span><br><span class="line">bits := math.Float32bits(number)</span><br><span class="line">binary := fmt.Sprintf(<span class="string">"%.32b"</span>, bits)</span><br><span class="line"> <span class="comment">// 打印浮点数的符号位、指数位 、小数位</span></span><br><span class="line">fmt.Printf(<span class="string">"Bit Pattern: %s | %s %s | %s %s %s %s %s %s\n\n"</span>,</span><br><span class="line">binary[<span class="number">0</span>:<span class="number">1</span>],</span><br><span class="line">binary[<span class="number">1</span>:<span class="number">5</span>], binary[<span class="number">5</span>:<span class="number">9</span>],</span><br><span class="line">binary[<span class="number">9</span>:<span class="number">12</span>], binary[<span class="number">12</span>:<span class="number">16</span>], binary[<span class="number">16</span>:<span class="number">20</span>],</span><br><span class="line">binary[<span class="number">20</span>:<span class="number">24</span>], binary[<span class="number">24</span>:<span class="number">28</span>], binary[<span class="number">28</span>:<span class="number">32</span>])</span><br><span class="line"> <span class="comment">// 偏移量</span></span><br><span class="line">bias := <span class="number">127</span></span><br><span class="line"> <span class="comment">// 获取符号位</span></span><br><span class="line">sign := bits &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">exponentRaw := <span class="keyword">int</span>(bits &gt;&gt; <span class="number">23</span>)</span><br><span class="line"> <span class="comment">// 获取指数位</span></span><br><span class="line">exponent := exponentRaw - bias</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mantissa <span class="keyword">float64</span></span><br><span class="line"> <span class="comment">// 小数位求和</span></span><br><span class="line"><span class="keyword">for</span> index, bit := <span class="keyword">range</span> binary[<span class="number">9</span>:<span class="number">32</span>] &#123;</span><br><span class="line"><span class="keyword">if</span> bit == <span class="number">49</span> &#123;</span><br><span class="line">position := index + <span class="number">1</span></span><br><span class="line">bitValue := math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(position))</span><br><span class="line">fractional := <span class="number">1</span> / bitValue</span><br><span class="line">mantissa = mantissa + fractional</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 反向求出最终10进制表示</span></span><br><span class="line">value := (<span class="number">1</span> + mantissa) * math.Pow(<span class="number">2</span>, <span class="keyword">float64</span>(exponent))</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Sign: %d Exponent: %d (%d) Mantissa: %f Value: %f\n\n"</span>,</span><br><span class="line">sign,</span><br><span class="line">exponentRaw,</span><br><span class="line">exponent,</span><br><span class="line">mantissa,</span><br><span class="line">value)</span><br></pre></td></tr></table></figure><p>输出： 表明我们对于浮点数的理解正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting Number: 0.085000</span><br><span class="line">Bit Pattern: 0 | 0111 1011 | 010 1110 0001 0100 0111 1011</span><br><span class="line">Sign: 0 Exponent: 123 (-4) Mantissa: 0.360000 Value: 0.085000</span><br></pre></td></tr></table></figure><h2 id="经典问题如何判断一个浮点数其实存储的是整数"><a class="markdownIt-Anchor" href="#经典问题如何判断一个浮点数其实存储的是整数"></a> 经典问题：如何判断一个浮点数其实存储的是整数</h2><p>下面是一个有趣的问题，如何判断一个浮点数其实存储的是整数？<br>思考10秒钟…<br>下面是一段判断浮点数是否为整数的go代码实现，我们接下来逐行分析函数。<br>它可以加深对于浮点数的理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsInt</span><span class="params">(bits <span class="keyword">uint32</span>, bias <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    exponent := <span class="keyword">int</span>(bits &gt;&gt; <span class="number">23</span>) - bias - <span class="number">23</span></span><br><span class="line">    coefficient := (bits &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">23</span>) - <span class="number">1</span>)) | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>)</span><br><span class="line">    intTest := (coefficient &amp; (<span class="number">1</span> &lt;&lt; <span class="keyword">uint32</span>(-exponent) - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"\nExponent: %d Coefficient: %d IntTest: %d\n"</span>,</span><br><span class="line">        exponent,</span><br><span class="line">        coefficient,</span><br><span class="line">        intTest)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exponent &lt; <span class="number">-23</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"NOT INTEGER\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exponent &lt; <span class="number">0</span> &amp;&amp; intTest != <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"NOT INTEGER\n"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"INTEGER\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、要保证是整数，一个重要的条件是必须要指数位大于127。指数位大于127，代表指数大于0， 反之指数小于0.</p><p>下面我们以数字234523为例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Starting Number: 234523.000000</span><br><span class="line">Bit Pattern: 0 | 1001 0000 | 110 0101 0000 0110 1100 0000</span><br><span class="line">Sign: 0 Exponent: 144 (17) Mantissa: 0.789268 Value: 234523.000000</span><br><span class="line">Exponent: -6 Coefficient: 15009472 IntTest: 0</span><br><span class="line">INTEGER</span><br></pre></td></tr></table></figure><p>第一步,计算指数。 由于exponent多减去了23，所以在第一个判断中 判断条件为  exponent &lt; -23<br>exponent := int(bits &gt;&gt; 23) - bias - 23</p><p>第二步，<br>(bits &amp; ((1 &lt;&lt; 23) - 1)) 计算小数位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coefficient := (bits &amp; ((1 &lt;&lt; 23) - 1)) | (1 &lt;&lt; 23)</span><br><span class="line"></span><br><span class="line">Bits:                   01001000011001010000011011000000</span><br><span class="line">(1 &lt;&lt; 23) - 1:          00000000011111111111111111111111</span><br><span class="line">bits &amp; ((1 &lt;&lt; 23) - 1): 00000000011001010000011011000000</span><br></pre></td></tr></table></figure><p>| (1 &lt;&lt; 23) 代表 将1加在前方。<br>1 + 小数 = 系数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bits &amp; ((1 &lt;&lt; 23) - 1): 00000000011001010000011011000000</span><br><span class="line">(1 &lt;&lt; 23):              00000000100000000000000000000000</span><br><span class="line">coefficient:            00000000111001010000011011000000</span><br></pre></td></tr></table></figure><p>第三步，计算intTest 只有当指数的倍数可以弥补最小的小数位的时候，才是一个整数。<br>如下，指数是17位，其不能够弥补最后6位的小数。即不能弥补1/2^18 以后的小数。<br>但是由于代表2^18的位之后为0.所以是整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exponent:                     (144 - 127 - 23) = -6</span><br><span class="line">1 &lt;&lt; uint32(-exponent):       000000</span><br><span class="line">(1 &lt;&lt; uint32(-exponent)) - 1: 111111</span><br><span class="line"></span><br><span class="line">coefficient:                 00000000111001010000011011000000</span><br><span class="line">1 &lt;&lt; uint32(-exponent)) - 1: 00000000000000000000000000111111</span><br><span class="line">intTest:                     00000000000000000000000000000000</span><br></pre></td></tr></table></figure><h2 id="golang-decimal-包详解"><a class="markdownIt-Anchor" href="#golang-decimal-包详解"></a> golang decimal 包详解</h2><p>要理解decimal包，首先需要知道两个重要的概念，Normal number、denormal (or subnormal) number 以及精度。</p><h3 id="normal-number-and-denormal-or-subnormal-number"><a class="markdownIt-Anchor" href="#normal-number-and-denormal-or-subnormal-number"></a> Normal number and denormal (or subnormal) number</h3><p>wiki的解释是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In computing, a normal number is a non-zero number in a floating-point representation which is within the balanced range supported by a given floating-point format: it is a floating point number that can be represented without leading zeros in its significand.</span><br></pre></td></tr></table></figure><p>什么意思呢？在IEEE-754中指数位有一个偏移量，偏移量是为了表达负数而设计的。 比如单精度中的0.085，实际的指数是 -3， 存储到浮点数的指数位是123。<br>所以表达的负数就是有上限的。这个上限就是2^-126。 如果比这个负数还要小，例如2^-127,这个时候应该表达为0.1 * 2 ^ -126.   这时系数变为了不是1为前导的数，这个数就叫做denormal (or subnormal) number。<br>正常的系数是以1为前导的数就叫做Normal number。</p><h3 id="概念精度"><a class="markdownIt-Anchor" href="#概念精度"></a> 概念：精度</h3><p>精度是一个非常复杂的概念，在这里笔者讨论的是2进制浮点数的10进制精度。<br>精度为d表示的是在一个范围内，如果我们将d位10进制（按照科学计数法表达）转换为二进制。再将二进制转换为d位10进制。如果数据没有不损失意味着在此范围内是有d精度的。<br>精度的原因在于，数据在进制之间相互转换时，是不能够精准匹配的，而是只能匹配到一个最近的数。如图所示：<br><center><img src="/2019/12/11/golang-106-IEE754-float/1.png"></center><br><center><div>精度转换</div></center><br>在这里暂时不深入探讨，而是给出结论：（注：精度是动态变化的，不同的范围可能有不同的精度。这是由于 2的幂 与 10的幂之间的交错是不同的。）<br>float32的精度为6-8位，<br>float64的精度为15-17位</p><p>目前使用比较多的精准操作浮点数的decimal包是shopspring/decimal。链接:<a href="https://github.com/shopspring/decimal" target="_blank" rel="noopener">https://github.com/shopspring/decimal</a><br>decimal包使用math/big包存储大整数并进行大整数的计算。<br>比如对于字符串 “123.45” 我们可以将其转换为12345这个大整数，以及-2代表指数。参考decimal结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Decimal struct &#123;</span><br><span class="line">value *big.Int</span><br><span class="line">exp int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本文中，笔者不会探讨math/big是如何进行大整数运算的，而是探讨decimal包一个非常重要的函数：<br>NewFromFloat(value float64) Decimal<br>其主要调用了下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func newFromFloat(val float64, bits uint64, flt *floatInfo) Decimal &#123;</span><br><span class="line">if math.IsNaN(val) || math.IsInf(val, 0) &#123;</span><br><span class="line">panic(fmt.Sprintf(&quot;Cannot create a Decimal from %v&quot;, val))</span><br><span class="line">&#125;</span><br><span class="line">exp := int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1)</span><br><span class="line">mant := bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1)</span><br><span class="line">switch exp &#123;</span><br><span class="line">case 0:</span><br><span class="line">exp++</span><br><span class="line">default:</span><br><span class="line">mant |= uint64(1) &lt;&lt; flt.mantbits</span><br><span class="line">&#125;</span><br><span class="line">exp += flt.bias</span><br><span class="line">var d decimal</span><br><span class="line">d.Assign(mant)</span><br><span class="line">d.Shift(exp - int(flt.mantbits))</span><br><span class="line">d.neg = bits&gt;&gt;(flt.expbits+flt.mantbits) != 0</span><br><span class="line">roundShortest(&amp;d, mant, exp, flt)</span><br><span class="line">if d.nd &lt; 19 &#123;</span><br><span class="line">tmp := int64(0)</span><br><span class="line">m := int64(1)</span><br><span class="line">for i := d.nd - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">tmp += m * int64(d.d[i]-&apos;0&apos;)</span><br><span class="line">m *= 10</span><br><span class="line">&#125;</span><br><span class="line">if d.neg &#123;</span><br><span class="line">tmp *= -1</span><br><span class="line">&#125;</span><br><span class="line">return Decimal&#123;value: big.NewInt(tmp), exp: int32(d.dp) - int32(d.nd)&#125;</span><br><span class="line">&#125;</span><br><span class="line">dValue := new(big.Int)</span><br><span class="line">dValue, ok := dValue.SetString(string(d.d[:d.nd]), 10)</span><br><span class="line">if ok &#123;</span><br><span class="line">return Decimal&#123;value: dValue, exp: int32(d.dp) - int32(d.nd)&#125;</span><br><span class="line">&#125;</span><br><span class="line">return NewFromFloatWithExponent(val, int32(d.dp)-int32(d.nd))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数会将浮点数转换为Decimal结构。<br>读者想象一下这个问题：如果存储到浮点数中的值（例如0.1）本身就是一个近似值，为什么decimal包能够解决计算的准确性？<br>原因在于，deciimal包可以精准的将一个浮点数转换为10进制。这就是NewFromFloat为我们做的事情。<br>下面我将对此函数做逐行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//2-4行判断浮点数有效性，不能为NAN或INF</span><br><span class="line">   if math.IsNaN(val) || math.IsInf(val, 0) &#123;</span><br><span class="line">panic(fmt.Sprintf(&quot;Cannot create a Decimal from %v&quot;, val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第5行：剥离出IEEE浮点数的指数位<br>exp := int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1)</p><p>第6行：剥离出浮点数的系数的小数位<br>mant := bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1)</p><p>第7行：如果是指数位为0，代表浮点数是denormal (or subnormal) number；<br>默认情况下会在mant之前加上1，因为mant只是系数的小数，在前面加上1后，代表真正的小数位。<br>现在 mant = IEEE浮点数系数 * 2^53</p><p>第13行： 加上偏移量，exp现在代表真正的指数。<br>第14行： 引入了一个中间结构<code>decimal</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type decimal struct &#123;</span><br><span class="line">d     [800]byte</span><br><span class="line">nd    int</span><br><span class="line">dp    int</span><br><span class="line">neg   bool</span><br><span class="line">trunc bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第15行： 调用d.Assign(mant) , 将mant作为10进制数，存起来。<br>10进制数的每一位都作为一个字符存储到 decimal的byte数组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func (a *decimal) Assign(v uint64) &#123;</span><br><span class="line">var buf [24]byte</span><br><span class="line"></span><br><span class="line">// Write reversed decimal in buf.</span><br><span class="line">n := 0</span><br><span class="line">for v &gt; 0 &#123;</span><br><span class="line">v1 := v / 10</span><br><span class="line">v -= 10 * v1</span><br><span class="line">buf[n] = byte(v + &apos;0&apos;)</span><br><span class="line">n++</span><br><span class="line">v = v1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Reverse again to produce forward decimal in a.d.</span><br><span class="line">a.nd = 0</span><br><span class="line">for n--; n &gt;= 0; n-- &#123;</span><br><span class="line">a.d[a.nd] = buf[n]</span><br><span class="line">a.nd++</span><br><span class="line">&#125;</span><br><span class="line">a.dp = a.nd</span><br><span class="line">trim(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第16行： 调用shift函数，这个函数非常难理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (a *decimal) Shift(k int) &#123;</span><br><span class="line">switch &#123;</span><br><span class="line">case a.nd == 0:</span><br><span class="line">case k &gt; 0:</span><br><span class="line">for k &gt; maxShift &#123;</span><br><span class="line">leftShift(a, maxShift)</span><br><span class="line">k -= maxShift</span><br><span class="line">&#125;</span><br><span class="line">leftShift(a, uint(k))</span><br><span class="line">case k &lt; 0:</span><br><span class="line">for k &lt; -maxShift &#123;</span><br><span class="line">rightShift(a, maxShift)</span><br><span class="line">k += maxShift</span><br><span class="line">&#125;</span><br><span class="line">rightShift(a, uint(-k))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数的功能是为了获取此浮点数代表的10进制数据的整数位个数以及小数位个数，此函数的完整证明附后。（注1)<br>exp是真实的指数，其也是能够覆盖小数部分2进制位的个数。（参考前面如何判断浮点数是整数）<br>exp - int(flt.mantbits)代表不能被exp覆盖的2进制位的个数<br>如果exp - int(flt.mantbits)  &gt; 0  代表exp能够完全覆盖小数位 因此 浮点数是一个非常大的整数，这时会调用leftShift(a, uint(k))。否则将调用rightShift(a, uint(-k)), 常规rightShift会调用得更多。因此我们来看看rightShift函数的实现。</p><p>第5行： 此for循环将计算浮点数10进制表示的小数部分的有效位为 r-1 。<br>n &gt;&gt; k  是一个重要的衡量指标，代表了小数部分与整数部分的分割。 此函数的完整证明附后。（注1)</p><p>第21行：此时整数部分所占的有效位数为a.dp -=（r-1）<br>第24行：这两个循环做了2件事情：<br>1、计算10进制表示的有效位数<br>2、将10进制表示存入bytes数组中。例如对于浮点数64.125，现在byte数组存储的前5位就是64125</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">func rightShift(a *decimal, k uint) &#123;</span><br><span class="line">r := 0</span><br><span class="line">w := 0</span><br><span class="line">var n uint</span><br><span class="line">for ; n&gt;&gt;k == 0; r++ &#123;</span><br><span class="line">if r &gt;= a.nd &#123;</span><br><span class="line">if n == 0 &#123;</span><br><span class="line">a.nd = 0</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">for n&gt;&gt;k == 0 &#123;</span><br><span class="line">n = n * 10</span><br><span class="line">r++</span><br><span class="line">&#125;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">c := uint(a.d[r])</span><br><span class="line">n = n*10 + c - &apos;0&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 整数部分的有效位数</span><br><span class="line">a.dp -= r - 1</span><br><span class="line"></span><br><span class="line">var mask uint = (1 &lt;&lt; k) - 1</span><br><span class="line">    // 整数部分</span><br><span class="line">for ; r &lt; a.nd; r++ &#123;</span><br><span class="line">c := uint(a.d[r])</span><br><span class="line">dig := n &gt;&gt; k</span><br><span class="line">n &amp;= mask</span><br><span class="line">a.d[w] = byte(dig + &apos;0&apos;)</span><br><span class="line">w++</span><br><span class="line">n = n*10 + c - &apos;0&apos;</span><br><span class="line">&#125;</span><br><span class="line">    // 小数部分</span><br><span class="line">for n &gt; 0 &#123;</span><br><span class="line">dig := n &gt;&gt; k</span><br><span class="line">n &amp;= mask</span><br><span class="line">if w &lt; len(a.d) &#123;</span><br><span class="line">a.d[w] = byte(dig + &apos;0&apos;)</span><br><span class="line">w++</span><br><span class="line">&#125; else if dig &gt; 0 &#123;</span><br><span class="line">a.trunc = true</span><br><span class="line">&#125;</span><br><span class="line">n = n * 10</span><br><span class="line">&#125;</span><br><span class="line">    // 有效位</span><br><span class="line">a.nd = w</span><br><span class="line">trim(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到newFromFloat函数，第18行，调用了roundShortest函数，<br>此函数非常关键。其会将浮点数转换为离其最近的十进制数。<br>这是为什么decimal.NewFromFloat(0.1)能够精准表达0.1的原因。</p><p>参考上面的精度，此函数主要考察了2的幂与10的幂之间的交错关系。四舍五入到最接近的10进制值。<br>此函数实质实现的是Grisu3 算法,有想深入了解的可以去看看论文。笔者在这里提示几点：<br>1、2^exp &lt;= d &lt; 10^dp。<br>2、10进制数之间至少相聚10^(dp-nd)<br>3、2的幂之间的最小间距至少为2^(exp-mantbits)<br>4、什么时候d就是最接近2进制的10进制数？<br>如果10^(dp-nd) &gt; 2^(exp-mantbits)，表明 当十进制下降一个最小位数时，匹配到的是更小的数字value -  2^(exp-mantbits)，所以d就是最接近浮点数的10进制数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) &#123;</span><br><span class="line">if mant == 0 &#123;</span><br><span class="line">d.nd = 0</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">        // d 是否就是最接近的2进制数。</span><br><span class="line">minexp := flt.bias + 1 // minimum possible exponent</span><br><span class="line">if exp &gt; minexp &amp;&amp; 332*(d.dp-d.nd) &gt;= 100*(exp-int(flt.mantbits)) &#123;</span><br><span class="line">// The number is already shortest.</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">        // 计算最接近的大于d的10进制数</span><br><span class="line">upper := new(decimal)</span><br><span class="line">upper.Assign(mant*2 + 1)</span><br><span class="line">upper.Shift(exp - int(flt.mantbits) - 1)</span><br><span class="line"></span><br><span class="line">var mantlo uint64</span><br><span class="line">var explo int</span><br><span class="line">if mant &gt; 1&lt;&lt;flt.mantbits || exp == minexp &#123;</span><br><span class="line">mantlo = mant - 1</span><br><span class="line">explo = exp</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mantlo = mant*2 - 1</span><br><span class="line">explo = exp - 1</span><br><span class="line">&#125;</span><br><span class="line">        // 计算最接近的小于d的10进制数</span><br><span class="line">lower := new(decimal)</span><br><span class="line">lower.Assign(mantlo*2 + 1)</span><br><span class="line">lower.Shift(explo - int(flt.mantbits) - 1)</span><br><span class="line"></span><br><span class="line">inclusive := mant%2 == 0</span><br><span class="line"></span><br><span class="line">//进行四舍五入</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续回到newFromFloat函数，第19行  如果精度小于19，是位于int64范围内的，可以使用快速路径，否则使用math/big包进行赋值操作，效率稍微要慢一些。<br>第36行，正常情况几乎不会发生。如果setstring在异常的情况下会调用NewFromFloatWithExponent 指定精度进行四舍五入截断。</p><h2 id="注一证明shift函数快速的获取一个浮点数代表的十进制"><a class="markdownIt-Anchor" href="#注一证明shift函数快速的获取一个浮点数代表的十进制"></a> 注一：证明shift函数：快速的获取一个浮点数代表的十进制</h2><p>以典型的数字64.125 为例 ， 它可以被浮点数二进制精准表达为：<br>Bit Patterns: 0 | 10000000101        | 0000000010000000000000000000000000000000000000000000<br>Sign: 0         | Exponent: 1029 (6) |  Mantissa: 0.001953</p><p>即 64.125 = 1.001953125 * 2^6<br>注意观察浮点数的小数位在第九位有1, 代表2^-9  即 0.001953125.</p><p>我们在浮点数的小数位前 附上数字1，10000000010000000000000000000000000000000000000000000  代表其为1 / 2^0 .</p><p>此时我们可以认为这个数代表的是1.001953125. 那么这样长的二进制数变为10进制又是多少呢:4512395720392704。</p><p>即 1.001953125 = 4512395720392704 * 2^(-52)</p><p>所以64.125 = 4512395720392704 * 2^(-52) * 2^6 =  4512395720392704 * 2^(-46)<br>在这里，有一种重要的等式。 即 (2 ^ -46) 等价于向左移动了46位。  并且移动后剩下的部分即为64,而舍弃的部分其实是小数部分0.125。<br>这个等式看似复杂其实很好证明，即第46位其实代表的是2^45。 其除以2^46后是一个小数。依次类推…</p><p>因此对于数字 4512395720392704 ， 我们可以用4，45，451，4512 … 依次除以 2 ^ 46. 一直到找到数451239572039270 其除以2^46不为0。这个不为0的数一定为6。<br>接着我们保留后46位，其实是保留了小数位。</p><p>假设 4512395720392704 / 2^46  = (6 + num)<br>64.125 =(6 + num) * 10 + C = 60 + 10* num + C</p><p>当我们将通过位运算保留后46位，设为A, 则 A / 2^46 = num<br>所以 (A * 10 + C) / 2 ^46 =(num * 10 +C) = 4.125<br>因此此我们又可以把4提取出来，实在精彩。<br>10进制小数位的提取是一样的，留给读者自己探索。<br>这样，就可以快速的把对应的10进制数的每一位都找出来…</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>1、本文介绍了go语言使用的IEEE-754标准存储浮点数的具体存储方式。<br>2、本文通过实际代码片段和一个脑筋急转弯帮助读者理解浮点数的存储方式。<br>3、本文介绍了normal number 以及精度这两个重要概念。<br>4、本文详细介绍了shopspring/decimal的实现方式，即借助了big.int，以及进制的巧妙精准转换。<br>5、shopspring/decimal其实在精度的巧妙转换方面参考了go源码ftoa函数的实现。 读者可以参考go源码<br>6、shopspring/decimal目前roundShortest函数有一个bug，笔者已经提交了pr，此bug已在go源码中得到了修复。<br>7、big.int计算存在效率问题，如果遇到特殊的快速大量计算的场景可能不太适合。<br>8、还有一些decimal的实现，例如tibd/decimal,代码实在不忍淬读。<br>9、浮点数计算，除了要解决进制的转换外，还需要解决重要的溢出问题，例如相乘常常要超过int64的范围，这就是为什么shopspring/decimal使用了big.int,而tibd/decimal将数据转换为了很多的word（int32），导致其计算非常复杂。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://dreamerjonson.com/2019/12/11/golang-106-IEE754-float/">深入浮点数</a><br>我将此文章放在了github上：<a href="https://github.com/dreamerjackson/theWayToGolang/blob/master/3-agrs/8_IEEE754%20Float%20introduce.md" target="_blank" rel="noopener">github地址</a><br><a href="https://www.exploringbinary.com/why-0-point-1-does-not-exist-in-floating-point/" target="_blank" rel="noopener">Why 0.1 Does Not Exist In Floating-Point</a></p><p><a href="https://en.wikipedia.org/wiki/Normal_number" target="_blank" rel="noopener">Normal number</a></p><p><a href="https://www.exploringbinary.com/7-bits-are-not-enough-for-2-digit-accuracy/" target="_blank" rel="noopener">7-bits-are-not-enough-for-2-digit-accuracy</a></p><p><a href="https://www.exploringbinary.com/decimal-precision-of-binary-floating-point-numbers/" target="_blank" rel="noopener">Decimal Precision of Binary Floating-Point Numbers</a></p><p><a href="https://www.ardanlabs.com/blog/2014/04/introduction-to-numeric-constants-in-go.html" target="_blank" rel="noopener">Introduction To Numeric Constants In Go</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#引言&quot;&gt;&lt;/a&gt; 引言&lt;/h2&gt;
&lt;p&gt;下面的一段简单程序 0.3 + 0.6 结果是什么？&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[105]-stack-trace</title>
    <link href="https://dreamerjonson.com/2019/12/05/golang-105-stack-trace/"/>
    <id>https://dreamerjonson.com/2019/12/05/golang-105-stack-trace/</id>
    <published>2019-12-05T14:10:18.000Z</published>
    <updated>2019-12-11T07:35:58.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p>Having some basic skills in debugging Go programs can save any programmer a good amount of time trying to identify problems. I believe in logging as much information as you can, but sometimes a panic occurs and what you logged is not enough. Understanding the information in a stack trace can sometimes mean the difference between finding the bug now or needing to add more logging and waiting for it to happen again</p><p>I have been seeing stack traces since I started writing Go. At some point we all do something silly that causes the runtime to kill our program and throw a stack trace. I am going to show you the information the stack trace provides, including how to identify the value for each parameter that was passed into each function.</p><p>Functions<br>Let’s start with a small piece of code that will produce a stack trace:</p><h2 id="listing-1"><a class="markdownIt-Anchor" href="#listing-1"></a> Listing 1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">    slice := make([]string, 2, 4)</span><br><span class="line">    Example(slice, “hello”, 10)</span><br><span class="line">&#125;</span><br><span class="line">func Example(slice []string, str string, i int) &#123;</span><br><span class="line">    panic(“Want stack trace”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 1 shows a program where the main function calls the Example function on line 05. The Example function is declared on line 08 and accepts three parameters, a slice of strings, a string and an integer. The only code Example executes is a call to the built-in function panic on line 09, which immediately produces a stack trace:</p><h2 id="listing-2"><a class="markdownIt-Anchor" href="#listing-2"></a> Listing 2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Panic: Want stack trace</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:9 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:5 +0x85</span><br><span class="line"></span><br><span class="line">goroutine 2 [runnable]:</span><br><span class="line">runtime.forcegchelper()</span><br><span class="line">        /Users/bill/go/src/runtime/proc.go:90</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1</span><br><span class="line"></span><br><span class="line">goroutine 3 [runnable]:</span><br><span class="line">runtime.bgsweep()</span><br><span class="line">        /Users/bill/go/src/runtime/mgc0.go:82</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /Users/bill/go/src/runtime/asm_amd64.s:2232 +0x1</span><br></pre></td></tr></table></figure><p>The stack trace in listing 2 shows all the goroutines that existed at the time of the panic, the status of each routine and the call stack under that respective goroutine. The goroutines that were running and the one that caused the stack trace will be at the top. Let’s focus on the goroutine that panicked.</p><h2 id="list3"><a class="markdownIt-Anchor" href="#list3"></a> list3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goroutine 1 [running]:</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:9 +0x64</span><br><span class="line">main.main()</span><br><span class="line">        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">        temp/main.go:5 +0x85</span><br></pre></td></tr></table></figure><p>The stack trace on line 01 in listing 3 is showing that goroutine 1 was running prior to the panic. On line 02, we see that the code that panicked was in the Example function in package main. The line indented shows the code file and path this function is located in, plus the line of code that was executing. In this case, the code on line 09 was running which is the call to panic.</p><p>Line 03 shows the name of the function that called Example. This is the main function in the main package. Underneath the function name once again, the line that is indented shows the code file, path and line of code where the call to Example was made.</p><p>The stack trace is showing the chain of function calls in the scope of that goroutine up to the time the panic occurred. Now, let’s focus on the values for each parameter that was passed into the Example function:</p><h2 id="listing-4"><a class="markdownIt-Anchor" href="#listing-4"></a> Listing 4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Declaration</span><br><span class="line">main.Example(slice []string, str string, i int)</span><br><span class="line"></span><br><span class="line">// Call to Example by main.</span><br><span class="line">slice := make([]string, 2, 4)</span><br><span class="line">Example(slice, &quot;hello&quot;, 10)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br></pre></td></tr></table></figure><p>Listing 4 shows the values from the stack trace that were passed into the Example function when the call was made by main and the declaration of the function. When you compare the values from the stack trace with the function declaration, it doesn’t seem to match up. The declaration of the Example function accepts three parameters but the stack trace is showing six hexadecimal values. The key to understanding how the values do match up with the parameters requires knowing the implementation for each parameter type.</p><p>Let’s start with the first parameter which is a slice of strings. A slice is a reference type in Go. This means the value for a slice is a header value with a pointer to some underlying data. In the case of a slice, the header value is a three word structure that contains a pointer to an underlying array, the length of the slice and the capacity. The values associated with the slice header are represented by the first three values in the stack trace:</p><h2 id="listing-5"><a class="markdownIt-Anchor" href="#listing-5"></a> Listing 5</h2><p>// Slice parameter value<br>slice := make([]string, 2, 4)</p><p>// Slice header values<br>Pointer:  0x2080c3f50<br>Length:   0x2<br>Capacity: 0x4</p><p>// Declaration<br>main.Example(slice []string, str string, i int)</p><p>// Stack trace<br>main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</p><p>Listing 5 shows how the first three values in the stack trace do match up with the slice parameter. The first value represents the pointer to the underlying array of strings. The length and capacity numbers used to initialize the slice match with the second and third values. Those three values represent each value of the slice header, the first parameter.</p><p>Now let’s look at the second parameter which is a string. A string is also a reference type but this header value is immutable. The header value for a string is declared as a two word structure that contains a pointer to an underlying byte array and the length of the string:</p><h2 id="listing-6"><a class="markdownIt-Anchor" href="#listing-6"></a> Listing 6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// String parameter value</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">// String header values</span><br><span class="line">Pointer: 0x425c0</span><br><span class="line">Length:  0x5</span><br><span class="line"></span><br><span class="line">// Declaration</span><br><span class="line">main.Example(slice []string, str string, i int)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br></pre></td></tr></table></figure><p>Listing 6 shows how the fourth and fifth values in the stack trace do match up with the string parameter. The fourth value represents the pointer to the underlying array of bytes and the fifth value is the length of the string which was 5. The string “hello” requires 5 bytes. Those two values represent each value of the string header, the second parameter.</p><p>The third parameter is an integer which is a single word value:</p><h2 id="listing-7"><a class="markdownIt-Anchor" href="#listing-7"></a> Listing 7</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Integer parameter value</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">// Integer value</span><br><span class="line">Base 16: 0xa</span><br><span class="line"></span><br><span class="line">// Declaration</span><br><span class="line">main.Example(slice []string, str string, i int)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa)</span><br></pre></td></tr></table></figure><p>Listing 7 shows how the last value in the stack trace matches up with the integer parameter. The very last value in the trace is hexadecimal number 0xa, which is the value of 10. The same value that was passed in for that parameter. That value represents the third parameter.<br>Methods<br>Let’s change the program so the Example function is now a method:</p><h2 id="listing-8"><a class="markdownIt-Anchor" href="#listing-8"></a> Listing 8</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type trace struct&#123;&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">slice := make([]string, 2, 4)</span><br><span class="line">var t trace</span><br><span class="line">t.Example(slice, &quot;hello&quot;, 10)</span><br><span class="line">&#125;</span><br><span class="line">func (t *trace) Example(slice []string, str string, i int) &#123;</span><br><span class="line">fmt.Printf(&quot;Receiver Address: %p\n&quot;, t)</span><br><span class="line">panic(&quot;Want stack trace&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 8 changes the original program by declaring a new type named trace on line 05 and converting the Example function into a method on line 14. The conversion is accomplished by re-declaring the function with a pointer receiver of type trace. Then on line 10, a variable named t is declared of type trace and the method call is made with the variable on line 11.</p><p>Since the method is declared with a pointer receiver, Go will take the address of the t variable to support the receiver type, even though the method call is made with a value. This time when the program is run, the stack trace is a little different:</p><h2 id="listing-9"><a class="markdownIt-Anchor" href="#listing-9"></a> Listing 9</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Receiver Address: 0x1553a8</span><br><span class="line">panic: Want stack trace</span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.(*trace).Example(0x1553a8, 0x2081b7f50, 0x2, 0x4, 0xdc1d0, 0x5, 0xa)</span><br><span class="line">           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">           temp/main.go:16 +0x116</span><br><span class="line">main.main()</span><br><span class="line">           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">           temp/main.go:11 +0xae</span><br></pre></td></tr></table></figure><p>The first thing you should notice in listing 9 is that the stack trace on line 02 is making it clear this was a method call using a pointer receiver. The name of the function is now displayed with (*trace) between the package name and the method name. The second thing to notice is how the value list now shows the value of the receiver first. Method calls are really function calls with the first parameter being the receiver value. We are seeing this implementation detail in action from the stack trace.</p><p>Since nothing else changed with the declaration or call to the Example method, all the other values remain the same. The line numbers where the call to Example is made and where the panic occurred changed and reflects the new code.</p><p>Packing<br>When you have multiple parameters that fit inside of a single word, then the values for the parameters in the stack trace will be packed together:</p><h2 id="listing-10"><a class="markdownIt-Anchor" href="#listing-10"></a> Listing 10</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">Example(true, false, true, 25)</span><br><span class="line">&#125;</span><br><span class="line">func Example(b1, b2, b3 bool, i uint8) &#123;</span><br><span class="line">panic(&quot;Want stack trace&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Listing 10 shows a new sample program that changes the Example function to accept four parameters. The first three are booleans and the last one is an eight bit unsigned integer. A boolean value is also an eight bit value, so all four parameters fit inside of a single word on both 32 and 64 bit architectures. When the program runs, it produces an interesting stack trace:</p><h2 id="listing-11"><a class="markdownIt-Anchor" href="#listing-11"></a> Listing 11</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goroutine 1 [running]:</span><br><span class="line">main.Example(0x19010001)</span><br><span class="line">          /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">          temp/main.go:8 +0x64</span><br><span class="line">main.main()</span><br><span class="line">          /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/</span><br><span class="line">          temp/main.go:4 +0x32</span><br></pre></td></tr></table></figure><p>Instead of there being four values in the stack trace for the call to Example, there is a single value. All four individual 8 bit values were packed together into a single word:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Parameter values</span><br><span class="line">true, false, true, 25</span><br><span class="line"></span><br><span class="line">// Word value</span><br><span class="line">Bits    Binary      Hex   Value</span><br><span class="line">00-07   0000 0001   01    true</span><br><span class="line">08-15   0000 0000   00    false</span><br><span class="line">16-23   0000 0001   01    true</span><br><span class="line">24-31   0001 1001   19    25</span><br><span class="line"></span><br><span class="line">// Declaration</span><br><span class="line">main.Example(b1, b2, b3 bool, i uint8)</span><br><span class="line"></span><br><span class="line">// Stack trace</span><br><span class="line">main.Example(0x19010001)</span><br></pre></td></tr></table></figure><p>Listing 12 shows how the value in the stack trace matches up with all four parameter values that were passed in. The value of true is an 8 bit value that is represented with the value of 1 and the value of false is represented with the value of 0. The value of 25 in binary is 11001 which converts to 19 in hexadecimal. Now when we look at the hexadecimal value represented in the stack trace, we see how it does represent the values that were passed in.</p><h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2><p>The Go runtime provides a great deal of information to help us debug our programs. In this post we concentrated on stack traces. The ability to decode the values that were passed into each function throughout the call stack is huge. It has helped me more than once to identify my bug very quickly. Now that you know how to read stack traces, hopefully you can leverage this knowledge the next time a stack trace happens to you.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#introduction&quot;&gt;&lt;/a&gt; Introduction&lt;/h2&gt;
&lt;p&gt;Having some basic skills in debugging Go p
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[104]-go语言渐入佳境-网络[16]-获取本机地址</title>
    <link href="https://dreamerjonson.com/2019/12/04/golang-104-go%E8%AF%AD%E8%A8%80%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83-%E7%BD%91%E7%BB%9C-16-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%9C%B0%E5%9D%80/"/>
    <id>https://dreamerjonson.com/2019/12/04/golang-104-go语言渐入佳境-网络-16-获取本机地址/</id>
    <published>2019-12-04T06:15:17.000Z</published>
    <updated>2019-12-04T06:26:43.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是外网ip和内网ip"><a class="markdownIt-Anchor" href="#什么是外网ip和内网ip"></a> 什么是外网IP和内网IP?</h2><p>tcp/ip协议中，专门保留了三个IP地址区域作为私有地址，其地址范围如下：<br>10.0.0.0/8：10.0.0.0～10.255.255.255<br>172.16.0.0/12：172.16.0.0～172.31.255.255<br>192.168.0.0/16：192.168.0.0～192.168.255.255</p><p>什么是内网IP</p><p>一些小型企业或者学校，通常都是申请一个固定的IP地址，然后通过IP共享（IP Sharing），使用整个公司或学校的机器都能够访问互联网。而这些企业或学校的机器使用的IP地址就是内网IP，内网IP是在规划IPv4协议时，考虑到IP地址资源可能不足，就专门为内部网设计私有IP地址（或称之为保留地址），一般常用内网IP地址都是这种形式的：10.X.X.X、172.16.X.X-172.31.X.X、192.168.X.X等。需要注意的是，内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他的计算机无法向内网的计算机发送连接请求。我们平时可能在内网机器上搭建过网站或者FTP服务器，而在外网是不能访问该网站和FTP服务器的，原因就在于此。</p><p>什么是公网IP</p><p>公网IP就是除了保留IP地址以外的IP地址，可以与Internet上的其他计算机随意互相访问。我们通常所说的IP地址，其实就是指的公网IP。互联网上的每台计算机都有一个独立的IP地址，该IP地址唯一确定互联网上的一台计算机。这里的IP地址就是指的公网IP地址。</p><p>怎样理解互联网上的每台计算机都有一个唯一的IP地址</p><p>其实，互联网上的计算机是通过“公网IP＋内网IP”来唯一确定的，就像很多大楼都是201房间一样，房间号可能一样，但是大楼肯定是唯一的。公网IP地址和内网IP地址也是同样，不同企业或学校的机器可能有相同的内网IP地址，但是他们的公网IP地址肯定不同。那么这些企业或学校的计算机是怎样IP地址共享的呢？这就需要使用NAT（Network Address Translation,网络地址转换）功能。当内部计算机要连接互联网时，首先需要通过NAT技术，将内部计算机数据包中有关IP地址的设置都设成NAT主机的公共IP地址，然后再传送到Internet，虽然内部计算机使用的是私有IP地址，但在连接Internet时，就可以通过NAT主机的NAT技术，将内网我IP地址修改为公网IP地址，如此一来，内网计算机就可以向Internet请求数据了。<br>————————————————</p><h2 id="what-is-a-network-interface"><a class="markdownIt-Anchor" href="#what-is-a-network-interface"></a> What Is a Network Interface?</h2><p>A network interface is the point of interconnection between a computer and a private or public network. A network interface is generally a network interface card (NIC), but does not have to have a physical form. Instead, the network interface can be implemented in software. For example, the loopback interface (127.0.0.1 for IPv4 and ::1 for IPv6) is not a physical device but a piece of software simulating a network interface. The loopback interface is commonly used in test environments.</p><h2 id="获取本地ip"><a class="markdownIt-Anchor" href="#获取本地ip"></a> 获取本地ip</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ip, err := externalIP()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ip)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">externalIP</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// get all interface.</span></span><br><span class="line">    ifaces, err := net.Interfaces()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, iface := <span class="keyword">range</span> ifaces &#123;</span><br><span class="line"><span class="keyword">if</span> iface.Flags&amp;net.FlagUp == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// interface down</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> iface.Flags&amp;net.FlagLoopback != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// loopback interface</span></span><br><span class="line">&#125;</span><br><span class="line">addrs, err := iface.Addrs()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> addrs &#123;</span><br><span class="line"><span class="keyword">var</span> ip net.IP</span><br><span class="line"><span class="keyword">switch</span> v := addr.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *net.IPNet:</span><br><span class="line">ip = v.IP</span><br><span class="line"><span class="keyword">case</span> *net.IPAddr:</span><br><span class="line">ip = v.IP</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ip == <span class="literal">nil</span> || ip.IsLoopback() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ip = ip.To4()</span><br><span class="line"><span class="keyword">if</span> ip == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// not an ipv4 address</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">" ip.String()"</span>, ip.String())</span><br><span class="line"><span class="comment">// return ip.String(), nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"are you connected to the network?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取外网ip"><a class="markdownIt-Anchor" href="#获取外网ip"></a> 获取外网ip</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get_external</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">resp, err := http.Get(<span class="string">"http://myexternalip.com/raw"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">content, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">buf.ReadFrom(resp.Body)</span><br><span class="line"><span class="comment">//s := buf.String()</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10进制与ip相互转换"><a class="markdownIt-Anchor" href="#10进制与ip相互转换"></a> 10进制与ip相互转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func inet_ntoa(ipnr int64) net.IP &#123;</span><br><span class="line">var bytes [4]byte</span><br><span class="line">bytes[0] = byte(ipnr &amp; 0xFF)</span><br><span class="line">bytes[1] = byte((ipnr &gt;&gt; 8) &amp; 0xFF)</span><br><span class="line">bytes[2] = byte((ipnr &gt;&gt; 16) &amp; 0xFF)</span><br><span class="line">bytes[3] = byte((ipnr &gt;&gt; 24) &amp; 0xFF)</span><br><span class="line"></span><br><span class="line">return net.IPv4(bytes[3], bytes[2], bytes[1], bytes[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func inet_aton(ipnr net.IP) int64 &#123;</span><br><span class="line">bits := strings.Split(ipnr.String(), &quot;.&quot;)</span><br><span class="line"></span><br><span class="line">b0, _ := strconv.Atoi(bits[0])</span><br><span class="line">b1, _ := strconv.Atoi(bits[1])</span><br><span class="line">b2, _ := strconv.Atoi(bits[2])</span><br><span class="line">b3, _ := strconv.Atoi(bits[3])</span><br><span class="line"></span><br><span class="line">var sum int64</span><br><span class="line"></span><br><span class="line">sum += int64(b0) &lt;&lt; 24</span><br><span class="line">sum += int64(b1) &lt;&lt; 16</span><br><span class="line">sum += int64(b2) &lt;&lt; 8</span><br><span class="line">sum += int64(b3)</span><br><span class="line"></span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否公网ip"><a class="markdownIt-Anchor" href="#判断是否公网ip"></a> 判断是否公网ip</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func IsPublicIP(IP net.IP) bool &#123;</span><br><span class="line">if IP.IsLoopback() || IP.IsLinkLocalMulticast() || IP.IsLinkLocalUnicast() &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">if ip4 := IP.To4(); ip4 != nil &#123;</span><br><span class="line">switch true &#123;</span><br><span class="line">case ip4[0] == 10:</span><br><span class="line">return false</span><br><span class="line">case ip4[0] == 172 &amp;&amp; ip4[1] &gt;= 16 &amp;&amp; ip4[1] &lt;= 31:</span><br><span class="line">return false</span><br><span class="line">case ip4[0] == 192 &amp;&amp; ip4[1] == 168:</span><br><span class="line">return false</span><br><span class="line">default:</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ip在区间内"><a class="markdownIt-Anchor" href="#ip在区间内"></a> ip在区间内</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IpBetween</span><span class="params">(from net.IP, to net.IP, test net.IP)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> from == <span class="literal">nil</span> || to == <span class="literal">nil</span> || test == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"An ip input is nil"</span>) <span class="comment">// or return an error!?</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from16 := from.To16()</span><br><span class="line">to16 := to.To16()</span><br><span class="line">test16 := test.To16()</span><br><span class="line"><span class="keyword">if</span> from16 == <span class="literal">nil</span> || to16 == <span class="literal">nil</span> || test16 == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"An ip did not convert to a 16 byte"</span>) <span class="comment">// or return an error!?</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bytes.Compare(test16, from16) &gt;= <span class="number">0</span> &amp;&amp; bytes.Compare(test16, to16) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是外网ip和内网ip&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是外网ip和内网ip&quot;&gt;&lt;/a&gt; 什么是外网IP和内网IP?&lt;/h2&gt;
&lt;p&gt;tcp/ip协议中，专门保留了三个IP地址区域作为私有地址，其地址范围如下：&lt;br
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[103]-ldflags技巧</title>
    <link href="https://dreamerjonson.com/2019/12/03/golang-103-ldflags%E6%8A%80%E5%B7%A7/"/>
    <id>https://dreamerjonson.com/2019/12/03/golang-103-ldflags技巧/</id>
    <published>2019-12-03T08:27:35.000Z</published>
    <updated>2019-12-03T12:47:15.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="x"><a class="markdownIt-Anchor" href="#x"></a> +X</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ServerBaseURL <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(ServerBaseURL)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中-w为去掉调试信息（无法使用gdb调试），-s为去掉符号表（暂未清楚具体作用）。<br>go build --ldflags “-s -w  -X main.ServerBaseURL=http://localhost:8080 -X main.UseTor=” -o test main.go<br>./test:<br>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br></pre></td></tr></table></figure><h2 id="打印日期"><a class="markdownIt-Anchor" href="#打印日期"></a> 打印日期</h2><p>go build --ldflags “-s -w  -X ‘main.ServerBaseURL=<code>date</code>’” -o test6 main.go</p><p>output：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tue Dec  3 16:37:08 CST 2019</span><br></pre></td></tr></table></figure><h2 id="打印go语言版本"><a class="markdownIt-Anchor" href="#打印go语言版本"></a> 打印go语言版本</h2><p>go build --ldflags “-s -w  -X ‘main.ServerBaseURL=$(go version)’” -o test7 main.go<br>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.12.9 darwin/amd64</span><br></pre></td></tr></table></figure><h2 id="link"><a class="markdownIt-Anchor" href="#link"></a> link</h2><p><a href="https://github.com/golang/go/wiki/GcToolchainTricks" target="_blank" rel="noopener">https://github.com/golang/go/wiki/GcToolchainTricks</a><br><a href="https://ms2008.github.io/2018/10/08/golang-build-version/" target="_blank" rel="noopener">https://ms2008.github.io/2018/10/08/golang-build-version/</a></p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>可以使用 go tool link --help 查看 ldflags 各参数含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">-B note</span><br><span class="line">      add an ELF NT_GNU_BUILD_ID note when using ELF</span><br><span class="line">-D address</span><br><span class="line">      set data segment address (default -1)</span><br><span class="line">-E entry</span><br><span class="line">      set entry symbol name</span><br><span class="line">-H type</span><br><span class="line">      set header type</span><br><span class="line">-I linker</span><br><span class="line">      use linker as ELF dynamic linker</span><br><span class="line">-L directory</span><br><span class="line">      add specified directory to library path</span><br><span class="line">-R quantum</span><br><span class="line">      set address rounding quantum (default -1)</span><br><span class="line">-T address</span><br><span class="line">      set text segment address (default -1)</span><br><span class="line">-V    print version and exit</span><br><span class="line">-X definition</span><br><span class="line">      add string value definition of the form importpath.name=value</span><br><span class="line">-a    disassemble output</span><br><span class="line">-buildid id</span><br><span class="line">      record id as Go toolchain build id</span><br><span class="line">-buildmode mode</span><br><span class="line">      set build mode</span><br><span class="line">-c    dump call graph</span><br><span class="line">-compressdwarf</span><br><span class="line">      compress DWARF if possible (default true)</span><br><span class="line">-cpuprofile file</span><br><span class="line">      write cpu profile to file</span><br><span class="line">-d    disable dynamic executable</span><br><span class="line">-debugtramp int</span><br><span class="line">      debug trampolines</span><br><span class="line">-dumpdep</span><br><span class="line">      dump symbol dependency graph</span><br><span class="line">-extar string</span><br><span class="line">      archive program for buildmode=c-archive</span><br><span class="line">-extld linker</span><br><span class="line">      use linker when linking in external mode</span><br><span class="line">-extldflags flags</span><br><span class="line">      pass flags to external linker</span><br><span class="line">-f    ignore version mismatch</span><br><span class="line">-g    disable go package data checks</span><br><span class="line">-h    halt on error</span><br><span class="line">-importcfg file</span><br><span class="line">      read import configuration from file</span><br><span class="line">-installsuffix suffix</span><br><span class="line">      set package directory suffix</span><br><span class="line">-k symbol</span><br><span class="line">      set field tracking symbol</span><br><span class="line">-libgcc string</span><br><span class="line">      compiler support lib for internal linking; use &quot;none&quot; to disable</span><br><span class="line">-linkmode mode</span><br><span class="line">      set link mode</span><br><span class="line">-linkshared</span><br><span class="line">      link against installed Go shared libraries</span><br><span class="line">-memprofile file</span><br><span class="line">      write memory profile to file</span><br><span class="line">-memprofilerate rate</span><br><span class="line">      set runtime.MemProfileRate to rate</span><br><span class="line">-msan</span><br><span class="line">      enable MSan interface</span><br><span class="line">-n    dump symbol table</span><br><span class="line">-o file</span><br><span class="line">      write output to file</span><br><span class="line">-pluginpath string</span><br><span class="line">      full path name for plugin</span><br><span class="line">-r path</span><br><span class="line">      set the ELF dynamic linker search path to dir1:dir2:...</span><br><span class="line">-race</span><br><span class="line">      enable race detector</span><br><span class="line">-s    disable symbol table</span><br><span class="line">-tmpdir directory</span><br><span class="line">      use directory for temporary files</span><br><span class="line">-u    reject unsafe packages</span><br><span class="line">-v    print link trace</span><br><span class="line">-w    disable DWARF generation</span><br></pre></td></tr></table></figure><p>禁止gc优化和内联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &apos;-N -l&apos;</span><br></pre></td></tr></table></figure><p>说明:<br>-N 禁止编译优化<br>-l 禁止内联,禁止内联也可以一定程度上减小可执行程序大小<br>可以使用 go tool compile --help 查看 gcflags 各参数含义</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;x&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#x&quot;&gt;&lt;/a&gt; +X&lt;/h2&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[102]-assembly-汇编教程</title>
    <link href="https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/"/>
    <id>https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/</id>
    <published>2019-11-30T05:15:47.000Z</published>
    <updated>2019-12-04T10:43:49.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduce"><a class="markdownIt-Anchor" href="#introduce"></a> introduce</h2><p>golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编主要了解各种寄存器的使用跟寻址方式。根据汇编我们能够一探golang的底层实现。比如内存如何分配，栈如何扩张。接口如何转变。</p><h2 id="register"><a class="markdownIt-Anchor" href="#register"></a> register</h2><p>各种伪计数器:</p><ul><li>FP: Frame pointer: arguments and locals.(指向当前栈帧)</li><li>PC: Program counter: jumps and branches.(指向指令地址)</li><li>SB: Static base pointer: global symbols.(指向全局符号表)</li><li>SP: Stack pointer: top of stack.(指向当前栈顶部)</li><li>注意: 栈是向下整长 golang的汇编是调用者维护参数返回值跟返回地址。所以FP的值小于参数跟返回值。</li></ul><h2 id="analysis-for-add"><a class="markdownIt-Anchor" href="#analysis-for-add"></a> analysis for add</h2><p>think about this simple program:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="params">(<span class="keyword">int32</span>, <span class="keyword">bool</span>)</span></span> &#123; <span class="keyword">return</span> a + b, <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; add(<span class="number">10</span>, <span class="number">32</span>) &#125;</span><br></pre></td></tr></table></figure><p>generate assemly  code in linux:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go tool compile -S main.go</span><br></pre></td></tr></table></figure><p>this is the logic of add function</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 0x0000: Offset of the current instruction, relative to the start of the function.</span><br><span class="line">// TEXT &quot;&quot;.add: The TEXT directive declares the &quot;&quot;.add symbol as part of the .text section (i.e. runnable code) and indicates that the instructions that follow are the body of the function.</span><br><span class="line">// The empty string &quot;&quot; will be replaced by the name of the current package at link-time: i.e., &quot;&quot;.add will become main.add once linked into our final binary.</span><br><span class="line">// (SB): SB is the virtual register that holds the &quot;static-base&quot; pointer, i.e. the address of the beginning of the address-space of our program.</span><br><span class="line">// &quot;&quot;.add(SB) declares that our symbol is located at some constant offset (computed by the linker) from the start of our address-space. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// NOSPLIT: Indicates to the compiler that it should not insert the stack-split preamble, which checks whether the current stack needs to be grown.</span><br><span class="line">// In the case of our add function, the compiler has set the flag by itself: it is smart enough to figure that, since add has no local variables and no stack-frame of its own, it simply cannot outgrow the current stack; thus it&apos;d be a complete waste of CPU cycles to run these checks at each call site.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// $0-16: $0 denotes the size in bytes of the stack-frame that will be allocated; while $16 specifies the size of the arguments passed in by the caller.</span><br><span class="line">// In the general case, the frame size is followed by an argument size, separated by a minus sign. (It&apos;s not a subtraction, just idiosyncratic syntax.)</span><br><span class="line">// The frame size $24-8 states that the function has a 24-byte frame and is called with 8 bytes of argument, which live on the caller&apos;s frame.</span><br><span class="line">// If NOSPLIT is not specified for the TEXT, the argument size must be provided. For assembly functions with Go prototypes, go vet will check that the argument size is correct.</span><br><span class="line"></span><br><span class="line">0x0000 00000 (main.go:4)TEXT&quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-16</span><br><span class="line"></span><br><span class="line">//for GOLANG GC</span><br><span class="line">0x0000 00000 (main.go:4)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 00000 (main.go:4)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 00000 (main.go:4)FUNCDATA$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">  0x0000 00000 (main.go:4)PCDATA$2, $0</span><br><span class="line">  0x0000 00000 (main.go:4)PCDATA$0, $0</span><br><span class="line">  </span><br><span class="line">//   The Go calling convention mandates that every argument must be passed on the stack, using the pre-reserved space on the caller&apos;s stack-frame.</span><br><span class="line">//   It is the caller&apos;s responsibility to grow (and shrink back) the stack appropriately so that arguments can be passed to the callee, and potential return-values passed back to the caller.</span><br><span class="line">//   The Go compiler never generates instructions from the PUSH/POP family: the stack is grown or shrunk by respectively decrementing or incrementing the virtual hardware stack pointer SP.</span><br><span class="line">//   The SP pseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls.</span><br><span class="line">//   It points to the top of the local stack frame, so references should use negative offsets in the range [−framesize, 0): x-8(SP), y-4(SP), and so on.</span><br><span class="line"></span><br><span class="line">// &quot;&quot;.b+12(SP) and &quot;&quot;.a+8(SP) respectively refer to the addresses 12 bytes and 8 bytes below the top of the stack (remember: it grows downwards!).</span><br><span class="line">// .a and .b are arbitrary aliases given to the referred locations; although they have absolutely no semantic meaning whatsoever, they are mandatory when using relative addressing on virtual registers. The documentation about the virtual frame-pointer has some to say about this:</span><br><span class="line"></span><br><span class="line">// The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset —offset from the frame pointer— distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument&apos;s name.</span><br><span class="line"></span><br><span class="line">//  The first argument a is not located at 0(SP), but rather at 8(SP); that&apos;s because the caller stores its return-address in 0(SP) via the CALL pseudo-instruction.</span><br><span class="line">// Arguments are passed in reverse-order; i.e. the first argument is the closest to the top of the stack.</span><br><span class="line"></span><br><span class="line">0x0000 00000 (main.go:4)MOVL&quot;&quot;.b+12(SP), AX</span><br><span class="line">0x0004 00004 (main.go:4)MOVL&quot;&quot;.a+8(SP), CX</span><br><span class="line"></span><br><span class="line">// ADDL does the actual addition of the two Long-words (i.e. 4-byte values) stored in AX and CX, then stores the final result in AX.</span><br><span class="line">0x0008 00008 (main.go:4)ADDLCX, AX</span><br><span class="line">// That result is then moved over to &quot;&quot;.~r2+16(SP), where the caller had previously reserved some stack space and expects to find its return values. Once again, &quot;&quot;.~r2 has no semantic meaning here.</span><br><span class="line">0x000a 00010 (main.go:4)MOVLAX, &quot;&quot;.~r2+16(SP)</span><br><span class="line">0x000e 00014 (main.go:4)MOVB$1, &quot;&quot;.~r3+20(SP)</span><br><span class="line">// A final RET pseudo-instruction tells the Go assembler to insert whatever instructions are required by the calling convention of the target platform in order to properly return from a subroutine call.</span><br><span class="line">// Most likely this will cause the code to pop off the return-address stored at 0(SP) then jump back to it.</span><br><span class="line">0x0013 00019 (main.go:4)RET</span><br></pre></td></tr></table></figure><p>look at more concise version：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;; Declare global function symbol &quot;&quot;.add (actually main.add once linked)</span><br><span class="line">;; Do not insert stack-split preamble</span><br><span class="line">;; 0 bytes of stack-frame, 16 bytes of arguments passed in</span><br><span class="line">;; func add(a, b int32) (int32, bool)</span><br><span class="line">0x0000 TEXT&quot;&quot;.add(SB), NOSPLIT, $0-16</span><br><span class="line">  ;; ...omitted FUNCDATA stuff...</span><br><span class="line">  0x0000 MOVL&quot;&quot;.b+12(SP), AX    ;; move second Long-word (4B) argument from caller&apos;s stack-frame into AX</span><br><span class="line">  0x0004 MOVL&quot;&quot;.a+8(SP), CX    ;; move first Long-word (4B) argument from caller&apos;s stack-frame into CX</span><br><span class="line">  0x0008 ADDLCX, AX    ;; compute AX=CX+AX</span><br><span class="line">  0x000a MOVLAX, &quot;&quot;.~r2+16(SP)   ;; move addition result (AX) into caller&apos;s stack-frame</span><br><span class="line">  0x000e MOVB$1, &quot;&quot;.~r3+20(SP)   ;; move `true` boolean (constant) into caller&apos;s stack-frame</span><br><span class="line">  0x0013 RET    ;; jump to return address stored at 0(SP)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   |    +-------------------------+ &lt;-- 32(SP)              </span><br><span class="line">   |    |                         |                         </span><br><span class="line"> G |    |                         |                         </span><br><span class="line"> R |    |                         |                         </span><br><span class="line"> O |    | main.main&apos;s saved       |                         </span><br><span class="line"> W |    |     frame-pointer (BP)  |                         </span><br><span class="line"> S |    |-------------------------| &lt;-- 24(SP)              </span><br><span class="line">   |    |      [alignment]        |                         </span><br><span class="line"> D |    | &quot;&quot;.~r3 (bool) = 1/true  | &lt;-- 21(SP)              </span><br><span class="line"> O |    |-------------------------| &lt;-- 20(SP)              </span><br><span class="line"> W |    |                         |                         </span><br><span class="line"> N |    | &quot;&quot;.~r2 (int32) = 42     |                         </span><br><span class="line"> W |    |-------------------------| &lt;-- 16(SP)              </span><br><span class="line"> A |    |                         |                         </span><br><span class="line"> R |    | &quot;&quot;.b (int32) = 32       |                         </span><br><span class="line"> D |    |-------------------------| &lt;-- 12(SP)              </span><br><span class="line"> S |    |                         |                         </span><br><span class="line">   |    | &quot;&quot;.a (int32) = 10       |                         </span><br><span class="line">   |    |-------------------------| &lt;-- 8(SP)               </span><br><span class="line">   |    |                         |                         </span><br><span class="line">   |    |                         |                         </span><br><span class="line">   |    |                         |                         </span><br><span class="line"> \ | /  | return address to       |                         </span><br><span class="line">  \|/   |     main.main + 0x30    |                         </span><br><span class="line">   -    +-------------------------+ &lt;-- 0(SP) (TOP OF STACK)</span><br><span class="line"></span><br><span class="line">(diagram made with https://textik.com)</span><br></pre></td></tr></table></figure><h2 id="analysis-for-main"><a class="markdownIt-Anchor" href="#analysis-for-main"></a> analysis for main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    // &quot;&quot;.main (main.main once linked) is a global function symbol in the .text section, whose address is some constant offset from the beginning of our address-space.</span><br><span class="line">// It allocates a 24 bytes stack-frame and doesn&apos;t receive any argument nor does it return any value</span><br><span class="line"></span><br><span class="line">    // As we mentioned above, the Go calling convention mandates that every argument must be passed on the stack.</span><br><span class="line"></span><br><span class="line">// Our caller, main, grows its stack-frame by 24 bytes (remember that the stack grows downwards, so SUBQ here actually makes the stack-frame bigger) by decrementing the virtual stack-pointer. Of those 24 bytes:</span><br><span class="line"></span><br><span class="line">// 8 bytes (16(SP)-24(SP)) are used to store the current value of the frame-pointer BP (the real one!) to allow for stack-unwinding and facilitate debugging</span><br><span class="line">// 1+3 bytes (12(SP)-16(SP)) are reserved for the second return value (bool) plus 3 bytes of necessary alignment on amd64</span><br><span class="line">// 4 bytes (8(SP)-12(SP)) are reserved for the first return value (int32)</span><br><span class="line">// 4 bytes (4(SP)-8(SP)) are reserved for the value of argument b (int32)</span><br><span class="line">// 4 bytes (0(SP)-4(SP)) are reserved for the value of argument a (int32).</span><br><span class="line">0x0000 00000 (main.go:6)TEXT&quot;&quot;.main(SB), ABIInternal, $24-0</span><br><span class="line">//   ;; stack-split prologue...</span><br><span class="line">    // The prologue checks whether the goroutine is running out of space and, if it&apos;s the case, jumps to the epilogue.</span><br><span class="line">    // TLS is a virtual register maintained by the runtime that holds a pointer to the current g, i.e. the data-structure that keeps track of all the state of a goroutine.</span><br><span class="line"> // Looking at the definition of g from the source code of the runtime:</span><br><span class="line"> //   type g struct &#123;</span><br><span class="line">//stack       stack   // 16 bytes</span><br><span class="line">// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span><br><span class="line">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span><br><span class="line">//stackguard0 uintptr</span><br><span class="line">//stackguard1 uintptr</span><br><span class="line"></span><br><span class="line">// ...omitted dozens of fields...</span><br><span class="line">//    &#125;</span><br><span class="line">    // We can see that 16(CX) corresponds to g.stackguard0, which is the threshold value maintained by the runtime that, when compared to the stack-pointer, indicates whether or not a goroutine is about to run out of space.</span><br><span class="line">// The prologue thus checks if the current SP value is less than or equal to the stackguard0 threshold (that is, it&apos;s bigger), then jumps to the epilogue if it happens to be the case.</span><br><span class="line">  </span><br><span class="line">0x0000 00000 (main.go:6)MOVQ(TLS), CX ;; store current *g in CX</span><br><span class="line">0x0009 00009 (main.go:6)CMPQSP, 16(CX) ;; compare SP and g.stackguard0</span><br><span class="line">0x000d 00013 (main.go:6)JLS58 ;; jumps to 0x3a if SP &lt;= g.stackguard0</span><br><span class="line">// 把栈减了24个字节。增大了栈空间。</span><br><span class="line">    0x000f 00015 (main.go:6)SUBQ$24, SP</span><br><span class="line">    // 保存老的bp设置新的bp。这里的bp是真实的寄存器</span><br><span class="line">0x0013 00019 (main.go:6)MOVQBP, 16(SP)</span><br><span class="line">0x0018 00024 (main.go:6)LEAQ16(SP), BP</span><br><span class="line">    //  ;; ... PCDATA stuff...</span><br><span class="line">0x001d 00029 (main.go:6)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)FUNCDATA$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)PCDATA$2, $0</span><br><span class="line">0x001d 00029 (main.go:6)PCDATA$0, $0</span><br><span class="line">//Finally, following the growth of the stack, LEAQ computes the new address of the frame-pointer and stores it in BP.</span><br><span class="line">    // The caller pushes the arguments for the callee as a Quad word (i.e. an 8-byte value) at the top of the stack that it has just grown.</span><br><span class="line">// Although it might look like random garbage at first, 137438953482 actually corresponds to the 10 and 32 4-byte values concatenated into one 8-byte value:</span><br><span class="line">    </span><br><span class="line">// $ echo &apos;obase=2;137438953482&apos; | bc</span><br><span class="line">//10000000000000000000000000000000001010</span><br><span class="line">// \____/\______________________________/</span><br><span class="line">//    32                              10</span><br><span class="line">    </span><br><span class="line">0x001d 00029 (main.go:6)MOVQ$137438953482, AX</span><br><span class="line">0x0027 00039 (main.go:6)MOVQAX, (SP)</span><br><span class="line">0x002b 00043 (main.go:6)CALL&quot;&quot;.add(SB)</span><br><span class="line">   // 恢复BP寄存器，缩减栈空间</span><br><span class="line">0x0030 00048 (main.go:6)MOVQ16(SP), BP</span><br><span class="line">0x0035 00053 (main.go:6)ADDQ$24, SP</span><br><span class="line">0x0039 00057 (main.go:6)RET</span><br><span class="line">  ;; ... stack-split epilogue...</span><br><span class="line">      // The epilogue, on the other hand, triggers the stack-growth machinery and then jumps back to the prologue.</span><br><span class="line">  // This creates a feedback loop that goes on for as long as a large enough stack hasn&apos;t been allocated for our starved goroutine.</span><br><span class="line"></span><br><span class="line">    // The body of the epilogue is pretty straightforward: it calls into the runtime, which will do the actual work of growing the stack, then jumps back to the first instruction of the function (i.e. to the prologue).</span><br><span class="line"></span><br><span class="line">// The NOP instruction just before the CALL exists so that the prologue doesn&apos;t jump directly onto a CALL instruction. On some platforms, doing so can lead to very dark places; it&apos;s a common pratice to set-up a noop instruction right before the actual call and land on this NOP instead.</span><br><span class="line"> 0x003a 00058 (main.go:6)NOP</span><br><span class="line">0x003a 00058 (main.go:6)PCDATA$0, $-1</span><br><span class="line">0x003a 00058 (main.go:6)PCDATA$2, $-1</span><br><span class="line">0x003a 00058 (main.go:6)CALLruntime.morestack_noctxt(SB)</span><br><span class="line">0x003f 00063 (main.go:6)JMP0</span><br></pre></td></tr></table></figure><h2 id="reciever-method"><a class="markdownIt-Anchor" href="#reciever-method"></a> reciever method</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; id int32 &#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder *Adder) AddPtr(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) AddVal(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">Add(10, 32) // direct call of top-level function</span><br><span class="line"></span><br><span class="line">adder := Adder&#123;id: 6754&#125;</span><br><span class="line">adder.AddPtr(10, 32) // direct call of method with pointer receiver</span><br><span class="line">adder.AddVal(10, 32) // direct call of method with value receiver</span><br><span class="line"></span><br><span class="line">(&amp;adder).AddVal(10, 32) // implicit dereferencing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (main.go:14)TEXT&quot;&quot;.main(SB), ABIInternal, $40-0</span><br><span class="line">0x0000 00000 (main.go:14)MOVQ(TLS), CX </span><br><span class="line">0x0009 00009 (main.go:14)CMPQSP, 16(CX)</span><br><span class="line">0x000d 00013 (main.go:14)JLS161</span><br><span class="line">    // 把栈减了40个字节。增大了栈空间。</span><br><span class="line">0x0013 00019 (main.go:14)SUBQ$40, SP</span><br><span class="line">0x0017 00023 (main.go:14)MOVQBP, 32(SP)</span><br><span class="line">0x001c 00028 (main.go:14)LEAQ32(SP), BP</span><br><span class="line">0x0021 00033 (main.go:14)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0021 00033 (main.go:14)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0021 00033 (main.go:14)FUNCDATA$3, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)</span><br><span class="line">0x0021 00033 (main.go:15)PCDATA$2, $0</span><br><span class="line">0x0021 00033 (main.go:15)PCDATA$0, $0</span><br><span class="line">// move (10,32) to </span><br><span class="line">    0x0021 00033 (main.go:15)MOVQ$137438953482, AX</span><br><span class="line">0x002b 00043 (main.go:15)MOVQAX, (SP)</span><br><span class="line">0x002f 00047 (main.go:15)CALL&quot;&quot;.Add(SB)</span><br><span class="line"></span><br><span class="line">   // First things first, the receiver is initialized via adder := Adder&#123;id: 6754&#125;:</span><br><span class="line">    0x0034 00052 (main.go:17)MOVL$0, &quot;&quot;.adder+28(SP)</span><br><span class="line">0x003c 00060 (main.go:17)MOVL$6754, &quot;&quot;.adder+28(SP)</span><br><span class="line">0x0044 00068 (main.go:18)PCDATA$2, $1</span><br><span class="line">    // recieve address to the AX,8 bytes.</span><br><span class="line">    0x0044 00068 (main.go:18)LEAQ&quot;&quot;.adder+28(SP), AX</span><br><span class="line">0x0049 00073 (main.go:18)PCDATA$2, $0</span><br><span class="line">0x0049 00073 (main.go:18)MOVQAX, (SP)</span><br><span class="line">0x004d 00077 (main.go:18)MOVQ$137438953482, AX</span><br><span class="line">0x0057 00087 (main.go:18)MOVQAX, 8(SP)</span><br><span class="line">0x005c 00092 (main.go:18)CALL&quot;&quot;.(*Adder).AddPtr(SB)</span><br><span class="line"></span><br><span class="line">    // value to the AX.</span><br><span class="line">    0x0061 00097 (main.go:19)MOVL&quot;&quot;.adder+28(SP), AX</span><br><span class="line">0x0065 00101 (main.go:19)MOVLAX, (SP)</span><br><span class="line">0x0068 00104 (main.go:19)MOVQ$137438953482, AX</span><br><span class="line">0x0072 00114 (main.go:19)MOVQAX, 4(SP)</span><br><span class="line">0x0077 00119 (main.go:19)CALL&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line"></span><br><span class="line">    // Somehow, Go automagically dereferences our pointer and manages to make the call. How so?</span><br><span class="line"></span><br><span class="line">// How the compiler handles this kind of situation depends on whether or not the receiver being pointed to has escaped to the heap or not.</span><br><span class="line">  </span><br><span class="line">// Case A: The receiver is on the stack</span><br><span class="line"></span><br><span class="line">// If the receiver is still on the stack and its size is sufficiently small that it can be copied in a few instructions, as is the case here, the compiler simply copies its value over to the top of the stack then does a straightforward method call to &quot;&quot;.Adder.AddVal (i.e. the one with a value receiver).</span><br><span class="line"></span><br><span class="line">// (&amp;adder).AddVal(10, 32) thus looks like this in this situation:</span><br><span class="line"></span><br><span class="line">// 0x0074 MOVL&quot;&quot;.adder+28(SP), AX;; move (i.e. copy) adder (note the MOV instead of a LEA) to..</span><br><span class="line">// 0x0078 MOVLAX, (SP);; ..the top of the stack (argument #1)</span><br><span class="line">// 0x007b MOVQ$137438953482, AX;; move (32,10) to..</span><br><span class="line">// 0x0085 MOVQAX, 4(SP);; ..the top of the stack (arguments #3 &amp; #2)</span><br><span class="line">// 0x008a CALL&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line">// Boring (although efficient). Let&apos;s move on to case B.</span><br><span class="line"></span><br><span class="line">// Case B: The receiver is on the heap</span><br><span class="line"></span><br><span class="line">// If the receiver has escaped to the heap then the compiler has to take a cleverer route: it generates a new method (with a pointer receiver, this time) that wraps &quot;&quot;.Adder.AddVal, and replaces the original call to &quot;&quot;.Adder.AddVal (the wrappee) with a call to &quot;&quot;.(*Adder).AddVal (the wrapper).</span><br><span class="line">// The wrapper&apos;s sole mission, then, is to make sure that the receiver gets properly dereferenced before being passed to the wrappee, and that any arguments and return values involved are properly copied back and forth between the caller and the wrappee.</span><br><span class="line"></span><br><span class="line">// (NOTE: In assembly outputs, these wrapper methods are marked as &lt;autogenerated&gt;.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x007c 00124 (main.go:21)MOVL&quot;&quot;.adder+28(SP), AX</span><br><span class="line">0x0080 00128 (main.go:21)MOVLAX, (SP)</span><br><span class="line">0x0083 00131 (main.go:21)MOVQ$137438953482, AX</span><br><span class="line">0x008d 00141 (main.go:21)MOVQAX, 4(SP)</span><br><span class="line">0x0092 00146 (main.go:21)CALL&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line">0x0097 00151 (main.go:22)MOVQ32(SP), BP</span><br><span class="line">0x009c 00156 (main.go:22)ADDQ$40, SP</span><br><span class="line">0x00a0 00160 (main.go:22)RET</span><br><span class="line">0x00a1 00161 (main.go:22)NOP</span><br><span class="line">0x00a1 00161 (main.go:14)PCDATA$0, $-1</span><br><span class="line">0x00a1 00161 (main.go:14)PCDATA$2, $-1</span><br><span class="line">0x00a1 00161 (main.go:14)CALLruntime.morestack_noctxt(SB)</span><br><span class="line">0x00a6 00166 (main.go:14)JMP0</span><br></pre></td></tr></table></figure><p>Here’s an annotated listing of the generated wrapper that should hopefully clear things up a bit:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0x0000 TEXT&quot;&quot;.(*Adder).AddVal(SB), DUPOK|WRAPPER, $32-24</span><br><span class="line">  ;; ...omitted preambles...</span><br><span class="line"></span><br><span class="line">  0x0026 MOVQ&quot;&quot;..this+40(SP), AX ;; check whether the receiver..</span><br><span class="line">  0x002b TESTQAX, AX    ;; ..is nil</span><br><span class="line">  0x002e JEQ92    ;; if it is, jump to 0x005c (panic)</span><br><span class="line"></span><br><span class="line">  0x0030 MOVL(AX), AX            ;; dereference pointer receiver..</span><br><span class="line">  0x0032 MOVLAX, (SP)            ;; ..and move (i.e. copy) the resulting value to argument #1</span><br><span class="line"></span><br><span class="line">  ;; forward (copy) arguments #2 &amp; #3 then call the wrappee</span><br><span class="line">  0x0035 MOVL&quot;&quot;.a+48(SP), AX</span><br><span class="line">  0x0039 MOVLAX, 4(SP)</span><br><span class="line">  0x003d MOVL&quot;&quot;.b+52(SP), AX</span><br><span class="line">  0x0041 MOVLAX, 8(SP)</span><br><span class="line">  0x0045 CALL&quot;&quot;.Adder.AddVal(SB) ;; call the wrapped method</span><br><span class="line"></span><br><span class="line">  ;; copy return value from wrapped method then return</span><br><span class="line">  0x004a MOVL16(SP), AX</span><br><span class="line">  0x004e MOVLAX, &quot;&quot;.~r2+56(SP)</span><br><span class="line">  ;; ...omitted frame-pointer stuff...</span><br><span class="line">  0x005b RET</span><br><span class="line"></span><br><span class="line">  ;; throw a panic with a detailed error</span><br><span class="line">  0x005c CALLruntime.panicwrap(SB)</span><br><span class="line"></span><br><span class="line">  ;; ...omitted epilogues...</span><br></pre></td></tr></table></figure><p>Obviously, this kind of wrapper can induce quite a bit of overhead considering all the copying that needs to be done in order to pass the arguments back and forth; especially if the wrappee is just a few instructions.<br>Fortunately, in practice, the compiler would have inlined the wrappee directly into the wrapper to amortize these costs (when feasible, at least).</p><p>Note the WRAPPER directive in the definition of the symbol, which indicates that this method shouldn’t appear in backtraces (so as not to confuse the end-user), nor should it be able to recover from panics that might be thrown by the wrappee.</p><p>WRAPPER: This is a wrapper function and should not count as disabling recover.</p><p>The runtime.panicwrap function, which throws a panic if the wrapper’s receiver is nil, is pretty self-explanatory; here’s its complete listing for reference (src/runtime/error.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// panicwrap generates a panic for a call to a wrapped value method</span><br><span class="line">// with a nil pointer receiver.</span><br><span class="line">//</span><br><span class="line">// It is called from the generated wrapper code.</span><br><span class="line">func panicwrap() &#123;</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    name := funcname(findfunc(pc))</span><br><span class="line">    // name is something like &quot;main.(*T).F&quot;.</span><br><span class="line">    // We want to extract pkg (&quot;main&quot;), typ (&quot;T&quot;), and meth (&quot;F&quot;).</span><br><span class="line">    // Do it by finding the parens.</span><br><span class="line">    i := stringsIndexByte(name, &apos;(&apos;)</span><br><span class="line">    if i &lt; 0 &#123;</span><br><span class="line">        throw(&quot;panicwrap: no ( in &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    pkg := name[:i-1]</span><br><span class="line">    if i+2 &gt;= len(name) || name[i-1:i+2] != &quot;.(*&quot; &#123;</span><br><span class="line">        throw(&quot;panicwrap: unexpected string after package name: &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    name = name[i+2:]</span><br><span class="line">    i = stringsIndexByte(name, &apos;)&apos;)</span><br><span class="line">    if i &lt; 0 &#123;</span><br><span class="line">        throw(&quot;panicwrap: no ) in &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    if i+2 &gt;= len(name) || name[i:i+2] != &quot;).&quot; &#123;</span><br><span class="line">        throw(&quot;panicwrap: unexpected string after type name: &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    typ := name[:i]</span><br><span class="line">    meth := name[i+2:]</span><br><span class="line">    panic(plainError(&quot;value method &quot; + pkg + &quot;.&quot; + typ + &quot;.&quot; + meth + &quot; called using nil *&quot; + typ + &quot; pointer&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="anatomy-of-an-interface"><a class="markdownIt-Anchor" href="#anatomy-of-an-interface"></a> Anatomy of an interface</h2><h3 id="overview-of-the-datastructures"><a class="markdownIt-Anchor" href="#overview-of-the-datastructures"></a> Overview of the datastructures</h3><p>Before we can understand how they work, we first need to build a mental model of the datastructures that make up interfaces and how they’re laid out in memory.<br>To that end, we’ll have a quick peek into the runtime package to see what an interface actually looks like from the standpoint of the Go implementation.</p><h3 id="the-iface-structure"><a class="markdownIt-Anchor" href="#the-iface-structure"></a> The iface structure</h3><p>iface is the root type that represents an interface within the runtime (src/runtime/runtime2.go).<br>Its definition goes like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123; // 16 bytes on a 64bit arch</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An interface is thus a very simple structure that maintains 2 pointers:</p><ul><li>tab holds the address of an itab object, which embeds the datastructures that describe both the type of the interface as well as the type of the data it points to.</li><li>data is a raw (i.e. unsafe) pointer to the value held by the interface.</li></ul><p>More often than not, this will result in a heap allocation as the compiler takes the conservative route and forces the receiver to escape.<br>This holds true even for scalar types!</p><p>We can prove that with a few lines of code (escape.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Addifier interface&#123; Add(a, b int32) int32 &#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; name string &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    adder := Adder&#123;name: &quot;myAdder&quot;&#125;</span><br><span class="line">    adder.Add(10, 32)      // doesn&apos;t escape</span><br><span class="line">    Addifier(adder).Add(10, 32) // escapes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One could even visualize the resulting heap allocation using a simple benchmark (escape_test.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkDirect(b *testing.B) &#123;</span><br><span class="line">    adder := Adder&#123;id: 6754&#125;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        adder.Add(10, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkInterface(b *testing.B) &#123;</span><br><span class="line">    adder := Adder&#123;id: 6754&#125;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        Addifier(adder).Add(10, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ GOOS=linux GOARCH=amd64 go test -bench=. -benchmem ./escape_test.go</span><br><span class="line">BenchmarkDirect-8      2000000000         1.60 ns/op       0 B/op       0 allocs/op</span><br><span class="line">BenchmarkInterface-8   100000000         15.0 ns/op       4 B/op       1 allocs/op</span><br></pre></td></tr></table></figure><p>We can clearly see how each time we create a new Addifier interface and initialize it with our adder variable, a heap allocation of sizeof(Adder) actually takes place. Later in this chapter, we’ll see how even simple scalar types can lead to heap allocations when used with interfaces.</p><p>Let’s turn our attention towards the next datastructure: itab.</p><h3 id="the-itab-structure"><a class="markdownIt-Anchor" href="#the-itab-structure"></a> The itab structure</h3><p>itab is defined thusly (src/runtime/runtime2.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123; // 40 bytes on a 64bit arch</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">    _     [4]byte</span><br><span class="line">    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An itab is the heart &amp; brain of an interface.</p><p>First, it embeds a _type, which is the internal representation of any Go type within the runtime.<br>A _type describes every facets of a type: its name, its characteristics (e.g. size, alignment…), and to some extent, even how it behaves (e.g. comparison, hashing…)!<br>In this instance, the _type field describes the type of the value held by the interface, i.e. the value that the data pointer points to.</p><p>Second, we find a pointer to an interfacetype, which is merely a wrapper around _type with some extra information that are specific to interfaces.<br>As you’d expect, the inter field describes the type of the interface itself.</p><p>Finally, the fun array holds the function pointers that make up the virtual/dispatch table of the interface.<br>Notice the comment that says // variable sized, meaning that the size with which this array is declared is irrelevant.<br>We’ll see later in this chapter that the compiler is responsible for allocating the memory that backs this array, and does so independently of the size indicated here. Likewise, the runtime always accesses this array using raw pointers, thus bounds-checking does not apply here.</p><p>The _type structure</p><p>As we said above, the _type structure gives a complete description of a Go type.<br>It’s defined as such (src/runtime/type.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type _type struct &#123; // 48 bytes on a 64bit arch</span><br><span class="line">    size       uintptr</span><br><span class="line">    ptrdata    uintptr // size of memory prefix holding all pointers</span><br><span class="line">    hash       uint32</span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      uint8</span><br><span class="line">    fieldalign uint8</span><br><span class="line">    kind       uint8</span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    // gcdata stores the GC type data for the garbage collector.</span><br><span class="line">    // If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">    gcdata    *byte</span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thankfully, most of these fields are quite self-explanatory.</p><p>The nameOff &amp; typeOff types are int32 offsets into the metadata embedded into the final executable by the linker. This metadata is loaded into runtime.moduledata structures at run time (src/runtime/symtab.go), which should look fairly similar if you’ve ever had to look at the content of an ELF file.<br>The runtime provide helpers that implement the necessary logic for following these offsets through the moduledata structures, such as e.g. resolveNameOff (src/runtime/type.go) and resolveTypeOff (src/runtime/type.go):</p><p>func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {}<br>func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {}</p><p>I.e., assuming t is a _type, calling resolveTypeOff(t, t.ptrToThis) returns a copy of t.</p><p>The interfacetype structure</p><p>Finally, here’s the interfacetype structure (src/runtime/type.go):</p><p>type interfacetype struct { // 80 bytes on a 64bit arch<br>typ     _type<br>pkgpath name<br>mhdr    []imethod<br>}</p><p>type imethod struct {<br>name nameOff<br>ityp typeOff<br>}<br>As mentioned, an interfacetype is just a wrapper around a _type with some extra interface-specific metadata added on top.<br>In the current implementation, this metadata is mostly composed of a list of offsets that points to the respective names and types of the methods exposed by the interface ([]imethod).</p><p>Conclusion</p><p>Here’s an overview of what an iface looks like when represented with all of its sub-types inlined; this hopefully should help connect all the dots:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// `iface`</span></span><br><span class="line">    tab *<span class="keyword">struct</span> &#123; <span class="comment">// `itab`</span></span><br><span class="line">        inter *<span class="keyword">struct</span> &#123; <span class="comment">// `interfacetype`</span></span><br><span class="line">            typ <span class="keyword">struct</span> &#123; <span class="comment">// `_type`</span></span><br><span class="line">                size       <span class="keyword">uintptr</span></span><br><span class="line">                ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">                hash       <span class="keyword">uint32</span></span><br><span class="line">                tflag      tflag</span><br><span class="line">                align      <span class="keyword">uint8</span></span><br><span class="line">                fieldalign <span class="keyword">uint8</span></span><br><span class="line">                kind       <span class="keyword">uint8</span></span><br><span class="line">                alg        *typeAlg</span><br><span class="line">                gcdata     *<span class="keyword">byte</span></span><br><span class="line">                str        nameOff</span><br><span class="line">                ptrToThis  typeOff</span><br><span class="line">            &#125;</span><br><span class="line">            pkgpath name</span><br><span class="line">            mhdr    []<span class="keyword">struct</span> &#123; <span class="comment">// `imethod`</span></span><br><span class="line">                name nameOff</span><br><span class="line">                ityp typeOff</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _type *<span class="keyword">struct</span> &#123; <span class="comment">// `_type`</span></span><br><span class="line">            size       <span class="keyword">uintptr</span></span><br><span class="line">            ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">            hash       <span class="keyword">uint32</span></span><br><span class="line">            tflag      tflag</span><br><span class="line">            align      <span class="keyword">uint8</span></span><br><span class="line">            fieldalign <span class="keyword">uint8</span></span><br><span class="line">            kind       <span class="keyword">uint8</span></span><br><span class="line">            alg        *typeAlg</span><br><span class="line">            gcdata     *<span class="keyword">byte</span></span><br><span class="line">            str        nameOff</span><br><span class="line">            ptrToThis  typeOff</span><br><span class="line">        &#125;</span><br><span class="line">        hash <span class="keyword">uint32</span></span><br><span class="line">        _    [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">        fun  [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">    &#125;</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This section glossed over the different data-types that make up an interface to help us to start building a mental model of the various cogs involved in the overall machinery, and how they all work with each other.</p><p>Creating an interface<br>Now that we’ve had a quick look at all the datastructures involved, we’ll focus on how they actually get allocated and initiliazed.</p><p>Consider the following program (iface.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Mather interface &#123;</span><br><span class="line">    Add(a, b int32) int32</span><br><span class="line">    Sub(a, b int64) int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; id int32 &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Sub(a, b int64) int64 &#123; return a - b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := Mather(Adder&#123;id: 6754&#125;)</span><br><span class="line"></span><br><span class="line">    // This call just makes sure that the interface is actually used.</span><br><span class="line">    // Without this call, the linker would see that the interface defined above</span><br><span class="line">    // is in fact never used, and thus would optimize it out of the final</span><br><span class="line">    // executable.</span><br><span class="line">    m.Add(10, 32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NOTE: For the remainder of this chapter, we will denote an interface I that holds a type T as &lt;I,T&gt;. E.g. Mather(Adder{id: 6754}) instantiates an iface&lt;Mather, Adder&gt;.</p><p>Let’s zoom in on the instantiation of iface&lt;Mather, Adder&gt;:</p><p>m := Mather(Adder{id: 6754})<br>This single line of Go code actually sets off quite a bit of machinery, as the assembly listing generated by the compiler can attest:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;; part 1: allocate the receiver</span><br><span class="line">;; A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame.</span><br><span class="line">;; It&apos;s stored there so that the compiler will later be able to reference it by its address;</span><br><span class="line">0x001d MOVL$6754, &quot;&quot;..autotmp_1+36(SP)</span><br><span class="line">;; part 2: set up the itab</span><br><span class="line">;; Semantically, this gives us something along the lines of the following pseudo-code:</span><br><span class="line"></span><br><span class="line">;; tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line">;; That&apos;s half of our interface right there!</span><br><span class="line"></span><br><span class="line">;; Now, while we&apos;re at it, let&apos;s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol.</span><br><span class="line">;; As usual, the -S flag of the compiler can tell us a lot:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0025 LEAQgo.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX</span><br><span class="line">0x002c MOVQAX, (SP)</span><br><span class="line">;; part 3: set up the data</span><br><span class="line">0x0030 LEAQ&quot;&quot;..autotmp_1+36(SP), AX</span><br><span class="line">0x0035 MOVQAX, 8(SP)</span><br><span class="line">0x003a CALLruntime.convT2I32(SB)</span><br><span class="line">0x003f MOVQ16(SP), AX</span><br><span class="line">0x0044 MOVQ24(SP), CX</span><br></pre></td></tr></table></figure><p>Part 1: Allocate the receiver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x001d MOVL$6754, &quot;&quot;..autotmp_1+36(SP)</span><br></pre></td></tr></table></figure><p>A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame.<br>It’s stored there so that the compiler will later be able to reference it by its address; we’ll see why in part 3.</p><p>Part 2: Set up the itab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0025 LEAQgo.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX</span><br><span class="line">0x002c MOVQAX, (SP)</span><br></pre></td></tr></table></figure><p>It looks like the compiler has already created the necessary itab for representing our iface&lt;Mather, Adder&gt; interface, and made it available to us via a global symbol: go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather.</p><p>We’re in the process of building an iface&lt;Mather, Adder&gt; interface and, in order to do so, we’re loading the effective address of this global go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol at the top of the current stack-frame.<br>Once again, we’ll see why in part 3.<br>Semantically, this gives us something along the lines of the following pseudo-code:<br>tab := getSymAddr(<code>go.itab.main.Adder,main.Mather</code>).(*itab)<br>That’s half of our interface right there!</p><p>Now, while we’re at it, let’s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol.<br>As usual, the -S flag of the compiler can tell us a lot:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ GOOS=linux GOARCH=amd64 go tool compile -S iface.go | grep -A 7 &apos;^go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&apos;</span><br><span class="line">go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40</span><br><span class="line">    0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">    0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............</span><br><span class="line">    0x0020 00 00 00 00 00 00 00 00                          ........</span><br><span class="line">    rel 0+8 t=1 type.&quot;&quot;.Mather+0</span><br><span class="line">    rel 8+8 t=1 type.&quot;&quot;.Adder+0</span><br><span class="line">    rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0</span><br><span class="line">    rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0</span><br></pre></td></tr></table></figure><p>Neat. Let’s analyze this piece by piece.</p><p>The first piece declares the symbol and its attributes:</p><p>go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40<br>As usual, since we’re looking directly at the intermediate object file generated by the compiler (i.e. the linker hasn’t run yet), symbol names are still missing package names. Nothing new on that front.<br>Other than that, what we’ve got here is a 40-byte global object symbol that will be stored in the .rodata section of our binary.</p><p>Note the dupok directive, which tells the linker that it is legal for this symbol to appear multiple times at link-time: the linker will have to arbitrarily choose one of them over the others.</p><p>The second piece is a hexdump of the 40 bytes of data associated with the symbol. I.e., it’s a serialized representation of an itab structure:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............</span><br><span class="line">0x0020 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>As you can see, most of this data is just a bunch of zeros at this point. The linker will take care of filling them up, as we’ll see in a minute.</p><p>Notice how, among all these zeros, 4 bytes actually have been set though, at offset 0x10+4.<br>If we take a look back at the declaration of the itab structure and annotate the respective offsets of its fields:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123; // 40 bytes on a 64bit arch</span><br><span class="line">    inter *interfacetype // offset 0x00 ($00)</span><br><span class="line">    _type *_type // offset 0x08 ($08)</span><br><span class="line">    hash  uint32 // offset 0x10 ($16)</span><br><span class="line">    _     [4]byte // offset 0x14 ($20)</span><br><span class="line">    fun   [1]uintptr // offset 0x18 ($24)</span><br><span class="line"> // offset 0x20 ($32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We see that offset 0x10+4 matches the hash uint32 field: i.e., the hash value that corresponds to our main.Adder type is already right there in our object file.</p><p>The third and final piece lists a bunch of relocation directives for the linker:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rel 0+8 t=1 type.&quot;&quot;.Mather+0</span><br><span class="line">rel 8+8 t=1 type.&quot;&quot;.Adder+0</span><br><span class="line">rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0</span><br><span class="line">rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0</span><br></pre></td></tr></table></figure><p>rel 0+8 t=1 type.&quot;&quot;.Mather+0 tells the linker to fill up the first 8 bytes (0+8) of the contents with the address of the global object symbol type.&quot;&quot;.Mather.<br>rel 8+8 t=1 type.&quot;&quot;.Adder+0 then fills the next 8 bytes with the address of type.&quot;&quot;.Adder, and so on and so forth.</p><p>Once the linker has done its job and followed all of these directives, our 40-byte serialized itab will be complete.<br>Overall, we’re now looking at something akin to the following pseudo-code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line"></span><br><span class="line">// NOTE: The linker strips the `type.` prefix from these symbols when building</span><br><span class="line">// the executable, so the final symbol names in the .rodata section of the</span><br><span class="line">// binary will actually be `main.Mather` and `main.Adder` rather than</span><br><span class="line">// `type.main.Mather` and `type.main.Adder`.</span><br><span class="line">// Don&apos;t get tripped up by this when toying around with objdump.</span><br><span class="line">tab.inter = getSymAddr(`type.main.Mather`).(*interfacetype)</span><br><span class="line">tab._type = getSymAddr(`type.main.Adder`).(*_type)</span><br><span class="line"></span><br><span class="line">tab.fun[0] = getSymAddr(`main.(*Adder).Add`).(uintptr)</span><br><span class="line">tab.fun[1] = getSymAddr(`main.(*Adder).Sub`).(uintptr)</span><br></pre></td></tr></table></figure><p>We’ve got ourselves a ready-to-use itab, now if we just had some data to along with it, that’d make for a nice, complete interface.</p><p>Remember from part 1 that the top of the stack (SP) currently holds the address of go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather (argument #1).<br>Also remember from part 2 that we had stored a $6754 decimal constant in “”…autotmp_1+36(SP): we now load the effective address of this constant just below the top of the stack-frame, at 8(SP) (argument #2).</p><p>These two pointers are the two arguments that we pass into runtime.convT2I32, which will apply the final touches of glue to create and return our complete interface.<br>Let’s have a closer look at it (src/runtime/iface.go):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func convT2I32(tab *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">    t := tab._type</span><br><span class="line">    /* ...omitted debug stuff... */</span><br><span class="line">    var x unsafe.Pointer</span><br><span class="line">    if *(*uint32)(elem) == 0 &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[0])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        x = mallocgc(4, t, false)</span><br><span class="line">        *(*uint32)(x) = *(*uint32)(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So runtime.convT2I32 does 4 things:</p><p>It creates a new iface structure i (to be pedantic, its caller creates it… same difference).<br>It assigns the itab pointer we just gave it to i.tab.<br>It allocates a new object of type i.tab._type on the heap, then copy the value pointed to by the second argument elem into that new object.<br>It returns the final interface.</p><p>This process is quite straightforward overall, although the 3rd step does involve some tricky implementation details in this specific case, which are caused by the fact that our Adder type is effectively a scalar type.<br>We’ll look at the interactions of scalar types and interfaces in more details in the section about the special cases of interfaces.</p><p>Conceptually, we’ve now accomplished the following (pseudo-code):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line">elem := getSymAddr(`&quot;&quot;..autotmp_1+36(SP)`).(*int32)</span><br><span class="line"></span><br><span class="line">i := runtime.convTI32(tab, unsafe.Pointer(elem))</span><br><span class="line"></span><br><span class="line">assert(i.tab == tab)</span><br><span class="line">assert(*(*int32)(i.data) == 6754) // same value..</span><br><span class="line">assert((*int32)(i.data) != elem)  // ..but different (al)locations!</span><br></pre></td></tr></table></figure><p>To summarize all that just went down, here’s a complete, annotated version of the assembly code for all 3 parts:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x001d MOVL$6754, &quot;&quot;..autotmp_1+36(SP)         ;; create an addressable $6754 value at 36(SP)</span><br><span class="line">0x0025 LEAQgo.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX  ;; set up go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather..</span><br><span class="line">0x002c MOVQAX, (SP)                            ;; ..as first argument (tab *itab)</span><br><span class="line">0x0030 LEAQ&quot;&quot;..autotmp_1+36(SP), AX            ;; set up &amp;36(SP)..</span><br><span class="line">0x0035 MOVQAX, 8(SP)                           ;; ..as second argument (elem unsafe.Pointer)</span><br><span class="line">0x003a CALLruntime.convT2I32(SB)               ;; call convT2I32(go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather, &amp;$6754)</span><br><span class="line">0x003f MOVQ16(SP), AX                          ;; AX now holds i.tab (go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather)</span><br><span class="line">0x0044 MOVQ24(SP), CX                          ;; CX now holds i.data (&amp;$6754, somewhere on the heap)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;introduce&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#introduce&quot;&gt;&lt;/a&gt; introduce&lt;/h2&gt;
&lt;p&gt;golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>emacs-package-for-golang</title>
    <link href="https://dreamerjonson.com/2019/11/24/emacs-package-for-golang/"/>
    <id>https://dreamerjonson.com/2019/11/24/emacs-package-for-golang/</id>
    <published>2019-11-24T01:15:15.000Z</published>
    <updated>2019-12-04T09:13:17.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ivy-mode"><a class="markdownIt-Anchor" href="#ivy-mode"></a> ivy-mode</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; ivy mode</span><br><span class="line">;;</span><br><span class="line">(use-package ivy</span><br><span class="line">  :ensure t</span><br><span class="line">  :diminish (ivy-mode . &quot;&quot;)</span><br><span class="line">  :config</span><br><span class="line">  (ivy-mode 1)</span><br><span class="line">  (setq ivy-use-virutal-buffers t)</span><br><span class="line">  (setq enable-recursive-minibuffers t)</span><br><span class="line">  (setq ivy-height 10)</span><br><span class="line">  (setq ivy-initial-inputs-alist nil)</span><br><span class="line">  (setq ivy-count-format &quot;%d/%d&quot;)</span><br><span class="line">  (setq ivy-re-builders-alist</span><br><span class="line">        `((t . ivy--regex-ignore-order)))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; counsel</span><br><span class="line">;;</span><br><span class="line">(use-package counsel</span><br><span class="line">  :ensure t</span><br><span class="line">  :bind ((&quot;M-x&quot; . counsel-M-x)</span><br><span class="line">         (&quot;\C-x \C-f&quot; . counsel-find-file)))</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">;; swiper</span><br><span class="line">;;</span><br><span class="line">(use-package swiper</span><br><span class="line">  :ensure t</span><br><span class="line">  :bind ((&quot;\C-s&quot; . swiper))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="gomode-goimport自动导入-godef跳转"><a class="markdownIt-Anchor" href="#gomode-goimport自动导入-godef跳转"></a> gomode + goimport自动导入 + godef跳转</h2><p>go get -u <a href="http://github.com/rogpeppe/godef" target="_blank" rel="noopener">github.com/rogpeppe/godef</a><br>go get -u <a href="http://golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">golang.org/x/tools/cmd/goimports</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-mode</span><br><span class="line">  ;; :load-path &quot;~/.emacs.d/vendor/go-mode&quot;</span><br><span class="line">  :mode (&quot;\\.go\\&apos;&quot; . go-mode)</span><br><span class="line">  :ensure-system-package</span><br><span class="line">  ((goimports . &quot;go get -u golang.org/x/tools/cmd/goimports&quot;)</span><br><span class="line">   (godef . &quot;go get -u github.com/rogpeppe/godef&quot;))</span><br><span class="line">  :init</span><br><span class="line">  (setq gofmt-command &quot;goimports&quot;</span><br><span class="line">        indent-tabs-mode t)</span><br><span class="line">  :config</span><br><span class="line">  (add-hook &apos;before-save-hook &apos;gofmt-before-save)</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;\C-c \C-c&quot; . compile)</span><br><span class="line">              (&quot;\C-c \C-g&quot; . go-goto-imports)</span><br><span class="line">              (&quot;\C-c \C-k&quot; . godoc)</span><br><span class="line">              (&quot;M-j&quot; . godef-jump)))</span><br></pre></td></tr></table></figure><p>M-n find引用 M-x lsp-find-ref<br>M-. find 实现</p><h2 id="gocodecompany-自动补全"><a class="markdownIt-Anchor" href="#gocodecompany-自动补全"></a> gocode+company 自动补全</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;;</span><br><span class="line">;; company</span><br><span class="line">;;</span><br><span class="line">(use-package company</span><br><span class="line">  :ensure t</span><br><span class="line">  :config</span><br><span class="line">  (global-company-mode t)</span><br><span class="line">  (setq company-idle-delay 0)</span><br><span class="line">  (setq company-minimum-prefix-length 3)</span><br><span class="line">  (setq company-backends</span><br><span class="line">        &apos;((company-files</span><br><span class="line">           company-yasnippet</span><br><span class="line">           company-keywords</span><br><span class="line">           company-capf</span><br><span class="line">           )</span><br><span class="line">          (company-abbrev company-dabbrev))))</span><br><span class="line"></span><br><span class="line">(add-hook &apos;emacs-lisp-mode-hook (lambda ()</span><br><span class="line">                                  (add-to-list  (make-local-variable &apos;company-backends)</span><br><span class="line">                                                &apos;(company-elisp))))</span><br></pre></td></tr></table></figure><p>gocode<br>go get -u <a href="http://github.com/stamblerre/gocode" target="_blank" rel="noopener">github.com/stamblerre/gocode</a> # for go-eldoc/company-go // this feel better than nsf/gocde</p><p>gocode 是守护进程，查看是否在后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep gocode</span><br></pre></td></tr></table></figure><h2 id="语法检查"><a class="markdownIt-Anchor" href="#语法检查"></a> 语法检查</h2><p>C-c ! l<br>C-c ! v</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package flycheck</span><br><span class="line">  :ensure t</span><br><span class="line">  :config</span><br><span class="line">  (global-flycheck-mode t)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="gotest"><a class="markdownIt-Anchor" href="#gotest"></a> gotest</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(use-package gotest</span><br><span class="line">  :after go-mode</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;C-c C-f&quot; . go-test-current-file)</span><br><span class="line">              (&quot;C-c C-t&quot; . go-test-current-test)</span><br><span class="line">              (&quot;C-c C-p&quot; . go-test-current-project)</span><br><span class="line">              (&quot;C-c C-b&quot; . go-test-current-benchmark)</span><br><span class="line">              (&quot;C-x x&quot; . go-run))</span><br><span class="line">  :config</span><br><span class="line">  (setq go-test-verbose t))</span><br></pre></td></tr></table></figure><h2 id="gorename"><a class="markdownIt-Anchor" href="#gorename"></a> gorename</h2><p>go get -u  <a href="http://golang.org/x/tools/cmd/gorename" target="_blank" rel="noopener">golang.org/x/tools/cmd/gorename</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-rename</span><br><span class="line">  :after go-mode</span><br><span class="line">  :ensure-system-package (gorename . &quot;go get -u golang.org/x/tools/cmd/gorename&quot;)</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;C-c C-r&quot; . go-rename)))</span><br></pre></td></tr></table></figure><h2 id="errorcheck"><a class="markdownIt-Anchor" href="#errorcheck"></a> errorcheck</h2><p>go get -u <a href="http://github.com/kisielk/errcheck" target="_blank" rel="noopener">github.com/kisielk/errcheck</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-errcheck</span><br><span class="line">  :after go-mode</span><br><span class="line">  :ensure-system-package (errcheck . &quot;go get -u github.com/kisielk/errcheck&quot;)</span><br><span class="line">  :bind (:map go-mode-map</span><br><span class="line">              (&quot;C-c C-e&quot; . go-errcheck)))</span><br></pre></td></tr></table></figure><h2 id="go-imenu"><a class="markdownIt-Anchor" href="#go-imenu"></a> go-imenu</h2><p>go get -u <a href="http://github.com/lukehoban/go-outline" target="_blank" rel="noopener">github.com/lukehoban/go-outline</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(use-package go-imenu</span><br><span class="line">  :ensure-system-package (go-outline . &quot;go get -u github.com/lukehoban/go-outline&quot;)</span><br><span class="line">  :after go-mode</span><br><span class="line">  :config</span><br><span class="line">  (add-hook &apos;go-mode-hook &apos;go-imenu-setup))</span><br></pre></td></tr></table></figure><h2 id="gtags"><a class="markdownIt-Anchor" href="#gtags"></a> gtags</h2><p>安装GUN global though source code 注意不要用brew安装，因为必须要配置sqlite3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://tamacom.com/global/global-6.5.7.tar.gz</span><br><span class="line">tar xvf global-6.5.7.tar.gz</span><br><span class="line">cd global-6.5.7</span><br><span class="line">./configure --with-sqlite3</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/juntaki/gogtags</span><br></pre></td></tr></table></figure><p>在项目目录中输入：<br>gogtags -v<br>会生成GTAGS等文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(use-package helm-gtags</span><br><span class="line">  :config</span><br><span class="line">  (setq helm-gtags-ignore-case t</span><br><span class="line">        helm-gtags-auto-update t</span><br><span class="line">        helm-gtags-use-input-at-cursor t</span><br><span class="line">        helm-gtags-pulse-at-cursor t</span><br><span class="line">        helm-gtags-prefix-key &quot;\C-cg&quot;</span><br><span class="line">        helm-gtags-suggested-key-mapping t)</span><br><span class="line">  :bind (:map helm-gtags-mode-map</span><br><span class="line">              (&quot;C-c g a&quot; . helm-gtags-tags-in-this-function)</span><br><span class="line">              (&quot;C-j&quot; . helm-gtags-select)</span><br><span class="line">              (&quot;M-.&quot; . helm-gtags-dwim)</span><br><span class="line">              (&quot;M-,&quot; . helm-gtags-pop-stack)</span><br><span class="line">              (&quot;C-c &lt;&quot; . helm-gtags-previous-history)</span><br><span class="line">              (&quot;C-c &gt;&quot; . helm-gtags-next-history))</span><br><span class="line">  :hook ((dired-mode eshell-mode c-mode c++-mode asm-mode) . helm-gtags-mode))</span><br></pre></td></tr></table></figure><p>这时候再项目中即可使用<br>M-x helm-gtags finn partern 等查找tags</p><h2 id="projecttle-在项目中切换"><a class="markdownIt-Anchor" href="#projecttle-在项目中切换"></a> projecttle 在项目中切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(use-package dumb-jump</span><br><span class="line">  :bind ((&quot;M-g o&quot; . dumb-jump-go-other-window)</span><br><span class="line">         (&quot;M-g j&quot; . dumb-jump-go)</span><br><span class="line">         (&quot;M-g x&quot; . dumb-jump-go-prefer-external)</span><br><span class="line">         (&quot;M-g z&quot; . dumb-jump-go-prefer-external-other-window))</span><br><span class="line">  :config </span><br><span class="line">  ;; (setq dumb-jump-selector &apos;ivy) ;; (setq dumb-jump-selector &apos;helm)</span><br><span class="line">:initny</span><br><span class="line">(dumb-jump-mode)</span><br><span class="line">  :ensure</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="dumb-jump-跳转ob"><a class="markdownIt-Anchor" href="#dumb-jump-跳转ob"></a> dumb-jump 跳转OB</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(use-package dumb-jump</span><br><span class="line">  :bind ((&quot;M-g o&quot; . dumb-jump-go-other-window)</span><br><span class="line">         (&quot;M-g j&quot; . dumb-jump-go)</span><br><span class="line">         (&quot;M-g x&quot; . dumb-jump-go-prefer-external)</span><br><span class="line">         (&quot;M-g z&quot; . dumb-jump-go-prefer-external-other-window))</span><br><span class="line">  :config </span><br><span class="line">  ;; (setq dumb-jump-selector &apos;ivy) ;; (setq dumb-jump-selector &apos;helm)</span><br><span class="line">:init</span><br><span class="line">(dumb-jump-mode)</span><br><span class="line">  :ensure</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ivy-mode&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ivy-mode&quot;&gt;&lt;/a&gt; ivy-mode&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac install tor</title>
    <link href="https://dreamerjonson.com/2019/11/18/mac-install-tor/"/>
    <id>https://dreamerjonson.com/2019/11/18/mac-install-tor/</id>
    <published>2019-11-18T04:27:45.000Z</published>
    <updated>2019-11-20T02:58:54.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="install"><a class="markdownIt-Anchor" href="#install"></a> install</h2><p>brew install tor</p><h2 id="config"><a class="markdownIt-Anchor" href="#config"></a> config</h2><p>You will find a sample Tor configuration file at /usr/local/etc/tor/torrc.sample. Remove the .sample extension to make it effective.</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>man tor</p><h2 id="simple-excute"><a class="markdownIt-Anchor" href="#simple-excute"></a> simple excute</h2><p>tor</p><h2 id="github-though-socket"><a class="markdownIt-Anchor" href="#github-though-socket"></a> github though socket</h2><p>测试通过之后，你可以修改 SSH 的配置文件，就不用每次都在命令行参数中指定密钥文件的路径了。如果你用 SSH 方式操作2个以上的项目，很有必要进行如下定制，可以节省很多命令行输入。<br>　　SSH 配置文件的路径是： ~/.ssh/config<br>　　如果你系统中没有这个文件，就创建一个。然后用你熟悉的文本编辑器修改这个文件。<br>　　下面俺给出一个示例：<br>你需要把示例中的“别名”改为你自己起的名字（用一个可读性好点的名字）；<br>把“私钥文件路径”也同样替换为你本机所使用的文件路径。<br>其它部分【不要】改动。<br>Host 别名<br>HostName                  <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>Port                      443<br>User                      git<br>PreferredAuthentications  publickey<br>IdentityFile              私钥文件路径</p><p>所谓的“别名”，用来替换 URL 中的主机名。比如俺那个 zhao 项目，俺在 ~/.ssh/config 中使用的别名就是 zhao<br>　　之后俺如果要 clone 该项目，只需用如下命令：<br>git clone ssh://zhao/programthink/zhao<br>看到没？俺在 URL 中就不写 <a href="http://github.com" target="_blank" rel="noopener">github.com</a> 而改为 zhao，那么 openssh 就会去 ~/.ssh/config 中找到 zhao 这个配置项，然后用对应的私钥文件进行 SSH 连接，</p><p>★针对不同的 Git 使用方式，如何配置代理？</p><h2 id="bs-方式web-方式"><a class="markdownIt-Anchor" href="#bs-方式web-方式"></a> B/S 方式（Web 方式）</h2><p>这种方式最简单——就跟你翻墙访问其它网站类似——只需要让你的浏览器通过 Tor 的线路访问 GitHub 的页面，就 OK 了。<br>　　没用过 Tor 的同学，先去看俺的扫盲教程《戴“套”翻墻的方法》。</p><h2 id="cs-方式-下的-https-协议"><a class="markdownIt-Anchor" href="#cs-方式-下的-https-协议"></a> C/S 方式 下的 HTTPS 协议</h2><p>对于这种方式，你需要修改 Git 的配置参数，让 Git 知道 Tor 代理的 IP 和 端口。<br>　　具体的配置命令如下：<br>git config --global http.proxy SOCKS5h://代理地址:端口号<br>注意1：<br>假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为： 127.0.0.1<br>否则就替换为：运行 Tor 客户端的主机的 IP 地址。<br>注意2：<br>如果你的 Tor 客户端用的是【Tor Browser】，“端口号”必须用 9150<br>如果你用的是 Tor 的其它软件包（比如：Tor Expert Bundle），则“端口号”使用 9050</p><h2 id="cs-方式下的-ssh-协议"><a class="markdownIt-Anchor" href="#cs-方式下的-ssh-协议"></a> C/S 方式下的 SSH 协议</h2><p>要让 SSH 通过 Tor 的代理，稍微麻烦一点。因为 Tor 默认提供的是 SOCKS 代理，而 OpenSSH 客户端默认又【不】支持 SOCKS 代理。<br>　　因此，得依靠第三方的工具，来实现“SSH through SOCKS”。<br>　　这里要提醒一下列位看官：<br>　　俺说的是“SSH through SOCKS”，而【不是】“SOCKS through SSH”（这两者完全不同）</p><p>为了搞定“SSH through SOCKS”，俺选用大名鼎鼎的 netcat（俗称“网猫”）。<br>　　由于这个 netcat 名气很大，主流 Linux 发行版的软件仓库中都有它。你只需要用发行版自带的软件包管理器，把 netcat 装上。<br>　　说到 netcat，有一个“原版的”以及非常多的【变种】。“原版的 netcat”【不】支持代理，必须用某些支持代理的【变种】。俺推荐的是 OpenBSD 社区开发的 netcat 变种（也叫“OpenBSD netcat”或“netcat-openbsd”）。<br>　　如何判断你是否装对了捏？<br>　　在装好 netcat 之后，先运行如下命令（命令中的 nc 就是 netcat 的缩写）。如果输出的第一行能看到 OpenBSD 这个单词，就说明你装对了。<br>nc -h</p><p>接下来，用如下命令测试“SSH through Tor SOCKS”是否成功。<br>ssh -o “ProxyCommand=nc -X 5 -x 代理地址:端口号 %h %p” -T <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>注意1：<br>假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为 127.0.0.1<br>否则就替换为：运行 Tor 客户端的主机的 IP 地址。<br>注意2：<br>如果你的 Tor 客户端用的是 Tor Browser，“端口号”必须用 9150<br>如果你用的是 Tor 的其它软件包（比如：Tor Expert Bundle），则“端口号”使用 9050</p><p>上述测试命令如果最终显示 Permession denied 就说明已经通过 SOCKS 代理连接到 GitHub 了（也就是说，你的 SSH 已经能够走 SOCKS 代理联网了）。<br>　　如果没有显示这个信息，而是显示了其它其它信息，你再用如下命令重新试一次<br>ssh -o “ProxyCommand=nc -X 5 -x 代理地址:端口号 %h %p” -Tv <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>这次俺加了一个 v 选项，可以打印出详细的诊断信息（不过都是洋文）。如果你略懂洋文并略懂网络技术，或许能判断出错的原因所在。</p><p>搞定之后，为了方便起见，同样可以把 SSH 的这个 ProxyCommand 命令行选项加入到 SSH 的配置文件。如此一来，以后每次你要连接 GitHub 的服务器，都会自动走 Tor 提供的 SOCKS 代理。<br>　　前面俺已经给出了 SSH 配置文件的示例，俺把之前那个示例文件，加上 ProxyCommand 选项之后，变为如下<br>Host 别名<br>HostName                  <a href="http://ssh.github.com" target="_blank" rel="noopener">ssh.github.com</a><br>Port                      443<br>User                      git<br>PreferredAuthentications  publickey<br>IdentityFile              私钥文件路径<br>ProxyCommand              nc -X 5 -x 代理地址:端口号 %h %p<br>　　注意1：<br>　　假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为 127.0.0.1<br>　　否则就替换为：Tor 客户端所在主机的 IP 地址。<br>　　注意2：<br>　　如果你的 Tor 客户端用的是 Tor Browser，“端口号”必须是 9150<br>　　如果你用的是 Tor 的其它软件包，则“端口号”使用 9050</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;install&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#install&quot;&gt;&lt;/a&gt; install&lt;/h2&gt;
&lt;p&gt;brew install tor&lt;/p&gt;
&lt;h2 id=&quot;config&quot;&gt;&lt;a class=&quot;markdownIt
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>扫盲 netcat（网猫）的 N 种用法——从网络诊断”到“系统入侵</title>
    <link href="https://dreamerjonson.com/2019/11/14/%E6%89%AB%E7%9B%B2-netcat%EF%BC%88%E7%BD%91%E7%8C%AB%EF%BC%89%E7%9A%84-N-%E7%A7%8D%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E2%80%9D%E5%88%B0%E2%80%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5/"/>
    <id>https://dreamerjonson.com/2019/11/14/扫盲-netcat（网猫）的-N-种用法——从网络诊断”到“系统入侵/</id>
    <published>2019-11-14T15:49:56.000Z</published>
    <updated>2019-11-29T13:11:27.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="招数1网络诊断测试某个远程主机的监听端口是否可达"><a class="markdownIt-Anchor" href="#招数1网络诊断测试某个远程主机的监听端口是否可达"></a> ★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达</h2><p>◇使用场景</p><p>经常有这种需求，要判断某个主机的监听端口是否能连上。<br>　　导致监听端口【无法】，通常有两种原因：<br>其一，这个监听端口根本就【没开启】；<br>其二，监听端口虽然开启，但是被防火墙阻拦了。<br>　　对第1个原因，（如果你能在该主机上运行命令）可以直接用 netstat 这个命令查看监听端口是否开启（不懂 netstat 命令的同学，可以看这篇博文）<br>　　但对于第2个原因，netstat 就用不上了。这时候就可以用 nc 来帮你搞定。</p><p>◇方法</p><p>用如下命令可以测试某个 IP 地址（x.x.x.x）上的某个监听端口（xx）是否开启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nv x.x.x.x xx</span><br></pre></td></tr></table></figure><p>上述命令用到了如下几个选项：</p><p>选项 -v<br>　　如果你是 nc 的新手，俺建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。<br>　　在本文后续的举例中，俺会尽量都加上这个选项（但这段话就不再重复唠叨啦）</p><p>选项 -n<br>　　由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；<br>　　反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”。</p><h2 id="补充说明超时设置"><a class="markdownIt-Anchor" href="#补充说明超时设置"></a> ◇补充说明：超时设置</h2><p>在测试链接的时候，如果你【没】使用 -w 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。<br>　　如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“-w 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。<br>nc -nv -w 3 x.x.x.x xx</p><h2 id="招数2网络诊断判断防火墙是否允许-or-禁止某个端口"><a class="markdownIt-Anchor" href="#招数2网络诊断判断防火墙是否允许-or-禁止某个端口"></a> ★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口</h2><p>◇使用场景</p><p>前一个章节（招数1）的场景是——已经有某个网络软件开启了监听端口，然后用 nc 测试端口是否可达。<br>　　现在换另一个场景：<br>　　假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何【验证】自己的配置是 OK 滴？<br>　　更进一步说：如果当前【没有】任何软件开启 8080 这个监听端口，你如何判断：该端口号是否会被防火墙阻拦？<br>　　为了叙述方便，设想如下场景：<br>有两台主机——“主机C”充当客户端，“主机S”充当服务端。<br>然后要判断“主机S”上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。</p><p>◇方法</p><p>在“主机S”上运行 nc，让它在 8080 端口，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lv -p 8080</span><br></pre></td></tr></table></figure><p>选项 -l<br>　　这个选项会让 nc 进入监听模式。</p><p>选项 -p<br>　　这个选项有“选项值”，也就是具体端口号。</p><p>然后在“主机C”上运行 nc，测试“主机S”上的 8080 端口是否可达（具体的命令行参见前一章节“招数1”）</p><p>◇补充说明：如何让 nc 的监听端口【持续开启】</p><p>在默认情况下，nc 开启 listen 模式充当服务端，在接受【第一次】客户端连接之后，就会把监听端口关闭。<br>　　为啥会这样捏？因为当年设计 nc 更多的是作为某种网络诊断/配置工具，并【不是】真拿它当服务端软件来用的。<br>　　如果你想要让 nc 始终监听模式，使之能【重复】接受客户端发起的连接，可以追加 -k 选项。</p><p>◇补充说明：UDP</p><p>上述举例是基于 TCP 协议。如果你要测试 UDP 协议，要记得【两边】的 nc 都要追加 -u 选项。</p><h2 id="招数3渗透测试用-nc-玩端口扫描"><a class="markdownIt-Anchor" href="#招数3渗透测试用-nc-玩端口扫描"></a> ★招数3：（渗透测试）用 nc 玩“端口扫描”</h2><p>◇使用场景</p><p>在“招数1”里面介绍了：如何测试【单个】端口是否可达。<br>　　扩展一下：如果你要测试的不止一个端口，而是某个【范围】的端口。这种行为有个专门的术语叫【端口扫描】。<br>　　“端口扫描”是一把双刃剑——“黑帽子”用这招进行信息收集，为后续的入侵做铺垫；“白帽子”用这招来进行“渗透测试”，以排查自己系统中【尚未屏蔽】的对外监听端口。<br>　　作为一款牛逼的网络瑞士军刀，nc 当然可以用来干这事儿啦。<br>　　顺便说一下：<br>不论是 TCP 还是 UDP，协议规定的【有效】端口号范围都是：1 ~ 65535</p><p>◇方法</p><p>下面这个命令，用来扫描 IP 地址为 x.x.x.x 的主机，扫描的端口范围从 1 到 1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -znv x.x.x.x 1-1024</span><br></pre></td></tr></table></figure><p>选项 -z<br>　　意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。<br>　　选项 -n<br>　　（前面已聊过，参见“招数1”）<br>　　选项 -v<br>　　-v 选项前面也聊过，这里要特地强调一下。<br>　　对 nc 的其它用法，-v 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果。</p><p>◇补充说明：优化输出</p><p>玩“端口扫描”的时候，“-v 选项”会把“成功/失败”的结果统统打印出来。<br>　　通常大伙儿关注的都是“扫描成功”的那些端口。因此，可以用如下命令过滤一下，只打印扫出来的端口。<br>nc -znv x.x.x.x 1-1024  2&gt;&amp;1 | grep succeeded<br>　　由于“-v 选项”产生的输出位于【stderr】，上述命令中的 2&gt;&amp;1 用来把【stderr】合并到【stdout】（注：这种写法只适用于 POSIX 系统上的 shell）<br>　　grep 命令用来进行【过滤】。对于 Windows 系统，默认【没有】grep 命令，需改用 find 命令过滤。</p><p>◇补充说明：超时设置</p><p>如果你要扫描的端口范围，跨度比较大，超时值要【恰到好处】——<br>超时值太大，会浪费时间；超时值太小，可能会遗漏某些端口（端口本身开放，但 nc 还没来得及连上就超时了）<br>　　具体如何设置，参见“招数1”的“补充说明”。</p><p>◇补充说明：【并发】扫描</p><p>如果你设置了较小的超时值，依然嫌慢，还可以用【并发】扫描的方式，进一步提升效率。<br>　　简而言之就是：同时运行多个 nc，分别扫描不同的端口范围。</p><h2 id="招数4隐匿性如何让-nc-走暗网以-tor-为例"><a class="markdownIt-Anchor" href="#招数4隐匿性如何让-nc-走暗网以-tor-为例"></a> ★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例）</h2><p>◇方法</p><p>为了支持代理，nc 的“OpenBSD 变种”增加了两个选项：-X 与 -x</p><p>选项 -x<br>　　该选项表示【代理的位置】，以 x.x.x.x:xxx 的形式表示（中间是【半角冒号】）。</p><p>选项 -X<br>　　该选项表示【代理的类型】，含义如下：<br>选项值含义<br>5SOCKS5 代理<br>4SOCKS4 代理<br>connectCONNECT 型的 HTTP 代理<br>　　上述这几种类型的代理，功能上有啥差异，参见下面这篇博文开头部分的★预备知识章节。<br>《如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）》</p><p>首先，确保你本机已经运行了 Tor；<br>　　然后，拿俺的域名测试一下。如果 nc 的输出中包含 succeeded（参见下面的第2行），说明 OK 啦——nc 已经能通过 Tor 联网。<br>nc -X 5 -x 127.0.0.1:9050 -q 3 -v <a href="http://program-think.blogspot.com" target="_blank" rel="noopener">program-think.blogspot.com</a> 443</p><p>Connection to <a href="http://program-think.blogspot.com" target="_blank" rel="noopener">program-think.blogspot.com</a> 443 port [tcp/https] succeeded!<br>◇补充说明：Tor 暗网的好处</p><p>关于 Tor 的用处/好处，俺在博客上重复唠叨的次数，已经数不清了。<br>　　（简而言之）由于 Tor 暗网的线路会经历“三级跳”＆“三重套”，而且其线路每隔10分钟就会【随机】变换一次。这种变态的玩法，可以让【网络层面】的逆向追溯变得非常非常困难。<br>　　对这方面的更多介绍，参见：《关于 Tor 的常见问题解答》</p><p>◇补充说明：域名解析</p><p>当你用刚才的招数做到【nc over Tor】之后，一旦 nc 的网络行为需要解析域名，会自动通过 Tor 的 SOCKS 代理进行【远程域名解析】。<br>　　也就是说，“DNS 协议”相关数据流也经过 Tor 暗网——这样既可以【防止】“域名解析”暴露你的网络行为，还可以避免 GFW 的“域名污染”。<br>　　关于“DNS 协议”的引申阅读，可以看如下几篇：<br>《扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗／域名污染”》<br>《对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS》</p><p>◇补充说明：设置别名（alias）</p><p>如果你比较懒，觉得每次都输入上述两个代理选项太麻烦，可以为 nc 设置一个【别名】（命令如下）<br>alias nc-tor=‘nc -X 5 -x 127.0.0.1:9050’<br>　　设置好之后，你只要用 nc-tor 就可以自动追加代理选项。<br>　　如果想让别名【永久】生效，要把上述命令加入到：你当前使用的 shell 的启动文件中。<br>　　再次唠叨：“裸 Tor”与“Tor Browser”的监听端口有差异。俺上述命令的 9050 是用于“裸 Tor”。</p><h2 id="招数5信息收集用-nc-探测服务器类型和软件版本以-ssh-为例"><a class="markdownIt-Anchor" href="#招数5信息收集用-nc-探测服务器类型和软件版本以-ssh-为例"></a> ★招数5（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例）</h2><p>如今要【远程管理】服务器，最常用的大概就是 SSH 这种方式了。<br>　　如果某个服务器运行了 SSH 服务端（默认监听端口是 22），那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection to 192.168.1.25 port 22 [tcp/*] succeeded!</span><br><span class="line">SSH-2.0-OpenSSH_for_Windows_7.7</span><br></pre></td></tr></table></figure><p>◇补充说明：批处理 ＆ 自动化</p><p>某些“有心人”甚至可以搞一个脚本，批量探测某个 IP 地址段的 22 端口，然后把找到的服务器信息保存在某个文件中。<br>　　另外，<br>　　有的系统管理员会把 sshd 的监听端口从 22 改为其它数值，想要迷惑攻击者。但这么干，【效果不大】。<br>　　攻击者可以先进行端口扫描，拿到所有已开启的 TCP 监听端口；然后利用上述方法，对这些 TCP 端口进行【自动化】探测，从而判断出哪个端口是 SSH Server。</p><p>◇补充说明：防范措施</p><p>本章节以“SSH Server”举例来说明入侵者如何探测服务端的软件版本。<br>　　除了“SSH Server”，很多其它的服务端软件，也存在类似的【信息暴露】。<br>　　一个谨慎的系统管理员，应该通过定制，【消除 or 伪造】这些信息，从而增加入侵者的攻击成本。</p><h2 id="招数7网络配置基于-nc-的端口转发port-forward"><a class="markdownIt-Anchor" href="#招数7网络配置基于-nc-的端口转发port-forward"></a> ★招数7：（网络配置）基于 nc 的端口转发（Port Forward）</h2><p>◇原理</p><p>用 nc 进行端口转发，需要运行【两个】nc 进程，一个充当“服务端”，另一个是“客户端”，然后用【管道】让把两个进程的“标准输入输出”交叉配对。所谓的“交叉配对”就是——每一个 nc 进程的“标准输出”都【对接】到另一个 nc 进程的“标准输入”。如此一来，就可以完美地建立【双向通讯】。<br>　　玩过命令行的同学，应该都知道：大部分 shell 都支持【管道符】（就是那个竖线符号 |），可以把某个进程的标准输出，重定向给另一个进程的标准输入。但是 shell 的“管道符”只能做到“单向配对”，【无法】做到“交叉配对”。所以还需要再借助另一个管道——也就是“命名管道”。<br>　　“命名管道”洋文叫做“named pipe”，是一种进程间通讯（IPC）的机制。顾名思义，“命名管道”就是有名号滴，而 shell 中使用的那个【管道符】，其本质上是“匿名管道”（无名管道）。<br>　　主流的操作系统（Windows、Linux、UNIX）都支持“命名管道”这种机制。由于俺本人的环境是 Linux，下面只以 Linux 举例。</p><p>◇方法</p><p>步骤1：创建命名管道<br>　　用下面这个简单的命令创建一个“命名管道”，其名称叫做 nc_pipe。（俺用这个名称只是为了举例，你也可以用别的名称）<br>mkfifo nc_pipe</p><p>步骤2：同时启动两个 nc<br>nc -l -p 1234 &lt; nc_pipe | nc 127.0.0.1 5678 &gt; nc_pipe<br>　　运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。</p><p>这个命令有点复杂。技术菜鸟如果看不懂，就算了（没关系滴，不影响你看后续的章节）。<br>　　如果你比较喜欢刨根问底，俺稍微解释一下：<br>　　上述命令行中，前一个 nc 充当【服务端】，后一个 nc 充当【客户端】。命令行中的“管道符”使得“服务端 nc”的输出绑定到“客户端 nc”的输入。然后再用 nc_pipe 这个命名管道做中转，使得“客户端 nc”的输出绑定到“服务端 nc”的输入。从而完成了【交叉配对】。</p><p>◇补充说明：如何让 nc 的监听端口【持续开启】</p><p>参见“招数2”章节中的“补充说明”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep &quot;LISTEN&quot;</span><br></pre></td></tr></table></figure><h2 id="招数9系统管理用-nc-传输文件"><a class="markdownIt-Anchor" href="#招数9系统管理用-nc-传输文件"></a> 招数9：（系统管理）用 nc 传输文件</h2><p>◇使用场景</p><p>有时候，你需要在两台电脑之间传输文件。也可以用 nc 搞定。<br>　　俺猜到某些技术小白会问：为啥不用 Windows 的共享目录？<br>　　反驳的理由很多——<br>反驳1：这个玩意儿只能在 Windows 上用。<br>反驳2：为了使用“共享目录”，需要启用（Enable）系统中的好几个 service，这会增加你系统的【攻击面】。<br>反驳3：启用的 service 越多，占用的内容也越多，影响性能。<br>…<br>　　还有些同学会问：为啥不用 FTP、SSH（或诸如此类的东东）？<br>　　俺觉得：<br>1、如果只是临时传一个文件，还要额外再去装某某软件的客户端/服务端，岂不是很蛋疼？<br>2、任何服务端软件，（从某种意义上说）都是在【增加攻击面】。</p><p>◇方法</p><p>为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2</p><p>你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号）<br>nc -l -p xxx &gt; file2</p><p>然后在【发送端】（A 主机）运行如下命令。<br>nc x.x.x.x xxx &lt; file1<br>　　第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。</p><p>◇补充说明：nc 的性能优势</p><p>用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。<br>　　（不熟悉网络分层的同学，再去复习一下本文开头的 OSI 模型）<br>　　如果你传输的文件【超级大】或者文件数量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言）</p><h2 id="招数10系统管理用-nc-远程备份整个磁盘"><a class="markdownIt-Anchor" href="#招数10系统管理用-nc-远程备份整个磁盘"></a> 招数10：（系统管理）用 nc 远程备份整个磁盘</h2><p>◇使用场景</p><p>当你学会“用 nc 传输文件”，还可以用 nc【复制整个硬盘】。<br>　　无论是对“系统管理员”，还是对“入侵者”甚至是“数据取证人员”，这招都是蛮有用滴。</p><p>考虑到某些读者是“技术菜鸟”，俺稍微说明一下。<br>　　“磁盘复制”【不同于】“在两块磁盘之间复制文件”。两者之间有很多差别，至少包括：<br>　　性能差异——如果“源盘”上有非常多的小文件，“在两块磁盘之间复制文件”就会【非常慢】。<br>　　完整性差异——“磁盘复制”可以确保两块盘的内容是完全一致滴。而如果你仅仅在两块磁盘之间复制文件，很多信息都损失掉了。<br>　　一般来说，“系统管理员”和“入侵者”更看重第1个差异（性能）；而“数据取证人员”更看重第2个差异（完整性）。</p><p>◇原理</p><p>为了传输整个磁盘，你需要用到 dd 命令。这玩意儿源自 UNIX，后来也移植到 Linux 和 Windows。<br>　　俺曾经在如下博文中稍微介绍过 dd 命令的使用。<br>《如何用 ISO 镜像制作 U 盘安装盘（通用方法、无需 WinPE）》<br>　　关于 dd 命令的更详细介绍，可以参见“维基百科”（这里）或“Gnu 官网”（这里）。</p><p>通过 dd 命令，你可以把“整个硬盘”（或者硬盘上的某个“物理分区”、“逻辑分区”）dump 成一个文件。<br>　　在本章节，由于最终目的是要【跨主机备份磁盘】，所以并【不】需要真的把 dd 命令的输出保存成文件，而是把 dd 的输出通过管道符（|）重定向给【本机】的 nc，然后让【本机】的 nc 发送到另一台主机的 nc（参见前一个招数）。</p><p>◇方法</p><p>由于操作物理磁盘会涉及到操作系统的差异，下面俺以 Linux 举例。<br>　　假设你要把 A 主机 /dev/sda 磁盘的【原始数据】整个复制到 B 主机的 /dev/sdb 磁盘。</p><p>你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号）<br>nc -l -p xxx | dd of=/dev/sdb</p><p>然后在【发送端】（A 主机）运行如下命令。<br>dd if=/dev/sda | nc x.x.x.x xxx<br>　　第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。</p><p>◇补充说明：nc 的性能优势</p><p>如今的存储设备越来越大了。“磁盘”或者“分区”，动不动都是几百个 GB，这时候 nc 的【性能优势】就体现出来啦。<br>　　（具体的原因，前一个章节已经分析过了）</p><h2 id="招数11入侵手法用-nc-开启被动连接型后门"><a class="markdownIt-Anchor" href="#招数11入侵手法用-nc-开启被动连接型后门"></a> 招数11：（入侵手法）用 nc 开启【被动】连接型后门</h2><p>既然聊 netcat，很自然地会聊到“黑客/骇客”的入侵招数。<br>　　做这方面的介绍，并【不是】为了传授入侵技巧；而是为了——让那些注重安全性的同学，能做到“知己知彼”。</p><p>◇使用场景</p><p>假设1：你使用的浏览器存在某个安全漏洞，并且该漏洞会让攻击者获得【执行代码】的机会。<br>　　假设2：你在某个公共场合使用某个 wifi 热点上网。遗憾的是，这个热点是攻击者设置的陷阱。<br>　　假设3：设置该陷阱的攻击者，正好也知道：如何利用上述漏洞。<br>　　当这三个假设都成立，攻击者就可以获得在你【本机】执行代码的机会。这时候，攻击者可以下载一个 nc 到你本机，然后用 nc 开启一个【被动】连接型后门。所谓的“【被动】连接型”就是指——nc 开启对外监听端口。<br>　　在该场景中，因为攻击者与你处于【同一个局域网】，攻击者自然能从自己的机器访问到你本机的 nc 后门。</p><p>◇原理</p><p>为了让后门能工作，通常会使用 nc 的 -e 选项，该选项的“选项值”是一个可执行文件的路径。<br>　　设置了该选项之后，当处于监听状态的 nc 接受到某个连接，会启动“选项值”对应的可执行文件（并得到某个进程），nc 会把该进程的“标准输入输出”与网络通讯【对接】。<br>　　为了让这个后门用起来足够爽，攻击者通常会让 nc 去启动一个【shell 进程】。对 Windows 系统而言，就是 cmd.exe；对 POSIX 系统（Linux or UNIX）而言，就是 /bin/sh<br>　　在这种情况下（nc 挂载 shell），攻击者远程连入 nc 的端口，就可以直接在这个 shell 上进行各种操作，其效果类似于 SSH 或（老式的）telnet。</p><p>◇入侵方法</p><p>步骤1<br>　　如果受害者是 Windows 系统，只须如下命令就可以开启一个后门（其中的 xxx 是端口号）<br>nc.exe -l -p xxx -e cmd.exe<br>　　如果受害者是 POSIX 系统（Linux or UNIX），则用如下命令：<br>nc -l -p xxx -e /bin/sh</p><p>步骤2<br>　　后门创建好之后，攻击者在自己机器上也运行 nc（客户端 nc），然后连接到作为后门的 nc（服务端 nc）。一旦连上之后，攻击者就可以在自己的 nc 上看到对方（受害者机器）的 shell 提示符。</p><p>◇补充说明：-e 选项</p><p>据说是考虑到 -e 选项太过危险，nc 的 OpenBSD 变种（在多年前）已经【移除】了该选项。但其实捏，还是可以用间接的方式达到同样的效果（具体如何做，俺就不透露啦）。<br>　　另，“原版 nc”依然有这个选项；nc 的很多其它变种，也依然有这个选项。</p><p>◇【不够】靠谱的防范措施</p><p>在这个场景中，大伙儿可能会想到三个值得改进之处：<br>1、浏览器的漏洞<br>2、使用公共 wifi 热点的习惯<br>3、防火墙的设置</p><p>对第1点<br>　　其实是【无解】滴！因为任何人都无法确保浏览器是【零漏洞】；</p><p>对第2点<br>　　要看每个人的具体情况而定。对有些人而言，“用公共热点上网”属于【刚需】。那就没办法了。</p><p>对第3点<br>　　“防火墙”这招，似乎是比较通用的解决之道。对大部分人而言，桌面 PC 根本就【不必】开启对外监听端口。因此，你可以配置操作系统自带防火墙，禁止【所有的】对外监听端口。<br>　　但是！（俺要开始说【但是】了）<br>　　操作系统自带的防火墙，本身也运行在操作系统【之内】。如果你是以【管理员身份】遭遇入侵，入侵者在进行【代码执行】的时候，就已经具有了【管理员权限】。在这个权限下，入侵者完全有可能“搞定”防火墙。方法有很多种——<br>比如说：把用作后门的端口号，悄悄加入到防火墙的白名单中；<br>再比如说：直接把防火墙的过滤模块干掉；<br>更牛逼的入侵者，甚至可以在【网卡驱动】上做文章——因为网卡驱动位于防火墙的过滤模块【之下】（比防火墙更底层）</p><p>◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS）</p><p>首先，这里所说的“NAT 模式”指的是【虚拟机的网卡模式】。如果你不熟悉虚拟机的网卡模式，建议先看俺写的《扫盲操作系统虚拟机》系列教程。</p><p>要想用这招，步骤如下：<br>1、当然先要安装【虚拟化软件】（VBox、VMware …），<br>2、安装一个虚拟的操作系统（洋文叫“Guest OS”）<br>3、虚拟系统的网卡设置为【NAT】模式</p><p>完成上述步骤后，你就可以在这个虚拟系统中上网。<br>　　NAT 的好处在于【单向可见】。也就是说，Guest OS 可以访问到物理系统（Host OS）【外部】的网络环境；但外部网络环境只能看到 Host OS，看不到 Guest OS。<br>　　在这种配置下，就算某个入侵者完全控制了你的 Guest OS，他/她也【没】办法在 Guest OS 中搭建“被动连接型后门”。换句话说，即使入侵者运行了这种后门，（但由于 NAT 的缘故）后门【无法】接受外部网络的连接，这个后门就【失去意义】啦。</p><p>◇补充说明：“NAT 模式”如何搭配“系统防火墙”？</p><p>上述“NAT 招数”与“系统防火墙”并【不】矛盾。<br>　　也就是说，即使你用了这招，你的物理系统（Host OS）还是要配置系统防火墙，并禁止【所有的】对外监听端口。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h2><p><a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2019/09/Netcat-Tricks.html</a><br><a href="https://program-think.blogspot.com/2016/03/GitHub-Security-Tips.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2016/03/GitHub-Security-Tips.html</a><br><a href="https://program-think.blogspot.com/2019/09/Netcat-Tricks.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2019/09/Netcat-Tricks.html</a><br><a href="https://program-think.blogspot.com/2013/11/tor-faq.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2013/11/tor-faq.html</a><br><a href="https://program-think.blogspot.com/2009/09/break-through-gfw-with-tor.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2009/09/break-through-gfw-with-tor.html</a><br><a href="https://program-think.blogspot.com/2019/04/Proxy-Tricks.html" target="_blank" rel="noopener">https://program-think.blogspot.com/2019/04/Proxy-Tricks.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;招数1网络诊断测试某个远程主机的监听端口是否可达&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#招数1网络诊断测试某个远程主机的监听端口是否可达&quot;&gt;&lt;/a&gt; ★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达&lt;/h2&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[101]-redis</title>
    <link href="https://dreamerjonson.com/2019/11/07/golang-101-redis/"/>
    <id>https://dreamerjonson.com/2019/11/07/golang-101-redis/</id>
    <published>2019-11-07T10:46:19.000Z</published>
    <updated>2019-11-09T13:50:07.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>Redis is an “advanced key-value store”</p><h2 id="redis-data-types"><a class="markdownIt-Anchor" href="#redis-data-types"></a> Redis Data Types</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Strings</span><br><span class="line">Lists</span><br><span class="line">Sets</span><br><span class="line">Sorted/Scored Sets</span><br><span class="line">Hashes</span><br></pre></td></tr></table></figure><h2 id="type"><a class="markdownIt-Anchor" href="#type"></a> type</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> string:                 page:index.html   -&gt; &lt;html&gt;&lt;head&gt;[...]   login_count -&gt; 7464</span><br><span class="line"> set:                    users_logged_in_today  -&gt; &#123; 1, 2, 3, 4, 5 &#125;</span><br><span class="line">List:                          latest_post_ids -&gt;  [201, 204, 209,..]</span><br><span class="line">Hashes                     user:123:session      : time =&gt; 10927353      username =&gt; joe</span><br><span class="line">Sorted Set               joe ~ 1.3483  bert ~ 93.4 fred ~ 283.22 chris ~ 23774.17</span><br></pre></td></tr></table></figure><h2 id="golang-redis-helloworld"><a class="markdownIt-Anchor" href="#golang-redis-helloworld"></a> golang redis helloworld</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/go-redis/redis&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Go Redis Tutorial&quot;)</span><br><span class="line"></span><br><span class="line">client := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr: &quot;localhost:6379&quot;,</span><br><span class="line">Password: &quot;&quot;,</span><br><span class="line">DB: 0,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pong, err := client.Ping().Result()</span><br><span class="line">fmt.Println(pong, err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-docker-配置-redis-主从复制"><a class="markdownIt-Anchor" href="#使用-docker-配置-redis-主从复制"></a> 使用 Docker 配置 Redis 主从复制</h2><p>配置 master 节点<br>编辑 redis-master.conf，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 监听来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br></pre></td></tr></table></figure><p>配置 slave 节点<br>创建 redis-slave1.conf，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 监听来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line"># 即在没有使用bind指令绑定具体地址时</span><br><span class="line"># 或在没有设定密码时</span><br><span class="line"># Redis将拒绝来自外部的连接</span><br><span class="line">protected-mode yes</span><br><span class="line"></span><br><span class="line"># 监听端口</span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"># 启动时不打印logo</span><br><span class="line"># 这个不重要，想看logo就打开它</span><br><span class="line">always-show-logo no</span><br><span class="line"></span><br><span class="line"># 设定密码认证</span><br><span class="line">requirepass redis</span><br><span class="line"></span><br><span class="line"># 禁用KEYS命令</span><br><span class="line"># 一方面 KEYS * 命令可以列出所有的键，会影响数据安全</span><br><span class="line"># 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间</span><br><span class="line"># 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 此外还应禁止 FLUSHALL 和 FLUSHDB 命令</span><br><span class="line"># 这两个命令会清空数据，并且不会失败</span><br><span class="line"></span><br><span class="line"># 配置master节点信息</span><br><span class="line"># 格式：</span><br><span class="line">#slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"># 此处masterip所指定的redis-server-master是运行master节点的容器名</span><br><span class="line"># Docker容器间可以使用容器名代替实际的IP地址来通信</span><br><span class="line">slaveof redis-server-master 6379</span><br><span class="line"></span><br><span class="line"># 设定连接主节点所使用的密码</span><br><span class="line">masterauth &quot;redis&quot;</span><br></pre></td></tr></table></figure><p>创建 redis-slave2.conf，修改监听端口号为 6381，其余配置与 redis-slave1.conf 相同。</p><h2 id="编写-docker-composeyml"><a class="markdownIt-Anchor" href="#编写-docker-composeyml"></a> 编写 docker-compose.yml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  # 主节点的容器</span><br><span class="line">  redis-server-master:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-server-master</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    networks:</span><br><span class="line">      redis-cluster:</span><br><span class="line">        # 为容器指定一个静态IP</span><br><span class="line">        ipv4_address: 10.1.0.2</span><br><span class="line">    environment:</span><br><span class="line">      TZ: &quot;Asia/Shanghai&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      # 映射配置文件和数据目录</span><br><span class="line">      - ./redis-master.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">      - ../data/redis-master:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      # 必要的内核参数</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line">  # 从节点1的容器</span><br><span class="line">  redis-server-slave-1:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-server-slave-1</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis-server-master</span><br><span class="line">    ports:</span><br><span class="line">      - 6380:6380</span><br><span class="line">    networks:</span><br><span class="line">      redis-cluster:</span><br><span class="line">        ipv4_address: 10.1.0.3</span><br><span class="line">    environment:</span><br><span class="line">      TZ: &quot;Asia/Shanghai&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-slave1.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">      - ../data/redis-slave-1:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line">  # 从节点2的容器</span><br><span class="line">  redis-server-slave-2:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-server-slave-2</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis-server-master</span><br><span class="line">    ports:</span><br><span class="line">      - 6381:6381</span><br><span class="line">    networks:</span><br><span class="line">      redis-cluster:</span><br><span class="line">        ipv4_address: 10.1.0.4</span><br><span class="line">    environment:</span><br><span class="line">      TZ: &quot;Asia/Shanghai&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-slave2.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line">      - ../data/redis-slave-2:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  redis-cluster:</span><br><span class="line">    # IP Address Management</span><br><span class="line">    ipam:</span><br><span class="line">      config:</span><br><span class="line">        # 为容器分配一个独立的子网，用来方便为容器指定静态IP</span><br><span class="line">        # 使用独立的子网可以避免IP地址冲突的问题</span><br><span class="line">        - subnet: 10.1.0.0/16</span><br></pre></td></tr></table></figure><p>启动容器<br>在 docker-compose.yml 所在位置执行 docker-compose up 即可启动上述三个容器，docker-compose 会将容器日志打印到终端，在日志中可以看到三个 Redis 服务器在启动过程中的动作，以及从节点加入主节点的信息。</p><p>启动成功后，可以在本机使用 redis-cli 连接至主节点。连接成功后，可以使用 info replication 命令检查主从复制的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=10.1.0.3,port=6380,state=online,offset=476,lag=1</span><br><span class="line">slave1:ip=10.1.0.4,port=6381,state=online,offset=476,lag=0</span><br><span class="line">master_replid:f29d9059a286deb4bbe5360f9c673a2484370205</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:476</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:476</span><br></pre></td></tr></table></figure><p>启动容器<br>在 docker-compose.yml 所在位置执行 docker-compose up 即可启动上述三个容器，docker-compose 会将容器日志打印到终端，在日志中可以看到三个 Redis 服务器在启动过程中的动作，以及从节点加入主节点的信息。</p><p>启动成功后，可以在本机使用 redis-cli 连接至主节点。连接成功后，可以使用 info replication 命令检查主从复制的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379         &gt; redis-cli -h 127.0.0.1  -p 6379 -a redis</span><br><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=10.1.0.3,port=6380,state=online,offset=476,lag=1</span><br><span class="line">slave1:ip=10.1.0.4,port=6381,state=online,offset=476,lag=0</span><br><span class="line">master_replid:f29d9059a286deb4bbe5360f9c673a2484370205</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:476</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:476</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">测试一下</span><br><span class="line">光是启动成功还不够，还需要测试一下从节点是否能同步主节点的数据。</span><br><span class="line"></span><br><span class="line">首先连接到主节点，新增一个 set：</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">好的，在主节点里面成功添加了一条数据。那么接下来连接到 slave-1，看一下数据有没有同步过去：</span><br><span class="line"></span><br><span class="line">127.0.0.1:6380&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6380&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br><span class="line">看来 slave-1 成功的从主节点同步了数据，并且这个节点也按照设定，是一个只读的节点。那么 slave-2 呢？</span><br><span class="line"></span><br><span class="line">127.0.0.1:6381&gt; auth redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6381&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line">127.0.0.1:6381&gt; set foo baz</span><br><span class="line">(error) READONLY You can&apos;t write against a read only replica.</span><br><span class="line">OK，slave-2 也成功的同步了数据，并且正在作为一个只读节点运行着。</span><br></pre></td></tr></table></figure><h2 id="使用-docker-配置-redis-哨兵"><a class="markdownIt-Anchor" href="#使用-docker-配置-redis-哨兵"></a> 使用 Docker 配置 Redis 哨兵</h2><p>编辑 redis-sentinel.conf，修改下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 接受来自外部的连接</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 哨兵的端口号</span><br><span class="line"># 因为各个哨兵节点会运行在单独的Docker容器中</span><br><span class="line"># 所以无需担心端口重复使用</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 配置哨兵的监控参数</span><br><span class="line"># 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># master-name是为这个被监控的master起的名字</span><br><span class="line"># ip是被监控的master的IP或主机名。因为Docker容器之间可以使用容器名访问，所以这里写master节点的容器名</span><br><span class="line"># redis-port是被监控节点所监听的端口号</span><br><span class="line"># quorom设定了当几个哨兵判定这个节点失效后，才认为这个节点真的失效了</span><br><span class="line">sentinel monitor local-master redis-server-master 6379 2</span><br><span class="line"></span><br><span class="line"># 连接主节点的密码</span><br><span class="line"># 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass local-master redis</span><br></pre></td></tr></table></figure><p>配置及启动容器<br>编写 docker-compose.yml<br>这里继续使用 docker-compose 管理容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  # 哨兵的数量应是奇数，以便于哨兵通过投票来作出决策</span><br><span class="line">  redis-sentinel-1:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-sentinel-1</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      # 向外暴露26379端口</span><br><span class="line">      - 26379:26379</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        ipv4_address: 10.1.0.5</span><br><span class="line">    volumes:</span><br><span class="line">      # 将哨兵配置文件和存放数据的文件夹挂载到容器内</span><br><span class="line">      - ./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span><br><span class="line">      - ../data/redis-sentinel-1:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      # 设定容器的内核参数，以消除Redis启动过程中的一个warning</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    # 根据指定的配置文件来启动Redis哨兵</span><br><span class="line">    command: [&quot;redis-sentinel&quot;, &quot;/usr/local/etc/redis/redis-sentinel.conf&quot;]</span><br><span class="line">  redis-sentinel-2:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-sentinel-2</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 26380:26379</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        ipv4_address: 10.1.0.6</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span><br><span class="line">      - ../data/redis-sentinel-2:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-sentinel&quot;, &quot;/usr/local/etc/redis/redis-sentinel.conf&quot;]</span><br><span class="line">  redis-sentinel-3:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis-sentinel-3</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 26381:26379</span><br><span class="line">    networks:</span><br><span class="line">      default:</span><br><span class="line">        ipv4_address: 10.1.0.7</span><br><span class="line">    volumes:</span><br><span class="line">      - ./redis-sentinel.conf:/usr/local/etc/redis/redis-sentinel.conf</span><br><span class="line">      - ../data/redis-sentinel-3:/data</span><br><span class="line">    sysctls:</span><br><span class="line">      net.core.somaxconn: &apos;511&apos;</span><br><span class="line">    command: [&quot;redis-sentinel&quot;, &quot;/usr/local/etc/redis/redis-sentinel.conf&quot;]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      # 因为哨兵容器需要与服务端容器运行在同一网络内</span><br><span class="line">      # 所以这里指定了一个外部的网络</span><br><span class="line">      # 网络名参考《使用Docker配置Redis主从复制》中的注释</span><br><span class="line">      name: server_redis-cluster</span><br></pre></td></tr></table></figure><p>启动容器<br>这里同样使用 docker-compose up -d 启动容器，然后使用 redis-cli 连接到哨兵节点，连接成功后，可以使用 info sentinel 检查哨兵的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:26379&gt; info sentinel</span><br><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name=local-master,status=ok,address=10.1.0.2:6379,slaves=2,sentinels=1</span><br></pre></td></tr></table></figure><p>其中，sentinel_masters:1 说明这个哨兵在监控一个 master，最后一行中写明了 master0 这个节点别名为 local-master，状态为 OK，地址是 10.1.0.2:6379，有 2 个从节点。</p><h2 id="测试一下"><a class="markdownIt-Anchor" href="#测试一下"></a> 测试一下</h2><p>哨兵光是启动了还是不够的，还需要测试一下当被监控节点下线之后，哨兵是否能作出反应。</p><p>首先，停掉 master，slave-1，slave-2，然后观察哨兵的日志，在经过一段时间之后，哨兵宣布有节点下线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:13.581 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:13.582 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:43:14.429 # +sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:43:14.439 # +sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:43:14.470 # +sdown master local-master 10.1.0.2 6379</span><br></pre></td></tr></table></figure><p>然后再启动 master，slave-1，slave-2，并观察哨兵的日志，在节点上线之后，哨兵宣布了节点重启，并解除了节点的下线状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.040 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.082 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.140 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.141 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:45.231 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:45.960 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:45.963 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-1    | 1:X 19 Aug 2019 11:49:46.043 # -sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-3    | 1:X 19 Aug 2019 11:49:46.046 # -sdown master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:46.054 * +reboot master local-master 10.1.0.2 6379</span><br><span class="line">redis-sentinel-2    | 1:X 19 Aug 2019 11:49:46.144 # -sdown master local-master 10.1.0.2 6379</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;/h2&gt;
&lt;p&gt;Redis is an “advanced key-value store”&lt;/p&gt;
&lt;h2 id=&quot;redis-data-types&quot;&gt;&lt;a class=
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[100]-jaeger</title>
    <link href="https://dreamerjonson.com/2019/11/04/golang-100-jaeger/"/>
    <id>https://dreamerjonson.com/2019/11/04/golang-100-jaeger/</id>
    <published>2019-11-04T09:33:50.000Z</published>
    <updated>2019-11-05T14:54:56.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jaeger"><a class="markdownIt-Anchor" href="#jaeger"></a> jaeger</h2><p>1、jaeger是uber公司开发的一种链路追踪工具，是为了应对当前微服务的架构而设计。<br>2、jaeger是opentracing协议的一种实现，opentracing对链路追踪定义了协议。</p><p>要使用jaeger的第一步是搭建jager服务</p><h2 id="docker安装jaeger-server"><a class="markdownIt-Anchor" href="#docker安装jaeger-server"></a> docker安装jaeger server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --rm \</span><br><span class="line">  -p 6831:6831/udp \</span><br><span class="line">  -p 6832:6832/udp \</span><br><span class="line">  -p 16686:16686 \</span><br><span class="line">  jaegertracing/all-in-one:1.7 \</span><br><span class="line">  --log-level=debug</span><br></pre></td></tr></table></figure><h2 id="ui界面"><a class="markdownIt-Anchor" href="#ui界面"></a> UI界面</h2><p><a href="http://localhost:16686/" target="_blank" rel="noopener">http://localhost:16686/</a></p><h2 id="jaeger的使用"><a class="markdownIt-Anchor" href="#jaeger的使用"></a> jaeger的使用</h2><p>trace： 需要首先初始化trace，trace可以理解为span构成的有向无环图。<br>span： span是具体业务的一种抽象<br>A trace is a directed acyclic graph of spans.<br>A span is a logical representation of some work done in your application.<br>Each span has these minimum attributes: an operation name, a start time, and a finish time.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tp, error := jaeger.NewUDPTransport(cfg.JaegerUrl, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"jaeger NewUDPTransport error"</span>)</span><br><span class="line">&#125;</span><br><span class="line">tracer, <span class="built_in">close</span> := jaeger.NewTracer(</span><br><span class="line">serviceName,</span><br><span class="line">jaeger.NewConstSampler(<span class="literal">true</span>),</span><br><span class="line">jaeger.NewRemoteReporter(tp),</span><br><span class="line">jaeger.TracerOptions.MaxTagValueLength(<span class="number">1024</span>),</span><br><span class="line">)</span><br><span class="line">cl.AppendCloser(<span class="built_in">close</span>)</span><br><span class="line">opentracing.InitGlobalTracer(tracer)</span><br></pre></td></tr></table></figure><p>可以通过多种方式创建jaeger，StartSpan(serviceName)创建一个root span<br>我们也可以通过下面的方法创建一个child span。child span 可以理解为父节点的子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StartSpanFromContext、</span><br><span class="line">opentracing.GlobalTracer().StartSpan(req.Method(), ext.RPCServerOption(spCtx))</span><br></pre></td></tr></table></figure><h3 id="jaeger要实现不同程序之间的链路关系需要主动推送信息到server"><a class="markdownIt-Anchor" href="#jaeger要实现不同程序之间的链路关系需要主动推送信息到server"></a> jaeger要实现不同程序之间的链路关系，需要主动推送信息到server</h3><p>In order to continue the trace over the process boundaries and RPC calls, we need a way to propagate the span context over the wire. The OpenTracing API provides two functions in the Tracer interface to do that, Inject(spanContext, format, carrier) and Extract(format, carrier).</p><p>format 和 carrier 就是附带的一些参数，这些参数会被下一个程序接收到。<br>format是这些参数的格式，在openntraceing中有3个标准的格式。<br>The format parameter refers to one of the three standard encodings the OpenTracing API defines:<br>TextMap where span context is encoded as a collection of string key-value pairs,<br>Binary where span context is encoded as an opaque byte array,<br>HTTPHeaders, which is similar to TextMap except that the keys must be safe to be used as HTTP headers.<br>carrier是附带的内容<br>The carrier is an abstraction over the underlying RPC framework. For example, a carrier for TextMap format is an interface that allows the tracer to write key-value pairs via Set(key, value) function, while a carrier for Binary format is simply an io.Writer.</p><h3 id="extract"><a class="markdownIt-Anchor" href="#extract"></a> Extract</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">carrier := opentracing.TextMapCarrier(md)</span><br><span class="line">clientContext, err := tracer.Extract(opentracing.TextMap, carrier)</span><br></pre></td></tr></table></figure><h3 id="inject"><a class="markdownIt-Anchor" href="#inject"></a> Inject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := make(map[string]string)</span><br><span class="line">carrier := opentracing.TextMapCarrier(hash)</span><br><span class="line">e := tracer.Inject(</span><br><span class="line">sp.Context(),</span><br><span class="line">opentracing.TextMap,</span><br><span class="line">carrier)</span><br></pre></td></tr></table></figure><p>在golang中，大量使用了context来进行操作。 在golang实现的jaeger客户端和opentracing中，需要注意span与context的大量api。<br>例如StartSpanFromContext会从context中读取父节点，并生成一个子节点。<br>在opentracing.StartSpan中</p><h2 id="example"><a class="markdownIt-Anchor" href="#example"></a> example</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/log"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"ERROR: Expecting one argument"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer := tracing.Init(<span class="string">"hello-world"</span>)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"></span><br><span class="line">helloTo := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">span := tracer.StartSpan(<span class="string">"say-hello"</span>)</span><br><span class="line">span.SetTag(<span class="string">"hello-to"</span>, helloTo)</span><br><span class="line"></span><br><span class="line">helloStr := fmt.Sprintf(<span class="string">"Hello, %s!"</span>, helloTo)</span><br><span class="line">span.LogFields(</span><br><span class="line">log.String(<span class="string">"event"</span>, <span class="string">"string-format"</span>),</span><br><span class="line">log.String(<span class="string">"value"</span>, helloStr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(helloStr)</span><br><span class="line">span.LogKV(<span class="string">"event"</span>, <span class="string">"println"</span>)</span><br><span class="line"></span><br><span class="line">span.Finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-子关系的span"><a class="markdownIt-Anchor" href="#2-子关系的span"></a> 2、子关系的span</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go"</span></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/log"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"ERROR: Expecting one argument"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer := tracing.Init(<span class="string">"hello-world"</span>)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br><span class="line"></span><br><span class="line">helloTo := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">span := tracer.StartSpan(<span class="string">"say-hello"</span>)</span><br><span class="line">span.SetTag(<span class="string">"hello-to"</span>, helloTo)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">ctx := opentracing.ContextWithSpan(context.Background(), span)</span><br><span class="line"></span><br><span class="line">helloStr := formatString(ctx, helloTo)</span><br><span class="line">printHello(ctx, helloStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//StartSpanFromContext 建立一个span，是父亲节点的一个child。</span></span><br><span class="line"><span class="comment">// If we think of the trace as a directed acyclic graph where nodes are the spans and edges are the causal relationships between them, then the ChildOf option is used to create one such edge between span and rootSpan. In the API the edges are represented by SpanReference type that consists of a SpanContext and a label. The SpanContext represents an immutable, thread-safe portion of the span that can be used to establish references or to propagate it over the wire. The label, or ReferenceType, describes the nature of the relationship. ChildOf relationship means that the rootSpan has a logical dependency on the child span before rootSpan can complete its operation. Another standard reference type in OpenTracing is FollowsFrom, which means the rootSpan is the ancestor in the DAG, but it does not depend on the completion of the child span, for example if the child represents a best-effort, fire-and-forget cache write.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatString</span><span class="params">(ctx context.Context, helloTo <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"formatString"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">helloStr := fmt.Sprintf(<span class="string">"Hello, %s!"</span>, helloTo)</span><br><span class="line">span.LogFields(</span><br><span class="line">log.String(<span class="string">"event"</span>, <span class="string">"string-format"</span>),</span><br><span class="line">log.String(<span class="string">"value"</span>, helloStr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> helloStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(ctx context.Context, helloStr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"printHello"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(helloStr)</span><br><span class="line">span.LogKV(<span class="string">"event"</span>, <span class="string">"println"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-模拟rpc-跨程序进行追踪"><a class="markdownIt-Anchor" href="#3-模拟rpc-跨程序进行追踪"></a> 3、 模拟rpc， 跨程序进行追踪。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先启动publisher与formatter，接着执行master</span><br></pre></td></tr></table></figure><p>master</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go"</span></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/ext"</span></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go/log"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/http"</span></span><br><span class="line"><span class="string">"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"ERROR: Expecting one argument"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer := tracing.Init(<span class="string">"hello-world"</span>)</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br><span class="line"></span><br><span class="line">helloTo := os.Args[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">span := tracer.StartSpan(<span class="string">"say-hello"</span>)</span><br><span class="line">span.SetTag(<span class="string">"hello-to"</span>, helloTo)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">ctx := opentracing.ContextWithSpan(context.Background(), span)</span><br><span class="line"></span><br><span class="line">helloStr := formatString(ctx, helloTo)</span><br><span class="line">printHello(ctx, helloStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatString</span><span class="params">(ctx context.Context, helloTo <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"formatString"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">v := url.Values&#123;&#125;</span><br><span class="line">v.Set(<span class="string">"helloTo"</span>, helloTo)</span><br><span class="line">url := <span class="string">"http://localhost:8081/format?"</span> + v.Encode()</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext.SpanKindRPCClient.Set(span)</span><br><span class="line">ext.HTTPUrl.Set(span, url)</span><br><span class="line">ext.HTTPMethod.Set(span, <span class="string">"GET"</span>)</span><br><span class="line">span.Tracer().Inject(</span><br><span class="line">span.Context(),</span><br><span class="line">opentracing.HTTPHeaders,</span><br><span class="line">opentracing.HTTPHeadersCarrier(req.Header),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">resp, err := xhttp.Do(req)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">helloStr := <span class="keyword">string</span>(resp)</span><br><span class="line"></span><br><span class="line">span.LogFields(</span><br><span class="line">log.String(<span class="string">"event"</span>, <span class="string">"string-format"</span>),</span><br><span class="line">log.String(<span class="string">"value"</span>, helloStr),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> helloStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHello</span><span class="params">(ctx context.Context, helloStr <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">span, _ := opentracing.StartSpanFromContext(ctx, <span class="string">"printHello"</span>)</span><br><span class="line"><span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">v := url.Values&#123;&#125;</span><br><span class="line">v.Set(<span class="string">"helloStr"</span>, helloStr)</span><br><span class="line">url := <span class="string">"http://localhost:8082/publish?"</span> + v.Encode()</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext.SpanKindRPCClient.Set(span)</span><br><span class="line">ext.HTTPUrl.Set(span, url)</span><br><span class="line">ext.HTTPMethod.Set(span, <span class="string">"GET"</span>)</span><br><span class="line">span.Tracer().Inject(span.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := xhttp.Do(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>formatter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">opentracing &quot;github.com/opentracing/opentracing-go&quot;</span><br><span class="line">&quot;github.com/opentracing/opentracing-go/ext&quot;</span><br><span class="line">otlog &quot;github.com/opentracing/opentracing-go/log&quot;</span><br><span class="line">&quot;github.com/yurishkuro/opentracing-tutorial/go/lib/tracing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">tracer, closer := tracing.Init(&quot;formatter&quot;)</span><br><span class="line">defer closer.Close()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(&quot;/format&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">spanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))</span><br><span class="line">span := tracer.StartSpan(&quot;format&quot;, ext.RPCServerOption(spanCtx))</span><br><span class="line">defer span.Finish()</span><br><span class="line"></span><br><span class="line">helloTo := r.FormValue(&quot;helloTo&quot;)</span><br><span class="line">helloStr := fmt.Sprintf(&quot;Hello, %s!&quot;, helloTo)</span><br><span class="line">span.LogFields(</span><br><span class="line">otlog.String(&quot;event&quot;, &quot;string-format&quot;),</span><br><span class="line">otlog.String(&quot;value&quot;, helloStr),</span><br><span class="line">)</span><br><span class="line">w.Write([]byte(helloStr))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(&quot;:8081&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>publisher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">opentracing &quot;github.com/opentracing/opentracing-go&quot;</span><br><span class="line">&quot;github.com/opentracing/opentracing-go/ext&quot;</span><br><span class="line">&quot;github.com/yurishkuro/opentracing-tutorial/go/lib/tracing&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">tracer, closer := tracing.Init(&quot;publisher&quot;)</span><br><span class="line">defer closer.Close()</span><br><span class="line"></span><br><span class="line">http.HandleFunc(&quot;/publish&quot;, func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">spanCtx, _ := tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header))</span><br><span class="line">span := tracer.StartSpan(&quot;publish&quot;, ext.RPCServerOption(spanCtx))</span><br><span class="line">defer span.Finish()</span><br><span class="line"></span><br><span class="line">helloStr := r.FormValue(&quot;helloStr&quot;)</span><br><span class="line">println(helloStr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(&quot;:8082&quot;, nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>jaeger github ：<a href="http://github.com/uber/jaeger-client-go" target="_blank" rel="noopener">github.com/uber/jaeger-client-go</a><br>opentracing   ：<a href="http://github.com/opentracing/opentracing-go" target="_blank" rel="noopener">github.com/opentracing/opentracing-go</a><br>tutorial：      <a href="http://github.com/yurishkuro/opentracing-tutorial" target="_blank" rel="noopener">github.com/yurishkuro/opentracing-tutorial</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jaeger&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jaeger&quot;&gt;&lt;/a&gt; jaeger&lt;/h2&gt;
&lt;p&gt;1、jaeger是uber公司开发的一种链路追踪工具，是为了应对当前微服务的架构而设计。&lt;br&gt;
2、jaeger是op
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>emacs-studynode</title>
    <link href="https://dreamerjonson.com/2019/10/29/emacs-studynode/"/>
    <id>https://dreamerjonson.com/2019/10/29/emacs-studynode/</id>
    <published>2019-10-29T02:03:35.000Z</published>
    <updated>2019-11-19T06:25:15.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="quit-emacs"><a class="markdownIt-Anchor" href="#quit-emacs"></a> QUIT EMACS</h2><p>To quit Emacs, press: <control-x> <control-c>. (Be sure to use <control>,<br>not <command> .)</control></control-c></control-x></p><h2 id="在item2中设置meta键"><a class="markdownIt-Anchor" href="#在item2中设置meta键"></a> 在item2中设置meta键</h2><h3 id="开启"><a class="markdownIt-Anchor" href="#开启"></a> 开启</h3><p>emacs</p><h3 id="开启-不显示splash-screen"><a class="markdownIt-Anchor" href="#开启-不显示splash-screen"></a> 开启-不显示splash screen</h3><p>emacs -Q</p><h3 id="开启特定的文件"><a class="markdownIt-Anchor" href="#开启特定的文件"></a> 开启特定的文件</h3><p>emacs XXX<br>emacs -Q XXX</p><h2 id="stopping-emacs"><a class="markdownIt-Anchor" href="#stopping-emacs"></a> Stopping Emacs</h2><p>C-x C-c</p><h2 id="save-files"><a class="markdownIt-Anchor" href="#save-files"></a> save files</h2><p>press y to save and n to not <a href="http://save.To" target="_blank" rel="noopener">save.To</a> save all of the files at once and then quit, press ! (exclamation mark). To quit<br>immediately, without saving anything more, press q . To save the current file only, but<br>quit without saving anything else, press . (period).</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><p>c-p  previous-line<br>c-n next-line<br>c-f 向后移动一个字符<br>M-f  向后移动一个word<br>C-x C-b   display a list of all your buffers<br>C-x h C-w .清空buffer ( C-x h selects the entire buffer; C-w erases the<br>selection.)<br>C-g 退出指令<br>C-x k kills (deletes) the current buffer</p><p>C-x b  Switch to buffer</p><p>C-x 0 (the number zero). This tells Emacs to kill (get rid of) the selected window<br>C-v to scroll down one screenful<br>M-v to scroll up one screenful<br>M-x 输入命令<br>C-d 消除右边得一个字符<br>C-o open the new line</p><p>C-k   删除后面的所有字符<br>Here are the details for using C-o . If you are at the beginning of a line, C-o<br>creates a new, empty line above the current line. If you are at the end of a line, C-o<br>creates a new, empty line below the current line. If you are within a line, C-o breaks it<br>into two separate lines</p><p>To insert one of these characters into your text, first press C-q . This tells Emacs<br>that the next character is to be taken literally. (Think of the q as meaning “quote”; that<br>is, to take the next key you type literally.) Thus, to insert a <ctrl-c> character, type<br>C-q C-c . To insert a <ctrl-q>, type C-q C-q . To insert a tab, use C-q TAB</ctrl-q></ctrl-c></p><p>C-x BS delete from the current position, backwards, to the beginning of the sentence.(从当前点删到尾)</p><h2 id="撤销-反撤销"><a class="markdownIt-Anchor" href="#撤销-反撤销"></a> 撤销 &amp; 反撤销</h2><p>C-x u  撤销<br>C--  撤销<br>C-/  撤销<br>在撤销的时候如果撤销多了需要进行反撤销<br>具体是用C-f等打断当前撤销操作，接着进行的撤销动作就是反撤销。<br>C-x z 重复之前的操作 重复多次可以只按zzzz</p><h2 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h2><p>C-x 0  delete the select window<br>C-x 1  delete all windows excpet select window<br>C-x 2 Split select window verticall<br>C-x 3 Split select window horizontally<br>C-x o move cursor to the next (other) Windows<br>C-x } Make selected windows wider<br>C-x { Make selected windows narrower<br>C-x ^ Make selected windows narrower</p><h2 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> buffer</h2><p>C-x b When you press C-x b , Emacs will wait for you to enter the name of the buffer with<br>which you want to work. If this buffer already exists, Emacs will just move it into the<br>window. Otherwise, Emacs will create a brand new empty buffer in the window using<br>the name you specified. Thus, C-x b is the command to use when you want to create a<br>new buffer.<br>C-x 4 b tells Emacs to display whichever buffer you specify in a different window<br>C-x 4 C-o command. This is similar to the C-x 4 b command, except that the selected window does not change<br>C-x k  kill a buffer</p><h2 id="file"><a class="markdownIt-Anchor" href="#file"></a> file</h2><p>C-x C-f 打开一个文件的buffer<br>C-x C-v replace buffer contents with specified file<br>C-x C-s Save a buffer to file<br>C-x C-w Save a buffer to special file<br>C-x i insert contents of a file into buffer 把文件插入到此buffer中<br>C-x 4 C-f read a file into next window<br>C-x 4 f   same as C-x 4 C-f<br>C-x 4 r  same as C-x 4 C-f read-only</p><h2 id="cursor"><a class="markdownIt-Anchor" href="#cursor"></a> cursor</h2><p>C-f 后一个字符   C-b  前一个字符<br>M-f 后一个word   M-b 前一个word<br>C-p 前一line    C-n 后一line<br>M-a            M-e    sentence  ？<br>M-{            M-}    paragraph 空格分隔段落<br>C-a            C-e  当前行</p><h2 id="重复一个命令多次"><a class="markdownIt-Anchor" href="#重复一个命令多次"></a> 重复一个命令多次</h2><p>M-number C-p   重复一个命令多次<br>C-u number   重复一个命令多次<br>C-u    repeat the command 4 times<br>C-u C-u    repeat the command 16 times<br>C-u C-u C-u    repeat the command 64 times</p><h2 id="scroll"><a class="markdownIt-Anchor" href="#scroll"></a> scroll</h2><p>C-v scroll down<br>M-v scroll up<br>M-C-v scroll down in next windows<br>M- &lt;  jump to start of the buffer<br>M- &gt;  jump to end of the buffer<br>C-l 将当前行放置在屏幕的中间。<br>M-g g 跳到指定行<br>M-x line-number-mode toggle miinbuf下方显示行</p><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h2><p>C-SPC  标记<br>M-= 统计字符多少<br>C-x C-x  curson到mark的位置。 再次按C-x C-x 交换位置<br>M-@ 设置当前curson的单词末尾<br>M-number M-@ 设置当前curson的number个word后<br>M-h Put region arounnd paragraph<br>C-x h Put region arounnd entire buffer</p><h2 id="operating-the-region"><a class="markdownIt-Anchor" href="#operating-the-region"></a> operating the region</h2><p>C-w kill all the characters<br>C-x C-l Convert the characters to lower<br>C-x C-u Convert the characters to lower<br>M-=   count<br>M-|    Run the shell command use the characters as data    example:M -| sort -u</p><h2 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h2><p>delete不会保存</p><p>ESC number<br>M-:<br>删除空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To continue, the M-\ (&lt;Meta-Backslash&gt;) command erases any space or tab</span><br><span class="line">characters that happen to be on either side of point. This command provides a quick</span><br><span class="line">way to clean up a section of whitespace. For example, say that you have typed the</span><br><span class="line">following text and the cursor is under one of the spaces between tea and ch :</span><br><span class="line">Everything we tea ch you is true.</span><br><span class="line">If you press M-\ , Emacs will erase all the surrounding spaces. The line now</span><br><span class="line">looks like:</span><br><span class="line">Everything we teach you is true.</span><br></pre></td></tr></table></figure><p>M-SPC： 删除空格 保留一个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The M-SPC (&lt;Meta-Space&gt;) command is similar, except that it leaves exactly</span><br><span class="line">one space. Here is an example. You have just typed the line:</span><br><span class="line">The sentence above is only partially correct.</span><br><span class="line">You would like to erase the extra spaces. Move the cursor to one of the spaces</span><br><span class="line">between is and only and press M-SPC . The line is changed to the following:</span><br><span class="line">The sentence above is only partially correct.</span><br></pre></td></tr></table></figure><p>C-x C-o:<br>删除紧临的空行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The C-x C-o command performs the analogous operation for blank lines</span><br></pre></td></tr></table></figure><p>M-^<br>合并到一行，注意curson要放在第二行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Finally, the M-^ command joins two lines into one long one. This command</span><br><span class="line">joins the current line to the one immediately above it, while leaving a single space</span><br><span class="line">between the two groups of text. Any extra spaces (at the end of the first line or at</span><br><span class="line">the beginning of the second line) are removed. For example, say that you have the</span><br><span class="line">following lines of text:</span><br><span class="line">This is the first sentence.</span><br><span class="line">This is the second sentence.</span><br><span class="line">You want to join these two lines. Move the cursor to the second line and press M-^ .</span><br><span class="line">You will now have one long line:</span><br><span class="line">This is the first sentence. This is the second sentence.</span><br><span class="line">The cursor will be at the place where the lines were joined, in this case, at the space</span><br><span class="line">between the two sentences.</span><br></pre></td></tr></table></figure><h2 id="kill-text"><a class="markdownIt-Anchor" href="#kill-text"></a> Kill Text</h2><p>会保留删除的文本<br>C-k     删除后面的文本<br>M-d    kill word<br>M-BS   kill word Forward<br>C-w    kill the region<br>M-z    char</p><p>To erase an entire line: if you are at the beginning of the line, press C -k C-k . If you<br>are not at the beginning of the line, press C-a C-k C-k .</p><h2 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> COPY</h2><p>C-y yank most recently killed text<br>C-u C-y same as .  curson at the beging<br>M-y replace the yank test with previous killed Text<br>M-w Copy region to kill ring,without erasing<br>M-C-W Apend next kill to newest kill ring entry</p><h2 id="correcting"><a class="markdownIt-Anchor" href="#correcting"></a> correcting</h2><p>M - BS  kill the previous word<br>C-x BS kill backwards to beginning of sentence<br>M–M-l change previous word to lower<br>M–M-u change previous word to upper<br>M–M-c change previous word to lower,initial cap<br>M-l change follow  word to lower<br>M-u change follow  word to upper<br>M-c change follow word to lower,initial Cap<br>ESC 10 M-- M-c chage many times<br>C-t transport two adjaent charactors<br>M-t transport two adjaent words<br>C-x C-t transport two adjaen lin</p><h2 id="search"><a class="markdownIt-Anchor" href="#search"></a> search</h2><p>C-s  foword: Incremental search<br>C-s RET foword: no-Incremental search<br>M-s w Foward Non-increment word search<br>M-C-s foword: Incremental regexp  search<br>M-C-s RET  foword: No-Incremental regexp  search</p><p>The basic type of Emacs search is called an INCREMENTAL SEARCH. That<br>means Emacs starts searching as soon as you type a single character. With each<br>character you type, Emacs refines its search.</p><p>C-r  foword: Incremental search<br>C-r RET foword: no-Incremental search<br>M-r w Foward Non-increment word search<br>M-C-r foword: Incremental regexp  search<br>M-C-r  foword: No-Incremental regexp  search</p><p>when you searchig:<br>C-s if you do again . search next<br>C-r  same as<br>C-w Copy the word afer point to search string<br>C-y Copy  kill ring  afer point to search string<br>M-y replace next kill ring</p><h2 id="replace"><a class="markdownIt-Anchor" href="#replace"></a> replace</h2><p>M - %  search and replace<br>M-C- % search and replace regexp<br>M-x replace-string<br>M-x replace-regexp</p><p>• SPC (<space>) to make a replacement and continue.<br>• BS (<backspace>) to skip a replacement and continue.<br>• ! (exclamation mark) to make all the rest of the replacements automatically with<br>no more questions.<br>• RET (<enter>) to quit immediately<br>M-x replace-string makes all the replacements automatically without<br>asking you any questions.</enter></backspace></space></p><p>M-x replace-regexp makes all the replacements automatically, while<br>allowing you to use a regular expression for the search pattern.</p><h2 id="recursive-editing"><a class="markdownIt-Anchor" href="#recursive-editing"></a> Recursive Editing</h2><p>C-r  when you searing and  want interrupt to do other things<br>M-C-c This will stop recursive editing and return you to the search and replace operation, exactly where you left off.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;quit-emacs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#quit-emacs&quot;&gt;&lt;/a&gt; QUIT EMACS&lt;/h2&gt;
&lt;p&gt;To quit Emacs, press: &lt;control-x&gt; &lt;control-c&gt;. (
      
    
    </summary>
    
      <category term="mac" scheme="https://dreamerjonson.com/categories/mac/"/>
    
    
      <category term="mac" scheme="https://dreamerjonson.com/tags/mac/"/>
    
  </entry>
  
</feed>
