<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jonson</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreamerjonson.com/"/>
  <updated>2019-07-19T06:35:28.667Z</updated>
  <id>https://dreamerjonson.com/</id>
  
  <author>
    <name>Jonson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang[83]-golang-mac交叉编译windows程序</title>
    <link href="https://dreamerjonson.com/2019/07/19/golang-83-golang-mac%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91windows%E7%A8%8B%E5%BA%8F/"/>
    <id>https://dreamerjonson.com/2019/07/19/golang-83-golang-mac交叉编译windows程序/</id>
    <published>2019-07-19T06:31:55.000Z</published>
    <updated>2019-07-19T06:35:28.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装mingw"><a class="markdownIt-Anchor" href="#安装mingw"></a> 安装mingw：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install mingw-w64</span><br></pre></td></tr></table></figure><h2 id="编译x64"><a class="markdownIt-Anchor" href="#编译x64"></a> 编译x64</h2><h3 id="可执行"><a class="markdownIt-Anchor" href="#可执行"></a> 可执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -x -v -ldflags &quot;-s -w&quot; -o test_x64.exe</span><br></pre></td></tr></table></figure><h3 id="静态库"><a class="markdownIt-Anchor" href="#静态库"></a> 静态库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -buildmode=c-archive -x -v -ldflags &quot;-s -w&quot; -o bin/x64/x64.a main.go</span><br></pre></td></tr></table></figure><h3 id="动态库"><a class="markdownIt-Anchor" href="#动态库"></a> 动态库</h3><p>将-buildmode=c-archive改为-buildmode=c-shared即可</p><h3 id="编译x86"><a class="markdownIt-Anchor" href="#编译x86"></a> 编译x86</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=1 CC=i686-w64-mingw32-gcc CXX=i686-w64-mingw32-g++ GOOS=windows GOARCH=386 go build -x -v -ldflags &quot;-s -w&quot; -o test_x86.exe</span><br></pre></td></tr></table></figure><h3 id="静态库-2"><a class="markdownIt-Anchor" href="#静态库-2"></a> 静态库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CGO_ENABLED=1 CC=i686-w64-mingw32-gcc CXX=i686-w64-mingw32-g++ GOOS=windows GOARCH=386 go build -buildmode=c-archive -x -v -ldflags &quot;-s -w&quot; -o bin/x86/x86.a main.go</span><br></pre></td></tr></table></figure><h3 id="动态库-2"><a class="markdownIt-Anchor" href="#动态库-2"></a> 动态库</h3><p>将-buildmode=c-archive改为-buildmode=c-shared即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装mingw&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装mingw&quot;&gt;&lt;/a&gt; 安装mingw：&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>anaconda3-python-install</title>
    <link href="https://dreamerjonson.com/2019/07/18/python-install/"/>
    <id>https://dreamerjonson.com/2019/07/18/python-install/</id>
    <published>2019-07-18T08:57:14.000Z</published>
    <updated>2019-07-18T09:01:16.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载适用的安装包"><a class="markdownIt-Anchor" href="#下载适用的安装包"></a> 下载适用的安装包</h2><p>网址：<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">https://www.anaconda.com/download/#macos</a></p><h2 id="安装后"><a class="markdownIt-Anchor" href="#安装后"></a> 安装后</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export PATH = /Users/jackson/anaconda3/bin</span><br><span class="line">conda list</span><br><span class="line">conda create env_name python=3.7</span><br><span class="line">python</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://blog.csdn.net/lq_547762983/article/details/81003528" target="_blank" rel="noopener">https://blog.csdn.net/lq_547762983/article/details/81003528</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载适用的安装包&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#下载适用的安装包&quot;&gt;&lt;/a&gt; 下载适用的安装包&lt;/h2&gt;
&lt;p&gt;网址：&lt;a href=&quot;https://www.anaconda.com/download/#macos&quot; 
      
    
    </summary>
    
      <category term="python" scheme="https://dreamerjonson.com/categories/python/"/>
    
    
      <category term="python" scheme="https://dreamerjonson.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>golang[82]-viper-</title>
    <link href="https://dreamerjonson.com/2019/07/04/golang-82-viper/"/>
    <id>https://dreamerjonson.com/2019/07/04/golang-82-viper/</id>
    <published>2019-07-04T07:07:00.000Z</published>
    <updated>2019-07-04T07:08:04.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="viper中将mapinterfaceinterface转换为mapstringinterface-的逻辑"><a class="markdownIt-Anchor" href="#viper中将mapinterfaceinterface转换为mapstringinterface-的逻辑"></a> viper中将map[interface{}]interface{}转换为map[string]interface{} 的逻辑</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insensitiviseMap</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> key, val := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">switch</span> val.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line"><span class="comment">// nested map: cast and recursively insensitivise</span></span><br><span class="line">val = ToStringMap(val)</span><br><span class="line">insensitiviseMap(val.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;))</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line"><span class="comment">// nested map: recursively insensitivise</span></span><br><span class="line">insensitiviseMap(val.(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lower := strings.ToLower(key)</span><br><span class="line"><span class="keyword">if</span> key != lower &#123;</span><br><span class="line"><span class="comment">// remove old key (not lower-cased)</span></span><br><span class="line"><span class="built_in">delete</span>(m, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update map</span></span><br><span class="line">m[lower] = val</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToString casts an interface to a string type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToString</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">v, _ := ToStringE(i)</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToStringMap casts an interface to a map[string]interface&#123;&#125; type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToStringMap</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">v, _ := ToStringMapE(i)</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToStringMapE casts an interface to a map[string]interface&#123;&#125; type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToStringMapE</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line"><span class="keyword">for</span> k, val := <span class="keyword">range</span> v &#123;</span><br><span class="line">m[ToString(k)] = val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;:</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">err := jsonStringToObject(v, &amp;m)</span><br><span class="line"><span class="keyword">return</span> m, err</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> m, fmt.Errorf(<span class="string">"unable to cast %#v of type %T to map[string]interface&#123;&#125;"</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ToStringE casts an interface to a string type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToStringE</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">i = indirectToStringerOrError(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> s := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line"><span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatBool(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatFloat(s, <span class="string">'f'</span>, <span class="number">-1</span>, <span class="number">64</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatFloat(<span class="keyword">float64</span>(s), <span class="string">'f'</span>, <span class="number">-1</span>, <span class="number">32</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int64</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(s, <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int32</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(<span class="keyword">int</span>(s)), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int16</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(<span class="keyword">int64</span>(s), <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int8</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(<span class="keyword">int64</span>(s), <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(<span class="keyword">int64</span>(s), <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint64</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(<span class="keyword">int64</span>(s), <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint32</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(<span class="keyword">int64</span>(s), <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint16</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(<span class="keyword">int64</span>(s), <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">uint8</span>:</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(<span class="keyword">int64</span>(s), <span class="number">10</span>), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> []<span class="keyword">byte</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> template.HTML:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> template.URL:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> template.JS:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> template.CSS:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> template.HTMLAttr:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(s), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> fmt.Stringer:</span><br><span class="line"><span class="keyword">return</span> s.String(), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> error:</span><br><span class="line"><span class="keyword">return</span> s.Error(), <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"unable to cast %#v of type %T to string"</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonStringToObject attempts to unmarshall a string as JSON into</span></span><br><span class="line"><span class="comment">// the object passed as pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jsonStringToObject</span><span class="params">(s <span class="keyword">string</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">data := []<span class="keyword">byte</span>(s)</span><br><span class="line"><span class="keyword">return</span> json.Unmarshal(data, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// From html/template/content.go</span></span><br><span class="line"><span class="comment">// Copyright 2011 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// indirectToStringerOrError returns the value, after dereferencing as many times</span></span><br><span class="line"><span class="comment">// as necessary to reach the base type (or nil) or an implementation of fmt.Stringer</span></span><br><span class="line"><span class="comment">// or error,</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indirectToStringerOrError</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errorType = reflect.TypeOf((*error)(<span class="literal">nil</span>)).Elem()</span><br><span class="line"><span class="keyword">var</span> fmtStringerType = reflect.TypeOf((*fmt.Stringer)(<span class="literal">nil</span>)).Elem()</span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line"><span class="keyword">for</span> !v.Type().Implements(fmtStringerType) &amp;&amp; !v.Type().Implements(errorType) &amp;&amp; v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() &#123;</span><br><span class="line">v = v.Elem()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v.Interface()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;viper中将mapinterfaceinterface转换为mapstringinterface-的逻辑&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#viper中将mapinterfaceinterface转换为mapstringi
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[81]-mac检查端口暴露</title>
    <link href="https://dreamerjonson.com/2019/06/18/golang-81-golang-docker/"/>
    <id>https://dreamerjonson.com/2019/06/18/golang-81-golang-docker/</id>
    <published>2019-06-18T03:59:30.000Z</published>
    <updated>2019-06-18T04:06:17.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看正在监听的端口"><a class="markdownIt-Anchor" href="#查看正在监听的端口"></a> 查看正在监听的端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -iTCP -sTCP:LISTEN -n -P</span><br></pre></td></tr></table></figure><h2 id="查看端口是否在监听"><a class="markdownIt-Anchor" href="#查看端口是否在监听"></a> 查看端口是否在监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v 192.168.5.192:11111</span><br><span class="line">lsof -i tcp:11111</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看正在监听的端口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#查看正在监听的端口&quot;&gt;&lt;/a&gt; 查看正在监听的端口&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[80]-项目查看过时mod</title>
    <link href="https://dreamerjonson.com/2019/06/13/golang-80-tips-go-mod/"/>
    <id>https://dreamerjonson.com/2019/06/13/golang-80-tips-go-mod/</id>
    <published>2019-06-13T07:07:53.000Z</published>
    <updated>2019-06-14T02:13:03.218Z</updated>
    
    <content type="html"><![CDATA[<p>I’m working on a large (oldish) project that I’ve just migrated to go modules ✅ The conversion of the old vendored files (govendor) has produced a large go.mod file with about 100 direct requires.</p><p>Is there a tool/way of going through this list of requires and printing current version versus latest github version (ie find out-of-date modules)? For example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require (</span><br><span class="line">  github.com/foo/bar v1.2.0</span><br><span class="line">  ...</span><br><span class="line">)</span><br><span class="line">The latest tagged version of foo/bar on github is v1.3.1, I&apos;d like to get a list like:</span><br><span class="line"></span><br><span class="line">package                       current                    latest</span><br><span class="line">github.com/foo/bar            v1.2.0                     v1.3.1</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go list -m -u all | column -t</span><br><span class="line"></span><br><span class="line">fubar</span><br><span class="line">cloud.google.com/go                           v0.26.0                             [v0.40.0]</span><br><span class="line">github.com/BurntSushi/toml                    v0.3.1</span><br><span class="line">github.com/PuerkitoBio/purell                 v1.1.0                              [v1.1.1]</span><br></pre></td></tr></table></figure><h2 id="查看版本依赖"><a class="markdownIt-Anchor" href="#查看版本依赖"></a> 查看版本依赖</h2><p>下面可以看出项目依赖了protobuf@v1.2.0版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; go mod graph | grep github.com/golang/protobuf      </span><br><span class="line"></span><br><span class="line">gitlab.followme.com/FollowmeGo/utils@v0.0.0-20190608152033-4ef278ca4fca github.com/golang/protobuf@v1.2.0</span><br><span class="line">gopkg.in/gorethink/gorethink.v4@v4.1.0 github.com/golang/protobuf@v1.2.0</span><br><span class="line">github.com/hashicorp/go-discover@v0.0.0-20190117190025-e88f86e24f50 github.com/golang/protobuf@v1.2.0</span><br><span class="line">github.com/hashicorp/go-plugin@v0.0.0-20190212232519-b838ffee39ce github.com/golang/protobuf@v1.2.0</span><br><span class="line">github.com/onsi/gomega@v1.4.3 github.com/golang/protobuf@v1.2.0</span><br><span class="line">google.golang.org/appengine@v1.2.0 github.com/golang/protobuf@v1.2.0</span><br><span class="line">github.com/hashicorp/go-plugin@v0.0.0-20181030172320-54b6ff97d818 github.com/golang/protobuf@v1.2.0</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://www.reddit.com/r/golang/comments/c00fw6/finding_whats_outofdate_in_gomod/" target="_blank" rel="noopener">https://www.reddit.com/r/golang/comments/c00fw6/finding_whats_outofdate_in_gomod/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I’m working on a large (oldish) project that I’ve just migrated to go modules ✅ The conversion of the old vendored files (govendor) has p
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>search-update-mod</title>
    <link href="https://dreamerjonson.com/2019/06/13/search-update-mod/"/>
    <id>https://dreamerjonson.com/2019/06/13/search-update-mod/</id>
    <published>2019-06-13T07:04:37.000Z</published>
    <updated>2019-06-13T07:04:37.073Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac-info</title>
    <link href="https://dreamerjonson.com/2019/06/11/mac-info/"/>
    <id>https://dreamerjonson.com/2019/06/11/mac-info/</id>
    <published>2019-06-11T10:13:35.000Z</published>
    <updated>2019-06-11T10:18:12.409Z</updated>
    
    <content type="html"><![CDATA[<p>##exec format error:<br>当出现这一个错误的时候，首先检查文件格式：<br>file program</p><p>查看系统：<br>uname -a</p><h2 id="mac-cpu-info"><a class="markdownIt-Anchor" href="#mac-cpu-info"></a> mac cpu  info</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl machdep.cpu</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##exec format error:&lt;br&gt;
当出现这一个错误的时候，首先检查文件格式：&lt;br&gt;
file program&lt;/p&gt;
&lt;p&gt;查看系统：&lt;br&gt;
uname -a&lt;/p&gt;
&lt;h2 id=&quot;mac-cpu-info&quot;&gt;&lt;a class=&quot;markdownIt-
      
    
    </summary>
    
      <category term="macOS" scheme="https://dreamerjonson.com/categories/macOS/"/>
    
    
      <category term="macOS" scheme="https://dreamerjonson.com/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>golang[79]-mac安装指定版本的protobuf</title>
    <link href="https://dreamerjonson.com/2019/06/11/golang-79-protobuf/"/>
    <id>https://dreamerjonson.com/2019/06/11/golang-79-protobuf/</id>
    <published>2019-06-11T07:19:59.000Z</published>
    <updated>2019-06-11T07:48:15.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看版本"><a class="markdownIt-Anchor" href="#查看版本"></a> 查看版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --version</span><br></pre></td></tr></table></figure><h2 id="brew-安装"><a class="markdownIt-Anchor" href="#brew-安装"></a> brew 安装</h2><p>brew install protobuf</p><h2 id="brew-安装指定版本"><a class="markdownIt-Anchor" href="#brew-安装指定版本"></a> brew 安装指定版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew search protobuf</span><br><span class="line">brew reinstall protobuf@2.5</span><br></pre></td></tr></table></figure><h2 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h2><p>brew uninstall protobuf</p><h2 id="方法2源代码编译"><a class="markdownIt-Anchor" href="#方法2源代码编译"></a> 方法2:源代码编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew install automake</span><br><span class="line">https://github.com/google/protobuf/releases 找到对应版本下载</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">protoc --version   //如果有之前的版本记得删除</span><br></pre></td></tr></table></figure><h2 id="go-gen-protobuf"><a class="markdownIt-Anchor" href="#go-gen-protobuf"></a> go-gen-protobuf</h2><p><a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">https://github.com/golang/protobuf</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout v1.3.0</span><br><span class="line">cd proto-gen-go</span><br><span class="line">go build</span><br><span class="line">go install</span><br><span class="line">即可在$GOPATH/bin中看到</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://blog.csdn.net/qq_21383435/article/details/81035852" target="_blank" rel="noopener">https://blog.csdn.net/qq_21383435/article/details/81035852</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看版本&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#查看版本&quot;&gt;&lt;/a&gt; 查看版本&lt;/h2&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[78]-alfred-awgo</title>
    <link href="https://dreamerjonson.com/2019/05/24/golang-78-alfred-awgo/"/>
    <id>https://dreamerjonson.com/2019/05/24/golang-78-alfred-awgo/</id>
    <published>2019-05-24T03:11:34.000Z</published>
    <updated>2019-05-24T03:25:41.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2、安装</h2><p>go get -u <a href="http://github.com/jason0x43/go-alfred/alfred" target="_blank" rel="noopener">github.com/jason0x43/go-alfred/alfred</a></p><h2 id="3-任意位置新建一个工作目录alfred-web-searches在内部新建一个文件夹workflow"><a class="markdownIt-Anchor" href="#3-任意位置新建一个工作目录alfred-web-searches在内部新建一个文件夹workflow"></a> 3、任意位置新建一个工作目录alfred-web-searches，在内部新建一个文件夹workflow</h2><h2 id="4-alfred中新建workflow打开其文件夹将文件夹中的plist文件以及icon文件移动到-workflow-中"><a class="markdownIt-Anchor" href="#4-alfred中新建workflow打开其文件夹将文件夹中的plist文件以及icon文件移动到-workflow-中"></a> 4、alfred中新建workflow，打开其文件夹，将文件夹中的plist文件以及icon文件移动到 workflow 中</h2><h2 id="5-工作目录alfred-web-searches中编写go文件"><a class="markdownIt-Anchor" href="#5-工作目录alfred-web-searches中编写go文件"></a> 5、 工作目录alfred-web-searches中编写go文件</h2><p>使用awgo</p><h2 id="6-在alfred-web-searches所在目录执行"><a class="markdownIt-Anchor" href="#6-在alfred-web-searches所在目录执行"></a> 6、在alfred-web-searches所在目录执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alfred link</span><br><span class="line">&gt; alfred build</span><br></pre></td></tr></table></figure><p>go的执行文件会出现在workflow中</p><h2 id="7-打开alfred会看到多了一个workflow双击打开"><a class="markdownIt-Anchor" href="#7-打开alfred会看到多了一个workflow双击打开"></a> 7、打开alfred，会看到多了一个workflow，双击打开。</h2><p>会看到./alfred-web-searches $1 代表执行的文件以及输入参数等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2-安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#2-安装&quot;&gt;&lt;/a&gt; 2、安装&lt;/h2&gt;
&lt;p&gt;go get -u &lt;a href=&quot;http://github.com/jason0x43/go-alfred/alfred&quot; t
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[77]-sed快速替换指定字母</title>
    <link href="https://dreamerjonson.com/2019/05/20/golang-77-sed/"/>
    <id>https://dreamerjonson.com/2019/05/20/golang-77-sed/</id>
    <published>2019-05-20T12:25:10.000Z</published>
    <updated>2019-05-28T05:58:34.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速替换"><a class="markdownIt-Anchor" href="#快速替换"></a> 快速替换</h2><p><a href="http://xn--gitlab-9v7ir7c3xowzbo6euxvdws12bf2wblisogno0t.followme.com/CopyTradingGo%E5%AD%97%E7%AC%A6%E7%9A%84%E6%89%80%E6%9C%89go%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">快速替换当前文件夹中包含gitlab.followme.com/CopyTradingGo字符的所有go文件</a> <a href="http://xn--gitlab-ow6o.followme.com/CopyTradingGo" target="_blank" rel="noopener">的gitlab.followme.com/CopyTradingGo</a> <a href="http://xn--fmgo-uh5fp43i8jf.io/trade" target="_blank" rel="noopener">替换为fmgo.io/trade</a><br>sed -i “” ‘s/gitlab.followme.com/CopyTradingGo/fmgo.io/trade/g’ <code>grep -Rl gitlab.followme.com/CopyTradingGo . | grep &quot;.go&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速替换&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#快速替换&quot;&gt;&lt;/a&gt; 快速替换&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://xn--gitlab-9v7ir7c3xowzbo6euxvdws12bf2wblisogno0t.
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[76]-Reflection反射</title>
    <link href="https://dreamerjonson.com/2019/05/18/golang-76-reflection/"/>
    <id>https://dreamerjonson.com/2019/05/18/golang-76-reflection/</id>
    <published>2019-05-18T01:12:41.000Z</published>
    <updated>2019-05-28T06:27:20.334Z</updated>
    
    <content type="html"><![CDATA[<p>Reflection is one of the advanced topics in Go. I will try to make it as simple as possible.<br>This tutorial has the following sections.<br>What is reflection?<br>What is the need to inspect a variable and find its type?<br>reflect package<br>reflect.Type and reflect.Value<br>reflect.Kind<br>NumField() and Field() methods<br>Int() and String() methods<br>Complete program<br>Should reflection be used?<br>Let’s discuss these sections one by one now.</p><h2 id="what-is-reflection"><a class="markdownIt-Anchor" href="#what-is-reflection"></a> What is reflection?</h2><p>Reflection is the ability of a program to inspect its variables and values at run time and find their type. You might not understand what this means but that’s alright. You will get a clear understanding of reflection by the end of this tutorial, so stay with me.</p><h2 id="what-is-the-need-to-inspect-a-variable-and-find-its-type"><a class="markdownIt-Anchor" href="#what-is-the-need-to-inspect-a-variable-and-find-its-type"></a> What is the need to inspect a variable and find its type?</h2><p>The first question anyone gets when learning about reflection is why do we even need to inspect a variable and find its type at runtime when each and every variable in our program is defined by us and we know its type at compile time itself. Well this is true most of the times, but not always.</p><h2 id="let-me-explain-what-i-mean-lets-write-a-simple-program"><a class="markdownIt-Anchor" href="#let-me-explain-what-i-mean-lets-write-a-simple-program"></a> Let me explain what I mean. Let’s write a simple program.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    i := 10</span><br><span class="line">    fmt.Printf(&quot;%d %T&quot;, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, the type of i is known at compile time and we print it in the next line. Nothing magical here.</p><p>Now let’s understand the need to know the type of a variable at run time. Let’s say we want to write a simple function which will take a struct as argument and will create a SQL insert query using it.</p><p>Consider the following program,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">1234</span>,</span><br><span class="line">        customerId: <span class="number">567</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We need to write a function which will take the struct o in the program above as an argument and return the following SQL insert query,</p><p>insert into order values(1234, 567)<br>This function is simple to write. Lets do that now.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(o order)</span> <span class="title">string</span></span> &#123;  </span><br><span class="line">    i := fmt.Sprintf(<span class="string">"insert into order values(%d, %d)"</span>, o.ordId, o.customerId)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">1234</span>,</span><br><span class="line">        customerId: <span class="number">567</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(createQuery(o))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The createQuery function in line no. 12 creates the insert query by using the ordId and customerId fields of o. This program will output,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into order values(1234, 567)</span><br></pre></td></tr></table></figure><p>Now lets take our query creator to the next level. What if we want to generalize our query creator and make it work on any struct. Let me explain what I mean using a program.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">    salary <span class="keyword">int</span></span><br><span class="line">    country <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Our objective is to finish the createQuery function in line no. 16 of the above program so that it takes any struct as argument and creates an insert query based on the struct fields.</p><p>For example, if we pass the struct below</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o := order &#123;  </span><br><span class="line">    ordId: 1234,</span><br><span class="line">    customerId: 567</span><br><span class="line">&#125;</span><br><span class="line">``</span><br></pre></td></tr></table></figure><p>Our createQuery function should return,</p><p>insert into order values (1234, 567)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Similarly if we pass</span><br><span class="line"></span><br><span class="line">e := employee &#123;</span><br><span class="line">       name: &quot;Naveen&quot;,</span><br><span class="line">       id: 565,</span><br><span class="line">       address: &quot;Science Park Road, Singapore&quot;,</span><br><span class="line">       salary: 90000,</span><br><span class="line">       country: &quot;Singapore&quot;,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>it should return,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into employee values(&quot;Naveen&quot;, 565, &quot;Science Park Road, Singapore&quot;, 90000, &quot;Singapore&quot;)</span><br></pre></td></tr></table></figure><p>Since the createQuery function should work with any struct, it takes a interface{} as argument. For simplicity, we will only deal with structs that contain fields of type string and int but this can be extended for any type.</p><p>The createQuery function should work on any struct. The only way to write this function is to examine the type of the struct argument passed to it at run time, find its fields and then create the query. This is where reflection is useful. In the next steps of the tutorial, we will learn how we can achieve this using the reflect package.</p><h2 id="reflect-package"><a class="markdownIt-Anchor" href="#reflect-package"></a> reflect package</h2><p>The reflect package implements run-time reflection in Go. The reflect package helps to identify the underlying concrete type and the value of a interface{} variable. This is exactly what we need. The createQuery function takes a interface{} argument and the query needs to be created based on the concrete type and value of the interface{} argument. This is exactly what the reflect package helps in doing.</p><p>There are a few types and methods in the reflect package which we need to know first before writing our generic query generator program. Lets look at them one by one.</p><h2 id="reflecttype-and-reflectvalue"><a class="markdownIt-Anchor" href="#reflecttype-and-reflectvalue"></a> reflect.Type and reflect.Value</h2><p>The concrete type of interface{} is represented by reflect.Type and the underlying value is represented by reflect.Value. There are two functions reflect.TypeOf() and reflect.ValueOf() which return the reflect.Type and reflect.Value respectively. These two types are the base to create our query generator. Let’s write a simple example to understand these two types.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    t := reflect.TypeOf(q)</span><br><span class="line">    v := reflect.ValueOf(q)</span><br><span class="line">    fmt.Println(<span class="string">"Type "</span>, t)</span><br><span class="line">    fmt.Println(<span class="string">"Value "</span>, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, the createQuery function in line no. 13 takes a interface{} as argument. The function reflect.TypeOf in line no. 14 takes a interface{} as argument and returns the reflect.Type containing the concrete type of the interface{} argument passed. Similarly the reflect.ValueOf function in line no. 15 takes a interface{} as argument and returns the reflect.Value which contains the underlying value of the interface{} argument passed.</p><p>The above program prints,</p><p>Type  main.order<br>Value  {456 56}<br>From the output, we can see that the program prints the concrete type and the value of the interface.</p><h2 id="reflectkind"><a class="markdownIt-Anchor" href="#reflectkind"></a> reflect.Kind</h2><p>There is one more important type in the reflection package called Kind.</p><p>The types Kind and Type in the reflection package might seem similar but they have a difference which will be clear from the program below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type order struct &#123;  </span><br><span class="line">    ordId      int</span><br><span class="line">    customerId int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createQuery(q interface&#123;&#125;) &#123;  </span><br><span class="line">    t := reflect.TypeOf(q)</span><br><span class="line">    k := t.Kind()</span><br><span class="line">    fmt.Println(&quot;Type &quot;, t)</span><br><span class="line">    fmt.Println(&quot;Kind &quot;, k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      456,</span><br><span class="line">        customerId: 56,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The program above outputs,</p><p>Type  main.order<br>Kind  struct<br>I think you will now be clear about the differences between the two. Type represents the actual type of the interface{}, in this case main.Order and Kind represents the specific kind of the type. In this case, it’s a struct.</p><h2 id="numfield-and-field-methods"><a class="markdownIt-Anchor" href="#numfield-and-field-methods"></a> NumField() and Field() methods</h2><p>The NumField() method returns the number of fields in a struct and the Field(i int) method returns the reflect.Value of the ith field.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;</span><br><span class="line">        v := reflect.ValueOf(q)</span><br><span class="line">        fmt.Println(<span class="string">"Number of fields"</span>, v.NumField())</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Field:%d type:%T value:%v\n"</span>, i, v.Field(i), v.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, in line no. 14 we first check whether the Kind of q is a struct because the NumField method works only on struct. The rest of the program is self explanatory. This program outputs,</p><p>Number of fields 2<br>Field:0 type:reflect.Value value:456<br>Field:1 type:reflect.Value value:56</p><h2 id="int-and-string-methods"><a class="markdownIt-Anchor" href="#int-and-string-methods"></a> Int() and String() methods</h2><p>The methods Int and String help extract the reflect.Value as an int64 and string respectively.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">56</span></span><br><span class="line">    x := reflect.ValueOf(a).Int()</span><br><span class="line">    fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">    b := <span class="string">"Naveen"</span></span><br><span class="line">    y := reflect.ValueOf(b).String()</span><br><span class="line">    fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, y, y)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the program above, in line no. 10, we extract the reflect.Value as an int64 and in line no. 13, we extract it as string. This program prints,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type:int64 value:56  </span><br><span class="line">type:string value:Naveen</span><br></pre></td></tr></table></figure><h2 id="complete-program"><a class="markdownIt-Anchor" href="#complete-program"></a> Complete Program</h2><p>Now that we have enough knowledge to finish our query generator, lets go ahead and do it.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ordId      <span class="keyword">int</span></span><br><span class="line">    customerId <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    id      <span class="keyword">int</span></span><br><span class="line">    address <span class="keyword">string</span></span><br><span class="line">    salary  <span class="keyword">int</span></span><br><span class="line">    country <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;</span><br><span class="line">        t := reflect.TypeOf(q).Name()</span><br><span class="line">        query := fmt.Sprintf(<span class="string">"insert into %s values("</span>, t)</span><br><span class="line">        v := reflect.ValueOf(q)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> v.Field(i).Kind() &#123;</span><br><span class="line">            <span class="keyword">case</span> reflect.Int:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s%d"</span>, query, v.Field(i).Int())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s, %d"</span>, query, v.Field(i).Int())</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> reflect.String:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s\"%s\""</span>, query, v.Field(i).String())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">"%s, \"%s\""</span>, query, v.Field(i).String())</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">"Unsupported type"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        query = fmt.Sprintf(<span class="string">"%s)"</span>, query)</span><br><span class="line">        fmt.Println(query)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"unsupported type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">    e := employee&#123;</span><br><span class="line">        name:    <span class="string">"Naveen"</span>,</span><br><span class="line">        id:      <span class="number">565</span>,</span><br><span class="line">        address: <span class="string">"Coimbatore"</span>,</span><br><span class="line">        salary:  <span class="number">90000</span>,</span><br><span class="line">        country: <span class="string">"India"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(e)</span><br><span class="line">    i := <span class="number">90</span></span><br><span class="line">    createQuery(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In line no. 22, we first check whether the passed argument is a struct. In line no. 23 we get the name of the struct from its reflect.Type using the Name() method. In the next line, we use t and start creating the query.</p><p>The case statement in line. 28 checks whether the current field is reflect.Int, if that’s the case we extract the value of that field as int64 using the Int() method. The if else statement is used to handle edge cases. Please add logs to understand why it is needed. Similar logic is used to extract the string in line no. 34.</p><p>We have also added checks to prevent the program from crashing when unsupported types are passed to the createQuery function. The rest of the program is self explanatory. I recommend adding logs at appropriate places and checking their output to understand this program better.</p><p>This program prints,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into order values(456, 56)  </span><br><span class="line">insert into employee values(&quot;Naveen&quot;, 565, &quot;Coimbatore&quot;, 90000, &quot;India&quot;)  </span><br><span class="line">unsupported type</span><br></pre></td></tr></table></figure><p>I would leave it as an exercise for the reader to add the field names to the output query. Please try changing the program to print query of the format,</p><p>insert into order(ordId, customerId) values(456, 56)<br>Should reflection be used?<br>Having shown a practical use of reflection, now comes the real question. Should you be using reflection? I would like to quote Rob Pike’s proverb on the use of reflection which answers this question.</p><p>Clear is better than clever. Reflection is never clear.</p><p>Reflection is a very powerful and advanced concept in Go and it should be used with care. It is very difficult to write clear and maintainable code using reflection. It should be avoided wherever possible and should be used only when absolutely necessary.</p><p>This brings us to and end of this tutorial. Hope you enjoyed it. Have a good day.</p><p>Like my tutorials? Please show your support by donating. Your donations will help me create more awesome tutorials.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Reflection is one of the advanced topics in Go. I will try to make it as simple as possible.&lt;br&gt;
This tutorial has the following sections
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[75]-docker中编译go mod</title>
    <link href="https://dreamerjonson.com/2019/05/16/golang-75-useDocker/"/>
    <id>https://dreamerjonson.com/2019/05/16/golang-75-useDocker/</id>
    <published>2019-05-16T14:19:47.000Z</published>
    <updated>2019-05-28T05:59:33.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在docker中编译-go-mod程序"><a class="markdownIt-Anchor" href="#在docker中编译-go-mod程序"></a> 在docker中编译 Go mod程序。</h2><p>并且可以用到gitlab的私有仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:alpine</span><br><span class="line"></span><br><span class="line">RUN apk update</span><br><span class="line">RUN apk add --no-cache git</span><br><span class="line">RUN apk add openssh</span><br><span class="line">ADD id_ed25519 /root/.ssh/id_ed25519</span><br><span class="line">RUN chmod 600 /root/.ssh/id_ed25519</span><br><span class="line"></span><br><span class="line">RUN echo -e  &quot;[url \&quot;git@gitlab.followme.com:\&quot;]\n\tinsteadOf = https://gitlab.followme.com/&quot; &gt;&gt; /root/.gitconfig</span><br><span class="line"># Skip Host verification for git</span><br><span class="line">RUN echo &quot;StrictHostKeyChecking no &quot; &gt; /root/.ssh/config</span><br><span class="line">WORKDIR /contour</span><br><span class="line">COPY . .</span><br><span class="line">RUN go build -o remote -v viperRemote/viperRemote.go</span><br><span class="line">ENTRYPOINT [&quot;./remote&quot;]</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/paperchain/fetching-private-github-repos-from-a-docker-container-273f25ec5a74" target="_blank" rel="noopener">https://medium.com/paperchain/fetching-private-github-repos-from-a-docker-container-273f25ec5a74</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在docker中编译-go-mod程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#在docker中编译-go-mod程序&quot;&gt;&lt;/a&gt; 在docker中编译 Go mod程序。&lt;/h2&gt;
&lt;p&gt;并且可以用到gitlab的私有仓库：&lt;/
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac-effitive</title>
    <link href="https://dreamerjonson.com/2019/05/15/a-mac-effitive/"/>
    <id>https://dreamerjonson.com/2019/05/15/a-mac-effitive/</id>
    <published>2019-05-15T07:20:17.000Z</published>
    <updated>2019-07-01T03:23:11.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="按住-option-键来快捷缩放窗口"><a class="markdownIt-Anchor" href="#按住-option-键来快捷缩放窗口"></a> 按住 ⌥Option 键来快捷缩放窗口</h2><p>窗口管理应该是每个用户都会有的需求，如果你还没有窗口管理工具，可以在我派搜索到许多款质量不俗的。但如果你不想受制于这些工具硬性规定的窗口尺寸，在某些场景下需要手动调整，按住 ⌥Option 键再缩放窗口则可以获得更加快捷的体验。</p><p>而除此之外，你还可以将常用的文件及文件夹拖拽到 Finder 工具栏，形成快捷入口，只要按住 ⌘Command 键并拖动目标，看到绿色的加号再释放即可，下次使用就不用再「翻箱倒柜」一番了。</p><h2 id="parallels-desktop-共享文件夹"><a class="markdownIt-Anchor" href="#parallels-desktop-共享文件夹"></a> Parallels Desktop 共享文件夹</h2><p>下载ubuntu 共享目录挂载在/media/psf<br>链接  ln -srf /media/psf/src $GOPATH/src</p><p>在ubuntu中使用桥接模式</p><p>步骤             命令                         说明<br>步骤1            sudo su               切换至root用户，ubuntu缺省下root用户有所限制，使用sudo su可以使用当前管理用户的密码切换至root用户，也可以在需要安装权限的命令前加sudo<br>步骤2            apt install openssh-server 安装openssh-server<br>步骤3            ssh -V                      确认openssh-server版本<br>步骤4           /etc/init.d/ssh status     确认openssh-server状态<br>步骤5            /etc/init.d/ssh restart     重新启动 openssh-server<br>步骤6            vim  /etc/ssh/sshd.config    添加：PermisionRootLogin YES<br>步骤7             passwd                        输入新的密码<br>步骤8             ifconfig                      获取ip<br>步骤9             ssh  <a href="mailto:root@10.211.55.4" target="_blank" rel="noopener">root@10.211.55.4</a>         输入新设置的密码</p><p>从终端使用ssh命令连接确认ssh -p 22 <a href="mailto:userkunyu@119.29.37.63" target="_blank" rel="noopener">userkunyu@119.29.37.63</a>  输入密码：</p><h2 id="任务管理工具things-3"><a class="markdownIt-Anchor" href="#任务管理工具things-3"></a> 任务管理工具——things 3</h2><p>快捷键：<br>⌘ + N      Create a new to-do<br>Space     Create a new to-do below selection<br>⌘ + ⇧ + C  Create a checklist in an open to-do<br>⌘ + ⇧ + N  Create a new heading in a project<br>⌘  + D    Duplicate a to-do or project<br>⌘  + C    Copy a to-do or project<br>⌘  + V     Paste a to-do or project<br>⌘  + .    Complete selected items<br>⌘ + ⌥ + .  Cancel selected items<br>Delete    Delete selected items<br>⇧ + ↑      Extend selection upwards<br>⇧ + ↓      Extend selection downwards<br>⌥ + ⇧ + ↑  Extend selection to the top<br>⌥ + ⇧ + ↓  Extend selection to the bottom<br>⌘ + A      Select everything</p><p>⌘  + SShow Jump Start<br>⌘  + TStart Today</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;按住-option-键来快捷缩放窗口&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#按住-option-键来快捷缩放窗口&quot;&gt;&lt;/a&gt; 按住 ⌥Option 键来快捷缩放窗口&lt;/h2&gt;
&lt;p&gt;窗口管理应该是每个用户都会有的需求，如果你还没
      
    
    </summary>
    
      <category term="mac" scheme="https://dreamerjonson.com/categories/mac/"/>
    
    
      <category term="mac" scheme="https://dreamerjonson.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>golang[74]-goland-技巧</title>
    <link href="https://dreamerjonson.com/2019/05/11/golang-74-goland-tips/"/>
    <id>https://dreamerjonson.com/2019/05/11/golang-74-goland-tips/</id>
    <published>2019-05-11T01:59:34.000Z</published>
    <updated>2019-07-04T09:36:48.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="implement-interface"><a class="markdownIt-Anchor" href="#implement-interface"></a> Implement Interface</h2><p>Implement Interface is a hidden gem that can be found by using the common Intellij keystroke combo ⌥ (Option/Alt) + Enter on the struct that you wish to implement the interface. This will open a search window, and you can type the interface that you wish to implement.</p><h2 id="extract-interface"><a class="markdownIt-Anchor" href="#extract-interface"></a> Extract Interface</h2><p>I wish this had a great keyboard combination, but it doesn’t currently by default. If you wish to extract an interface, then you need to Right-Click on struct → Refactor → Extract → Interface. Once the menu pops up it asks you more information, name, file to add to, package…etc. I still use this quite often.<br>you can consider Ctrl+T 6 (Refactor this) as a shortcut for Extract interface</p><h2 id="live-templates"><a class="markdownIt-Anchor" href="#live-templates"></a> Live Templates</h2><p>Live templates are awesome for quickly generating some code that you commonly use. In general, you type in a few characters and then hit tab. Some built in live templates are forr which generates a for range loop (you need the extra “r”) and err which allow you to handle errors quickly. These are really powerful because you can also create your own live templates. For example, if you have a common logging framework when you logged “info” you could create logi as your own template which would generate your “<a href="http://log.info" target="_blank" rel="noopener">log.info</a>” statement. If you have a hard time remembering these, just remember one keyboard combo: ⌘ (Command) + j — this will show you all available templates within the context of the block of code where your cursor is at. Enjoy these examples below:</p><p>forr — for range loop<br>To execute this live template, just type “forr” + tab</p><p>3b. err — check for error and handle<br>To execute this live template, just type “err” + tab</p><h2 id="fill-struct"><a class="markdownIt-Anchor" href="#fill-struct"></a> Fill Struct</h2><p>I am not exactly sure when this was released, but it is glorious. If are familiar constructors in Java or C#, then you were used to a little IDE help when you instantiated a new class. This gives you that same power (albeit a little more clunky). In this case, if you have a struct that you are creating, then if you put your cursor between the brackets {}, then hit ⌥ (Option/Alt) + Enter, it will give you the option of “Fill Struct” or “Fill Struct Recursively”. Choose one. Save your typing for some other fun code, and let this thing do its work!</p><h2 id="generate-test-casestest-file"><a class="markdownIt-Anchor" href="#generate-test-casestest-file"></a> Generate test cases/test file</h2><p>This is probably my favorite. I am pretty passionate about writing testable code and unit testing in general. I really think that writing testable code using SOLID principles will help you design better and more maintainable code. I found this nugget pretty early in my golang learnings, but it is definitely my most used feature. If you put your cursor on a method, type  ⌘ (Command) + n , and this will bring up the “Generate” menu, and from here you can select “Test for function” or “Test for file” and if the <code>_</code>test.go file doesn’t exist, it will create it for you along with the outline of parameterized/table tests for your functions. Pretty awesome.</p><h2 id="refactorings"><a class="markdownIt-Anchor" href="#refactorings"></a> Refactorings</h2><p>Refactorings is another fundamental need one may have when making changes to a program.</p><p>With GoLand, you can extract a function from an expression at the caret, or from a group of selected statements, by using the dedicated Extract action (Alt+Ctrl+M for Windows/Linux and Alt+Cmd+M for macOS), or selecting the Method option in the generic Refactor This popup (Ctrl+T):</p><p>The same refactoring is available for variables (Alt+Ctrl+V for Windows/Linux and Alt+Cmd+V for macOS) and constants (Alt+Ctrl+V for Windows/Linux and Alt+Cmd+V for macOS).</p><p>You can inline a constant, or variable at the caret by using the dedicated Extract action (Alt+Ctrl+M for Windows/Linux and Alt+Cmd+M for macOS), or select the Inline option in the generic Refactor This popup (Ctrl+T). The IDE will update all references to the symbol and replace them with the value:</p><h2 id="navigation"><a class="markdownIt-Anchor" href="#navigation"></a> Navigation</h2><p>One thing that you do more often than write code is read code. GoLand helps here as well. For example, the IDE lets you instantly navigate to an interface implemented by the type at the caret with one click: either by clicking the icon on the left side of the editor, using the dedicated Show Interfaces (Ctrl+U for Windows/Linux and Cmd+U for macOS) action, or by using the corresponding intention action:</p><p>A similar icon, dedicated action (Show Implementations via Ctrl+B for Windows/Linux and Cmd+B for macOS) and intention action can navigate you to types that implement the interface at the caret.</p><p>Every time you see a popup with a list of symbols, be it usages, implementations, implemented interfaces or completion suggestions, you can call Quick Definition (Ctrl+Shift+I for Windows/Linux or Cmd+Y for macOS) or Quick Documentation (Ctrl+Q for Windows/Linux and Ctrl+J for macOS) to have another popup open aside it with the definition or documentation for the selected symbol:</p><p>Navigate back/forward ⌘[ ⌘]</p><p>Expand or collapse a code block in the editor ⌘+ ⌘-    shift</p><p>Show implementation ⌥⌘B    ⌘B</p><p>Quick definition ⌥Space</p><p>Search everywhere  Double Shift<br>importtant               ⌘E<br>Navigate to type hierarchy ⌃H</p><pre><code>Move the current line of code⇧⌘↑ ⇧⌘↓Duplicate a line of code⌘DRemove a line of code⌘⌫Comment or uncomment a line of code⌘/Comment a block of code⌥⌘/Find in the currently opened file⌘FFind and replace in the current file⌘RNext occurrence⌘GPrevious occurrence⇧⌘GNavigate between opened tabs⇧⌘] ⇧⌘[Navigate back/forward⌘[ ⌘]Expand or collapse a code block in the editor⌘+ ⌘-Create new...⌘NWhen you access Basic Completion by pressing ⌃Space, you get basic suggestions for variables, types, methods, expressions, and so on.The Smart Completion feature is aware of the expected type and data flow, and offers the options relevant to the context. To call Smart Completion, press ⌃⇧Space.Quick definition⌥Space    Show implementation⌥⌘BExtract variable⌥⌘VExtract constant⌥⌘CExtract function⌥⌘MIf what you're looking for is plain text, use Find in Path by pressing ⇧⌘F.Just press ⌥F7 and get a list of references grouped by usage type,Run</code></pre><p>⌃R</p><p>Debug</p><p>⌃D</p><p>⌥+F7 查看引用</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://medium.com/@andrey_cheptsov/golands-take-on-go-development-7d2611b14b99" target="_blank" rel="noopener">https://medium.com/@andrey_cheptsov/golands-take-on-go-development-7d2611b14b99</a><br><a href="https://www.jetbrains.com/help/go/discover-goland.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/go/discover-goland.html</a></p><p>select in project view</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;implement-interface&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#implement-interface&quot;&gt;&lt;/a&gt; Implement Interface&lt;/h2&gt;
&lt;p&gt;Implement Interface i
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[73]-context详解</title>
    <link href="https://dreamerjonson.com/2019/05/09/golang-73-context/"/>
    <id>https://dreamerjonson.com/2019/05/09/golang-73-context/</id>
    <published>2019-05-09T09:12:56.000Z</published>
    <updated>2019-05-11T03:25:56.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>golang在1.6.2的时候还没有自己的context，<a href="http://xn--1-xh0b.xn--7golang-g43kv55hkjnx5lcp6avrl.org/x/net/context%E5%8C%85%E8%A2%AB%E5%8A%A0%E5%85%A5%E5%88%B0%E4%BA%86%E5%AE%98%E6%96%B9%E7%9A%84%E5%BA%93%E4%B8%AD%E3%80%82golang" target="_blank" rel="noopener">在1.7的版本中就把golang.org/x/net/context包被加入到了官方的库中。golang</a> 的 Context包，是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。<br>比如有一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。这样的话， 我们就可以通过Context，来跟踪这些goroutine，并且通过Context来控制他们的目的，这就是Go语言为我们提供的Context，中文可以称之为“上下文”。<br>另外一个实际例子是，在Go服务器程序中，每个请求都会有一个goroutine去处理。然而，处理程序往往还需要创建额外的goroutine去访问后端资源，比如数据库、RPC服务等。由于这些goroutine都是在处理同一个请求，所以它们往往需要访问一些共享的资源，比如用户身份信息、认证token、请求截止时间等。而且如果请求超时或者被取消后，所有的goroutine都应该马上退出并且释放相关的资源。这种情况也需要用Context来为我们取消掉所有goroutine<br>如果要使用可以通过 go get <a href="http://golang.org/x/net/context" target="_blank" rel="noopener">golang.org/x/net/context</a> 命令获取这个包。</p><h2 id="context-定义"><a class="markdownIt-Anchor" href="#context-定义"></a> Context 定义</h2><p>ontext的主要数据结构是一种嵌套的结构或者说是单向的继承关系的结构，比如最初的context是一个小盒子，里面装了一些数据，之后从这个context继承下来的children就像在原本的context中又套上了一个盒子，然后里面装着一些自己的数据。或者说context是一种分层的结构，根据使用场景的不同，每一层context都具备有一些不同的特性，这种层级式的组织也使得context易于扩展，职责清晰。<br>context 包的核心是 struct Context，声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Err() error</span><br><span class="line"></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Context是一个interface，在golang里面，interface是一个使用非常广泛的结构，它可以接纳任何类型。Context定义很简单，一共4个方法，我们需要能够很好的理解这几个方法</p><p>Deadline方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</p><p>Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。</p><p>Err方法返回取消的错误原因，因为什么Context被取消。</p><p>Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。</p><h2 id="context-的实现方法"><a class="markdownIt-Anchor" href="#context-的实现方法"></a> Context 的实现方法</h2><p>Context 虽然是个接口，但是并不需要使用方实现，golang内置的context 包，已经帮我们实现了2个方法，一般在代码中，开始上下文的时候都是以这两个作为最顶层的parent context，然后再衍生出子context。这些 Context 对象形成一棵树：当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。两个实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line"></span><br><span class="line">todo = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是Background，主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。<br>一个是TODO，如果我们不知道该使用什么Context的时候，可以使用这个，但是实际应用中，暂时还没有使用过这个TODO。<br>他们两个本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="context-的-继承"><a class="markdownIt-Anchor" href="#context-的-继承"></a> Context 的 继承</h2><p>有了如上的根Context，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure><p>通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。<br>WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。<br>WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。<br>WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。<br>WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。<br>With 系列函数详解<br>WithCancel<br>context.WithCancel生成了一个withCancel的实例以及一个cancelFuc，这个函数就是用来关闭ctxWithCancel中的 Done channel 函数。<br>下面来分析下源码实现，首先看看初始化，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func newCancelCtx(parent Context) cancelCtx &#123;</span><br><span class="line">return cancelCtx&#123;</span><br><span class="line">Context: parent,</span><br><span class="line">done:    make(chan struct&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line">return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newCancelCtx返回一个初始化的cancelCtx，cancelCtx结构体继承了Context，实现了canceler方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*cancelCtx 和 *timerCtx 都实现了canceler接口，实现该接口的类型都可以被直接canceled</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// closed by the first cancel call.</span></span><br><span class="line">    mu       sync.Mutex</span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">bool</span> <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error             <span class="comment">// 当其被cancel时将会把err设置为非nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> c.done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v.WithCancel"</span>, c.Context)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心是关闭c.done</span></span><br><span class="line"><span class="comment">//同时会设置c.err = err, c.children = nil</span></span><br><span class="line"><span class="comment">//依次遍历c.children，每个child分别cancel</span></span><br><span class="line"><span class="comment">//如果设置了removeFromParent，则将c从其parent的children中删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"context: internal error: missing cancel error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// already canceled</span></span><br><span class="line">    &#125;</span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="built_in">close</span>(c.done)</span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> acquiring the child's lock while holding parent's lock.</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c) <span class="comment">// 从此处可以看到 cancelCtx的Context项是一个类似于parent的概念</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，所有的children都存在一个map中；Done方法会返回其中的done channel， 而另外的cancel方法会关闭Done channel并且逐层向下遍历，关闭children的channel，并且将当前canceler从parent中移除。<br>WithCancel初始化一个cancelCtx的同时，还执行了propagateCancel方法，最后返回一个cancel function。<br>propagateCancel 方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// propagateCancel arranges for child to be canceled when parent is.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> parent.Done() == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// parent has already been canceled</span></span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propagateCancel 的含义就是传递cancel，从当前传入的parent开始（包括该parent），向上查找最近的一个可以被cancel的parent， 如果找到的parent已经被cancel，则将方才传入的child树给cancel掉，否则，将child节点直接连接为找到的parent的children中（Context字段不变，即向上的父亲指针不变，但是向下的孩子指针变直接了）； 如果没有找到最近的可以被cancel的parent，即其上都不可被cancel，则启动一个goroutine等待传入的parent终止，则cancel传入的child树，或者等待传入的child终结。<br>WithDeadLine<br>在withCancel的基础上进行的扩展，如果时间到了之后就进行cancel的操作，具体的操作流程基本上与withCancel一致，只不过控制cancel函数调用的时机是有一个timeout的channel所控制的。</p><h2 id="context-使用原则-和-技巧"><a class="markdownIt-Anchor" href="#context-使用原则-和-技巧"></a> Context 使用原则 和 技巧</h2><p>不要把Context放在结构体中，要以参数的方式传递，parent Context一般为Background<br>应该要把Context作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名建议都统一，如ctx。<br>给一个函数方法传递Context的时候，不要传递nil，否则在tarce追踪的时候，就会断了连接<br>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递<br>Context是线程安全的，可以放心的在多个goroutine中传递<br>可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p><h2 id="context的常用方法实例"><a class="markdownIt-Anchor" href="#context的常用方法实例"></a> Context的常用方法实例</h2><p>调用Context Done方法取消</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, err := DoSomething(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> out &lt;- v:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、通过 context.WithValue 来传值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">valueCtx := context.WithValue(ctx, key, <span class="string">"add value"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//get value</span></span><br><span class="line">fmt.Println(ctx.Value(key), <span class="string">"is cancel"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//get value</span></span><br><span class="line">fmt.Println(ctx.Value(key), <span class="string">"int goroutine"</span>)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、超时取消 context.WithTimeout</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"golang.org/x/net/context"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"Doing some work "</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// we received the signal of cancelation in this channel</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">"Cancel the context "</span>, i)</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">4</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Hey, I'm going to do some work"</span>)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> work(ctx)</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Finished. I'm going home"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、截止时间 取消 context.WithDeadline</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d := time.Now().Add(<span class="number">1</span> * time.Second)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Even though ctx will be expired, it is good practice to call its</span></span><br><span class="line"><span class="comment">// cancelation function in any case. Failure to do so may keep the</span></span><br><span class="line"><span class="comment">// context and its parent alive longer than necessary.</span></span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"oversleep"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">go watch(ctx,&quot;【监控1】&quot;)</span><br><span class="line">go watch(ctx,&quot;【监控2】&quot;)</span><br><span class="line">go watch(ctx,&quot;【监控3】&quot;)</span><br><span class="line"></span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">fmt.Println(&quot;可以了，通知监控停止&quot;)</span><br><span class="line">cancel()</span><br><span class="line">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span><br><span class="line">time.Sleep(5 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func watch(ctx context.Context, name string) &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ctx.Done():</span><br><span class="line">fmt.Println(name,&quot;监控退出，停止了...&quot;)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">fmt.Println(name,&quot;goroutine监控中...&quot;)</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h2&gt;
&lt;p&gt;golang在1.6.2的时候还没有自己的context，&lt;a href=&quot;http://xn--1-xh0b.xn--7golang-g43k
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>golang[72]-理解Go标准库中的atomic.Value类型</title>
    <link href="https://dreamerjonson.com/2019/05/09/golang-72-atomic-Value/"/>
    <id>https://dreamerjonson.com/2019/05/09/golang-72-atomic-Value/</id>
    <published>2019-05-09T05:49:43.000Z</published>
    <updated>2019-05-09T06:12:12.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>在 Go 语言标准库中, <font color="#FF0000">sync/atomic</font>包将底层硬件提供的原子操作封装成了 Go 的函数。但这些操作只支持几种基本数据类型，因此为了扩大原子操作的适用范围，Go 语言在 1.4 版本的时候向sync/atomic包中添加了一个新的类型Value。此类型的值相当于一个容器，可以被用来“原子地”存储（Store）和加载（Load）任意类型的值。</p><h2 id="历史起源"><a class="markdownIt-Anchor" href="#历史起源"></a> 历史起源</h2><p>我在golang-dev邮件列表中翻到了14年的这段讨论，有人报告了encoding/gob包在多核机器上（80-core）上的性能问题，认为encoding/gob之所以不能完全利用到多核的特性是因为它里面使用了大量的互斥锁（mutex），如果把这些互斥锁换成用atomic.LoadPointer/StorePointer来做并发控制，那性能将能提升20倍。</p><p>针对这个问题，有人提议在已有的atomic包的基础上封装出一个atomic.Value类型，这样用户就可以在不依赖 Go 内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。所以我们现在看到的atomic包中除了atomic.Value外，其余都是早期由汇编写成的，并且atomic.Value类型的底层实现也是建立在已有的atomic包的基础上。</p><p>那为什么在上面的场景中，atomic会比mutex性能好很多呢？作者 Dmitry Vyukov 总结了这两者的一个区别：</p><p>Mutexes do no scale. Atomic loads do.</p><p>Mutex由操作系统实现，而atomic包中的原子操作则由底层硬件直接提供支持。在 CPU 实现的指令集里，有一些指令被封装进了atomic包，这些指令在执行的过程中是不允许中断（interrupt）的，因此原子操作可以在lock-free的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。</p><p>好了，说了这么多的原子操作，我们先来看看什么样的操作能被叫做原子操作 。</p><p>一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity） 。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。而在现实世界中，CPU 不可能不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣称他们拥有了”不可分割”的原子性。</p><p>有些朋友可能不知道，在 Go（甚至是大部分语言）中，一条普通的赋值语句其实不是一个原子操作。例如，在32位机器上写int64类型的变量有中间状态，它会被拆成两次写操作（MOV）——写低 32 位和写高 32 位，如下图所示：<br>如果一个线程刚写完低32位，还没来得及写高32位时，另一个线程读取了这个变量，那它得到的就是一个毫无逻辑的中间变量，这很有可能使我们的程序出现诡异的 Bug。</p><p>这还只是一个基础类型，如果我们对一个结构体进行赋值，那它出现并发问题的概率就更高了。很可能写线程刚写完一小半的字段，读线程就来读取这个变量，那么就只能读到仅修改了一部分的值。这显然破坏了变量的完整性，读出来的值也是完全错误的。</p><p>面对这种多线程下变量的读写问题，我们的主角——atomic.Value登场了，它使得我们可以不依赖于不保证兼容性的unsafe.Pointer类型，同时又能将任意数据类型的读写操作封装成原子性操作（让中间状态对外不可见）。</p><h2 id="使用姿势"><a class="markdownIt-Anchor" href="#使用姿势"></a> 使用姿势</h2><p>atomic.Value类型对外暴露的方法就两个：</p><p>v.Store© - 写操作，将原始的变量c存放到一个atomic.Value类型的v里。<br>c = v.Load() - 读操作，从线程安全的v中读取上一步存放的内容。<br>简洁的接口使得它的使用也很简单，只需将需要作并发保护的变量读取和赋值操作用Load()和Store()代替就行了。</p><p>下面是一个常见的使用场景。应用程序定期的从外界获取最新的配置信息，然后更改自己内存中维护的配置变量。工作线程根据最新的配置来处理请求。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"sync/atomic"</span></span><br><span class="line">  <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从数据库或者文件系统中读取配置信息，然后以map的形式存放在内存里</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requests</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将从外界中接受到的请求放入到channel里</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// config变量用来存放该服务的配置信息</span></span><br><span class="line">  <span class="keyword">var</span> config atomic.Value</span><br><span class="line">  <span class="comment">// 初始化时从别的地方加载配置文件，并存到config变量里</span></span><br><span class="line">  config.Store(loadConfig())</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 每10秒钟定时的拉取最新的配置信息，并且更新到config变量里</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">      <span class="comment">// 对应于赋值操作 config = loadConfig()</span></span><br><span class="line">      config.Store(loadConfig())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// 创建工作线程，每个工作线程都会根据它所读取到的最新的配置信息来处理请求</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> r := <span class="keyword">range</span> requests() &#123;</span><br><span class="line">        <span class="comment">// 对应于取值操作 c := config</span></span><br><span class="line">        <span class="comment">// 由于Load()返回的是一个interface&#123;&#125;类型，所以我们要先强制转换一下</span></span><br><span class="line">        c := config.Load().(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">        <span class="comment">// 这里是根据配置信息处理请求的逻辑...</span></span><br><span class="line">        _, _ = r, c</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2><p>atomic.Value被设计用来存储任意类型的数据，所以它内部的字段是一个interface{}类型，非常的简单粗暴。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">  v <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了Value外，这个文件里还定义了一个ifaceWords类型，这其实是一个空interface (interface{}）的内部表示格式（参见runtime/runtime2.go中eface的定义）。它的作用是将interface{}类型分解，得到其中的两个字段。</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ifaceWords <span class="keyword">struct</span> &#123;</span><br><span class="line">  typ  unsafe.Pointer</span><br><span class="line">  data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写入store操作"><a class="markdownIt-Anchor" href="#写入store操作"></a> 写入（Store）操作</h2><p>在介绍写入之前，我们先来看一下 Go 语言内部的unsafe.Pointer类型。</p><p>unsafe.Pointer<br>出于安全考虑，Go 语言并不支持直接操作内存，但它的标准库中又提供一种不安全（不保证向后兼容性） 的指针类型unsafe.Pointer，让程序可以灵活的读取/操作内存。</p><p>unsafe.Pointer的特别之处在于，它可以绕过 Go 语言类型系统的检查，与任意的指针类型互相转换。也就是说，如果两种类型具有相同的内存结构，我们可以将unsafe.Pointer当做桥梁，让这两种类型的指针相互转换，从而实现同一份内存拥有两种不同的解读方式。</p><p>比如说，[]byte和string其实内部的存储结构都是一样的，但 Go 语言的类型系统禁止他俩互换。如果借助unsafe.Pointer，我们就可以实现在零拷贝的情况下，将[]byte数组直接转换成string类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bytes := []<span class="keyword">byte</span>&#123;<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>&#125;</span><br><span class="line"></span><br><span class="line">p := unsafe.Pointer(&amp;bytes) <span class="comment">//强制转换成unsafe.Pointer，编译器不会报错</span></span><br><span class="line">str := *(*<span class="keyword">string</span>)(p) <span class="comment">//然后强制转换成string类型的指针，再将这个指针的值当做string类型取出来</span></span><br><span class="line">fmt.Println(str) <span class="comment">//输出 "hello"</span></span><br></pre></td></tr></table></figure><p>知道了unsafe.Pointer的作用，我们可以直接来看代码了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Store</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"sync/atomic: store of nil value into Value"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  vp := (*ifaceWords)(unsafe.Pointer(v))  <span class="comment">// Old value</span></span><br><span class="line">  xp := (*ifaceWords)(unsafe.Pointer(&amp;x)) <span class="comment">// New value</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">    <span class="keyword">if</span> typ == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to start first store.</span></span><br><span class="line">      <span class="comment">// Disable preemption so that other goroutines can use</span></span><br><span class="line">      <span class="comment">// active spin wait to wait for completion; and so that</span></span><br><span class="line">      <span class="comment">// GC does not see the fake type accidentally.</span></span><br><span class="line">      runtime_procPin()</span><br><span class="line">      <span class="keyword">if</span> !CompareAndSwapPointer(&amp;vp.typ, <span class="literal">nil</span>, unsafe.Pointer(^<span class="keyword">uintptr</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">        runtime_procUnpin()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Complete first store.</span></span><br><span class="line">      StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">      StorePointer(&amp;vp.typ, xp.typ)</span><br><span class="line">      runtime_procUnpin()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">uintptr</span>(typ) == ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// First store in progress. Wait.</span></span><br><span class="line">      <span class="comment">// Since we disable preemption around the first store,</span></span><br><span class="line">      <span class="comment">// we can wait with active spinning.</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// First store completed. Check type and overwrite data.</span></span><br><span class="line">    <span class="keyword">if</span> typ != xp.typ &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"sync/atomic: store of inconsistently typed value into Value"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    StorePointer(&amp;vp.data, xp.data)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概的逻辑：</p><p>第5~6行 - 通过unsafe.Pointer将现有的和要写入的值分别转成ifaceWords类型，这样我们下一步就可以得到这两个interface{}的原始类型（typ）和真正的值（data）。<br>从第7行开始就是一个无限 for 循环。配合CompareAndSwap食用，可以达到乐观锁的功效。<br>第8行，我们可以通过LoadPointer这个原子操作拿到当前Value中存储的类型。下面根据这个类型的不同，分3种情况处理。<br>第一次写入（第9~24行） - 一个Value实例被初始化后，它的typ字段会被设置为指针的零值 nil，所以第9行先判断如果typ是 nil 那就证明这个Value还未被写入过数据。那之后就是一段初始写入的操作：<br>runtime_procPin()这是runtime中的一段函数，具体的功能我不是特别清楚，也没有找到相关的文档。这里猜测一下，一方面它禁止了调度器对当前 goroutine 的抢占（preemption），使得它在执行当前逻辑的时候不被打断，以便可以尽快地完成工作，因为别人一直在等待它。另一方面，在禁止抢占期间，GC 线程也无法被启用，这样可以防止 GC 线程看到一个莫名其妙的指向^uintptr(0)的类型（这是赋值过程中的中间状态）。<br>使用CAS操作，先尝试将typ设置为^uintptr(0)这个中间状态。如果失败，则证明已经有别的线程抢先完成了赋值操作，那它就解除抢占锁，然后重新回到 for 循环第一步。<br>如果设置成功，那证明当前线程抢到了这个”乐观锁”，它可以安全的把v设为传入的新值了（19~23行）。注意，这里是先写data字段，然后再写typ字段。因为我们是以typ字段的值作为写入完成与否的判断依据的。<br>第一次写入还未完成（第25~30行）- 如果看到typ字段还是^uintptr(0)这个中间类型，证明刚刚的第一次写入还没有完成，所以它会继续循环，”忙等”到第一次写入完成。<br>第一次写入已完成（第31行及之后） - 首先检查上一次写入的类型与这一次要写入的类型是否一致，如果不一致则抛出异常。反之，则直接把这一次要写入的值写入到data字段。</p><embed id="embed" src="atomic-value.svg" type="image/svg+xml"><h2 id="读取load操作"><a class="markdownIt-Anchor" href="#读取load操作"></a> 读取（Load）操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span> <span class="title">Load</span><span class="params">()</span> <span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  vp := (*ifaceWords)(unsafe.Pointer(v))</span><br><span class="line">  typ := LoadPointer(&amp;vp.typ)</span><br><span class="line">  <span class="keyword">if</span> typ == <span class="literal">nil</span> || <span class="keyword">uintptr</span>(typ) == ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// First store not yet completed.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  data := LoadPointer(&amp;vp.data)</span><br><span class="line">  xp := (*ifaceWords)(unsafe.Pointer(&amp;x))</span><br><span class="line">  xp.typ = typ</span><br><span class="line">  xp.data = data</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取相对就简单很多了，它有两个分支：</p><p>如果当前的typ是 nil 或者^uintptr(0)，那就证明第一次写入还没有开始，或者还没完成，那就直接返回 nil （不对外暴露中间状态）。<br>否则，根据当前看到的typ和data构造出一个新的interface{}返回出去。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文从邮件列表中的一段讨论开始，介绍了atomic.Value的被提出来的历史缘由。然后由浅入深的介绍了它的使用姿势，以及内部实现。让大家不仅知其然，还能知其所以然。</p><p>另外，再强调一遍，原子操作由底层硬件支持，而锁则由操作系统提供的 API 实现。若实现相同的功能，前者通常会更有效率，并且更能利用计算机多核的优势。所以，以后当我们想并发安全的更新一些变量的时候，我们应该优先选择用atomic.Value来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;在 Go 语言标准库中, &lt;font color=&quot;#FF0000&quot;&gt;sync/atomic&lt;/font&gt;包将底层硬件提供的原子操作封装成了 G
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>mac远程windwos</title>
    <link href="https://dreamerjonson.com/2019/05/02/windwos%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/"/>
    <id>https://dreamerjonson.com/2019/05/02/windwos远程登陆/</id>
    <published>2019-05-02T13:47:12.000Z</published>
    <updated>2019-05-02T13:48:07.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windwos设置"><a class="markdownIt-Anchor" href="#windwos设置"></a> windwos设置</h2><p>windows远程登时，如果同一个用户名远程登录用户名或密码不正确，但是直接在机器上却登陆正常。<br>有可能是用户名错误了，有可能是密码错误。<br>当用户名和你的全称不一样时，就很容易出现这种情况。<br>解决方法：<br>直接在命令行输入lusrmgr.msc或者右键点击我的电脑选择管理,选择本地用户和组.右键点击你的用户名，选择修改密码。或者尝试一下使用户名与全称一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;windwos设置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windwos设置&quot;&gt;&lt;/a&gt; windwos设置&lt;/h2&gt;
&lt;p&gt;windows远程登时，如果同一个用户名远程登录用户名或密码不正确，但是直接在机器上却登陆正常。&lt;br
      
    
    </summary>
    
      <category term="智能合约 solidity语法" scheme="https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="mac环境配置" scheme="https://dreamerjonson.com/tags/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>MAC环境配置</title>
    <link href="https://dreamerjonson.com/2019/04/25/tmux/"/>
    <id>https://dreamerjonson.com/2019/04/25/tmux/</id>
    <published>2019-04-25T05:44:19.000Z</published>
    <updated>2019-07-26T13:43:36.104Z</updated>
    
    <content type="html"><![CDATA[<p>注意：本文内容适用于 Tmux 2.3 及以上的版本，但是绝大部分的特性低版本也都适用，鼠标支持、VI 模式、插件管理在低版本可能会与本文不兼容。</p><h2 id="tmux-快捷键-速查表"><a class="markdownIt-Anchor" href="#tmux-快捷键-速查表"></a> Tmux 快捷键 &amp; 速查表</h2><p>启动新会话：</p><pre><code>tmux [new -s 会话名 -n 窗口名]</code></pre><p>恢复会话：</p><pre><code>tmux at [-t 会话名]</code></pre><p>列出所有会话：</p><pre><code>tmux ls</code></pre><p><a name="killSessions"></a>关闭会话：</p><pre><code>tmux kill-session -t 会话名</code></pre><p><a name="killAllSessions"></a>关闭所有会话：</p><pre><code>tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill</code></pre><h3 id="在-tmux-中按下-tmux-前缀-ctrlb然后"><a class="markdownIt-Anchor" href="#在-tmux-中按下-tmux-前缀-ctrlb然后"></a> 在 Tmux 中，按下 Tmux 前缀 <code>ctrl+b</code>，然后：</h3><h3 id="会话"><a class="markdownIt-Anchor" href="#会话"></a> 会话</h3><pre><code>:new&lt;回车&gt;  启动新会话s           列出所有会话$           重命名当前会话</code></pre><h3 id="a-namewindowstabsa窗口-标签页"><a class="markdownIt-Anchor" href="#a-namewindowstabsa窗口-标签页"></a> <a name="WindowsTabs"></a>窗口 (标签页)</h3><pre><code>c  创建新窗口w  列出所有窗口n  后一个窗口p  前一个窗口f  查找窗口,  重命名当前窗口&amp;  关闭当前窗口</code></pre><h2 id="调整窗口排序"><a class="markdownIt-Anchor" href="#调整窗口排序"></a> 调整窗口排序</h2><pre><code>swap-window -s 3 -t 1  交换 3 号和 1 号窗口swap-window -t 1       交换当前和 1 号窗口move-window -t 1       移动当前窗口到 1 号</code></pre><h3 id="a-namepanessplitsa窗格分割窗口"><a class="markdownIt-Anchor" href="#a-namepanessplitsa窗格分割窗口"></a> <a name="PanesSplits"></a>窗格（分割窗口）</h3><pre><code>%  垂直分割&quot;  水平分割o  交换窗格x  关闭窗格⍽  左边这个符号代表空格键 - 切换布局q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格{ 与上一个窗格交换位置} 与下一个窗格交换位置z 切换窗格最大化/最小化</code></pre><h3 id="a-namesyncpanesa同步窗格"><a class="markdownIt-Anchor" href="#a-namesyncpanesa同步窗格"></a> <a name="syncPanes"></a>同步窗格</h3><p>这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:setw synchronize-panes</span><br></pre></td></tr></table></figure><p>你可以指定开或关，否则重复执行命令会在两者间切换。<br>这个选项值针对某个窗口有效，不会影响别的会话和窗口。<br>完事儿之后再次执行命令来关闭。<a href="http://blog.sanctum.geek.nz/sync-tmux-panes/" target="_blank" rel="noopener">帮助</a></p><h3 id="调整窗格尺寸"><a class="markdownIt-Anchor" href="#调整窗格尺寸"></a> 调整窗格尺寸</h3><p>如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格：</p><pre><code>PREFIX : resize-pane -D          当前窗格向下扩大 1 格PREFIX : resize-pane -U          当前窗格向上扩大 1 格PREFIX : resize-pane -L          当前窗格向左扩大 1 格PREFIX : resize-pane -R          当前窗格向右扩大 1 格PREFIX : resize-pane -D 20       当前窗格向下扩大 20 格PREFIX : resize-pane -t 2 -L 20  编号为 2 的窗格向左扩大 20 格</code></pre><h3 id="文本复制模式"><a class="markdownIt-Anchor" href="#文本复制模式"></a> 文本复制模式：</h3><p>按下 <code>PREFIX-[</code> 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中：</p><pre><code>setw -g mode-keys vi</code></pre><p>启用这条配置后，就可以使用 h、j、k、l 来移动光标了。</p><p>想要退出文本复制模式的话，按下回车键就可以了。然后按下 <code>PREFIX-]</code> 粘贴刚才复制的文本。</p><p>一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。</p><p>例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。</p><pre><code>vi             emacs        功能^              M-m          反缩进Escape         C-g          清除选定内容Enter          M-w          复制选定内容j              Down         光标下移h              Left         光标左移l              Right        光标右移L                           光标移到尾行M              M-r          光标移到中间行H              M-R          光标移到首行k              Up           光标上移d              C-u          删除整行D              C-k          删除到行末$              C-e          移到行尾:              g            前往指定行C-d            M-Down       向下滚动半屏C-u            M-Up         向上滚动半屏C-f            Page down    下一页w              M-f          下一个词p              C-y          粘贴C-b            Page up      上一页b              M-b          上一个词q              Escape       退出C-Down or J    C-Down       向下翻C-Up or K      C-Up         向下翻n              n            继续搜索?              C-r          向前搜索/              C-s          向后搜索0              C-a          移到行首Space          C-Space      开始选中               C-t          字符调序</code></pre><h3 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项：</h3><pre><code>d  退出 tmux（tmux 仍在后台运行）t  窗口中央显示一个数字时钟?  列出所有快捷键:  命令提示符</code></pre><h3 id="配置选项"><a class="markdownIt-Anchor" href="#配置选项"></a> 配置选项：</h3><pre><code># 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page)* set -g mouse on# 设置默认终端模式为 256colorset -g default-terminal &quot;screen-256color&quot;# 启用活动警告setw -g monitor-activity onset -g visual-activity on# 居中窗口列表set -g status-justify centre# 最大化/恢复窗格unbind Up bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmpunbind Downbind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp</code></pre><h3 id="参考配置文件~tmuxconf"><a class="markdownIt-Anchor" href="#参考配置文件~tmuxconf"></a> 参考配置文件（~/.tmux.conf）：</h3><p>下面这份配置是我使用 Tmux 几年来逐渐精简后的配置，请自取。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Tmux 基本配置 - 要求 Tmux &gt;= 2.3</span></span><br><span class="line"><span class="comment"># 如果不想使用插件，只需要将此节的内容写入 ~/.tmux.conf 即可</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近</span></span><br><span class="line"><span class="built_in">set</span> -g prefix C-z</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g base-index         1     <span class="comment"># 窗口编号从 1 开始计数</span></span><br><span class="line"><span class="built_in">set</span> -g display-panes-time 10000 <span class="comment"># PREFIX-Q 显示编号的驻留时长，单位 ms</span></span><br><span class="line"><span class="built_in">set</span> -g mouse              on    <span class="comment"># 开启鼠标</span></span><br><span class="line"><span class="built_in">set</span> -g pane-base-index    1     <span class="comment"># 窗格编号从 1 开始计数</span></span><br><span class="line"><span class="built_in">set</span> -g renumber-windows   on    <span class="comment"># 关掉某个窗口后，编号重排</span></span><br><span class="line"></span><br><span class="line">setw -g allow-rename      off   <span class="comment"># 禁止活动进程修改窗口名</span></span><br><span class="line">setw -g automatic-rename  off   <span class="comment"># 禁止自动命名新窗口</span></span><br><span class="line">setw -g mode-keys         vi    <span class="comment"># 进入复制模式的时候使用 vi 键位（默认是 EMACS）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 使用插件 - via tpm</span></span><br><span class="line"><span class="comment">#   1. 执行 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</span></span><br><span class="line"><span class="comment">#   2. 执行 bash ~/.tmux/plugins/tpm/bin/install_plugins</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">setenv -g TMUX_PLUGIN_MANAGER_PATH <span class="string">'~/.tmux/plugins'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐的插件（请去每个插件的仓库下读一读使用教程）</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'seebi/tmux-colors-solarized'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-pain-control'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-prefix-highlight'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-resurrect'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-sensible'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tmux-yank'</span></span><br><span class="line"><span class="built_in">set</span> -g @plugin <span class="string">'tmux-plugins/tpm'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux-resurrect</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-dir <span class="string">'~/.tmux/resurrect'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tmux-prefix-highlight</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">'#&#123;prefix_highlight&#125; #H | %a %Y-%m-%d %H:%M'</span></span><br><span class="line"><span class="built_in">set</span> -g @prefix_highlight_show_copy_mode <span class="string">'on'</span></span><br><span class="line"><span class="built_in">set</span> -g @prefix_highlight_copy_mode_attr <span class="string">'fg=white,bg=blue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 TPM 插件管理器 (放在配置文件的最后)</span></span><br><span class="line">run <span class="string">'~/.tmux/plugins/tpm/tpm'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 结束</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><h2 id="fzf"><a class="markdownIt-Anchor" href="#fzf"></a> fzf</h2><p>官方文档给的基本操作是 cd<code>**</code>+Tab生成列表+Enter生成命令+Enter执行 快捷键可以把4步变成两步 还是很Nice<br>ctrl+R<br>ctrl+T</p><p>特别介绍一下Preview 功能</p><p>我们知道在Unix环境下 我们要看文件的时候 必须一个个打开 当文件数量较大的场景</p><p>比如说 我们调了10个参数 做了20组实验 每组实验拿到30轮结果 这时候 一个个vim开 怕不是要吐了 这时候你是不是开始怀念有GUI的世界</p><p>当然 你可以写个bash脚本 把所有的文件合到一个文件 然后 只看一个file就行了</p><p>fzf给出了另外一个炫酷的解决方案</p><h1 id="set-alias"><a class="markdownIt-Anchor" href="#set-alias"></a> set alias</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.zshrc</span><br><span class="line">alias pp=&apos;fzf --preview &apos;&quot;&apos;&quot;&apos;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || rougify &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&apos;&quot;&apos;&quot;</span><br><span class="line">alias oo=&apos;fzf --preview &apos;&quot;&apos;&quot;&apos;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || rougify &#123;&#125; || tac &#123;&#125;) 2&gt; /dev/null | head -500&apos;&quot;&apos;&quot;  # flashback</span><br><span class="line">$ source ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="iterm2"><a class="markdownIt-Anchor" href="#iterm2"></a> ITerm2</h2><p>可定制化Hotkey, 一键召出iTerm2 (不再需要⌘+Tab 或者 通过spotlight切换)<br>快捷的组合键<br>⌘+Shift+E 召唤时间线<br>⌘+Option+b 时光机<br>⌘+T 新Tab<br>⌘+D 水平分屏<br>⌘+← 切换Tab / ⌘+shift+← 切换分屏<br>关闭panel：⌘ + w</p><p>最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次还原</p><p>按下 Command + T 可以新建一个 Tab，每个标签页的后面都会标记一个序号，通过 Command + 序号 就可以在多个页面之间切换了，或者用 Command + [ 和 Command + ] 来切换到左侧或者右侧的标签页。</p><p>同一个 Tab 内，还可以切分出多个 Pane，有两种切分方式：</p><p>Command + D：水平切分，切分出一左一右两个 Pane<br>Command + Shift + D：垂直切分，切分出一上一下两个 Pane<br>通过 Command + Ctrl + 方向键 可以调整每个 Pane 的大小，通过 Command + Option + 方向键 可以切换 Pane。</p><h2 id="mac系统快捷键进阶"><a class="markdownIt-Anchor" href="#mac系统快捷键进阶"></a> MAC系统快捷键进阶</h2><p>除了 Command + C/V 这种入门必备的快捷键，还有一些系统级的常用快捷键是有必要掌握一下的。</p><p>光标移动<br>这里比较推荐使用 Emacs 系的快捷键而不是传统的 Command + ←/→/Delete之类的。因为后者并不通用，比如在终端中就无法使用，而 Emacs 系的快捷键则在几乎所有系统级别的输入框内都通用。</p><p>常见的几个行级别操作有：</p><p>Ctrl + A：移动到行首<br>Ctrl + E：移动到行尾<br>Ctrl + K：删除到行尾<br>Ctrl + N：移动到下一行<br>Ctrl + P：移动到上一行<br>前三个命令在终端中非常常用，能大幅度提高工作效率。后两个命令则在 Vim 系列中很常见，多用于上下切换列表中的选项。</p><p>几个比较常见的字母级别操作有：</p><p>Ctrl + F：向右（Forward）移动一个字母，等价于方向键 →<br>Ctrl + B：向左（Backward）移动一个字母，等价于方向键 ←<br>Ctrl + D：向右删除一个字母，等价于 → + Delete这个快捷键也很常用<br>Ctrl + H：向左删除一个字母，等价于 Delete<br>使用 Option 键<br>如果觉得按字母操作太过于细粒度，按行操作又太粗粒度，那么 Option 键绝对算得上神器，因为它可以按单词操作。</p><p>Option + ←：光标向左移动一个单词<br>Option + →：光标向右移动一个单词<br>Option + Delete：删除一个单词<br>使用 Shift 键<br>Shift 键类似于可视模式，比如在某个位置点击光标并按住 shift 键不松开，再去另一个位置点击一次，就可以选中两次点击位置之间的文本内容。</p><p>注意，shift 键可视模式还可以和 Option 键一起合用，感兴趣的读者可以自行尝试。</p><h2 id="max连接-visulbox中的ubuntu-使用ssh服务器"><a class="markdownIt-Anchor" href="#max连接-visulbox中的ubuntu-使用ssh服务器"></a> max连接 visulBOX中的Ubuntu   使用ssh服务器</h2><p>在ubuntu中使用桥接模式</p><p>步骤             命令                         说明<br>步骤1            sudo su             切换至root用户，ubuntu缺省下root用户有所限制，使用sudo su可以使用当前管理用户的密码切换至root用户，也可以在需要安装权限的命令前加sudo<br>步骤2            apt install openssh-server安装openssh-server<br>步骤3            ssh -V                 确认openssh-server版本<br>步骤4           /etc/init.d/ssh status确认openssh-server状态<br>步骤5            /etc/init.d/ssh restart重新启动 openssh-server</p><p>vim  /etc/ssh/sshd.config</p><p>permisionRootLogin YES<br>修改unixpassword</p><p>ifconfig获取ip<br>从终端使用ssh命令连接确认ssh -p 22 <a href="mailto:userkunyu@119.29.37.63" target="_blank" rel="noopener">userkunyu@119.29.37.63</a>  输入密码：</p><h2 id="virsualbox共享文件夹"><a class="markdownIt-Anchor" href="#virsualbox共享文件夹"></a> virsualBox共享文件夹</h2><p>共享文件夹为：go文件<br>sudo su<br>挂载：mount -t vboxsf go /mnt<br>软连接：ln -s   /mnt/go /home/jackson/go</p><h2 id="mac-通过ssh连接windwos-windwos-的环境配置"><a class="markdownIt-Anchor" href="#mac-通过ssh连接windwos-windwos-的环境配置"></a> mac 通过ssh连接windwos &amp; windwos 的环境配置</h2><p>1、安装 OpenSSH Server<br>2、开启服务<br>安装完成后打开服务管理器，把 OpenSSH Authentication Agent 服务和 OpenSSH SSH Server 服务都设置为自启动，并启动这两个服务：<br>OPENSSH Authentication<br>OpenSSH SSH server</p><p>3\监听端口<br>启动服务后可以通过 netstat 命令查看 SSH Server 服务是不是已经开始监听默认的 22 号端口了：</p><p>4\防火墙规则 或者关闭所有防火墙<br>在安装 OpenSSH Server 的时候会在防火墙的入站规则中添加一条记录让防火墙放行对 22 号端口的访问：</p><p>服务器端的配置文件目录<br>服务器端的配置文件在 C:\ProgramData\ssh 目录中，注意 C:\ProgramData 是一个隐藏目录：</p><p>安装目录<br>Windows 系统中 OpenSSH 的安装目录为 C:\Windows\System32\OpenSSH，不管是客户端程序还是服务器端程序都这这个目录中：</p><p>OpenSSH 服务器端程序的默认配置文件 sshd_config_default 也在这个目录中。这个目录会被添加到 PATH 环境变量中：</p><h2 id="前面我们介绍的-ssh-命令都是通过密码认证连接服务器的下面介绍通过秘钥认证的方式登录服务器"><a class="markdownIt-Anchor" href="#前面我们介绍的-ssh-命令都是通过密码认证连接服务器的下面介绍通过秘钥认证的方式登录服务器"></a> 前面我们介绍的 ssh 命令都是通过密码认证连接服务器的，下面介绍通过秘钥认证的方式登录服务器。</h2><p>1、在 PowerShell 中执行 notepad .ssh\authorized_keys 命令创建文本文件，把客户端的公钥复制到这个文件中并保存。<br>把文本文件的名称修改为 authorized_keys：</p><p>2、修改 ssh 服务的配置文件<br>以管理员权限打开 PowerShell，执行命令 notepad C:\ProgramData\ssh\sshd_config。<br>注释掉配置文件中的最后两行然后保存：<br>#Match Group administrators</p><h1 id="authorizedkeysfile-programdatasshadministrators_authorized_keys"><a class="markdownIt-Anchor" href="#authorizedkeysfile-programdatasshadministrators_authorized_keys"></a> AuthorizedKeysFile <strong>PROGRAMDATA</strong>/ssh/administrators_authorized_keys</h1><p>3、最后在服务管理器器中重启 OpenSSH SSH Server 服务，然后客户端就可以通过公钥认证的方式登录到远程服务器了。</p><h2 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后</h2><p>在 Windows 系统中，PowerShell 已逐渐成为主流，我们可以把默认的 shell 设置为 PowerShell。其实就是在运行 OpenSSH Server 的 Windows 系统的注册表中添加一个配置项，注册表路径为 HKEY_LOCAL_MACHINE\SOFTWARE\OpenSSH，项的名称为 DefaultShell，项的值为 C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe。我们可以以管理员身份启动 PowerShell，然后执行下面的命令完成注册表项的添加：</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://www.cnblogs.com/sparkdev/p/10166061.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/10166061.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：本文内容适用于 Tmux 2.3 及以上的版本，但是绝大部分的特性低版本也都适用，鼠标支持、VI 模式、插件管理在低版本可能会与本文不兼容。&lt;/p&gt;
&lt;h2 id=&quot;tmux-快捷键-速查表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#t
      
    
    </summary>
    
      <category term="开发配置" scheme="https://dreamerjonson.com/categories/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="开发配置" scheme="https://dreamerjonson.com/tags/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>git操作github-gitlab</title>
    <link href="https://dreamerjonson.com/2019/04/02/connect-github-gitlab/"/>
    <id>https://dreamerjonson.com/2019/04/02/connect-github-gitlab/</id>
    <published>2019-04-02T07:43:32.000Z</published>
    <updated>2019-07-01T03:11:16.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="克隆"><a class="markdownIt-Anchor" href="#克隆"></a> 克隆</h2><p>有两种方式，一种是通过ssh,一种是通过http</p><p>使用ssh的方式需要在本机生成ssh文件，<br>参考资料：<a href="https://gitlab.followme.com/help/ssh/README#generating-a-new-ssh-key-pair" target="_blank" rel="noopener">https://gitlab.followme.com/help/ssh/README#generating-a-new-ssh-key-pair</a></p><h3 id="产生ssh"><a class="markdownIt-Anchor" href="#产生ssh"></a> 产生SSH</h3><p>To create a new SSH key pair:<br>Open a terminal on Linux or macOS, or Git Bash / WSL on Windows.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Generate a new ED25519 SSH key pair:</span><br><span class="line">ssh-keygen -t ed25519 -C &quot;email@example.com&quot;</span><br><span class="line"></span><br><span class="line">Or, if you want to use RSA:</span><br><span class="line">ssh-keygen -o -t rsa -b 4096 -C &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="adding-an-ssh-key-to-your-gitlab-account"><a class="markdownIt-Anchor" href="#adding-an-ssh-key-to-your-gitlab-account"></a> Adding an SSH key to your GitLab account</h3><p>Copy your public SSH key to the clipboard by using one of the commands below<br>depending on your Operating System:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">macOS:</span><br><span class="line">pbcopy &lt; ~/.ssh/id_ed25519.pub</span><br><span class="line"></span><br><span class="line">WSL / GNU/Linux (requires the xclip package):</span><br><span class="line">xclip -sel clip &lt; ~/.ssh/id_ed25519.pub</span><br><span class="line"></span><br><span class="line">Git Bash on Windows:</span><br><span class="line">cat ~/.ssh/id_ed25519.pub | clip</span><br></pre></td></tr></table></figure><h3 id="go-mod-中下载依赖包时可以使用"><a class="markdownIt-Anchor" href="#go-mod-中下载依赖包时可以使用"></a> go mod 中下载依赖包时，可以使用</h3><p>go build  .<br>但是下载有时候会出现问题，例如：<br>我运行go mod download 提示 fatal: could not read Username for ‘<a href="https://gitlab.XXX.com" target="_blank" rel="noopener">https://gitlab.XXX.com</a>’: terminal prompts disabled</p><p>这时，需要通过ssh的方式下载gitlab中的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br></pre></td></tr></table></figure><p>添加：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[url &quot;ssh://git@gitlab.XXX.com/&quot;]</span><br><span class="line">insteadOf = https://gitlab.XXX.com/</span><br></pre></td></tr></table></figure><h2 id="查看分支"><a class="markdownIt-Anchor" href="#查看分支"></a> 查看分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="将远程分支-dev-到本地dev-并切换到dev分支"><a class="markdownIt-Anchor" href="#将远程分支-dev-到本地dev-并切换到dev分支"></a> 将远程分支 dev 到本地dev 并切换到dev分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git fetch origin dev  存疑</span><br><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br><span class="line"></span><br><span class="line">git push -f origin dev 强制更新</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r .idea</span><br></pre></td></tr></table></figure><h2 id="添加远程"><a class="markdownIt-Anchor" href="#添加远程"></a> 添加远程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add camel-snipet git@gitlab.followme.com:camel/go-snipet.git</span><br><span class="line"></span><br><span class="line"> git remote -v</span><br><span class="line"></span><br><span class="line"> git push camel-snipet dev</span><br></pre></td></tr></table></figure><h2 id="回退"><a class="markdownIt-Anchor" href="#回退"></a> 回退</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard a7e1d279</span><br></pre></td></tr></table></figure><h2 id="mac添加环境变量"><a class="markdownIt-Anchor" href="#mac添加环境变量"></a> mac添加环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">操作步骤:</span><br><span class="line">1、打开Terminal（终端）</span><br><span class="line">2、输入：vim ~/.bash_profile</span><br><span class="line">3、设置PATH：export PATH=/usr/local/mysql/bin:$PATH</span><br><span class="line">4、输入：:wq    //保存并退出vi</span><br><span class="line">5、修改立即生效：source ~/.bash_profile</span><br><span class="line">6、查看环境变量的值：echo $PATH</span><br></pre></td></tr></table></figure><p>go run main.go --registry=consul  --registry_address=“127.0.0.1:8500”</p><p>consul：<br>自动将服务添加到consul<br>UI ：<a href="http://localhost:8500" target="_blank" rel="noopener">http://localhost:8500</a></p><p>##gitlab Runner</p><p>To install GitLab Runner using Homebrew:</p><p>Install the GitLab Runner.</p><p>brew install gitlab-runner</p><p>Install the Runner as a service and start it.</p><p>brew services start gitlab-runner</p><p>Runner is installed and running.</p><p>gitlab-runner register<br>gitlab-runner stop<br>gitlab-runner register<br>gitlab-runner unregister --all-runners</p><p>./gitlab-runner run</p><h2 id="当远程分支有冲突强制"><a class="markdownIt-Anchor" href="#当远程分支有冲突强制"></a> 当远程分支有冲突，强制</h2><p>git fetch --all<br>git reset --hard origin/master</p><h2 id="merge"><a class="markdownIt-Anchor" href="#merge"></a> merge</h2><p>git merge -Xtheirs dev<br>git merge -Xou   rs dev</p><h2 id="工作区回到最后一次提交的状态"><a class="markdownIt-Anchor" href="#工作区回到最后一次提交的状态"></a> 工作区回到最后一次提交的状态。</h2><p>git checkout .</p><p>git log --pretty=oneline</p><p>但最有意思的是 format，可以定制要显示的记录格式，这样的输出便于后期编程提取分析，像这样：</p><p>$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;<br>ca82a6d - Scott Chacon, 11 months ago : changed the version number<br>085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code<br>a11bef0 - Scott Chacon, 11 months ago : first commit</p><h2 id="makefile-代码片段"><a class="markdownIt-Anchor" href="#makefile-代码片段"></a> makefile 代码片段</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">proto:</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> api srv; <span class="keyword">do</span> \</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $<span class="variable">$d</span>/**/proto/*.proto; <span class="keyword">do</span> \</span><br><span class="line">protoc --proto_path=<span class="variable">$&#123;GOPATH&#125;</span>/src --micro_out=. --go_out=. $<span class="variable">$f</span>; \</span><br><span class="line"><span class="built_in">echo</span> compiled: $<span class="variable">$f</span>; \</span><br><span class="line"><span class="keyword">done</span> \</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">lint:</span><br><span class="line">./bin/lint.sh</span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">./bin/build.sh</span><br><span class="line"></span><br><span class="line">data:</span><br><span class="line">go-bindata -o data/bindata.go -pkg data data/*.json</span><br><span class="line"></span><br><span class="line">run:</span><br><span class="line">docker-compose build</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h2><p>j sbin<br>./rabbitmq-server<br>./rabbitmqctl list_queues</p><p>brew install gnatsd<br>gnatsd<br>consul agent -dev -client=0.0.0.0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;克隆&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#克隆&quot;&gt;&lt;/a&gt; 克隆&lt;/h2&gt;
&lt;p&gt;有两种方式，一种是通过ssh,一种是通过http&lt;/p&gt;
&lt;p&gt;使用ssh的方式需要在本机生成ssh文件，&lt;br&gt;
参考资料：&lt;a href=&quot;
      
    
    </summary>
    
      <category term="git" scheme="https://dreamerjonson.com/categories/git/"/>
    
      <category term="mac环境配置" scheme="https://dreamerjonson.com/categories/git/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="https://dreamerjonson.com/tags/git/"/>
    
      <category term="mac环境配置" scheme="https://dreamerjonson.com/tags/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>golang[71]-golang操作mysql数据库</title>
    <link href="https://dreamerjonson.com/2019/04/01/golang-71-sql/"/>
    <id>https://dreamerjonson.com/2019/04/01/golang-71-sql/</id>
    <published>2019-04-01T09:38:37.000Z</published>
    <updated>2019-04-28T02:47:05.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p><a href="https://dev.mysql.com/downloads" target="_blank" rel="noopener">https://dev.mysql.com/downloads</a></p><h2 id="installing-mysql-on-macos"><a class="markdownIt-Anchor" href="#installing-mysql-on-macos"></a> Installing MySQL on macOS</h2><p>推荐使用dmg文件安装<br><a href="https://dev.mysql.com/doc/refman/5.7/en/osx-installation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/osx-installation.html</a><br>安装完毕有默认密码</p><h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h2><p>PATH=&quot;$PATH&quot;:/usr/local/mysql/bin<br>sudo su<br>mysql -u root -p 123456</p><p>create database test;<br>use test;<br>create table user_info(id int(11),username varchar(20),create_time timestamp ,primary key(id));<br>INSERT INTO user_info(id,username) VALUES(5,“jonson”);<br>select * from user_info;</p><p>create table user_info(id int(11),username varchar(20),create_time timestamp ,primary key(id));</p><h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(<span class="string">`INSERT user_info (id,username) values (?,?)`</span>)</span><br><span class="line">res, err := stmt.Exec(<span class="number">88</span>,<span class="string">"olaya"</span>)</span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line">fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(<span class="string">"delete from user_info where id=?"</span>)</span><br><span class="line"></span><br><span class="line">res, err := stmt.Exec(<span class="number">88</span>)</span><br><span class="line">id, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新"><a class="markdownIt-Anchor" href="#更新"></a> 更新</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(<span class="string">"update user_info set id=? where id=?"</span>)</span><br><span class="line"></span><br><span class="line">res, err := stmt.Exec(<span class="number">5</span>, <span class="number">99</span>)</span><br><span class="line">id, err := res.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mysql.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := db.Query(<span class="string">"SELECT * FROM user_info"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> id <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> create_time <span class="keyword">string</span></span><br><span class="line">err = rows.Scan(&amp;id, &amp;username, &amp;create_time)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(id, username, create_time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for rows.Next() &#123;</span></span><br><span class="line"><span class="comment">//    var userId int</span></span><br><span class="line"><span class="comment">//    var userName string</span></span><br><span class="line"><span class="comment">//    var userAge int</span></span><br><span class="line"><span class="comment">//    var userSex int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    rows.Columns()</span></span><br><span class="line"><span class="comment">//    err = rows.Scan(&amp;userId, &amp;userName, &amp;userAge, &amp;userSex)</span></span><br><span class="line"><span class="comment">//    checkErr(err)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    fmt.Println(userId)</span></span><br><span class="line"><span class="comment">//    fmt.Println(userName)</span></span><br><span class="line"><span class="comment">//    fmt.Println(userAge)</span></span><br><span class="line"><span class="comment">//    fmt.Println(userSex)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="go" scheme="https://dreamerjonson.com/categories/go/"/>
    
    
      <category term="go" scheme="https://dreamerjonson.com/tags/go/"/>
    
  </entry>
  
</feed>
