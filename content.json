{"pages":[{"title":"标签","date":"2019-02-08T03:59:43.233Z","updated":"2019-02-06T13:41:04.416Z","comments":false,"path":"aboutme/index.html","permalink":"https://dreamerjonson.com/aboutme/index.html","excerpt":"","text":""},{"title":"比特币外文资源荟萃","date":"2018-12-03T02:09:56.283Z","updated":"2018-12-03T02:09:56.283Z","comments":false,"path":"bitcoin/index.html","permalink":"https://dreamerjonson.com/bitcoin/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-04T16:55:54.345Z","updated":"2018-11-04T16:55:54.345Z","comments":false,"path":"categories/index.html","permalink":"https://dreamerjonson.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-11-13T15:32:53.109Z","updated":"2018-11-13T15:32:53.109Z","comments":false,"path":"links/index.html","permalink":"https://dreamerjonson.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-04T16:56:25.053Z","updated":"2018-11-04T16:56:25.053Z","comments":false,"path":"tags/index.html","permalink":"https://dreamerjonson.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"实战Kafka—术语","slug":"kafka-golang","date":"2020-07-02T06:50:37.000Z","updated":"2020-07-16T07:04:50.338Z","comments":true,"path":"2020/07/02/kafka-golang/","link":"","permalink":"https://dreamerjonson.com/2020/07/02/kafka-golang/","excerpt":"","text":"kafka特点 分布式，水平扩容，高可用 高吞吐量 开源 大规模、持久化存储 具备传统消息队列具有的解耦特性，可看做数据平台,适用连续处理数据流的场景 Kafka基本术语释疑 Message 存储在kafka中的数据单位被称为message。 Topic message 通过 topic进行分类 Partitions 分区，一个topic可以划分到多个分区中,每一个分区都是一组单独message队列,message顺序写入分区. 因此,当有多个分区,因此无法保证全局topic的时间顺序。 Producers &amp;&amp; publishers &amp;&amp; writers. 写数据到kafka的生产者 Consumers &amp;&amp; subscribers &amp;&amp; readers 消费者，可以订阅一个或多个topic消费数据，按照每个分区中产生的数据顺序消费。 Offset 偏移量,topic在每个分区中的每个message都有唯一的偏移量。消费者可以通过偏移量追踪到哪些数据是已经消费过了，这样即便程序中断和重启后可以继续消费。借助于offset的偏移还可以重复消费数据，甚至丢弃数据。 commit 我们将更新分区中当前offset的操作称为commit(提交) Consumers group 如果消费者A,B属于同一个消费组，他们可以并发消费同一个topic的数据。kafka分配统一topic不同的分区供A，B消费。如果某一个消费者挂掉了，还可以将分区进行重新的均衡分配。 Broker 单个kafka服务端叫做Broker，生产者消费者都需要与此交互。 cluster 多个Brokers组成cluster kafka集群 在cluster中,一个分区中的数据可能在多个broker中建立副本，这提供了kafka高可用性。但是一个分区只能有一个broker作为其leader.","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang快速入门[2.1]-go语言开发环境配置-windows","slug":"thewaytogolang2","date":"2020-07-01T06:56:54.000Z","updated":"2020-07-01T07:42:08.173Z","comments":true,"path":"2020/07/01/thewaytogolang2/","link":"","permalink":"https://dreamerjonson.com/2020/07/01/thewaytogolang2/","excerpt":"","text":"golang快速入门[2.1]-go语言开发环境配置-windows 本文将讲解在windows系统下构建go语言的开发环境 windows安装Go语言开发包 配置go语言的开发环境的第一步是要在go官网下载页面下载开发包 windows系统下需要下载msi后缀文件，msi是windows下的安装包文件格式,用于安装，存储和删除程序 上图中是 64 位的开发包，如果读者的电脑是 32 位系统或者有特殊的软件需求，则需要下载 32 位的开发包 如下图所示为windows下32位系统的开发包 双击后即可启动程序，如下图所示，这是Go语言的用户许可协议，直接点击勾选即可。 Go语言开发包会默认安装到 C 盘的 Go 目录下，这就是叫做GOROOT的目录，推荐使用此目录，也可以选择任意的目录。如下图所示，确认无误后点击“Next” 如下图所示，点击“Install”即可开始安装，没有其他需要配置的操作 等待程序完成安装，点击“Finish”完成安装。 安装完成后，在我们所设置的安装目录下(c:/go)将生成特定的文件和文件夹，如下图所示： 设置环境变量 开始写 go 项目代码之前，需要我们先配置好GOPATH环境变量，GOPATH是go中的一个重要概念，我们在之后的文章中会详细介绍 如下图所示，在桌面或者资源管理器右键 我的电脑 - 属性 - 高级系统设置 - 环境变量。 在弹出的界面里点击 GOPATH 对应的选项，点击编辑之后就可以对GOPATH进行修改。 如果没有GOPATH环境变量，则可以点击新建进行创建。 GOPATH可以设置为任何目录，但是尽量选择新的空目录，例如 :\\Go。 提示：填写完成后，每个打开的窗口都需要点击“确定”来保存设置。 其它的Go环境变量会由安装包自动设置。 在任意目录下使用终端执行 go env 命令，输出如下结果说明Go语言开发包已经安装成功 123456789101112131415161718C:\\Windows\\system32&gt; go envset GO111MODULE&#x3D;set GOARCH&#x3D;amd64set GOBIN&#x3D;set GOCACHE&#x3D;C:\\Users\\jackson\\AppData\\Local\\go-buildset GOENV&#x3D;C:\\Users\\jackson\\AppData\\Roaming\\go\\envset GOEXE&#x3D;.exeset GOFLAGS&#x3D;set GOHOSTARCH&#x3D;amd64set GOHOSTOS&#x3D;windowsset GONOPROXY&#x3D;set GONOSUMDB&#x3D;set GOOS&#x3D;windowsset GOPATH&#x3D;C:\\Users\\jackson\\goset GOPRIVATE&#x3D;set GOPROXY&#x3D;https:&#x2F;&#x2F;proxy.golang.org,directset GOROOT&#x3D;c:\\go... 参考资料 在Windows上安装Go语言开发包","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言快速入门[1]-go语言简介","slug":"thewaytogolang1","date":"2020-06-29T10:14:51.000Z","updated":"2020-07-01T07:21:45.901Z","comments":true,"path":"2020/06/29/thewaytogolang1/","link":"","permalink":"https://dreamerjonson.com/2020/06/29/thewaytogolang1/","excerpt":"","text":"声明 这是一套帮助初学者从0到1学习go语言的开源教程，致力于打造最完整、最强悍、最有深度的Go语言学习体系 我希望这套课程能够涵盖Go语言的所有体系、并致力于用大量的案例来诠释其用法 鉴于作者水平有限，真诚地希望能够集所有人的智慧，完善此项目，链接附后 简介 Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言 Go的最初目标是消除Google软件开发的缓慢性和笨拙性，从而使流程更具效率和可扩展性，更多的关注于软件工程领域 Go致力于解决当代大型工程项目面临的多核处理，网络系统，海量计算集群、快速构建等问题，Go在语言级别考虑并发问题,提供简单高效的并发编程 罗伯特·格瑞史莫(Robert Griesemer)，罗勃·派克（Rob Pike）及肯·汤普逊(Ken Thompson)于2007年9月开始设计Go，稍后Ian Lance Taylor、Russ Cox加入项目 Go是基于Inferno操作系统所开发的 Go于2009年11月正式宣布推出，成为开放源代码项目，支持Linux、macOS、Windows等操作系统 在2016年，Go被软件评价公司TIOBE 选为“TIOBE 2016 年最佳语言” 很多重要的开源项目都是使用Go语言开发的，其中包括 Docker、Go-Ethereum、Thrraform、Kubernetes、etcd、hyperledger、tidb 基本语言的历史 1960年 Ken Thompson(肯.汤普森) 发明了B语言 1972年 Dennis Ritchie(丹尼斯·里奇)发明了C语言 1982年 Bjarne Stroustrup(本贾尼)发明了C++语言 1989年 Guido von Rossum 发明了Python语言 1995年SUN公司发明了Java语言 2007年Go语言诞生 2009年的11月对外正式发布 Go语言创始人 对语言进行评估时，明白设计者的动机以及语言要解决的问题很重要。Go语言出自 Ken Thompson 和 Rob Pike、Robert Griesemer 之手，他们都是计算机科学领域的重量级人物。 Ken Thompson 贝尔实验室 Unix 团队成员，C语言、Unix 和 Plan 9 的创始人之一，在 20 世纪 70 年代，设计并实现了最初的 UNIX 操作系统，仅从这一点说，他对计算机科学的贡献怎么强调都不过分。他还与 Rob Pike 合作设计了 UTF-8 编码方案 Rob Pike Go语言项目总负责人，贝尔实验室 Unix 团队成员，除帮助设计 UTF-8 外，还帮助开发了分布式多用户操作系统 Plan 9、Inferno 操作系统和 Limbo 编程语言，并与人合著了《The Unix Programming Environment》，对 UNIX 的设计理念做了正统的阐述 Robert Griesemer 就职于 Google，参与开发 Java HotSpot 虚拟机，对语言设计有深入的认识，并负责 Chrome 浏览器和 Node.js 使用的 Google V8 JavaScript 引擎的代码生成部分 go语言的继承 Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言” Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等思想 Go继承了C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配 Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自Niklaus Wirth所设计的Pascal语言 Modula-2语言激发了包的概念，然后Oberon语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的Oberon-2语言直接影响了包的导入和声明的语法，还有Oberon语言的面向对象特性所提供的方法的声明语法等 Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的Tony Hoare于1978年发表的鲜为外界所知的关于并发研究的基础文献顺序通信进程（communicating sequential processes，缩写为CSP） 在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过Tony Hoare的CSP只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言 Rob Pike和其他人开始不断尝试将CSP引入实际的编程语言中。他们第一次尝试引入CSP特性的编程语言叫Squeak，是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的 然后是改进版的Newsqueak语言，提供了类似C语言语句和表达式的语法和类似Pascal语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。在Newsqueak语言中管道是动态创建的，属于第一等公民,可以保存到变量中 在Plan9操作系统中，这些优秀的想法被吸收到了一个叫Alef的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦 注：在Aelf之后还有一个叫Limbo的编程语言，Go语言从其中借鉴了很多特性。具体请参考Pike的讲稿：http://talks.golang.org/2012/concurrency.slide#9 Go语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从APL语言借鉴，词法作用域与嵌套函数来自于Scheme语言和其他很多语言 Go中也有很多创新的设计，比如Go语言的切片为动态数组提供了有效的随机存取的性能，还有Go语言新发明的defer语句 go语言的特点 所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。 简洁 Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的） 正如Rob Pike所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性 通过增加功能、选项、配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，卽使从长远来看，简洁依然是好软件的关键因素 简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变或坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应 而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化 附带了相关的工具和标准库 没有隐式的数值转换 没有构造函数和析构函数 没有运算符重载 没有默认参数 没有继承 没有泛型（go2中考虑加入） 没有异常，即没有与错误处理相关的控制结构 没有宏 没有函数修饰 没有线程局部存储。 没有指针运算 没有类型别名 数组边界总是受到检查 基本特性 自动垃圾回收 包管理 函数作为一等公民 系统调用接口 只读的UTF8字符串 函数多返回值 匿名函数和闭包 反射 静态链接 严格的依赖规范 CSP并发编程 Goroutine协程 接口类型 向后兼容 Go语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码 类型系统 相比较于js、python，Go语言的类型系统避免动态语言中那些粗心的类型错误。但是Go语言的类型系统相比传统的强类型语言又要简洁很多，虽然有时候这会导致一个“无类型”的抽象类型的概念 Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中Go语言简洁的类型系统给了程序员带来了更多的安全性和更好的运行时性能 Go语言遵循当代计算机系统设计的原则，特别是局部的重要性。Go的内置数据类型和大多数的标准数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因此内存分配和内存初始化代码被隐藏在库代码中了 Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存分配，而且指针操作比其他间接操作的语言也更有效率 并发支持 由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。 Go并发的座右铭：不要通过共享内存进行通信，而要通过通信共享内存（Don’t communicate by sharing memory, share memory by communicating） 自动垃圾回收机制 对于系统语言，垃圾回收可能是一个有争议的功能 Go没有显式的内存释放操作：分配的内存返回池的唯一方法是通过垃圾回收器。 内存管理对语言在实践中的工作方式具有深远的影响。在C和C++中，太多的编程工作花费在内存分配和释放上 由于垃圾回收机制，语言更易于使用。 垃圾回收会带来巨大的成本：常规开销，延迟和实现的复杂性 知识渊博的程序员可以限制收集器所承受的压力，从而提高性能。（此外，Go安装附带了用于研究正在运行的程序的动态内存性能的良好工具） 自动垃圾回收算法是一个持续跟新的过程、活跃的开发领域 强大的标准库与规范 Go语言的标准库，提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议 库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且每个Go程序结构都是如此的相似，因此Go程序也很容易学习 Go语言自带工具构建Go语言项目只需要使用文件名、标识符名称以及少量的注释确定所有的库、可执行文件、测试、基准测试、案例、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范 开源,活跃的社区 组成而不是继承 Go采用一种不寻常的方法来进行面向对象的编程（接口），它允许有相同方法的任何类型继承,而不仅是类 Go没有任何形式的基于类型的继承,这意味着没有类型层次结构 这是一个故意的设计选择，尽管类型层次结构已用于构建许多成功的软件，但Go认为该模型已被过度使用 Go语言的优势 学习曲线容易，语法简单清晰 单就类型和规则而言，Go 与 C99、C11 相似之处颇多，这也是Go语言被冠以“NextC”名号的重要原因。 Go语言的语法规则严谨，没有歧义，更没什么黑魔法变异用法。 任何人写出的代码都基本一致，这使得Go语言简单易学。放弃部分“灵活”和“自由”，换来更好的维护性 强大的标准库和工具链 完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具 内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的 pprof，这些都是保障代码能正确而稳定运行的必备利器 可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现 自动垃圾回收机制 垃圾回收一直是个难题。早年间，Java 就因垃圾回收低效被嘲笑了许久，后来 Sun 连续收纳了好多人和技术才发展到今天。可即便如此，在 Hadoop 等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰 相比 Java，Go 面临的困难要更多。因指针的存在，所以回收内存不能做收缩处理。幸好，指针运算被阻止，否则要做到精确回收都难 每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低 STW 时间，直到 Go 的 1.5 版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作 静态链接 运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库 编译迅速 清晰的依赖关系 并发编程 在早期 CPU 都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表 随着处理器技术的发展，单核时代以提升处理器频率来提高运行效率的方式遇到了瓶颈，单核 CPU 发展的停滞，给多核 CPU 的发展带来了机遇 现代计算机都拥有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。编程时需要写大量的线程同步代码来利用多个核，很容易导致错误 Go语言正是在多核和网络化的时代背景下诞生的原生支持并发的编程语言。Go语言从底层原生支持并发，无须第三方库，开发人员可以很轻松地在编写程序时决定怎么使用 CPU 资源 Goroutine 是 Go 最显著的特征 Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能 Go用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易 无须处理回调，无须关注线程切换，仅一个关键字，简单而自然 搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱 内存分配 Go 选择了 tcmalloc，它本就是为并发而设计的高性能内存分配组件 刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。使用 cache 为当前执行线程提供无锁分配，多个 central 在不同线程间平衡内存单元复用 heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务 Go语言擅长的领域 Go语言主要用作服务器端开发，适合于多人周期较长的大型软件和支持云计算的网络服务 在服务器编程方面，Go语言适合处理日志、中间件、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等 网络编程方面，Go语言广泛应用于 Web 应用、API 应用、下载应用等 此外，Go语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用 Go 开发 由于Go垃圾回收牺牲了一些性能，因此其不适合做操作系统编程以及对速度要求极致的程序，不适合直接处理数据分析与计算 使用Go语言的公司 参见世界上使用Go语言的企业 Google 作为创造了Go语言的 google 公司，当然会力挺Go语言了。Google 有很多基于 Go 开发的开源项目，比如 kubernets，docker，大家可以参考《哪些项目使用Go语言开发》一节了解更多的Go语言开源项目 Facebook Facebook 也在使用Go语言，为此他们还专门在 Github 上建立了一个开源组织 facebookgo。大家可以通过 https://github.com/facebookgo 访问查看 facebook 开源的项目，其中最具代表性的就是著名平滑重启工具 grace 腾讯 腾讯在 15 年就已经做了 Docker 万台规模的实践。因为腾讯主要的开发语言是 C/C++ ，所以在使用Go语言方面会方便很多，也有很多优势，不过日积月累的 C/C++ 代码很难改造，也不敢动，所以主要在新业务上尝试使用 Go 百度 百度主要在运维方面使用到了Go语言，比如百度运维的一个 BFE 项目，主要负责前端流量的接入，其次就是百度消息通讯系统的服务器端也使用到了Go语言 七牛云 七牛云算是国内第一家选Go语言做服务端的公司。早在 2011 年，当Go语言的语法还没完全稳定下来的情况下，七牛云就已经选择将 Go 作为存储服务端的主体语言 京东 京东云消息推送系统、云存储，以及京东商城的列表页等都是使用Go语言开发的 小米 小米对Go语言的支持，在于运维监控系统的开源，它的官方网址是 http://open-falcon.org/。此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Go语言 360 360 对Go语言的使用也不少，比如开源的日志搜索系统 Poseidon，大家可以通过 https://github.com/Qihoo360/poseidon 查看，还有 360 的推送团队也在使用Go语言 除了上面提到的，还有很多公司开始尝试使用Go语言，比如美团、滴滴、新浪等。 Go语言吉祥物 Go语言有一个吉祥物，在会议、文档页面和博文中，大多会包含下图所示的 Go Gopher，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。 参考资料 项目链接 My Blog Go源码 Go官网 优秀的Go语言项目 Bell Labs and CSP Threads Go语言简介 The Go Programming Language Go FAQ Go at Google: Language Design in the Service of Software Engineering","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"mac利用sz rz 从服务器下载 上传资源","slug":"mac-linux-rz-sz","date":"2020-04-28T03:14:58.000Z","updated":"2020-04-28T03:26:49.831Z","comments":true,"path":"2020/04/28/mac-linux-rz-sz/","link":"","permalink":"https://dreamerjonson.com/2020/04/28/mac-linux-rz-sz/","excerpt":"","text":"安装 1brew install lrzsz 安装脚本 123cd &#x2F;usr&#x2F;local&#x2F;binwget https:&#x2F;&#x2F;raw.github.com&#x2F;aikuyun&#x2F;iterm2-zmodem&#x2F;master&#x2F;iterm2-send-zmodem.shwget https:&#x2F;&#x2F;raw.github.com&#x2F;aikuyun&#x2F;iterm2-zmodem&#x2F;master&#x2F;iterm2-recv-zmodem.sh 权限 1chmod 777 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-* 配置item2 在iTerm 2添加Triggers 1234567Regular expression: rz waiting to receive.\\*\\*B0100Action: Run Silent CoprocessParameters: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-send-zmodem.shRegular expression: \\*\\*B00000000000000Action: Run Silent CoprocessParameters: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-recv-zmodem.sh 使用方法 将文件传到远端服务器 在远端服务器上输入 rz ，回车 选择本地要上传的文件 等待上传 从远端服务器下载文件 在远端服务器输入 sz filename filename1 … filenameN 选择本地的存储目录 等待下载 PS:远端服务器也需要安装lrzsz。centOS安装方法： yum -y install lrzsz","categories":[{"name":"mac","slug":"mac","permalink":"https://dreamerjonson.com/categories/mac/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dreamerjonson.com/tags/linux/"}]},{"title":"6.824分布式系统[4]-Zookeeper","slug":"distributed-systerm-4-Zookeeper","date":"2020-02-02T08:25:07.000Z","updated":"2020-02-16T12:59:49.285Z","comments":true,"path":"2020/02/02/distributed-systerm-4-Zookeeper/","link":"","permalink":"https://dreamerjonson.com/2020/02/02/distributed-systerm-4-Zookeeper/","excerpt":"","text":"准备工作 阅读： [https://pdos.csail.mit.edu/6.824/papers/zookeeper.pdf](“ZooKeeper: wait-free coordination for internet-scale systems”) 阅读：我之前写好的raft系列文章 为什么要阅读这篇文章 Zookeeper是广泛使用的主从状态机服务 受Chubby（Google的全局锁定服务）启发 最初在Yahoo得到应用，后来在Mesos, HBase广泛使用 Apache 开源项目 项目链接 主从复制的案例研究 API支持广泛的用例 性能优越 发展Zookeeper的动机 服务集群中的许多应用程序需要协调通信 例如对于GFS服务需要master存储每一个块服务器的列表，master决定哪一个块是primary等。 应用程序之间需要相互发现 MapReduce架构中需要了解GFS master的ip和port 性能优越 以lab3中3个节点的raft算法作对比，需要执行2次磁盘写入和一次消息往返，对于磁盘，大约50 msg/sec。对于ssd，大约200 msg/sec 但是Zookeeper能处理大约21,000 msg/sec,源于client允许异步调用机制，以及pipelining消息处理。 Zookeeper的替代方案：为每一个应用程序开发容错的master服务 根据DNS标识ip与端口 处理容错 高性能 Zookeeper设计: 通用的协调服务 设计挑战 API的设计 如何使master容错 如何获得良好的表现 基本设计 主从状态机 主从复制的是znodes对象 znodes以路径命名，拥有层次结构，类似于unix的文件系统 znodes包含应用程序的元数据（配置信息、时间戳、版本号） znodes的类型：Regular(客户端通过显式创建和删除常规znode来操作它们)，empheral(客户端创建了此类znode，它们要么显式删除它们，要么让系统在创建它们的会话终止时（故意或由于失败）自动将其删除) znode命名规则: name + 序列号。 如果n是新的znode，p是父znode，则n的序列值永远不会小于在p下创建的任何其他znode名称中的序列值 会话(session) 客户端连接上zookeeper时会初始化会话 会话允许在故障发生时，客户端请求转移到另一个服务（client知道最后完成操作的术语和索引） 会话有时间限制，client必须持续刷新会话（通过心跳检测） znodes上的操作 create(path, data, flags) delete(path, version) if znode.version = version, then delete exists(path, watch) getData(path, watch) setData(path, data, version) if znode.version = version, then update getChildren(path, watch) sync() 除此操作的其他操作是异步的，每个client的所有操作均按FIFO顺序排序。同步会一直等到之前的所有操作都认可为止 顺序保证 所有写操作都是完全有序的 ZooKeeper会对所有client发起的写操作做全局统一排序 每一个client的操作都是FIFO顺序的。 read操作能够感知到相同客户端的其他写操作 read操作能够感知之前的写操作针对相同的znode ready znode ZooKeeper中，新的leader可以将某个path指定为ready znode。 其他节点将仅在该znode存在时使用配置。 当leader 重建配置之后，会通知其他副本重建配置，并新建ready znode. 副本为了防止出现不一致，必须在重建配置时，处理完其之前的所有事务。保证所有服务的状态一致。 任何一个副本更新失败，都不能够应用都需要进行重试。 Zookeeper使用lock的例子 下面的伪代码向我们锁的实现。通过create试图持有锁，如果锁已经被其他的client持有，则通过watch方式监控锁的释放。 12345678910111213acquire lock: retry: r &#x3D; create(&quot;app&#x2F;lock&quot;, &quot;&quot;, empheral) if r: return else: getData(&quot;app&#x2F;lock&quot;, watch&#x3D;True) watch_event: goto retry release lock: delete(&quot;app&#x2F;lock&quot;) 由于上面的伪代码可能会出现羊群效应，可以尝试下面的方式 znode下方的children中，序号最低的的是持有锁的 其他在等待的client只watch前一个znode的变化，避免了羊群效应 123456789101112acquire lock: n &#x3D; create(&quot;app&#x2F;lock&#x2F;request-&quot;, &quot;&quot;, empheral|sequential) retry: requests &#x3D; getChildren(l, false) if n is lowest znode in requests: return p &#x3D; &quot;request-%d&quot; % n - 1 if exists(p, watch &#x3D; True) goto retry watch_event: goto retry Zookeeper简化程序构建但其不是最终的解决方案 应用程序还有许多需要解决的问题 例如如果我们要在GFS中使用Zookeeper，那么我们还需要 chunks的副本方案 primary失败的协议 … 但是使用了Zookeeper，至少可以使master容错，不会发生网络分区脑裂的问题 Zookeeper实现细节 和lab3相似 具有两层 ZooKeeper 服务层 (K/V 层) ZAB 层 (Raft 层) Start() 在底层执行插入操作 随后，ops从每个副本服务器的底层弹出，这些操作按照弹出的顺序提交(commited),在lab3中使用apply channel，在ZAB层中，通过调用abdeliver() 挑战：处理重复的客户端请求 场景：primary收到客户端请求后，返回失败，客户端进行重试 在lab3中，我们使用了map来解决重复的请求问题，但是每一个客户端时候堵塞的，只能够等待完成才能进行下一个 在Zookeeper中，在一段时间内的操作是幂等的，以最后一次操作为准 挑战： 读取操作的效率 大部分的操作都是读取操作，他们不修改状态 读取操作是否必须通过ZAB层？ 任何副本服务器都可以执行读取操作？ 如果读取操作通过Raft/ZAB层，则性能会降低 读取操作如果不通过Raft/ZAB层、可能会返回过时的数据 Zookeeper解决方案：允许返回过时的数据 读取可以由任何副本执行 读取吞吐量随着服务器数量的增加而增加 读取返回它看到的最后一个zxid 只有sync-read() 保证数据不过时","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"微服务理论与实践[1]-什么是微服务","slug":"Microservices-1","date":"2020-01-31T02:37:33.000Z","updated":"2020-02-04T06:18:22.530Z","comments":true,"path":"2020/01/31/Microservices-1/","link":"","permalink":"https://dreamerjonson.com/2020/01/31/Microservices-1/","excerpt":"","text":"什么是微服务 微服务 (Microservices) 是一种软件架构风格，将应用程序构造为围绕业务的小型自治服务的集合 微服务以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础。每个服务都是独立的，并实现单个业务功能 微服务利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API 集相互通信 微服务运用了以业务功能为主导的设计概念，应用程序在设计时就能先以业务功能或流程设计先行分割，将各个业务功能都独立实现成一个能自主运行的个体服务，然后再利用相同的协议将所有应用程序需要的服务都组合起来，形成一个应用程序 微服务例子1 以购物车应用程序为例，当打开购物车应用程序时，您看到的只是一个网站。但是，在后台，购物车应用程序具有用于接受付款服务，客户服务等 假设此应用程序的开发人员使用了单体框架，架构如下图: 单体架构 如图，在单体架构中，所有功能都放在一个代码库中，并在一个基础数据库下。 现在，假设市场上出现了一个新品牌，并且开发人员希望将即将到来的品牌的所有详细信息放入此应用程序中 此时，不仅需要处理新品牌的服务，而且还必须重新构建整个系统并相应地进行部署。为了避免此类挑战，开发人员决定将其应用程序从单体架构转换为微服务 微服务架构 开发人员为搜索，推荐，客户服务等创建了单独的微服务。 此微服务架构不仅可以帮助开发人员克服以前的架构所面临的所有挑战，而且还可以轻松地构建，部署和扩展购物车应用程序。 微服务例子2 以旅游行业应用程序为例 整体架构 * 整体服务包括了旅客关系管理、付款、消息通知等服务 * 传统的单体常常采用如上图所示的整体式架构，并采取MVC的设计模式 * 三层架构（MVC）的具体内容如下 + 表示层（view）： 用户使用应用程序时，看到的、听见的、输入的或者交互的部分。 + 业务逻辑层（controller）： 根据用户输入的信息，进行逻辑计算或者业务处理的部分。 + 数据访问层（model）： 关注有效地操作原始数据的部分，如将数据存储到存储介质（如数据库、文件系统）及 + 从存储介质中读取数据等。 * 虽然现在程序被分成了三层，但只是逻辑上的分层，并不是物理上的分层。也就是说，对不同层的代码而言，经过编译、打包和部署后，所有的代码最终还是运行在同一个进程中。 单体架构在规模比较小的情况下工作情况良好，但是随着系统规模的扩大，它暴露出来的问题也越来越多，主要有以下几点： * 复杂性逐渐变高 + 比如有的项目有几十万行代码，各个模块之间区别比较模糊，逻辑比较混乱，代码越多复杂性越高，越难解决遇到的问题。 * 技术债务逐渐上升 + 公司的人员流动是再正常不过的事情，有的员工在离职之前，疏于代码质量的自我管束，导致留下来很多坑，由于单体项目代码量庞大的惊人，留下的坑很难被发觉，这就给新来的员工带来很大的烦恼，人员流动越大所留下的坑越多，也就是所谓的技术债务越来越多。 * 维护成本大 + 当应用程序的功能越来越多、团队越来越大时，沟通成本、管理成本显著增加。当出现 bug 时，可能引起 bug 的原因组合越来越多，导致分析、定位和修复的成本增加；并且在对全局功能缺乏深度理解的情况下，容易在修复bug 时引入新的 bug。 * 持续交付周期长 + 构建和部署时间会随着功能的增多而增加，任何细微的修改都会触发部署流水线。新人培养周期长：新成员了解背景、熟悉业务和配置环境的时间越来越长。 * 技术选型成本高 + 单块架构倾向于采用统一的技术平台或方案来解决所有问题，如果后续想引入新的技术或框架，成本和风险都很大。 * 可扩展性差 + 随着功能的增加，垂直扩展的成本将会越来越大；而对于水平扩展而言，因为所有代码都运行在同一个进程，没办法做到针对应用程序的部分功能做独立的扩展。 微服务架构 整体架构 将上面的整体架构改造为如上图所示的微服务 来自不同设备的不同客户端尝试使用不同的服务，例如搜索，构建，配置和其他管理功能 所有服务均根据其功能进行分离，并进一步分离为单个微服务 这些微服务具有自己的负载均衡和执行环境以执行其功能,并在其自己的数据库中捕获数据 微服务之间通过无状态服务器(REST、GRPC或消息总线)进行通信 微服务借助服务发现来了解其通信路径并执行自动化，监控等操作功能 微服务执行的所有功能通过API网关传达给客户端 微服务特点 解耦 系统中的服务在很大程度上是解耦的。因此，整个应用程序可以轻松构建，更改和扩展 组件化 微服务被视为独立的组件，可以轻松替换和升级 专注业务功能 业务功能–微服务非常简单，专注于单一功能 独立自主 开发人员和团队可以彼此独立地工作，从而提高了速度 持续交付 通过自动化的构建、测试和部署，允许频繁发布软件。 分散治理 重点是使用正确的工具完成正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题 敏捷开发 微服务支持敏捷开发。任何新功能都可以快速开发并丢弃 微服务的优点 单一职责 微服务架构中的每个服务，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。 轻量级通信 服务之间通过轻量级的通信机制实现互通互联，而所谓的轻量级，通常指语言无关、平台无关的交互方式。 对于轻量级通信的格式而言，我们熟悉的 XML 和 JSON，它们是语言无关、平台无关的；对于通信的协议而言，通常基于 HTTP，能让服务间的通信变得标准化、无状态化。目前大家熟悉的 REST（Representational StateTransfer）、GRPC是实现服务间互相协作的轻量级通信机制之一。使用轻量级通信机制，可以让团队选择更适合的语言、工具或者平台来开发服务本身。 提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪 独立性 服务独立测试、部署、升级、发布 在单块架构中所有功能都在同一个代码库，功能的开发不具有独立性；当不同小组完成多个功能后，需要经过集成和回归测试，测试过程也不具有独立性；当测试完成后，应用被构建成一个包，如果某个功能存在 bug，将导致整个部署失败或者回滚 新技术的应用，系统不会被长期限制在某个技术栈上 可以根据市场需求，灵活多变的组合出新的业务场景 降低代码耦合度 服务实例水平扩展，服务单一职责，功能独立。保证可靠性与性能，提升资源利用 由于微服务是以业务功能导向的实现，因此不会受到应用程序的干扰，微服务的管理员可以视运算资源的需要来配置微服务到不同的运算资源内，或是布建新的运算资源并将它配置进去 提升开发交流，每个服务足够内聚，足够小，代码容易理解 进程隔离、故障隔离 单块架构中，整个系统运行在同一个进程中，当应用进行部署时，必须停掉当前正在运行的应用，部署完成后再重启进程，无法做到独立部署。 有时候我们会将重复的代码抽取出来封装成组件，在单块架构中，组件通常的形态叫做共享库（如 jar 包或者DLL），但是当程序运行时，所有组件最终也会被加载到同一进程中运行。 在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上。 即使应用程序的一项服务不起作用，系统仍然可以继续运行 数据分区，数据独立，可靠性保证 微服务的缺点 微服务提高了系统的复杂度 开发人员要处理分布式系统的复杂性 服务之间的分布式事务问题 服务的注册与发现问题 数据隔离再来的报表处理问题 不同服务实例的管理困难，持续自动化部署的要求 运维要求较高 对于单体架构来讲，我们只需要维护好这一个项目就可以了，但是对于微服务架构来讲，由于项目是由多个微服务构成的，每个模块出现问题都会造成整个项目运行出现异常，想要知道是哪个模块造成的问题往往是不容易的，因为我们无法一步一步通过debug的方式来跟踪，这就对运维人员提出了很高的要求。 分布式的复杂性 对于单体架构来讲，我们可以不使用分布式，但是对于微服务架构来说，分布式几乎是必会用的技术，由于分布式本身的复杂性，导致微服务架构也变得复杂起来。 接口调整成本高 比如，用户微服务是要被订单微服务和电影微服务所调用的，一旦用户微服务的接口发生大的变动，那么所有依赖它的微服务都要做相应的调整，由于微服务可能非常多，那么调整接口所造成的成本将会明显提高。 微服务的沟通 沟通与事件广播 微服务的规划与单体式应用程序十分不同，微服务中每个服务都需要避免与其他服务有所牵连，且都要能够自主，并在其他服务发生错误时不受干扰。 倘若真有沟通，也应采用异步沟通的方式来避免紧密的相依性问题。要达到此目的，则可用下列两种方式： 事件存储中心（Event Store） 这可以让你在服务集群中广播事件，并且在每个服务中监听这些事件并作处理，这令服务之间没有紧密的相依性，而这些发生的事件都会被保存在事件存储中心里。这意味着当微服务重新上线、部署时可以重播（Replay）所有的事件。这也造就了微服务的数据库随时都可以被删除、摧毁，且不需要从其他服务中获取数据。 消息队列（Message Queue） 能够在服务集群中广播消息，并传递到每个服务中 比较有名的消息中间件如：NSQ、RabbitMQ、Nats、Kafka A 服务上广播一个事件，此事件可以顺带一些数据。B 服务可以监听这个事件并在接收到之后有所处理。这些过程都是异步处理的 A 服务并不需要等到 B 服务处理完该事件后才能继续，而这也代表 A 服务无法获取 B 服务的处理结果 与事件存储中心不同的是：消息队列并不会保存事件。一旦事件被消化（接收）后就会从队列中消失 服务发现 单个微服务在上线的时候，会向服务注册中心注册自己的 IP 位置、服务内容 当服务需要调用另一个服务的时候，会去询问服务探索中心该服务的 IP 位置，得到位置后即可直接向目标服务发起调用 这么做的用意是可以统一集中所有服务的位置，就不会分散于每个微服务中 服务探索中心可以每隔一段时间就向微服务进行健康检查（TCP 调用、HTTP 调用、Ping） 倘若该服务在时间内没有回应，则将其从服务中心移除，避免其他微服务对一个无回应的服务进行调用 即便微服务重新在其他ip上部署，其他服务也是无感知的 比较常用的服务发现有：etcd，consul，普遍都采用了raft等分布式算法 微服务其他需要考虑的因素 网络延迟 分布式事务 限流 例如一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉。 因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。 熔断 当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。 如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。 服务降级 当Service A调用Service B，失败多次达到一定阀值，Service A不会再去调Service B，而会去执行本地的降级方法。 降级服务其实就是牺牲掉一些逻辑处理，或者停止部分依赖服务的请求。以保障服务可以提供关键能力 权限控制 API网关 分布式追踪 分布式日志记录 配置中心 参考资料 维基百科：微服务 什么是微服务架构？ What Is Microservices – Introduction To Microservice Architecture 微服务介绍","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"6.824分布式系统[3]-主从复制","slug":"distributed-systerm-3-replication","date":"2020-01-28T07:14:14.000Z","updated":"2020-01-30T12:05:08.257Z","comments":true,"path":"2020/01/28/distributed-systerm-3-replication/","link":"","permalink":"https://dreamerjonson.com/2020/01/28/distributed-systerm-3-replication/","excerpt":"","text":"准备工作 阅读：Fault-Tolerant Virtual Machines 为什么要阅读这篇文章 了解分布式系统的容错机制 本文是对于容错机制的比较特殊的实现，其并不是要设计一个应用程序级别的容错系统，而是一个系统级别的。需要处理中断，能够为了实现一个容错的虚拟机系统（VM-FT），难度更大。 容错（Fault tolerance） 即使发生故障也会继续提供服务的能力 一些理想的属性： 可用性：尽管[某些故障]仍然可用 一致性：对于客户端来说就像一台服务器 对用户和软件透明（内部运行机制透明） 高效 我们将尝试解决哪些失败？ 失败-停止错误 网络丢包 网络分区 核心思想 容错的核心思想是建立副本，需要两个以上的服务器。 每一个副本都维持相同的状态，如果一个服务器失败,其他服务器可以继续进行。 需要思考的重要问题： 什么状态需要去复制？ primary（主服务器）需要等待副本服务器复制完成吗？ 什么时候需要切换到副本服务器 转换时是否可见异常？ 转换到副本时能否加速？ 两种主要的方式 状态转移 primary执行操作 primary将状态转移到副本 状态转移虽然简单，但是状态可能很大，转移可能很慢 论文中的虚拟机使用了复制状态机。 复制状态机 所有副本执行所有操作 相同的开始状态 相同的操作 相同的顺序 确定性的操作 则具有相同的最终状态 更有效率，但是更复杂 本论文的目标 构建复制状态机 Primary和副本具有相同的初始状态（内存，磁盘文件） primary通过日志通道（logging channel）传递给副本服务器 相同的指令、相同的输入、相同的执行 什么时候在主数据库上执行与备份上可能不同？ 来自外部的输入（网络） 从存储服务器读取的数据 定时器中断（Timing of interrupts）。 参考：wikibook 一些特殊的指令：循环计数 冲突（） 不一致的原因 锁定服务器将锁定授予客户端C1，拒绝来自C2的后续请求 锁定服务器在一分钟后撤消锁定 假设C1持有锁并且，1分钟马上就要到时，c2请求锁。这时，Primary可能会在定时器1分钟发送中断之前立即看到C2的请求，拒绝其请求。副本可能会在定时器1分钟发送中断之后看到C2的请求，同意它。 因此：副本必须在指令流中的同一点以相同的顺序看到相同的事件。 解决定时器中断的解决方案 primary FT 收到定时器中断信号 FT从CPU读取指令号 FT在日志通道（logging channel）上发送的&quot;在指令x处触发计时器中断” FT给primary发送中断信号，然后恢复。 Backup 忽略自己的计时器硬件 在副本得到指令X之前，观察是否日志中有需要在这之前执行的日志。 FT告诉CPU在指令X处中断 FT模拟计时器中断，然后恢复。 解决磁盘、网络数据输入可能不一致的问题 FT拦截，只能够让primary能够访问硬件。 Primary: FT通知硬件通过方式将数据存入FT的私有缓存中 在某一时刻，硬件执行DMA，然后中断 FT收到中断信号 FT暂停primary FT复制缓冲区数据到primary内存中。 FT为primary模拟中断，稍后恢复。 FT将数据和指令发送到备份 Backup: FT从日志流中获取数据和指令 FT告诉CPU在指令X处中断 FT在中断期间复制数据 缓冲区（bounce buffer）的目的就是为了在内存的同一个时间点执行相同的操作，读取相同的数据。 解决特殊的指令 Primary: 如果primary执行了特殊的指令，FT会通知CPU中断 FT执行指令并记录结果 将结果和指令发送到备份 Backup: 副本在执行此指令时也会中断。 副本应用从primary中得到的值。 Output Rule primary必须在副本收到此输出指令的日志后，才能够输出。 此规则是必要的，因为我们的服务是为了在奔溃时让用户是无感知的。 有了此规则，即便peimary奔溃了，副本也能够和primary一样，对于之前的请求返回相同的数据。 假设primary收到请求I1 I2 I3 并输出, 这时primary奔溃，副本只能看到I1，I2。这时 一个之前收到I1，I2，I3的客户端由于切换到副本后，相同的请求就只能看到I1，I2。 增加了延迟，限制了性能。 问 &amp; 答 如果primary收到副本对于I3 ack确认后奔溃，会发生什么？ 这时会切换到副本运行，而副本会执行I3命令，并返回给客户端。 如果primary在发出输出之后崩溃了怎么办？ 副本会立即接管。 对于TCP传输：接收者将忽略重复的序列号。 对于磁盘：副本将相同的数据写入相同的块。 如果网络分区，primary和副本都认为彼此失活？ 共享磁盘只允许唯一的一个primary。 为什么确定性的操作，在物理硬件上比虚拟机上更难？ 虚拟机管理程序（hypervisor）模拟和控制硬件的许多操作，这些操作可能会导致primary和副本执行不同。例如定时中断(timing interrupts) 什么是虚拟机管理程序（hypervisor） 管理程序是虚拟机系统的一部分，和虚拟机监视器（VMM）一样。 系统管理程序模拟计算机以及在其中运行的操作系统和程序。 在本文中，primary和副本是运行在虚拟机中的guest操作系统。而FT是实现每个虚拟机的管理程序的一部分。 GFS和VMware FT均提供容错功能，谁更好？ FT更底层强大，对内存,网络包和磁盘提供了一种容错能力。可以使用它为所有运行在其上的服务透明地提供容错功能。 GFS仅提供存储容错功能。 由于GFS专用于特定的简单服务（存储），因此其复制比FT更有效。 例如，GFS不需要使中断在所有副本上的完全相同的指令处发生。 GFS是应用程序级别的具有容错能力的大型应用程序之一。 缓冲区如何帮助避免冲突 网络数据包或请求的磁盘块到达primary并且要复制到primary的内存时， 没有FT，相关硬件将数据复制到内存中，同时 软件正在执行。操作系统指令可以在DMA期间读取该内存。由于冲突，在某一时刻，可能无法看到DMA的数据。因此可能出现由于primary与副本的时间不同，一个能看到，一个不能看到这个数据。 表现 logging带宽 直接反应磁盘读取率 + 网络输入率 大约18 Mbit/s for my-sql 比较慢应用程序可以至少400 Mbps的速度读取磁盘 用途 关键但强度较低的服务，例如 名称服务器。 其软件不便于修改的服务。 高吞吐量服务的复制 * 人们将应用程序级复制状态机用于例如 数据库。 * 状态只是DB，而不是全部的内存和磁盘。 * 事件是数据库命令（put或get），而不是数据包和中断。 * 更少的细粒度同步，更少的开销。 * GFS使用应用程序级复制，与lab2相似。 参考资料 讲义 FAQ","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"6.824分布式系统[2]-GFS案例学习","slug":"distributed-systerm-2-GFS","date":"2020-01-21T07:05:28.000Z","updated":"2020-01-27T08:32:16.011Z","comments":true,"path":"2020/01/21/distributed-systerm-2-GFS/","link":"","permalink":"https://dreamerjonson.com/2020/01/21/distributed-systerm-2-GFS/","excerpt":"","text":"背景 GFS是Google在2003年发出的经典论文，其作为分布式文件系统实际应用在Google的MapReduce框架实现中作为原始数据和最终结果存储的基础服务， 同时为其他上层基础系统比如BigTable提供服务。Hadoop中的HDFS就是其开源实现。 这篇文章讨论了诸如一致性、容错、网络性能等分布式系统工程中的经典问题，启发了后续很多分布式文件系统的发展。 为什么阅读GFS的论文 GFS使用了map/reduce的架构 好的性能 —— 良好的并行I/O性能 其实一篇好的系统论文 —— 从apps到网络都有细节说明 包含分布式的许多概念：performance, fault-tolerance, consistency 使用广泛（Bigtable、Spanner、Hadoop） 一致性是什么 保证正确的条件，在有多个副本、并且并发下变得尤其困难。 一致性是分布式系统中最关键的问题，基本所有分布式系统都必须讨论这个问题。 即考虑如果在一个程序中写，但是在另一个程序的副本中读取的情况。 — 强的一致性会保证在另一个程序中读取到的一定是发生在最后一次写入之后。 — 弱的一致性无法对其进行保证，可能会读取到过时的数据。 强一致性可以保证读到最新的写信息，但是对性能肯定会造成影响，好的系统设计就是在这两点中进行平衡。 理想的一致性模型 分布式文件系统需要达成的“理想的“一致性就是多节点上面操作文件表现处理单机跟本地文件系统一样。 如果两个应用程序同时写入同一文件怎么办？ — 在单机，数据常常有一些混合的内容。即两个程序的处理可能是交错的。 如果两个应用程序同时写入同一目录怎么办 — 在单机，使用了锁。一个应用程序处理完毕后，再处理第二个。 挑战 — 多磁盘 — 机器故障，操作无法完成。 — 网络分区，可能不能够到达所有的机器和磁盘。 挑战难以解决的原因 — 需要客户端和服务器之间的通信 — 协议可能会变得复杂 不同的模型考虑不同的权衡 — 可串行性(serializability) — 顺序一致性(sequential consistency) — 线性一致性(linearizability) — 单项一致性模型(entry consistency) — 松散一致性(release consistency) GFS的目标 GFS中节点失效就是常见的（每天1000台机器中大约3台失效） 高性能：大量 有效的使用网络 设计 master存储（directories, files, names） 存储64MB的块，每个块就作为一个linux文件。 每个块在三台服务器上面做备份（保证可用性，负载均衡） 块为什么这么大（摊销间接费用、减少master中的状态大小 master掌握目录的层次结构 — 文件夹中有哪些文件 对于文件，知道哪些节点存储了此文件。 — master在内存中保持状态（每个块的64字节元数据） — 主数据库具有用于元数据的私有可恢复数据库 — 操作日志刷新到磁盘 — 检查点 — master快速恢复 — shadow masters略微落后于master 客户端读 发送文件名和块索引给master master回复具有该块的服务器集 — 回复版本号 — client缓存信息 请求块服务器 — 版本号（如果版本号错误，重新连接master） primary primary是一个副本节点的比较高级的 修改现有文件 client请求master 块的位置 和primary的位置 master回复块服务器，版本已经primary的位置 client根据网络拓扑计算副本链 客户端将数据发送到第一个副本节点，然后此副本节点转发给其他人 副本节点会ack，表明数据已被接收 client 告诉primary写入数据 primary分配序列号并写入 — primary 告诉其他副本写入 — 全部成功后，回复client 如果另一个客户端并发在同一位置写入数据，该怎么办？ — c1 与c2 可能会交替的写入，结果是一致性的，但是不能保证的。 添加文件 client 请求master 块的位置。 client将数据发送给副本，但是没有指定偏移量。 当数据在所有的块服务器上后，client联系primary primary分配序列号 primary检查是否能够刚好添加到一个块中 primary为添加选择偏移量，进行添加 转发请求到其他副本 失败后进行重试 — 不能使用下一个可用偏移量，因为在失败的节点中可能会有空字节。 GFS支持原子操作，保证至少一次添加，主Chunk服务器选择记录需要添加到的文件位置，然后发送给其他副本。 如果和一个副本的联系失败，那么主Chunk服务器会告诉客户端重试，如果重试成功，有些副本会出现追加两次的情况(因为这个副本追加成功两次)。 当GFS要去填塞chunk的边缘时，如果追加操作跨越chunk的边缘，那么文件也可能存在空洞。 失败情况 块服务器的失败会引起client重试。 master失败会导致GFS不可用，shadow master会服务只读的状态。可能会返回过时的数据。 总结 性能，容错，一致性（performance, fault-tolerance, consistency）的案例研究 优势 — 大量的顺序读取和写入 — 追加文件高效 — 大的吞吐量 — 数据容错（3个副本） 劣势 — master服务器的容错 — 小文件（master服务器的瓶颈） — client会看到过时的数据（弱的一致性） — 追加可能重复 GFS案例问答 为什么添加数据执行至少一次&quot;at-least-once&quot;语义，而不是精准的一次？ 实现困难，primary需要保留重复的状态。状态必须在服务器之间复制，以便如果primary出现故障, 此信息不会丢失。 应用程序如何知道块的哪些是有数据的块，哪些是重复的数据 可以在有效记录的开头做标识（magic number）就可以知道有数据的块。 检测重复的块可以为每个记录都有一个特殊的UID标识。 论文中提到的reference counts是什么意思 他们是实现快照copy-on-write（写时复制）的一部分。 当GFS创建快照时，它不复制块，而是增加每个块的引用计数器。 这使得创建快照的成本不高。 如果客户端写入了一个块，并且主服务器注意到引用计数大于1， 则主服务器会首先创建一个副本，以便客户端可以更新副本（而不是快照的一部分）。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[114]-raft理论与实践[5]-lab2c-持久化","slug":"golang-114-raft-5-presis","date":"2020-01-16T14:20:29.000Z","updated":"2020-01-18T12:12:55.610Z","comments":true,"path":"2020/01/16/golang-114-raft-5-presis/","link":"","permalink":"https://dreamerjonson.com/2020/01/16/golang-114-raft-5-presis/","excerpt":"","text":"准备工作 1、阅读raft论文 2、阅读raft理论与实践[1]-理论篇 3、阅读raft理论与实践[2]-lab2a 4、阅读raft理论与实践[3]-lab2a讲解 5、阅读raft理论与实践[4]-lab2b日志复制 6、查看我写的这篇文章： 模拟RPC远程过程调用 持久化 如果基于Raft的服务器重新启动，则应从中断的位置恢复服务。 这就要求Raft保持持久状态，使其在重启后仍然有效。 论文中Figure 2指出了那些字段需要持久化。 并且raft.go包含有关如何保存和恢复持久性状态的示例。 一个“真实的服务在每次Raft更改状态时将Raft的持久状态写入磁盘，并在重新启动时从磁盘读取最新的状态来恢复。 但是我们的实现将会采用一个结构体的方式来模拟实现persister.go。 调用Raft.Make（）会提供一个Persister，它持有Raft的最近持久状态。 Raft应从该Persister初始化其状态，并在每次状态更改时修改其持久状态。 主要使用Persister的ReadRaftState（）和SaveRaftState（）方法。 在本实验中，我们需要完善在raft.go中的persist() and readPersist()方法。 需要使用到labgob包中的编码与解码函数。 你需要明确在什么时候需要持久化。 下面只列出两个重要实现，其他不再赘述，留给读者自己实现。 持久化编码 123456789101112func (rf *Raft) persist() &#123; // Your code here (2C). w := new(bytes.Buffer) e:= labgob.NewEncoder(w) e.Encode(rf.CurrentTerm) e.Encode(rf.VotedFor) e.Encode(rf.Logs) data := w.Bytes() rf.persister.SaveRaftState(data)&#125; 持久化解码 123456789101112func (rf *Raft) readPersist(data []byte) &#123; if data &#x3D;&#x3D; nil || len(data) &lt; 1 &#123; &#x2F;&#x2F; bootstrap without any state? return &#125; &#x2F;&#x2F; Your code here (2C). r :&#x3D; bytes.NewBuffer(data) d:&#x3D; labgob.NewDecoder(r) d.Decode(&amp;rf.CurrentTerm) d.Decode(&amp;rf.VotedFor) d.Decode(&amp;rf.Logs)&#125; 测试 1&gt; go test -v -run&#x3D;2C","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"6.s081[2]-unix内存分配方式-malloc实现","slug":"6-s081-2-Memory-allocation","date":"2020-01-14T09:23:29.000Z","updated":"2020-02-05T04:05:18.664Z","comments":true,"path":"2020/01/14/6-s081-2-Memory-allocation/","link":"","permalink":"https://dreamerjonson.com/2020/01/14/6-s081-2-Memory-allocation/","excerpt":"","text":"系统编程（Systems programming） wiki参考 与应用程序编程相比，系统编程的主要区别在于，应用程序编程旨在产生直接向用户提供服务的软件。 系统编程主要为其他应用程序提供服务，直接操作操作系统。它的目标是实现对可用资源的有效利用。 例如： unix utilities K/V servers ssh bigint library 挑战： 低级编程环境 数字是64位（不是无限的整数） 分配/释放内存 并发 允许并行处理请求 崩溃 性能 为应用程序提供硬件支持 动态内存分配是一项基本的系统服务 底层编程： 指针操作，类型转换 使用底层操作系统请求内存块（memory chunks） 性能非常重要 支持广泛类型的应用程序负载 应用程序结构 text data (静态存储) stack (栈存储) heap (动态内存分配) 使用 sbrk() o或 mmap() 操作系统接口扩展堆。 [text | data | heap -&gt; … &lt;- stack] 0 top of address space data段的内存分配是静态的，始终存在。 栈的分配在函数中，随着函数消亡而释放。 堆的分配与释放，调用接口： — malloc(int sz) — free§ 堆分配的目标 快速分配和释放 内存开销小 想要使用所有内存 避免碎片化 下面介绍几种malloc实现的方式 方式1：K&amp;R malloc 又叫做first-fit规则, 即查找第一个可用的匹配块。与之相对应的是查找第一个最符合（best-fit）的可用块。 K&amp;R malloc的实现来自书籍 the C programming language by Kernighan and Ritchie (K&amp;R) Section 8.7 维持一个链表 维持的free list是一个环。 第一个元素是base。 1234567891011#define NALLOC 1024 &#x2F;* minimum #units to request *&#x2F;struct header &#123; struct header *ptr; size_t size;&#125;;typedef struct header Header;static Header base;static Header *freep &#x3D; NULL; 内存分配 指定分配的内存大小为sizeof(Header)的倍数，且一定大于nbytes。nunits就是这个倍数。 循环free list。 找到第一个符合即大于等于nbytes的块。 — 如果刚好合适，则链表删除此块并返回此块。 — 如果大于，则截断此元素 — 如果没有找到合适的块，则调用moreheap新分配一个。 123456789101112131415161718192021222324252627282930313233&#x2F;* malloc: general-purpose storage allocator *&#x2F;void *kr_malloc(size_t nbytes)&#123; Header *p, *prevp; unsigned nunits; nunits &#x3D; (nbytes + sizeof(Header) - 1) &#x2F; sizeof(Header) + 1; &#x2F;&#x2F; base作为第一个元素。 if ((prevp &#x3D; freep) &#x3D;&#x3D; NULL) &#123; &#x2F;* no free list yet *&#x2F; base.ptr &#x3D; freep &#x3D; prevp &#x3D; &amp;base; base.size &#x3D; 0; &#125; for (p &#x3D; prevp-&gt;ptr; ; prevp &#x3D; p, p &#x3D; p-&gt;ptr) &#123; if (p-&gt;size &gt;&#x3D; nunits) &#123; &#x2F;* big enough *&#x2F; if (p-&gt;size &#x3D;&#x3D; nunits) &#x2F;* exactly *&#x2F; prevp-&gt;ptr &#x3D; p-&gt;ptr; else &#123; &#x2F;* allocate tail end *&#x2F; p-&gt;size -&#x3D; nunits; p +&#x3D; p-&gt;size; p-&gt;size &#x3D; nunits; &#125; freep &#x3D; prevp; return (void *) (p + 1); &#125; if (p &#x3D;&#x3D; freep) &#123; &#x2F;* wrapped around free list *&#x2F; if ((p &#x3D; (Header *) moreheap(nunits)) &#x3D;&#x3D; NULL) &#123; return NULL; &#x2F;* none left *&#x2F; &#125; &#125; &#125;&#125; sbrk sbrk是unix增加内存的操作系统调用。 wiki的解释是： 12The brk and sbrk calls dynamically change the amount of space allocated for the data segment of the calling process. The change is made by resetting the program break of the process, which determines the maximum space that can be allocated. The program break is the address of the first location beyond the current end of the data region. The amount of available space increases as the break value increases. The available space is initialized to a value of zero, unless the break is lowered and then increased, as it may reuse the same pages in some unspecified way. The break value can be automatically rounded up to a size appropriate for the memory management architecture.[4]Upon successful completion, the brk subroutine returns a value of 0, and the sbrk subroutine returns the prior value of the program break (if the available space is increased then this prior value also points to the start of the new area). If either subroutine is unsuccessful, a value of −1 is returned and the errno global variable is set to indicate the error. 由于这里是增加内存，sbrk成功时会返回新增加区域的开始地址，如果失败则会返回-1。 新生成一个块之后，调用free函数将其加入到freelist当中。 注意这里的up+1 是什么意思。其代表的是新分配的区域的开头。以为新分配的区域之前有Header大小，用于标识大小和下一个区域。 123456789101112131415static Header *moreheap(size_t nu)&#123; char *cp; Header *up; if (nu &lt; NALLOC) nu &#x3D; NALLOC; cp &#x3D; sbrk(nu * sizeof(Header)); if (cp &#x3D;&#x3D; (char *) -1) return NULL; up &#x3D; (Header *) cp; up-&gt;size &#x3D; nu; kr_free((void *)(up + 1)); return freep;&#125; free ap是要释放的区域，其前面还有Header大小。bp 指向了块的开头。 遍历free list，找到要插入的中间区域。 如果前后的区域正好是连在一起的，则进行合并。 123456789101112131415161718192021222324252627282930&#x2F;* free: put block ap in free list *&#x2F;voidkr_free(void *ap)&#123; Header *bp, *p; if (ap &#x3D;&#x3D; NULL) return; bp &#x3D; (Header *) ap - 1; &#x2F;* point to block header *&#x2F; for (p &#x3D; freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;ptr); p &#x3D; p-&gt;ptr) if (p &gt;&#x3D; p-&gt;ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;ptr)) break; &#x2F;* freed block at start or end of arena *&#x2F; if (bp + bp-&gt;sizfe &#x3D;&#x3D; p-&gt;ptr) &#123; &#x2F;* join to upper nbr *&#x2F; bp-&gt;size +&#x3D; p-&gt;ptr-&gt;size; bp-&gt;ptr &#x3D; p-&gt;ptr-&gt;ptr; &#125; else &#123; bp-&gt;ptr &#x3D; p-&gt;ptr; &#125; if (p + p-&gt;size &#x3D;&#x3D; bp) &#123; &#x2F;* join to lower nbr *&#x2F; p-&gt;size +&#x3D; bp-&gt;size; p-&gt;ptr &#x3D; bp-&gt;ptr; &#125; else &#123; p-&gt;ptr &#x3D; bp; &#125; freep &#x3D; p;&#125; 方式2：Region-based allocator, a special-purpose allocator. malloc 与free 快速 内存开销低 内存碎片严重 不通用，用于特定应用程序。 1234567891011121314151617181920212223242526272829303132struct region &#123; void *start; void *cur; void *end;&#125;;typedef struct region Region;static Region rg_base;Region *rg_create(size_t nbytes)&#123; rg_base.start &#x3D; sbrk(nbytes); rg_base.cur &#x3D; rg_base.start; rg_base.end &#x3D; rg_base.start + nbytes; return &amp;rg_base;&#125;void *rg_malloc(Region *r, size_t nbytes)&#123; assert (r-&gt;cur + nbytes &lt;&#x3D; r-&gt;end); void *p &#x3D; r-&gt;cur; r-&gt;cur +&#x3D; nbytes; return p;&#125;&#x2F;&#x2F; free all memory in region resetting cur to startvoidrg_free(Region *r) &#123; r-&gt;cur &#x3D; r-&gt;start;&#125; 方式3：Buddy allocator 我觉得wiki的解释挺好的： wiki解析 提示： 对于2^k 大小的空间，我们可以将其分割为大小为2^0, 2^1, 2^2, … 2^k的多种可能。 malloc(17) 会分配 32 bytes，因此其会一定程度上浪费空间。 数据结构带来的格外内存开销 malloc 和free快速。 下面介绍一种代码实现。 基本参数 ROUNDUP(n,sz) 求出要分配n哥字节时，希望分配的实际内存是大于等于n 并且是sz的倍数。 1234567#define LEAF_SIZE 16 &#x2F;&#x2F; The smallest allocation size (in bytes)#define NSIZES 15 &#x2F;&#x2F; Number of entries in bd_sizes array#define MAXSIZE (NSIZES-1) &#x2F;&#x2F; Largest index in bd_sizes array#define BLK_SIZE(k) ((1L &lt;&lt; (k)) * LEAF_SIZE) &#x2F;&#x2F; Size in bytes for size k#define HEAP_SIZE BLK_SIZE(MAXSIZE) #define NBLK(k) (1 &lt;&lt; (MAXSIZE-k)) &#x2F;&#x2F; Number of block at size k#define ROUNDUP(n,sz) (((((n)-1)&#x2F;(sz))+1)*(sz)) &#x2F;&#x2F; Round up to the next multiple of sz NBLK求出在第k位置有多少块。 每一个大小k维护一个sz_info, sz_info中都有一个free list, alloc 是一个char数组用于记录块是否分配。split 是一个char数组用于块是否割裂。 这里要注意，使用的是bit数组来记录。 char有8位，如第n位代表的是当前k大小的第5个区块。 123456789101112&#x2F;&#x2F; The allocator has sz_info for each size k. Each sz_info has a free&#x2F;&#x2F; list, an array alloc to keep track which blocks have been&#x2F;&#x2F; allocated, and an split array to to keep track which blocks have&#x2F;&#x2F; been split. The arrays are of type char (which is 1 byte), but the&#x2F;&#x2F; allocator uses 1 bit per block (thus, one char records the info of&#x2F;&#x2F; 8 blocks).struct sz_info &#123; struct bd_list free; char *alloc; char *split;&#125;;typedef struct sz_info Sz_info; 每一个级别的双链表 for free list 12345&#x2F;&#x2F; A double-linked list for the free list of each levelstruct bd_list &#123; struct bd_list *next; struct bd_list *prev;&#125;; bit数组操作 1234567891011121314151617181920&#x2F;&#x2F; Return 1 if bit at position index in array is set to 1int bit_isset(char *array, int index) &#123; char b &#x3D; array[index&#x2F;8]; char m &#x3D; (1 &lt;&lt; (index % 8)); return (b &amp; m) &#x3D;&#x3D; m;&#125;&#x2F;&#x2F; Set bit at position index in array to 1void bit_set(char *array, int index) &#123; char b &#x3D; array[index&#x2F;8]; char m &#x3D; (1 &lt;&lt; (index % 8)); array[index&#x2F;8] &#x3D; (b | m);&#125;&#x2F;&#x2F; Clear bit at position index in arrayvoid bit_clear(char *array, int index) &#123; char b &#x3D; array[index&#x2F;8]; char m &#x3D; (1 &lt;&lt; (index % 8)); array[index&#x2F;8] &#x3D; (b &amp; ~m);&#125; 初始化 首先调用mmap分配一个非常大的区域。此大小为2 ^ MAXSIZE * 16,16为分配的最小块。 123456789101112131415161718192021222324&#x2F;&#x2F; Allocate memory for the heap managed by the allocator, and allocate&#x2F;&#x2F; memory for the data structures of the allocator.voidbd_init() &#123; bd_base &#x3D; mmap(NULL, HEAP_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (bd_base &#x3D;&#x3D; MAP_FAILED) &#123; fprintf(stderr, &quot;couldn&#39;t map heap; %s\\n&quot;, strerror(errno)); assert(bd_base); &#125; &#x2F;&#x2F; printf(&quot;bd: heap size %d\\n&quot;, HEAP_SIZE); for (int k &#x3D; 0; k &lt; NSIZES; k++) &#123; lst_init(&amp;bd_sizes[k].free); int sz &#x3D; sizeof(char)*ROUNDUP(NBLK(k), 8)&#x2F;8; bd_sizes[k].alloc &#x3D; malloc(sz); memset(bd_sizes[k].alloc, 0, sz); &#125; for (int k &#x3D; 1; k &lt; NSIZES; k++) &#123; int sz &#x3D; sizeof(char)*ROUNDUP(NBLK(k), 8)&#x2F;8; bd_sizes[k].split &#x3D; malloc(sz); memset(bd_sizes[k].split, 0, sz); &#125; lst_push(&amp;bd_sizes[MAXSIZE].free, bd_base);&#125; 找到第一个k， 使得2^k &gt;= n 123456789101112&#x2F;&#x2F; What is the first k such that 2^k &gt;&#x3D; n?intfirstk(size_t n) &#123; int k &#x3D; 0; size_t size &#x3D; LEAF_SIZE; while (size &lt; n) &#123; k++; size *&#x3D; 2; &#125; return k;&#125; 查找位置p ， 如果以2^k 大小为区块，那么其位于第几个区块。 1234567&#x2F;&#x2F; Compute the block index for address p at size kintblk_index(int k, char *p) &#123; int n &#x3D; p - (char *) bd_base; return n &#x2F; BLK_SIZE(k);&#125; 将k大小，序号为bi的区块的首地址计算出来 12345&#x2F;&#x2F; Convert a block index at size k back into an addressvoid *addr(int k, int bi) &#123; int n &#x3D; bi * BLK_SIZE(k); return (char *) bd_base + n;&#125; malloc 找到一个大小k，块2^k是大于等于要分配的大小。 如果db_size[k].free 不为空，说明当前有大小为k的空闲空间。 如果没有找到，则让k+1，继续找到更大的空间有无空闲。 如果找到，则lst_pop(&amp;bd_sizes[k].free)获取第一个块。 blk_index(k, p)获取以k为衡量指标，p位于的第n个块。 并通过bit_set将bd_sizes[k].alloc 在第n号位置设置为1。 如果找到的k是比较大的空间，这时候需要对此空间进行分割，一分为2。 一直到找到一个比较符合的空间。 1234567891011121314151617181920212223242526272829303132void *bd_malloc(size_t nbytes)&#123; int fk, k; assert(bd_base !&#x3D; NULL); &#x2F;&#x2F; Find a free block &gt;&#x3D; nbytes, starting with smallest k possible fk &#x3D; firstk(nbytes); for (k &#x3D; fk; k &lt; NSIZES; k++) &#123; if(!lst_empty(&amp;bd_sizes[k].free)) break; &#125; if(k &gt;&#x3D; NSIZES) &#x2F;&#x2F; No free blocks? return NULL; &#x2F;&#x2F; Found one; pop it and potentially split it. char *p &#x3D; lst_pop(&amp;bd_sizes[k].free); bit_set(bd_sizes[k].alloc, blk_index(k, p)); for(; k &gt; fk; k--) &#123; &#x2F;&#x2F; 第2半的空间 char *q &#x3D; p + BLK_SIZE(k-1); &#x2F;&#x2F; 对于大小k来说，其在位置p处是分割的。 bit_set(bd_sizes[k].split, blk_index(k, p)); &#x2F;&#x2F; 对于大小k-1来说，其在位置p处是分配的。 bit_set(bd_sizes[k-1].alloc, blk_index(k-1, p)); &#x2F;&#x2F; 对于大小k-1来说，其在位置q处是空闲的。 lst_push(&amp;bd_sizes[k-1].free, q); &#125; &#x2F;&#x2F; printf(&quot;malloc: %p size class %d\\n&quot;, p, fk); return p;&#125; free 当要free位置p时，size找到第一个k，当k+1在p位置是分割的，则返回k。这时候说明在k处区域是可以合并的。这是一种优化。 12345678910 &#x2F;&#x2F; Find the size of the block that p points to.intsize(char *p) &#123; for (int k &#x3D; 0; k &lt; NSIZES; k++) &#123; if(bit_isset(bd_sizes[k+1].split, blk_index(k+1, p))) &#123; return k; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122232425voidbd_free(void *p) &#123; void *q; int k; for (k &#x3D; size(p); k &lt; MAXSIZE; k++) &#123; int bi &#x3D; blk_index(k, p); bit_clear(bd_sizes[k].alloc, bi); int buddy &#x3D; (bi % 2 &#x3D;&#x3D; 0) ? bi+1 : bi-1; if (bit_isset(bd_sizes[k].alloc, buddy)) &#123; break; &#125; &#x2F;&#x2F; budy is free; merge with buddy q &#x3D; addr(k, buddy); lst_remove(q); if(buddy % 2 &#x3D;&#x3D; 0) &#123; p &#x3D; q; &#125; bit_clear(bd_sizes[k+1].split, blk_index(k+1, p)); &#125; &#x2F;&#x2F; 放入freelist当中。 &#x2F;&#x2F; printf(&quot;free %p @ %d\\n&quot;, p, k); lst_push(&amp;bd_sizes[k].free, p);&#125; 环形双链表的基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;&#x2F; Implementation of lists: double-linked and circular. Double-linked&#x2F;&#x2F; makes remove fast. Circular simplifies code, because don&#39;t have to&#x2F;&#x2F; check for empty list in insert and remove.voidlst_init(Bd_list *lst)&#123; lst-&gt;next &#x3D; lst; lst-&gt;prev &#x3D; lst;&#125;intlst_empty(Bd_list *lst) &#123; return lst-&gt;next &#x3D;&#x3D; lst;&#125;voidlst_remove(Bd_list *e) &#123; e-&gt;prev-&gt;next &#x3D; e-&gt;next; e-&gt;next-&gt;prev &#x3D; e-&gt;prev;&#125;void*lst_pop(Bd_list *lst) &#123; assert(lst-&gt;next !&#x3D; lst); Bd_list *p &#x3D; lst-&gt;next; lst_remove(p); return (void *)p;&#125;voidlst_push(Bd_list *lst, void *p)&#123; Bd_list *e &#x3D; (Bd_list *) p; e-&gt;next &#x3D; lst-&gt;next; e-&gt;prev &#x3D; lst; lst-&gt;next-&gt;prev &#x3D; p; lst-&gt;next &#x3D; e;&#125;voidlst_print(Bd_list *lst)&#123; for (Bd_list *p &#x3D; lst-&gt;next; p !&#x3D; lst; p &#x3D; p-&gt;next) &#123; printf(&quot; %p&quot;, p); &#125; printf(&quot;\\n&quot;);&#125; 其他顺序分配方式 dlmalloc slab allocator 其他目标 内存开销小 例如buddy的元数据很大 良好的内存位置 cpu核心增加时，扩展性好 并发malloc / free 参考资料 wiki 讲义","categories":[{"name":"unix","slug":"unix","permalink":"https://dreamerjonson.com/categories/unix/"}],"tags":[{"name":"unix","slug":"unix","permalink":"https://dreamerjonson.com/tags/unix/"}]},{"title":"golang[113]-raft理论与实践[4]-lab2b日志复制","slug":"golang-113-raft-4-log","date":"2020-01-12T13:00:32.000Z","updated":"2020-01-18T12:09:54.707Z","comments":true,"path":"2020/01/12/golang-113-raft-4-log/","link":"","permalink":"https://dreamerjonson.com/2020/01/12/golang-113-raft-4-log/","excerpt":"","text":"准备工作 1、阅读raft论文 2、阅读raft理论与实践[1]-理论篇 3、阅读raft理论与实践[2]-lab2a 4、阅读raft理论与实践[3]-lab2a讲解 5、查看我写的这篇文章： 模拟RPC远程过程调用 执行日志 我们需要执行日志中的命令，因此在make函数中，新开一个协程:applyLogEntryDaemon() 123456789func Make(peers []*labrpc.ClientEnd, me int, persister *Persister, applyCh chan ApplyMsg) *Raft &#123; ... go rf.applyLogEntryDaemon() // start apply log DPrintf(\"[%d-%s]: newborn election(%s) heartbeat(%s) term(%d) voted(%d)\\n\", rf.me, rf, rf.electionTimeout, rf.heartbeatInterval, rf.CurrentTerm, rf.VotedFor) return rf&#125; 一个死循环 1、如果rf.lastApplied == rf.commitIndex, 意味着commit log entry命令都已经被执行了，这时用信号量陷入等待。 一旦收到信号，说明需要执行命令。这时会把最后执行的log entry之后，一直到最后一个commit log entry的所有log都传入通道apply中进行执行。 由于是测试，处理apply的逻辑会在测试代码中。 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F; applyLogEntryDaemon exit when shutdown channel is closedfunc (rf *Raft) applyLogEntryDaemon() &#123; for &#123; var logs []LogEntry &#x2F;&#x2F; wait rf.mu.Lock() for rf.lastApplied &#x3D;&#x3D; rf.commitIndex &#123; rf.commitCond.Wait() select &#123; case &lt;-rf.shutdownCh: rf.mu.Unlock() DPrintf(&quot;[%d-%s]: peer %d is shutting down apply log entry to client daemon.\\n&quot;, rf.me, rf, rf.me) close(rf.applyCh) return default: &#125; &#125; last, cur :&#x3D; rf.lastApplied, rf.commitIndex if last &lt; cur &#123; rf.lastApplied &#x3D; rf.commitIndex logs &#x3D; make([]LogEntry, cur-last) copy(logs, rf.Logs[last+1:cur+1]) &#125; rf.mu.Unlock() for i :&#x3D; 0; i &lt; cur-last; i++ &#123; &#x2F;&#x2F; current command is replicated, ignore nil command reply :&#x3D; ApplyMsg&#123; CommandIndex: last + i + 1, Command: logs[i].Command, CommandValid: true, &#125; &#x2F;&#x2F; reply to outer service &#x2F;&#x2F; DPrintf(&quot;[%d-%s]: peer %d apply %v to client.\\n&quot;, rf.me, rf, rf.me) DPrintf(&quot;[%d-%s]: peer %d apply to client.\\n&quot;, rf.me, rf, rf.me) &#x2F;&#x2F; Note: must in the same goroutine, or may result in out of order apply rf.applyCh &lt;- reply &#125; &#125;&#125; 新增 Start函数，此函数为leader执行从client发送过来的命令。 当client发送过来之后，首先需要做的就是新增entry 到leader的log中。并且将自身的nextIndex 与matchIndex 更新。 123456789101112131415161718192021222324252627282930313233func (rf *Raft) Start(command interface&#123;&#125;) (int, int, bool) &#123; index :&#x3D; -1 term :&#x3D; 0 isLeader :&#x3D; false &#x2F;&#x2F; Your code here (2B). select &#123; case &lt;-rf.shutdownCh: return -1, 0, false default: rf.mu.Lock() defer rf.mu.Unlock() &#x2F;&#x2F; Your code here (2B). if rf.state &#x3D;&#x3D; Leader &#123; log :&#x3D; LogEntry&#123;rf.CurrentTerm, command&#125; rf.Logs &#x3D; append(rf.Logs, log) index &#x3D; len(rf.Logs) - 1 term &#x3D; rf.CurrentTerm isLeader &#x3D; true &#x2F;&#x2F;DPrintf(&quot;[%d-%s]: client add new entry (%d-%v), logs: %v\\n&quot;, rf.me, rf, index, command, rf.logs) DPrintf(&quot;[%d-%s]: client add new entry (%d)\\n&quot;, rf.me, rf, index) &#x2F;&#x2F;DPrintf(&quot;[%d-%s]: client add new entry (%d-%v)\\n&quot;, rf.me, rf, index, command) &#x2F;&#x2F; only update leader rf.nextIndex[rf.me] &#x3D; index + 1 rf.matchIndex[rf.me] &#x3D; index &#125; &#125; return index, term, isLeader&#125; 接下来最重要的部分涉及到日志复制，这是通过AppendEntries实现的。我们知道leader会不时的调用consistencyCheck(n)进行一致性检查。 在给第n号节点一致性检查时，首先获取pre = rf.nextIndex，pre至少要为1。代表要给n节点发送的log index。因此AppendEntriesArgs参数中，PrevLogIndex 与 prevlogTerm 都为pre - 1位置。 代表leader相信PrevLogIndex及其之前的节点都是与leader相同的。 将pre及其之后的entry 加入到AppendEntriesArgs参数中。 这些log entry可能是与leader不相同的，或者是follower根本就没有的。 12345678910111213141516171819202122232425func (rf *Raft) consistencyCheck(n int) &#123; rf.mu.Lock() defer rf.mu.Unlock() pre := max(1,rf.nextIndex[n]) var args = AppendEntriesArgs&#123; Term: rf.CurrentTerm, LeaderID: rf.me, PrevLogIndex: pre - 1, PrevLogTerm: rf.Logs[pre - 1].Term, Entries: nil, LeaderCommit: rf.commitIndex, &#125; if rf.nextIndex[n] &lt; len(rf.Logs)&#123; args.Entries = append(args.Entries, rf.Logs[pre:]...) &#125; go func() &#123; DPrintf(\"[%d-%s]: consistency Check to peer %d.\\n\", rf.me, rf, n) var reply AppendEntriesReply if rf.sendAppendEntries(n, &amp;args, &amp;reply) &#123; rf.consistencyCheckReplyHandler(n, &amp;reply) &#125; &#125;()&#125; 接下来查看follower执行AppendEntries时的反应。 AppendEntries会新增两个返回参数： ConflictTerm代表可能发生冲突的term FirstIndex 代表可能发生冲突的第一个index。 1234567type AppendEntriesReply struct &#123; CurrentTerm int &#x2F;&#x2F; currentTerm, for leader to update itself Success bool &#x2F;&#x2F; true if follower contained entry matching prevLogIndex and prevLogTerm &#x2F;&#x2F; extra info for heartbeat from follower ConflictTerm int &#x2F;&#x2F; term of the conflicting entry FirstIndex int &#x2F;&#x2F; the first index it stores for ConflictTerm&#125; 如果args.PrevLogIndex &lt; len(rf.Logs), 表明至少当前节点的log长度是合理的。 令preLogIdx 与 args.PrevLogIndex相等。prelogTerm为当前follower节点preLogIdx位置的term。 如果拥有相同的term，说明follower与leader 在preLogIdx之前的log entry都是相同的。因此请求是成功的。 此时会截断follower的log，将传递过来的entry加入到follower的log之后，执行此步骤后，强制要求与leader的log相同了。 请求成功后，reply的ConflictTerm为最后一个log entry的term,reply的FirstIndex为最后一个log entry的index。 否则说明leader与follower的日志是有冲突的，冲突的原因可能是： 1、leader认为的match log entry超出了follower的log个数，或者follower 还没有任何log entry（除了index为0的entry是每一个节点都有的）。 2、log在相同的index下，leader的term 与follower的term确是不同的。 这时找到follower冲突的term即为ConflictTerm。 获取此term的第一个entry的index即为FirstIndex。 所以最后，AppendEntries会返回冲突的term以及第一个可能冲突的index。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#x2F;&#x2F; AppendEntries handler, including heartbeat, must backup quicklyfunc (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123; ... preLogIdx, preLogTerm :&#x3D; 0, 0 if args.PrevLogIndex &lt; len(rf.Logs) &#123; preLogIdx &#x3D; args.PrevLogIndex preLogTerm &#x3D; rf.Logs[preLogIdx].Term &#125; &#x2F;&#x2F; last log is match if preLogIdx &#x3D;&#x3D; args.PrevLogIndex &amp;&amp; preLogTerm &#x3D;&#x3D; args.PrevLogTerm &#123; reply.Success &#x3D; true &#x2F;&#x2F; truncate to known match rf.Logs &#x3D; rf.Logs[:preLogIdx+1] rf.Logs &#x3D; append(rf.Logs, args.Entries...) var last &#x3D; len(rf.Logs) - 1 &#x2F;&#x2F; min(leaderCommit, index of last new entry) if args.LeaderCommit &gt; rf.commitIndex &#123; rf.commitIndex &#x3D; min(args.LeaderCommit, last) &#x2F;&#x2F; signal possible update commit index go func() &#123; rf.commitCond.Broadcast() &#125;() &#125; &#x2F;&#x2F; tell leader to update matched index reply.ConflictTerm &#x3D; rf.Logs[last].Term reply.FirstIndex &#x3D; last if len(args.Entries) &gt; 0 &#123; DPrintf(&quot;[%d-%s]: AE success from leader %d (%d cmd @ %d), commit index: l-&gt;%d, f-&gt;%d.\\n&quot;, rf.me, rf, args.LeaderID, len(args.Entries), preLogIdx+1, args.LeaderCommit, rf.commitIndex) &#125; else &#123; DPrintf(&quot;[%d-%s]: &lt;heartbeat&gt; current logs: %v\\n&quot;, rf.me, rf, rf.Logs) &#125; &#125; else &#123; reply.Success &#x3D; false &#x2F;&#x2F; extra info for restore missing entries quickly: from original paper and lecture note &#x2F;&#x2F; if follower rejects, includes this in reply: &#x2F;&#x2F; &#x2F;&#x2F; the follower&#39;s term in the conflicting entry &#x2F;&#x2F; the index of follower&#39;s first entry with that term &#x2F;&#x2F; &#x2F;&#x2F; if leader knows about the conflicting term: &#x2F;&#x2F; move nextIndex[i] back to leader&#39;s last entry for the conflicting term &#x2F;&#x2F; else: &#x2F;&#x2F; move nextIndex[i] back to follower&#39;s first index var first &#x3D; 1 reply.ConflictTerm &#x3D; preLogTerm if reply.ConflictTerm &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; which means leader has more logs or follower has no log at all first &#x3D; len(rf.Logs) reply.ConflictTerm &#x3D; rf.Logs[first-1].Term &#125; else &#123; i :&#x3D; preLogIdx &#x2F;&#x2F; term的第一个log entry for ; i &gt; 0; i-- &#123; if rf.Logs[i].Term !&#x3D; preLogTerm &#123; first &#x3D; i + 1 break &#125; &#125; &#125; reply.FirstIndex &#x3D; first if len(rf.Logs) &lt;&#x3D; args.PrevLogIndex &#123; DPrintf(&quot;[%d-%s]: AE failed from leader %d, leader has more logs (%d &gt; %d), reply: %d - %d.\\n&quot;, rf.me, rf, args.LeaderID, args.PrevLogIndex, len(rf.Logs)-1, reply.ConflictTerm, reply.FirstIndex) &#125; else &#123; DPrintf(&quot;[%d-%s]: AE failed from leader %d, pre idx&#x2F;term mismatch (%d !&#x3D; %d, %d !&#x3D; %d).\\n&quot;, rf.me, rf, args.LeaderID, args.PrevLogIndex, preLogIdx, args.PrevLogTerm, preLogTerm) &#125; &#125;&#125; leader调用AppendEntries后，会执行回调函数consistencyCheckReplyHandler。 如果调用是成功的，那么正常的跟新matchIndex，nextIndex即下一个要发送的index应该为matchIndex + 1。 如果调用失败，说明有冲突。 如果confiicting term等于0，说明了leader认为的match log entry超出了follower的log个数，或者follower 还没有任何log entry（除了index为0的entry是每一个节点都有的）。 此时简单的让nextIndex 为reply.FirstIndex即可。 如果confiicting term不为0，获取leader节点confiicting term 的最后一个log index，此时nextIndex 应该为此index与reply.FirstIndex的最小值。 检查最小值是必须的： 假设 s1: 0-0 1-1 1-2 1-3 1-4 1-5 s2: 0-0 1-1 1-2 1-3 1-4 1-5 s3: 0-0 1-1 此时s1为leader，并一致性检查s3, 从1-5开始检查，此时由于leader有更多的log，因此检查不成功，返回confict term 1， firstindex：2 如果只是获取confiicting term 的最后一个log index，那么nextIndex又是1-5，陷入了死循环。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func (rf *Raft) consistencyCheckReplyHandler(n int, reply *AppendEntriesReply) &#123; rf.mu.Lock() defer rf.mu.Unlock() if rf.state !&#x3D; Leader &#123; return &#125; if reply.Success &#123; &#x2F;&#x2F; RPC and consistency check successful rf.matchIndex[n] &#x3D; reply.FirstIndex rf.nextIndex[n] &#x3D; rf.matchIndex[n] + 1 rf.updateCommitIndex() &#x2F;&#x2F; try to update commitIndex &#125; else &#123; &#x2F;&#x2F; found a new leader? turn to follower if rf.state &#x3D;&#x3D; Leader &amp;&amp; reply.CurrentTerm &gt; rf.CurrentTerm &#123; rf.turnToFollow() rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; DPrintf(&quot;[%d-%s]: leader %d found new term (heartbeat resp from peer %d), turn to follower.&quot;, rf.me, rf, rf.me, n) return &#125; &#x2F;&#x2F; Does leader know conflicting term? var know, lastIndex &#x3D; false, 0 if reply.ConflictTerm !&#x3D; 0 &#123; for i :&#x3D; len(rf.Logs) - 1; i &gt; 0; i-- &#123; if rf.Logs[i].Term &#x3D;&#x3D; reply.ConflictTerm &#123; know &#x3D; true lastIndex &#x3D; i DPrintf(&quot;[%d-%s]: leader %d have entry %d is the last entry in term %d.&quot;, rf.me, rf, rf.me, i, reply.ConflictTerm) break &#125; &#125; if know &#123; rf.nextIndex[n] &#x3D; min(lastIndex, reply.FirstIndex) &#125; else &#123; rf.nextIndex[n] &#x3D; reply.FirstIndex &#125; &#125; else &#123; rf.nextIndex[n] &#x3D; reply.FirstIndex &#125; rf.nextIndex[n] &#x3D; min(rf.nextIndex[n], len(rf.Logs)) DPrintf(&quot;[%d-%s]: nextIndex for peer %d &#x3D;&gt; %d.\\n&quot;, rf.me, rf, n, rf.nextIndex[n]) &#125;&#125; 当调用AppendEntry成功后，说明follower与leader的log是匹配的。此时leader会找到commited的log并且执行其命令。 这里有一个比较巧妙的方法，对matchIndex排序后取最中间的数。 由于matchIndex代表follower有多少log与leader的log匹配，因此中间的log index意味着其得到了大部分节点的认可。 因此会将此中间的index之前的所有log entry都执行了。 rf.Logs[target].Term == rf.CurrentTerm 是必要的： 这是由于当一个entry出现在大多数节点的log中，并不意味着其一定会成为commit。考虑下面的情况： 12345S1: 1 2 1 2 4S2: 1 2 1 2S3: 1 --&gt; 1 2S4: 1 1S5: 1 1 3 s1在term2成为leader，只有s1，s2添加了entry2. s5变成了term3的leader，之后s1变为了term4的leader，接着继续发送entry2到s3中。 此时，如果s5再次变为了leader，那么即便没有S1的支持，S5任然变为了leader，并且应用entry3，覆盖掉entry2。 所以一个entry要变为commit，必须： 1、在其term周期内，就复制到大多数。 2、如果随后的entry被提交。在上例中，如果s1持续成为term4的leader，那么entry2就会成为commit。 这是由于以下原因造成的： 更高任期为最新的投票规则，以及leader将其日志强加给follower。 123456789101112131415161718192021222324252627&#x2F;&#x2F; updateCommitIndex find new commit id, must be called when hold lockfunc (rf *Raft) updateCommitIndex() &#123; match :&#x3D; make([]int, len(rf.matchIndex)) copy(match, rf.matchIndex) sort.Ints(match) DPrintf(&quot;[%d-%s]: leader %d try to update commit index: %v @ term %d.\\n&quot;, rf.me, rf, rf.me, rf.matchIndex, rf.CurrentTerm) target :&#x3D; match[len(rf.peers)&#x2F;2] if rf.commitIndex &lt; target &#123; &#x2F;&#x2F;fmt.Println(&quot;target:&quot;,target,match) if rf.Logs[target].Term &#x3D;&#x3D; rf.CurrentTerm &#123; &#x2F;&#x2F;DPrintf(&quot;[%d-%s]: leader %d update commit index %d -&gt; %d @ term %d command:%v\\n&quot;, &#x2F;&#x2F; rf.me, rf, rf.me, rf.commitIndex, target, rf.CurrentTerm,rf.Logs[target].Command) DPrintf(&quot;[%d-%s]: leader %d update commit index %d -&gt; %d @ term %d\\n&quot;, rf.me, rf, rf.me, rf.commitIndex, target, rf.CurrentTerm) rf.commitIndex &#x3D; target go func() &#123; rf.commitCond.Broadcast() &#125;() &#125; else &#123; DPrintf(&quot;[%d-%s]: leader %d update commit index %d failed (log term %d !&#x3D; current Term %d)\\n&quot;, rf.me, rf, rf.me, rf.commitIndex, rf.Logs[target].Term, rf.CurrentTerm) &#125; &#125;&#125; 参考 讲义 讲义新","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[112]-raft理论与实践[3]-lab2a讲解","slug":"golang-111-raft-3-elect","date":"2020-01-06T12:15:46.000Z","updated":"2020-01-12T12:56:56.541Z","comments":true,"path":"2020/01/06/golang-111-raft-3-elect/","link":"","permalink":"https://dreamerjonson.com/2020/01/06/golang-111-raft-3-elect/","excerpt":"","text":"1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。 12345678910111213141516171819202122232425262728type Raft struct &#123; mu sync.Mutex // Lock to protect shared access to this peer's state peers []*labrpc.ClientEnd // RPC end points of all peers persister *Persister // Object to hold this peer's persisted state me int // this peer's index into peers[] dead int32 // set by Kill() // Your data here (2A, 2B, 2C). // Look at the paper's Figure 2 for a description of what // state a Raft server must maintain. state int // follower, candidate or leader resetTimer chan struct&#123;&#125; // for reset election timer electionTimer *time.Timer // election timer electionTimeout time.Duration // 400~800ms heartbeatInterval time.Duration // 100ms CurrentTerm int // Persisted before responding to RPCs VotedFor int // Persisted before responding to RPCs Logs []LogEntry // Persisted before responding to RPCs commitCond *sync.Cond // for commitIndex update //newEntryCond []*sync.Cond // for new log entry commitIndex int // Volatile state on all servers lastApplied int // Volatile state on all servers nextIndex []int // Leader only, reinitialized after election matchIndex []int // Leader only, reinitialized after election applyCh chan ApplyMsg // outgoing channel to service shutdownCh chan struct&#123;&#125; // shutdown channel, shut raft instance gracefully&#125; 获取当前raft节点的term与状态 123456789101112func (rf *Raft) GetState() (int, bool) &#123; var term int var isleader bool &#x2F;&#x2F; Your code here (2A). rf.mu.Lock() defer rf.mu.Unlock() term &#x3D; rf.CurrentTerm isleader &#x3D; rf.state &#x3D;&#x3D; Leader return term, isleader&#125; 2、填充RequestVoteArgs和RequestVoteReply结构。 12345678910111213type RequestVoteArgs struct &#123; &#x2F;&#x2F; Your data here (2A, 2B). Term int &#x2F;&#x2F; candidate&#39;s term CandidateID int &#x2F;&#x2F; candidate requesting vote LastLogIndex int &#x2F;&#x2F; index of candidate&#39;s last log entry LastLogTerm int &#x2F;&#x2F; term of candidate&#39;s last log entry&#125;type RequestVoteReply struct &#123; &#x2F;&#x2F; Your data here (2A). CurrentTerm int &#x2F;&#x2F; currentTerm, for candidate to update itself VoteGranted bool &#x2F;&#x2F; true means candidate received vote&#125; 实现RPC方法RequestVote 1、获取当前节点的log个数，以及最后一个log的term 确定当前节点的term。 2、如果调用节点的term小于当前节点，返回当前term，并且不为其投票。 3、如果调用节点的term大于当前节点，修改当前节点的term，当前节点转为follower. 4、如果调用节点的term大于当前节点，或者等于当前节点term并且调用节点的log个数大于等于当前节点的log，则为调用节点投票。 5、投票后重置当前节点的选举超时时间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123; &#x2F;&#x2F; Your code here (2A, 2B). select &#123; case &lt;-rf.shutdownCh: DPrintf(&quot;[%d-%s]: peer %d is shutting down, reject RV rpc request.\\n&quot;, rf.me, rf, rf.me) return default: &#125; rf.mu.Lock() defer rf.mu.Unlock() lastLogIdx, lastLogTerm :&#x3D; rf.lastLogIndexAndTerm() DPrintf(&quot;[%d-%s]: rpc RV, from peer: %d, arg term: %d, my term: %d (last log idx: %d-&gt;%d, term: %d-&gt;%d)\\n&quot;, rf.me, rf, args.CandidateID, args.Term, rf.CurrentTerm, args.LastLogIndex, lastLogIdx, args.LastLogTerm, lastLogTerm) if args.Term &lt; rf.CurrentTerm &#123; reply.CurrentTerm &#x3D; rf.CurrentTerm reply.VoteGranted &#x3D; false &#125; else &#123; if args.Term &gt; rf.CurrentTerm &#123; &#x2F;&#x2F; convert to follower rf.CurrentTerm &#x3D; args.Term rf.state &#x3D; Follower rf.VotedFor &#x3D; -1 &#125; &#x2F;&#x2F; if is null (follower) or itself is a candidate (or stale leader) with same term if rf.VotedFor &#x3D;&#x3D; -1 &#123; &#x2F;&#x2F;|| (rf.VotedFor &#x3D;&#x3D; rf.me &amp;&amp; !sameTerm) &#123; &#x2F;&#x2F;|| rf.votedFor &#x3D;&#x3D; args.CandidateID &#123; &#x2F;&#x2F; check whether candidate&#39;s log is at-least-as update if (args.LastLogTerm &#x3D;&#x3D; lastLogTerm &amp;&amp; args.LastLogIndex &gt;&#x3D; lastLogIdx) || args.LastLogTerm &gt; lastLogTerm &#123; rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; rf.state &#x3D; Follower rf.VotedFor &#x3D; args.CandidateID reply.VoteGranted &#x3D; true DPrintf(&quot;[%d-%s]: peer %d vote to peer %d (last log idx: %d-&gt;%d, term: %d-&gt;%d)\\n&quot;, rf.me, rf, rf.me, args.CandidateID, args.LastLogIndex, lastLogIdx, args.LastLogTerm, lastLogTerm) &#125; &#125; &#125;&#125; 修改make 除了一些基本的初始化过程,新开了一个goroutine。 123456789101112131415161718192021222324252627282930func Make(peers []*labrpc.ClientEnd, me int, persister *Persister, applyCh chan ApplyMsg) *Raft &#123; rf :&#x3D; &amp;Raft&#123;&#125; rf.peers &#x3D; peers rf.persister &#x3D; persister rf.me &#x3D; me rf.applyCh &#x3D; applyCh &#x2F;&#x2F; Your initialization code here (2A, 2B, 2C). rf.state &#x3D; Follower rf.VotedFor &#x3D; -1 rf.Logs &#x3D; make([]LogEntry, 1) &#x2F;&#x2F; first index is 1 rf.Logs[0] &#x3D; LogEntry&#123; &#x2F;&#x2F; placeholder Term: 0, Command: nil, &#125; rf.nextIndex &#x3D; make([]int, len(peers)) rf.matchIndex &#x3D; make([]int, len(peers)) rf.electionTimeout &#x3D; time.Millisecond * time.Duration(400+rand.Intn(100)*4) rf.electionTimer &#x3D; time.NewTimer(rf.electionTimeout) rf.resetTimer &#x3D; make(chan struct&#123;&#125;) rf.shutdownCh &#x3D; make(chan struct&#123;&#125;) &#x2F;&#x2F; shutdown raft gracefully rf.commitCond &#x3D; sync.NewCond(&amp;rf.mu) &#x2F;&#x2F; commitCh, a distinct goroutine rf.heartbeatInterval &#x3D; time.Millisecond * 40 &#x2F;&#x2F; small enough, not too small &#x2F;&#x2F; initialize from state persisted before a crash rf.readPersist(persister.ReadRaftState()) go rf.electionDaemon() &#x2F;&#x2F; kick off election return rf&#125; 选举核心electionDaemon 除了shutdown，还有两个通道，一个是electionTimer，用于选举超时。 一个是resetTimer,用于重置选举超时。 注意time.reset是很难正确使用的。 一旦选举超时，调用go rf.canvassVotes() 123456789101112131415161718192021&#x2F;&#x2F; electionDaemonfunc (rf *Raft) electionDaemon() &#123; for &#123; select &#123; case &lt;-rf.shutdownCh: DPrintf(&quot;[%d-%s]: peer %d is shutting down electionDaemon.\\n&quot;, rf.me, rf, rf.me) return case &lt;-rf.resetTimer: if !rf.electionTimer.Stop() &#123; &lt;-rf.electionTimer.C &#125; rf.electionTimer.Reset(rf.electionTimeout) case &lt;-rf.electionTimer.C: rf.mu.Lock() DPrintf(&quot;[%d-%s]: peer %d election timeout, issue election @ term %d\\n&quot;, rf.me, rf, rf.me, rf.CurrentTerm) rf.mu.Unlock() go rf.canvassVotes() rf.electionTimer.Reset(rf.electionTimeout) &#125; &#125;&#125; 拉票 replyHandler是进行请求返回后的处理。 当前节点为了成为leader，会调用每一个节点的RequestVote方法。 如果返回过来的term大于当前term，那么当前节点变为follower,重置选举超时时间。 否则，如果收到了超过一半节点的投票,那么其变为了leader，并立即给其他节点发送心跳检测。 1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F; canvassVotes issues RequestVote RPCfunc (rf *Raft) canvassVotes() &#123; var voteArgs RequestVoteArgs rf.fillRequestVoteArgs(&amp;voteArgs) peers :&#x3D; len(rf.peers) var votes &#x3D; 1 replyHandler :&#x3D; func(reply *RequestVoteReply) &#123; rf.mu.Lock() defer rf.mu.Unlock() if rf.state &#x3D;&#x3D; Candidate &#123; if reply.CurrentTerm &gt; voteArgs.Term &#123; rf.CurrentTerm &#x3D; reply.CurrentTerm rf.turnToFollow() &#x2F;&#x2F;rf.persist() rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; &#x2F;&#x2F; reset timer return &#125; if reply.VoteGranted &#123; if votes &#x3D;&#x3D; peers&#x2F;2 &#123; rf.state &#x3D; Leader rf.resetOnElection() &#x2F;&#x2F; reset leader state go rf.heartbeatDaemon() &#x2F;&#x2F; new leader, start heartbeat daemon DPrintf(&quot;[%d-%s]: peer %d become new leader.\\n&quot;, rf.me, rf, rf.me) return &#125; votes++ &#125; &#125; &#125; for i :&#x3D; 0; i &lt; peers; i++ &#123; if i !&#x3D; rf.me &#123; go func(n int) &#123; var reply RequestVoteReply if rf.sendRequestVote(n, &amp;voteArgs, &amp;reply) &#123; replyHandler(&amp;reply) &#125; &#125;(i) &#125; &#125;&#125; 心跳检测 1、leader调用每一个节点的AppendEntries方法。 2、如果当前节点大于调用节点，那么AppendEntries失败。否则，修改当前的term为最大。 3、如果当前节点是leader，始终将其变为follower（为了让leader稳定） 4、将当前节点投票给调用者（对于落后的节点）。 5、重置当前节点的超时时间。 123456789101112131415161718192021222324252627282930313233343536373839404142func (rf *Raft) heartbeatDaemon() &#123; for &#123; if _, isLeader :&#x3D; rf.GetState(); !isLeader &#123; return &#125; &#x2F;&#x2F; reset leader&#39;s election timer rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; select &#123; case &lt;-rf.shutdownCh: return default: for i :&#x3D; 0; i &lt; len(rf.peers); i++ &#123; if i !&#x3D; rf.me &#123; go rf.consistencyCheck(i) &#x2F;&#x2F; routine heartbeat &#125; &#125; &#125; time.Sleep(rf.heartbeatInterval) &#125;&#125;func (rf *Raft) consistencyCheck(n int) &#123; rf.mu.Lock() defer rf.mu.Unlock() pre :&#x3D; rf.nextIndex[n] - 1 var args &#x3D; AppendEntriesArgs&#123; Term: rf.CurrentTerm, LeaderID: rf.me, PrevLogIndex: pre, PrevLogTerm: rf.Logs[pre].Term, Entries: nil, LeaderCommit: rf.commitIndex, &#125; go func() &#123; DPrintf(&quot;[%d-%s]: consistency Check to peer %d.\\n&quot;, rf.me, rf, n) var reply AppendEntriesReply if rf.sendAppendEntries(n, &amp;args, &amp;reply) &#123; rf.consistencyCheckReplyHandler(n, &amp;reply) &#125; &#125;()&#125; 12345678910111213141516171819202122232425262728293031323334353637383940func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123; select &#123; case &lt;-rf.shutdownCh: DPrintf(&quot;[%d-%s]: peer %d is shutting down, reject AE rpc request.\\n&quot;, rf.me, rf, rf.me) return default: &#125; DPrintf(&quot;[%d-%s]: rpc AE, from peer: %d, term: %d\\n&quot;, rf.me, rf, args.LeaderID, args.Term) rf.mu.Lock() defer rf.mu.Unlock() if args.Term &lt; rf.CurrentTerm &#123; &#x2F;&#x2F;DPrintf(&quot;[%d-%s]: AE failed from leader %d. (heartbeat: leader&#39;s term &lt; follower&#39;s term (%d &lt; %d))\\n&quot;, &#x2F;&#x2F; rf.me, rf, args.LeaderID, args.Term, rf.currentTerm) reply.CurrentTerm &#x3D; rf.CurrentTerm reply.Success &#x3D; false return &#125; if rf.CurrentTerm &lt; args.Term &#123; rf.CurrentTerm &#x3D; args.Term &#125; &#x2F;&#x2F; for stale leader if rf.state &#x3D;&#x3D; Leader &#123; rf.turnToFollow() &#125; &#x2F;&#x2F; for straggler (follower) if rf.VotedFor !&#x3D; args.LeaderID &#123; rf.VotedFor &#x3D; args.LeaderID &#125; &#x2F;&#x2F; valid AE, reset election timer &#x2F;&#x2F; if the node recieve heartbeat. then it will reset the election timeout rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; reply.Success &#x3D; true reply.CurrentTerm &#x3D; rf.CurrentTerm return&#125; 处理心跳检测返回 如果心跳检测失败了，那么变为follower，重置选举超时。 123456789101112131415161718192021&#x2F;&#x2F; n: which followerfunc (rf *Raft) consistencyCheckReplyHandler(n int, reply *AppendEntriesReply) &#123; rf.mu.Lock() defer rf.mu.Unlock() if rf.state !&#x3D; Leader &#123; return &#125; if reply.Success &#123; &#125; else &#123; &#x2F;&#x2F; found a new leader? turn to follower if rf.state &#x3D;&#x3D; Leader &amp;&amp; reply.CurrentTerm &gt; rf.CurrentTerm &#123; rf.turnToFollow() rf.resetTimer &lt;- struct&#123;&#125;&#123;&#125; DPrintf(&quot;[%d-%s]: leader %d found new term (heartbeat resp from peer %d), turn to follower.&quot;, rf.me, rf, rf.me, n) return &#125; &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[111]-raft理论与实践[2]-lab2a实验说明","slug":"golang-111-raft-2","date":"2020-01-06T06:57:48.000Z","updated":"2020-01-14T03:12:52.652Z","comments":true,"path":"2020/01/06/golang-111-raft-2/","link":"","permalink":"https://dreamerjonson.com/2020/01/06/golang-111-raft-2/","excerpt":"","text":"准备工作 1、阅读raft论文 2、阅读我写的raft理论与实践[1]-理论篇 3、由于我们需要模拟rpc远程调用， 因此需要查看我写的这篇文章： 模拟RPC远程过程调用 4、实验开始，我们首先需要拉取代码： 12git clone git@github.com:dreamerjackson&#x2F;golang-deep-distributed-lab.gitgit checkout --hard 4e6446c 实验说明 此代码中labrpc 与 labgob 为模拟rpc的 package。 raft文件夹为此实验用到的代码框架。 在其中已经写好了一部分代码，还需要我们通过实验来完善它。 在本实验中，我们只需要关注raft.go文件，并实现选举逻辑和心跳检测逻辑。 本实验的目标是要保证，唯一的leader能够被选举。 当leader被选举后，如果没有任何失败，其将会保持leader。 当leader被选举后，如果leader奔溃或者to/from leader 的网络包丢失，则新的leader将会产生。 要验证代码的正确性，运行go test -run 2A 实验提示 1、raft.go 的raft结构体 补充字段。 字段应该尽量与raft论文的Figure2接近。 2、填充RequestVoteArgs和RequestVoteReply结构。 修改Make()以创建一个后台goroutine，该后台goroutine将在有一段时间没有收到其他节点的请求时通过发出RequestVote RPC来定期启动领导者选举。 这样，节点将了解谁是leader（如果已经有leader），或者成为leader本身。 实现RequestVote（）RPC处理程序，以便节点之间相互投票。 3、要实现心跳检测，请定义AppendEntries RPC结构（尽管您可能还不需要所有参数），并让leader定期调用其他节点此方法。 编写AppendEntries RPC方法，该方法将重置选举超时，以便在已经有leader时，阻止其他节点成为leader。 4、确保不同对等方的选举超时不会总是同时触发，否则所有节点都只会为自己投票，而没有人会成为领导者。 5、测试要求leader每秒发送心跳RPC的次数不得超过十次。 6、测试要求在leader失败后，也能够再5秒之内选出新的leader。 您必须选择足够短的选举超时时间（以及因此产生的心跳间隔）， 以使选举很有可能在不到五秒钟的时间内完成，即使需要进行多轮选举也是如此。 7、raft论文的5.2提到选举超时的范围是150到300毫秒，但是仅当领导者发送心跳的频率大大超过每150毫秒一次的频率时，此范围才有意义。 由于测试要求您的心跳检测为每秒10个，因此您将必须使用大于150到300毫秒的选举超时时间，但不能太大，因为那样的话，您可能会在五秒钟内无法选举领导者。 8、使用go的rand方法产生随机数。 9、go的time.Timer 和 time.Ticker 很难使用正确。 10、要调试代码，可以将util.go 的debug设置为1. 11、您应该使用go test -race检查代码，并修复它报告的所有问题。 参考 讲义 讲义新","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"6.s081[1]-操作系统原理","slug":"6-s081-1","date":"2020-01-04T06:27:36.000Z","updated":"2020-01-16T02:20:05.876Z","comments":true,"path":"2020/01/04/6-s081-1/","link":"","permalink":"https://dreamerjonson.com/2020/01/04/6-s081-1/","excerpt":"","text":"前言 实验1需要我们调用unix操作系统保持出的接口，因此首先需要了解unix操作系统有关的知识。 操作系统（operating system）的功能 操作系统的任务是在多个程序之间共享一台计算机，并提供比单独的硬件所支持的更为有用的服务集。 操作系统管理和抽象化低级硬件，因此，例如，文字处理器不必担心自己正在使用哪种类型的硬件。 操作系统允许多个程序之间共享硬件，以便它们可以并发运行。 最后，操作系统提供了程序交互的方式，以便它们可以共享数据，协同工作。 操作系统为用户程序提供接口去调用。设计一个好的接口操作系统接口非常困难。 一方面希望简单，一方面又希望实现复杂的功能。 一种好的设计思路是接口之间可以通过某种机制组合起来以实现复杂的操作。 本实验中，使用了xv6 操作系统。其提供了unix的基本操作系统接口，并且模仿了Unix的内部设计。 unix提供的接口很少，但是由于其可以组合的机制，提供了难以想象的通用性。该接口非常成功，以至于现代操作系统（BSD，Linux，Mac OS X，Solaris，甚至在较小程度上是Microsoft Windows）都具有类似Unix的接口。了解xv6是了解这些系统和许多其他系统的良好起点。 内核是操作系统的核心，为运行的程序提供服务。 每个正在运行的程序（称为进程）都具有包含指令，数据和堆栈的内存。 指令说明了程序的运行逻辑。数据是指令运行所需要的变量。堆栈组织程序的过程调用。 当进程需要调用内核服务时，它将通过操作系统提供的接口进行过程调用。 这样的过程称为系统调用。 内核使用CPU的硬件保护机制来确保在用户空间中执行的每个进程只能访问其自己的内存。 用户程序调用操作系统接口后，硬件提高权限级别，并开始在内核中执行预先安排的功能。 shell是一个普通程序，可读取用户命令并执行命令。 shell是用户程序而不是内核的一部分，这一事实说明了操作系统接口的强大功能。shell没有什么特别之处，这也意味着shell易于更换；现代Unix系统有多种shell可供选择，每种shell都有其自己的用户界面和脚本功能。 xv6 shell是Unix Bourne shell的简单实现。 可以在（user / sh.c：1）中找到其实现。 操作系统接口 xv6进程由用户空间内存（指令，数据和堆栈）和内核专有的每个进程状态组成。 xv6保证进程的并发执行，在多个进程之间切换CPU能力。 当某个进程未执行时，xv6保存其CPU寄存器，并在下次运行该进程时恢复它们。 内核将进程标识符或pid与每个进程相关联。 进程可以使用fork系统调用来创建新进程。 Fork创建一个称为子进程的新进程，该进程与父进程的内存完全相同。 Fork在子进程与父进程中都会返回。 在父进程中，fork返回子进程的pid； 在子进程中，它返回零。 例如，考虑以下用C编程语言编写的程序片段： 1234567891011int pid &#x3D; fork();if(pid &gt; 0)&#123; printf(&quot;parent: child&#x3D;%d\\en&quot;, pid); pid &#x3D; wait(0); printf(&quot;child %d is done\\en&quot;, pid);&#125; else if(pid &#x3D;&#x3D; 0)&#123; printf(&quot;child: exiting\\en&quot;); exit(0);&#125; else &#123; printf(&quot;fork error\\en&quot;);&#125; exit导致调用进程停止执行并释放资源，例如内存和打开的文件。 exit接受一个整数状态参数，通常0表示成功，1表示失败。 wait系统调用返回当前进程已退出子进程的pid，并将该子进程的退出状态传递给wait。 如果子进程都没有退出，一直会等待。 如果父进程不在乎子进程的退出状态，则可以传递状态0。 在下面的例子中，输出是： parent: child=1234 child: exiting 也可能出现另外的情况，具体取决于父进程还是子进程首先进入其printf调用。 子进程退出后，父进程的wait返回，导致父进程打印出： parent: child 1234 is done。 尽管子进程最初具有与父进程相同的内存内容，但是父进程和子进程执行时使用的是不同的内存和不同的寄存器。 更改一个变量不会影响另一个变量。 例如，当wait的返回值在父进程中存储到pid中时，它不会更改子进程中的pid。 子进程中的pid的值仍为零。 exec系统调用使用从文件系统中存储的文件加载的新的内存映像替换调用进程的内存。 该文件必须具有特定的格式，该格式指定文件的哪一部分包含指令，哪一部分是数据，从哪条指令开始等。 xv6使用ELF格式，第3章将对此进行详细讨论。 当exec成功执行时，它不会返回到调用程序。从文件加载的指令在ELF标头中声明的入口点开始执行。 Exec接受两个参数：包含可执行文件的文件名和一个字符串参数数组。 例如： 123456char *argv[3];argv[0] &#x3D; &quot;echo&quot;;argv[1] &#x3D; &quot;hello&quot;;argv[2] &#x3D; 0;exec(&quot;&#x2F;bin&#x2F;echo&quot;, argv);printf(&quot;exec error\\en&quot;); 该片段将调用程序以程序/ bin / echo的实例替换，参数列表为echo hello。 大多数程序会忽略第一个参数，这通常是程序的名称 xv6 Shell使用上述调用执行用户运行的程序。 xv6 Shell使用上述调用代表用户运行程序。 shell的主要结构很简单； 参见main（user / sh.c：145）。 主循环使用getcmd从用户读取一行输入。 然后，它将调用fork，这将创建shell进程的副本。 父进程调用wait，而子进程运行命令。 例如，如果用户键入“ echo hello”给shell，则将以“ echo hello”作为参数调用runcmd。 runcmd（user / sh.c：58）运行实际命令 对于“ echo hello”，它将调用exec（user / sh.c：78） 如果exec成功，则子进程将从echo执行指令，而不是runcmd。 在某些时候，echo将调用exit，这将导致父进程从main（user / sh.c：145）的wait中返回。 您可能想知道为什么fork和exec不能在单个调用中组合？ 稍后我们将看到，用于创建进程和加载程序的单独调用在Shell中用于I / O重定向的用法很巧妙。 为了避免创建重复进程然后立即替换它的浪费，运行中的内核通过使用虚拟内存技术（如copy-on-write 写时复制）来针对此用例优化fork的实现。 Xv6隐式分配了大多数用户空间内存：fork分配了子进程复制父进程所需的内存，而exec分配了足够的内存来保存可执行文件。 一个在运行时需要更多内存的进程（可能是malloc）可以调用sbrk（n）将其数据内存增加n个字节。 sbrk返回新内存的位置。 Xv6没有提供用户概念来保护一个用户免受另一个用户侵害；用Unix术语，所有xv6进程都以root身份运行。 I/O 与文件描述符 文件描述符是一个小的整数，表示进程可以从中读取或写入的内核管理的对象。 进程可以通过打开文件，目录或设备，或通过创建管道，或通过复制现有描述符来获取文件描述符。 为简单起见，我们通常将文件描述符所指的对象称为“文件”； 文件描述符接口抽象了文件，管道和设备之间的差异，使它们看起来都像字节流。 在内部，xv6内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符专用空间。 按照惯例，进程从文件描述符0（标准输入）读取，将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。 就像我们将看到的那样，shell利用约定来实现I / O重定向(redirection)和管道(pipelines)。 shell确保始终打开三个文件描述符（user / sh.c：151），默认情况下，这三个文件描述符是控制台(console)的文件描述符。 read系统调用从文件描述符读取字节。 write系统调用从文件描述符写入字节。 调用read（fd，buf，n）最多从文件描述符fd中读取n个字节，将它们复制到buf中，并返回读取的字节数。 引用文件的每个文件描述符都有一个与之关联的偏移量。read从当前文件偏移量读取数据，随着读取到的数据增加，文件的偏移量随之增加。当没有更多字节可以读取时，read将返回零以指示文件末尾。 调用write（fd，buf，n）将buf中的n个字节写入文件描述符fd，并返回写入的字节数。 仅在发生错误时才写入少于n个字节。 与读操作类似，写操作会在当前文件偏移量处写入数据，然后将偏移量增加写入的字节数：每次写操作都从上次中止的位置开始。 以下程序片段（cat命令的功能）将数据从其标准输入复制到其标准输出。 如果发生错误，它将向标准错误写入一条消息。 123456789101112131415char buf[512];int n;for(;;)&#123; n &#x3D; read(0, buf, sizeof buf); if(n &#x3D;&#x3D; 0) break; if(n &lt; 0)&#123; fprintf(2, &quot;read error\\en&quot;); exit(); &#125; if(write(1, buf, n) !&#x3D; n)&#123; fprintf(2, &quot;write error\\en&quot;); exit(); &#125;&#125; 在代码片段中要注意的重要一点是cat不知道它是从文件，控制台还是管道中读取。 同样，cat不知道它是要打印到控制台，文件还是其他地方。 使用文件描述符以及文件描述符0是标准输入和输出文件描述符是标准输出的约定可以实现cat的简单实现。close系统调用将释放文件描述符，以供将来的open，pipe或dup系统调用重用。 新分配的文件描述符始终是当前进程中编号最小的未使用的描述符。 文件描述符和fork交互使I/O重定向易于实现。Fork会复制父文件的文件描述符表及其内存，以便子文件与父文件打开完全相同的文件。 exec系统调用替换了调用进程的内存，但保留了其文件表。 此行为允许Shell通过分叉，重新打开选定的文件描述符，然后exec新程序来实现I / O重定向。 这是shell为cat &lt;input.txt命令运行的代码的简化版本： 12345678char *argv[2]; argv[0] &#x3D; &quot;cat&quot;; argv[1] &#x3D; 0; if(fork() &#x3D;&#x3D; 0) &#123; close(0); open(&quot;input.txt&quot;, O_RDONLY); exec(&quot;cat&quot;, argv); &#125; 当child关闭文件描述符0后，0 是最小的文件描述符。因此open操作将使文件描述符0（标准输入）指向文件input.txt.xv6 shell中的I / O重定向代码完全以这种方式工作（user / sh.c：82）。 现在应该清楚为什么将fork和exec分开调用是一个好主意？ 因为如果它们是分开的，则shell可以fork一个child，在该child中使用open，close，dup来更改标准输入和输出文件描述符，然后exec。 不需要更改正在执行的程序（在我们的示例中为cat）。 如果将fork和exec组合到单个系统调用中，则shell将需要一些其他（可能更复杂）的方案来重定向标准输入和输出，或者程序本身将必须了解如何重定向I / O。 尽管fork复制了文件描述符表，但每个潜在文件的偏移量在父级和子级之间共享。 考虑以下示例： 1234567if(fork() &#x3D;&#x3D; 0) &#123; write(1, &quot;hello &quot;, 6); exit(0);&#125; else &#123; wait(0); write(1, &quot;world\\en&quot;, 6);&#125; 在上例中，父进程和子进程都将写入文件描述符1.最后输出的数据是&quot;hello world&quot; 父进程的写入会等到子进程写入后进行(由于wait)。两个文件描述符共享一个偏移量。 此行为有助于从Shell命令序列产生顺序输出，例如（echo hello; echo world）&gt; output.txt。 dup系统调用复制了一个现有的文件描述符，并返回了一个新的文件描述符，该描述符引用了相同的潜在I/O对象。两个文件描述符共享一个偏移量，就像fork所复制的文件描述符一样。这是将hello world写入文件的另一种方法： 123fd &#x3D; dup(1);write(1, &quot;hello &quot;, 6);write(fd, &quot;world\\en&quot;, 6); 如果两个文件描述符是通过fork和dup调用序列从同一原始文件描述符派生的，则它们共享一个偏移量。 否则，文件描述符不共享偏移量，即使它们是对同一文件的open产生的。 Dup允许shell执行以下命令： ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1。 2&gt;＆1告诉shell将文件描述符2与描述符1相同。已存在文件的名称和文件不存在等错误消息都将显示在文件tmp1中。 xv6 Shell不支持错误文件描述符的I / O重定向，但是现在您知道如何实现它。 文件描述符是一种强大的抽象，因为它们隐藏了它们所连接的对象的详细信息：写入文件描述符1的进程可能正在写入文件，诸如控制台的设备或管道。 管道 管道是一个小的内核缓冲区，以一对文件描述符的形式暴露给进程，一个用于读取，一个用于写入。 将数据写入管道的一端可使该数据可从管道的另一端读取。 管道为流程进行通信提供了一种方法。 以下示例代码运行程序wc,使用标准输入连接到管道的读取端。 12345678910111213141516int p[2];char *argv[2];argv[0] &#x3D; &quot;wc&quot;;argv[1] &#x3D; 0;pipe(p);if(fork() &#x3D;&#x3D; 0) &#123; close(0); dup(p[0]); close(p[0]); close(p[1]); exec(&quot;&#x2F;bin&#x2F;wc&quot;, argv);&#125; else &#123; close(p[0]); write(p[1], &quot;hello world\\en&quot;, 12); close(p[1]);&#125; 程序调用pipe创建一个新管道，并将读取和写入文件描述符记录在数组p中。 在fork之后，父进程和子进程都具有引用管道的文件描述符。 子进程将读取端复制到文件描述符0上，关闭p中的文件描述符，然后执行wc。 当wc从其标准输入中读取时，它将从管道中读取。 父进程关闭管道的读取侧，写入管道，然后关闭写入侧。 如果没有可用数据，则在管道上进行读取以等待写入数据或所有引用写入端的文件描述符被关闭； 在后一种情况下，读取将返回0，就像到达数据文件的末尾一样。 读取管道会一直堵塞直到无法接受到数据。因此，对于子进程来说，在执行上述wc之前关闭管道的写端很重要：如果wc进程的文件描述符之一引用了管道的写端，则wc将永远等不到文件末尾 。 xv6 shell实现了管道，例如grep fork sh.c | wc -l 类似于上面的代码（user / sh.c：100）。 子进程创建一个管道，以将管道的左端与右端连接起来。 然后，它在管道的左端调用fork和runcmd，在右端调用fork和runcmd，并等待两者都完成。 管道的右端可能是一个命令，该命令本身包括一个管道（例如a | b | c），该管道本身派生了两个新的子进程（一个用于b，一个用于c）。 因此，shell可以创建进程树。 该树的叶子是命令，内部节点是等待左右子节点完成的进程。 原则上，您可以让内部节点在管道的左端运行，但是这样做会使实现复杂化。 管道似乎没有临时文件强大：echo hello world | wc 可以在没有管道的情况下实现： echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz 在这种情况下，管道比临时文件至少具有四个优点。 首先，管道会自动清理自己； 使用文件重定向，shell必须在完成后小心删除/ tmp / xyz。 其次，管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。 第三，管道允许并行执行管道阶段，而文件方法要求第一个程序在第二个程序启动之前完成。 第四，如果要实现进程间通信，则管道的读写锁比文件的 non-blocking语义更有效。 文件系统 xv6文件系统提供了数据文件和目录，这些数据文件是原始的字节数组。目录包含对数据文件和其他目录的命名引用。 目录形成一棵树，从一个特殊的root目录开始。 类似于/a/b/c的路径是指根目录/中名为a的文件夹中名为b的文件夹中名为c的文件或文件夹。 不以/开头的路径是相对于调用进程的当前目录的。调用进程的当前目录可以通过chdir系统调用对其进行更改。 下面这两个程序片段都打开同一个文件（假设文件存在） 12345chdir(&quot;&#x2F;a&quot;);chdir(&quot;b&quot;);open(&quot;c&quot;, O_RDONLY);open(&quot;&#x2F;a&#x2F;b&#x2F;c&quot;, O_RDONLY); 第一个代码片段将进程的当前目录更改为/a /b； 第二个既不引用也不更改进程的当前目录。 有多个操作系统接口来创建新文件或文件夹：mkdir创建新文件夹，使用O_CREATE标志调用open将创建新数据文件，而mknod将创建新设备文件。 如下例所示: 1234mkdir(&quot;&#x2F;dir&quot;);fd &#x3D; open(&quot;&#x2F;dir&#x2F;file&quot;, O_CREATE|O_WRONLY);close(fd);mknod(&quot;&#x2F;console&quot;, 1, 1); Mknod在文件系统中创建一个文件，但是该文件没有内容。 但是，文件的元数据会将其标记为设备文件，并记录主设备号和次设备号（mknod的两个参数），它们唯一地标识内核设备。 当以后有一个进程打开文件时，内核会将read和write系统调用转换到内核设备的读写实现，而不是将它们转换到文件系统。 fstat系统调用得到有关文件描述符引用的对象的信息。此对象信息返回结构体stat，定义在 stat.h (kernel/stat.h)： 12345678910#define T_DIR 1 &#x2F;&#x2F; Directory#define T_FILE 2 &#x2F;&#x2F; File#define T_DEVICE 3 &#x2F;&#x2F; Devicestruct stat &#123; int dev; &#x2F;&#x2F; File system’s disk device uint ino; &#x2F;&#x2F; Inode number short type; &#x2F;&#x2F; Type of file short nlink; &#x2F;&#x2F; Number of links to file uint64 size; &#x2F;&#x2F; Size of file in bytes&#125;; 文件名与文件不同； 同一个文件（称为inode）可以具有多个名称（称为links）。 link系统调用将创建另一个文件名称，该名称引用与现有文件相同的inode。 下面的程序片段创建了一个名为a又为b的新文件。 12open(&quot;a&quot;, O_CREATE|O_WRONLY);link(&quot;a&quot;, &quot;b&quot;); 读取,写入a与读取,写入到b相同。 每个inode由唯一的inode编号标识。 在上面的代码片段之后，可以通过检查fstat的结果确定a和b是否引用相同的文件：两者将返回相同的inode编号（ino），并且nlink将变为2。 unlink系统调用从文件系统中删除一个名称。 仅当文件的link计数为零且没有文件描述符引用该文件时， 才会将inode和其所在的磁盘空间清除。 因此当执行了 1unlink(&quot;a&quot;); 之后，使用名称b任然能够访问文件。 下面的程序片段是一种惯用的方式创建一个临时inode。 12fd &#x3D; open(&quot;&#x2F;tmp&#x2F;xyz&quot;, O_CREATE|O_RDWR);unlink(&quot;&#x2F;tmp&#x2F;xyz&quot;); 当fd文件描述符被关闭后，临时的inode将会被清除。 用于文件系统操作的Shell命令是作为用户级程序（例如mkdir，ln，rm等）实现的。该设计允许任何人通过添加新的用户程序扩展Shell。在事后看来，似乎是理所当然的。 但和Unix同时期的其他系统设计，通常将这样的命令构建到shell中（并将shell构建到内核中）。 cd是一个例外，它内置在shell中（user / sh.c：160）。 cd必须更改shell本身的当前工作目录。 如果cd以常规命令运行，那么shell将派生一个子进程，该子进程将运行cd，而cd会更改该子进程的工作目录。 父进程(即shell)的工作目录不会更改。 终结 Unix结合了文件描述符，管道和方便的shell语法以对其进行操作，这是编写通用可复用程序的重大进步。这是Unix的强大功能和广泛使用的原因，外壳程序是第一种所谓的“脚本语言”。Unixit系统调用接口在BSD,Linux,和Mac OSX 上广泛使用。 Unix系统调用接口已通过可移植操作系统接口（POSIX）标准进行了标准化。 Xv6不兼容POSIX。 它抛弃一些了系统调用（包括诸如lseek之类的基本调用），仅部分实现了系统调用以及其他差异。 xv6的主要目标是简单性和清晰度，同时提供简单的类UNIX系统调用接口。 为了运行基本的Unix程序，一些人用更多的系统调用和一个简单的C库扩展了xv6。 但是，与xv6相比，现代内核提供了更多的系统调用和内核服务。 例如，它们支持联网，窗口系统，用户级线程，许多设备的驱动程序等。 现代内核不断快速发展，并提供了POSIX以外的许多功能。 在很大程度上，现代Unix派生的操作系统没有遵循早期的Unix模型，即将设备公开为特殊文件，例如上面讨论的控制台设备文件。Unix的作者继续构建Plan9，将“资源即文件”概念应用于现代设施，将网络，图形和其他资源表示为文件或文件树。 文件系统和文件描述符是强大的抽象。 即使这样，也存在其他模型。 Multics是Unix的前身，它以一种类似于内存的方式抽象了文件存储，从而产生了截然不同的界面风格。 Multics设计的复杂性直接影响了Unix的设计师，后者试图构建更简单的东西。 本书探讨了xv6如何实现其类似Unix的接口，但是这些思想和概念不仅适用于Unix。 任何操作系统都必须将进程多路复用到基础硬件上，将进程彼此隔离，并提供用于受控的进程间通信的机制。 研究xv6之后，您应该能够查看其他更复杂的操作系统， 参考资料 https://pdos.csail.mit.edu/6.828/2019/labs/util.html https://pdos.csail.mit.edu/6.828/2019/xv6/book-riscv-rev0.pdf https://pdos.csail.mit.edu/6.828/2019/lec/l-overview.txt","categories":[{"name":"unix","slug":"unix","permalink":"https://dreamerjonson.com/categories/unix/"}],"tags":[{"name":"unix","slug":"unix","permalink":"https://dreamerjonson.com/tags/unix/"}]},{"title":"golang[110]-raft算法理论与实践[1]","slug":"golang-110-lab-raft","date":"2019-12-29T15:06:17.000Z","updated":"2020-01-14T12:01:14.983Z","comments":true,"path":"2019/12/29/golang-110-lab-raft/","link":"","permalink":"https://dreamerjonson.com/2019/12/29/golang-110-lab-raft/","excerpt":"","text":"前言 我计划写raft的一系列文章，包含从理论到代码实践，此文章依托于MIT的研究生课程。 背景 raft 是一种分布式的共识算法，其目的是要实现多个节点集群的容错性,一致性从而能够构建大规模的软件系统。 在raft之前，比较有名的是Paxos。但是paxos难于理解。 raft的诞生是为了让共识算法更容易理解,在工程上更容易实现。 和其他的共识算法不同的是，raft具有下面的特点： 1、leader：raft中会有一个领导者具有超级权限，可以把自己的log 复制到其他节点中。 2、leader election： raft每隔一段随机的时间就会进行leader的选举 3、raft允许集群配置变化时正常运行。 Replicated state machine 状态机是分布式系统中的一个重要概念，任何一个系统的最终状态都可以看成是每一个操作的集合。因此，算法会维护一份replicated log，将每一份操作都存储起来。 每一个节点只要按顺序执行log中的命令，就会到达相同的最终状态。这样，即便是系统奔溃也可以快速的恢复。 共识算法需要保证relicated log的一致性,服务器收到客户端发出来的执行命令Command后，会将其加入到log中。 服务器之间会相互的交流，保证最后的log的一致性（即便服务器奔溃），即Command 会复制到其他服务器的log中，所有服务器的log是相同的，有序的。 其他服务器会执行此log，即会执行此命令。最后，所有的服务器都会到达同一个状态。 共识算法必须满足下面的属性： 1、在极端情况下（丢包、奔溃）任然能够保证安全性。 2、大多数节点正常的情况下能够保证可用。 3、不能依靠时间戳去保证log的一致性。 4、当大部分的节点通过RPC远程调用交流 达成共识后，command就可以被确认和执行。小部分节点的不稳定不会影响整个系统。 raft basic raft集群一般保持奇数个数量（5个节点比较普遍). 从而只要大部分节点存活，即可用。 raft中的节点有3种状态。 leader, Candidates, follower。 1、一般的状态只会存在一个leader，其余的节点都是follower。 2、leader会处理所有的客户端请求， 如果是客户端请求follower，也会被转发到leader处理。 3、Candidates 是一种选举时候的过渡状态，用于自身拉票选举leader。 在raft中会有一个叫做term的时间周期。term是以选举leader开始的，如果Candidates选举成为了leader，那么其会成为这个term剩下时间的leader。 有时候，在整个term周期都没有选举出leader。这时一个新的选举会在不久后开始。 Terms 在raft中类似于一种时间戳，后一个一定比前一个后发生，这一点和比特币中的区块链很类似。 每一个服务器会存储一个当前的term，其会随着时间的增加而增长。如果某一个节点的当前term小于其他节点，那么节点会更新自己的term为最大的term。 如果一个candidate 发现自己当前的term 过时了，那么其会立即变为follower。 raft节点之间通过RPC（远程过程调用）来进行通信。 RequestVote 方法用于candidate在选举时候使用，AppendEntries用于leader在通知其他节点复制log时使用。同时也用于心跳检测。 RPC 是并发的，并支持失败重试。 选举 在raft中会有一套心跳检测，只要follower收到来自leader或者Candidates的数据，那么其会保持follower的状态。 如果follower一段时间内没有收到RPC请求，这意味着选举超时（ election timeout ）。 这时follower会将current term 加1，过渡到Candidates状态。 其会给自己投票，并发送RequestVote RPC请求给其他的节点，拉票！ Candidates状态会持续，直到下面的3种情况发生: 1、当其获得了大部分节点的支持后，其赢得了选举，变为了leader。 一旦其变为了leader，其会向其他节点发送 AppendEntries RPC， 确认其leader的地位，阻止选举。 2、其他节点成为了leader。 如果其收到了其他节点的AppendEntries RPC. 并发现其他节点的current term比自己的大,则其变为follower状态。 3、一段时间过去任然没有参与者。 如果有许多的节点同时变为了candidate,则可能会出现一段时间内都没有节点能够选举成功的情况。 在raft中，为了快速解决并修复这个问题，规定了每一个candidate在选举前会重置一个随机的选举超时（ election timeout ）时间，此随机时间会在一个区间内（eg.150-300ms） 这样保证了，在大部分的情况下，有一个唯一的节点首先选举超时，其在大部分节点选举超时前发送心跳检测，赢得了选举。 当一个leader在心跳检测中发现另一个节点有更高的term时，会转变为follower。否则其将一直保持leader状态。 日志复制(Log replication) 当成为leader后，其会接受来自客户端的请求。每一个客户端请求都包含一个将要被节点的状态机执行的command。 leader其会将这个command 包装为一个entry放入到log中，并通过AppendEntries RPC 发送给其他节点，要求其添加此entry到log中。 当entry被 大部分的节点接受并复制后，这个entry的状态变为了committed. raft算法保证了commited entry到最后一定能够会被所有节点的状态机执行。 一旦follower知道（AppendEntries RPC）某一个entry被commit之后，follower会按顺序执行log中的entry entry in log 如图所示，我们可以把log 理解为entry的集合。在entry中包含了common命令、entry所在的term 以及每一个entry的顺序编号index。 raft的一致性保证了下面的属性： 1、如果在不同节点中log中的entry有相同的index 和term。 那么一定存储的是相同的command。 2、如果在不同节点中log中的entry有相同的index 和term。 那么此entry之前的所有entry都是相同的。 leader crashes 节点f可能会发生，如果其是term 2的leader, 添加entry到log中，但是没有commit时就奔溃了，其快速恢复后又变为了term 3 的leader， 添加entry到log中，没有commit又继续奔溃了。 在正常的情况下，上面的两个属性都能满足，但是异常情况下，这种情况会被打破，可能会出现如上图所示的情形， 在raft中，为了处理这样的不一致性，强制要求follower的log与leader的log要一致。 因此leader必须要发现一个entry，在这个entry之后的都是不相同的entry。在这个entry之前的都是一致的entry。在leader中会为每一个follower维护一份nextIndex 数组。标志了将要发送给follower的下一个index。 最后，follower会删除掉所有不同的entry，并用和leader一致的log。这一过程，都会通过AppendEntries RPC 执行完毕。当AppendEntries RPC返回success，就表明follower 与 leader的log是一致的。 安全性 上面的属性还不能够充分的保证系统的安全性。 考虑下面的例子： safe problem 上图要说明的是，一个已经被commit的entry 在目前的情况下是有可能被覆盖掉的。例如在a 阶段s1成为了leader，其entry还没有commit。 在b阶段,s1奔溃，s5成为了leader ，添加log但是任然没有commit。 在c阶段，s5奔溃，s1成为了leader。其entry成为了commit。 在d阶段s1奔溃，s5成为了leader，其会将本已commit的entry给覆盖掉。 raft使用一种更简单的方式来解决这个难题，raft为leader添加了限制: 要成为leader 必须要包含过去所有的commit entry。 Candidates 要想成为leader，必须要经过大部分follower节点的同意。 而commit entry 也表明其已经存在于大部分的服务器中。 因此commit entry 至少会出现在这些follower节点中的至少有一个节点。因此我们可以证明，在大部分的follower中，至少有一个是包含了leader的所有commit entry的。 因此 如果一个candidate的log是最新的（即他与其他的节点对比时，如果term更大的，最新。如果term相同的，那么越长的那个log越新。）其才可以成为leader。 因此可知，一个leader一定包含了以前leader的commit entry。 todo 配置改变、 日志压缩快照（log compaction / snapshotting ） 总结 上面对于raft的描述，保证了存在5点： 1、Election Safety：在一个term周期内只会存在一个leader。 2、Leader Append-Only： leader只会添加log，而不会删除或者覆盖log。 3、Log Matching：如果两个log有一个相同index与term的entry，那么他们之前的log都是相同的。 4、Leader Completeness：如果一个log entry在一个term周期成为commit， 那么其一定会存在于下一个leader的log中。 5、State Machine Safety：如果某节点已经将index A 应用于其状态机。则以后其他节点不可能在同一index A 却具有不同的log entry。 因为应用到状态机说明已经被commit，而借助于第4点得证。 参考资料 raft论文 raft可视化 知乎，写得一般但是有借鉴地方","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"emacs--构建cc++IDE","slug":"emacs-cc","date":"2019-12-25T09:10:26.000Z","updated":"2019-12-25T09:28:32.400Z","comments":true,"path":"2019/12/25/emacs-cc/","link":"","permalink":"https://dreamerjonson.com/2019/12/25/emacs-cc/","excerpt":"","text":"mac下安装依赖: 12345678910# for cmake$brew install cmake # for libclang$brew install llvm$echo &#39;export PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;opt&#x2F;llvm&#x2F;bin:$PATH&quot;&#39; &gt;&gt; ~&#x2F;.bash_profile $echo | clang -x c++ -v -E - 2&gt;&amp;1 | sed -n &#39;&#x2F;^#include &lt;&#x2F;,&#x2F;^End&#x2F;s|^&amp;#91;^&#x2F;&amp;#93;*\\(&amp;#91;^ &amp;#93;*&#x2F;include&amp;#91;^ &amp;#93;*\\).*$|-I\\1|p&#39; &gt; .clang_completionbrew install rtags user-package: ;;; c.el --- c/c++ mode -*- lexical-binding: t; -*- ;; Keywords: c ;;; Code: ;; ;; irony is for auto-complete, syntax checking and documentation ;; ;; You will need to install irony-server first time use ;; to install irony-server, your system need to install clang, cmake and clang-devel in advance ;; ;; if error:Could NOT find LibClang (missing: LIBCLANG_LIBRARY LIBCLANG_INCLUDE_DIR) ;; cmake add this flag: ;; -DLIBCLANG_LIBRARY\\=/usr/local/opt/llvm/lib/libclang.dylib ;; -DLIBCLANG_INCLUDE_DIR\\=/usr/local/opt/llvm/include/ (use-package irony :ensure t :hook ((c++-mode . irony-mode) (c-mode . irony-mode)) :config (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options) (use-package company-irony-c-headers :ensure t) (use-package company-irony :ensure t :config (add-to-list (make-local-variable 'company-backends) '(company-irony company-irony-c-headers))) (use-package flycheck-irony :ensure t :config (add-hook 'flycheck-mode-hook #'flycheck-irony-setup) ) (use-package irony-eldoc :ensure t :config (add-hook 'irony-mode-hook #'irony-eldoc) ) ) ;; ;; rtags enable jump-to-function definition ;; system need to install rtags first ;; ;; for centos, you need llvm-devel, cppunit-devl ;; install gcc-4.9, cmake 3.1 and download rtags from github and make it ;; (use-package rtags :ensure t :config (rtags-enable-standard-keybindings) (setq rtags-autostart-diagnostics t) (rtags-diagnostics) (setq rtags-completions-enabled t) (define-key c-mode-base-map (kbd &quot;M-.&quot;) (function rtags-find-symbol-at-point)) (define-key c-mode-base-map (kbd &quot;M-,&quot;) (function rtags-find-references-at-point)) ) ;; ;; cmake-ide enable rdm(rtags) auto start and rc(rtags) to watch directory ;; (use-package cmake-ide :ensure t :config (cmake-ide-setup) ) ;; ;; for editting CMakeLists.txt ;; (use-package cmake-mode :ensure t :mode ((&quot;CMakeLists\\\\.txt\\\\'&quot; . cmake-mode) (&quot;\\\\.cmake\\\\'&quot; . cmake-mode)) :config (add-hook 'cmake-mode-hook (lambda() (add-to-list (make-local-variable 'company-backends) 'company-cmake))) ) ;; for c formatting (use-package clang-format :ensure t :config (setq clang-format-style-option &quot;llvm&quot;) (add-hook 'c-mode-hook (lambda() (add-hook 'before-save-hook 'clang-format-buffer))) (add-hook 'c++-mode-hook (lambda() (add-hook 'before-save-hook 'clang-format-buffer))) ) (provide 'c) ;;; c.el ends here ## 参考资料 https://github.com/jerryhsieh/Emacs-config/blob/c%2B%2B/custom/c.el https://github.com/Sarcasm/irony-mode/issues/351","categories":[{"name":"emacs","slug":"emacs","permalink":"https://dreamerjonson.com/categories/emacs/"}],"tags":[{"name":"emacs","slug":"emacs","permalink":"https://dreamerjonson.com/tags/emacs/"}]},{"title":"golang[109]-lab-模拟rpc远程过程调用","slug":"golang-109-lab-simulate-rpc","date":"2019-12-25T03:24:06.000Z","updated":"2019-12-25T07:54:56.445Z","comments":true,"path":"2019/12/25/golang-109-lab-simulate-rpc/","link":"","permalink":"https://dreamerjonson.com/2019/12/25/golang-109-lab-simulate-rpc/","excerpt":"","text":"为了实践分布式的第一步，需要模拟远程的过程调用，就好像程序是部署在不同的机器通过tcp进行连接。 构建client 1234type ClientEnd struct &#123; endname interface&#123;&#125; &#x2F;&#x2F; this end-point&#39;s name ch chan reqMsg &#x2F;&#x2F; copy of Network.endCh&#125; endname 代表client的名字 ch 与network共享。用于传递请求参数： 1234567type reqMsg struct &#123; endname interface&#123;&#125; // name of sending ClientEnd svcMeth string // e.g. \"Raft.AppendEntries\" argsType reflect.Type args []byte replyCh chan replyMsg&#125; svcMeth 找到要请求的service，以及调用的方法 argsType 存储函数请求的类型，例如要远程调用的函数是， func (js *JunkServer) Handler4(args *JunkArgs, reply *JunkReply) { reply.X = “pointer” } 那么argsType存储的是*JunkArgs args 代表参数序列化后的字节数组 replych 接受返回字节数组。 1234type replyMsg struct &#123; ok bool reply []byte&#125; client调用 模拟客户端远程过程调用 1234567891011121314151617181920212223242526272829func (e *ClientEnd) Call(svcMeth string, args interface&#123;&#125;, reply interface&#123;&#125;) bool &#123; req := reqMsg&#123;&#125; req.endname = e.endname req.svcMeth = svcMeth req.argsType = reflect.TypeOf(args) req.replyCh = make(chan replyMsg) // serialize qb := new(bytes.Buffer) qe := gob.NewEncoder(qb) qe.Encode(args) req.args = qb.Bytes() // request param send to network e.ch &lt;- req rep := &lt;-req.replyCh if rep.ok &#123; // unserialize rb := bytes.NewBuffer(rep.reply) rd := gob.NewDecoder(rb) if err := rd.Decode(reply); err != nil &#123; log.Fatalf(\"ClientEnd.Call(): decode reply: %v\\n\", err) &#125; return true &#125; else &#123; return false &#125;&#125; build network 1234567891011type Network struct &#123; mu sync.Mutex reliable bool longDelays bool &#x2F;&#x2F; pause a long time on send on disabled connection longReordering bool &#x2F;&#x2F; sometimes delay replies a long time ends map[interface&#123;&#125;]*ClientEnd &#x2F;&#x2F; ends, by name enabled map[interface&#123;&#125;]bool &#x2F;&#x2F; by end name servers map[interface&#123;&#125;]*Server &#x2F;&#x2F; servers, by name connections map[interface&#123;&#125;]interface&#123;&#125; &#x2F;&#x2F; endname -&gt; servername endCh chan reqMsg&#125; reliable 模拟网络的可靠性 longDelays 模拟网络延迟 enabled 网络是否可用 endCh 用于接收client的请求 123456789101112131415161718func MakeNetwork() *Network &#123; rn :&#x3D; &amp;Network&#123;&#125; rn.reliable &#x3D; true rn.ends &#x3D; map[interface&#123;&#125;]*ClientEnd&#123;&#125; rn.enabled &#x3D; map[interface&#123;&#125;]bool&#123;&#125; rn.servers &#x3D; map[interface&#123;&#125;]*Server&#123;&#125; rn.connections &#x3D; map[interface&#123;&#125;](interface&#123;&#125;)&#123;&#125; rn.endCh &#x3D; make(chan reqMsg) &#x2F;&#x2F; single goroutine to handle all ClientEnd.Call()s go func() &#123; for xreq :&#x3D; range rn.endCh &#123; go rn.ProcessReq(xreq) &#125; &#125;() return rn&#125; network添加server 123456789101112131415func (rn *Network) AddServer(servername interface&#123;&#125;, rs *Server) &#123; rn.mu.Lock() defer rn.mu.Unlock() rn.servers[servername] &#x3D; rs&#125;func (rn *Network) DeleteServer(servername interface&#123;&#125;) &#123; rn.mu.Lock() defer rn.mu.Unlock() rn.servers[servername] &#x3D; nil&#125; 确保network 可用 12345678&#x2F;&#x2F; enable&#x2F;disable a ClientEnd.func (rn *Network) Enable(endname interface&#123;&#125;, enabled bool) &#123; rn.mu.Lock() defer rn.mu.Unlock() rn.enabled[endname] &#x3D; enabled&#125; network add server 123456func (rn *Network) AddServer(servername interface&#123;&#125;, rs *Server) &#123; rn.mu.Lock() defer rn.mu.Unlock() rn.servers[servername] &#x3D; rs&#125; network 连接client 与server 12345678&#x2F;&#x2F; connect a ClientEnd to a server.&#x2F;&#x2F; a ClientEnd can only be connected once in its lifetime.func (rn *Network) Connect(endname interface&#123;&#125;, servername interface&#123;&#125;) &#123; rn.mu.Lock() defer rn.mu.Unlock() rn.connections[endname] &#x3D; servername&#125; network create client end 在这里client的创建是通过network完成的 123456789101112131415161718&#x2F;&#x2F; create a client end-point.&#x2F;&#x2F; start the thread that listens and delivers.func (rn *Network) MakeEnd(endname interface&#123;&#125;) *ClientEnd &#123; rn.mu.Lock() defer rn.mu.Unlock() if _, ok :&#x3D; rn.ends[endname]; ok &#123; log.Fatalf(&quot;MakeEnd: %v already exists\\n&quot;, endname) &#125; e :&#x3D; &amp;ClientEnd&#123;&#125; e.endname &#x3D; endname e.ch &#x3D; rn.endCh rn.ends[endname] &#x3D; e rn.enabled[endname] &#x3D; false rn.connections[endname] &#x3D; nil return e&#125; network 统计进入的RPC数量 123456789&#x2F;&#x2F; get a server&#39;s count of incoming RPCs.func (rn *Network) GetCount(servername interface&#123;&#125;) int &#123; rn.mu.Lock() defer rn.mu.Unlock() svr :&#x3D; rn.servers[servername] return svr.GetCount()&#125; network处理client请求 ProceeReq 接受client发出的处理请求， 1、模拟网络的延迟，每次请求花费的时间 2、找到此client连接的server,调用server dispatch方法 3、等待返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081func (rn *Network) ProcessReq(req reqMsg) &#123; enabled, servername, server, reliable, longreordering := rn.ReadEndnameInfo(req.endname) if enabled &amp;&amp; servername != nil &amp;&amp; server != nil &#123; if reliable == false &#123; // short delay ms := (rand.Int() % 27) time.Sleep(time.Duration(ms) * time.Millisecond) &#125; if reliable == false &amp;&amp; (rand.Int()%1000) &lt; 100 &#123; // drop the request, return as if timeout req.replyCh &lt;- replyMsg&#123;false, nil&#125; return &#125; // execute the request (call the RPC handler). // in a separate thread so that we can periodically check // if the server has been killed and the RPC should get a // failure reply. ech := make(chan replyMsg) go func() &#123; r := server.dispatch(req) ech &lt;- r &#125;() // wait for handler to return, // but stop waiting if DeleteServer() has been called, // and return an error. var reply replyMsg replyOK := false serverDead := false for replyOK == false &amp;&amp; serverDead == false &#123; select &#123; case reply = &lt;-ech: replyOK = true case &lt;-time.After(100 * time.Millisecond): serverDead = rn.IsServerDead(req.endname, servername, server) &#125; &#125; // do not reply if DeleteServer() has been called, i.e. // the server has been killed. this is needed to avoid // situation in which a client gets a positive reply // to an Append, but the server persisted the update // into the old Persister. config.go is careful to call // DeleteServer() before superseding the Persister. serverDead = rn.IsServerDead(req.endname, servername, server) if replyOK == false || serverDead == true &#123; // server was killed while we were waiting; return error. req.replyCh &lt;- replyMsg&#123;false, nil&#125; &#125; else if reliable == false &amp;&amp; (rand.Int()%1000) &lt; 100 &#123; // drop the reply, return as if timeout req.replyCh &lt;- replyMsg&#123;false, nil&#125; &#125; else if longreordering == true &amp;&amp; rand.Intn(900) &lt; 600 &#123; // delay the response for a while ms := 200 + rand.Intn(1+rand.Intn(2000)) time.Sleep(time.Duration(ms) * time.Millisecond) req.replyCh &lt;- reply &#125; else &#123; req.replyCh &lt;- reply &#125; &#125; else &#123; // simulate no reply and eventual timeout. ms := 0 if rn.longDelays &#123; // let Raft tests check that leader doesn't send // RPCs synchronously. ms = (rand.Int() % 7000) &#125; else &#123; // many kv tests require the client to try each // server in fairly rapid succession. ms = (rand.Int() % 100) &#125; time.Sleep(time.Duration(ms) * time.Millisecond) req.replyCh &lt;- replyMsg&#123;false, nil&#125; &#125;&#125; build server 12345678910111213141516&#x2F;&#x2F;&#x2F;&#x2F; a server is a collection of services, all sharing&#x2F;&#x2F; the same rpc dispatcher. so that e.g. both a Raft&#x2F;&#x2F; and a k&#x2F;v server can listen to the same rpc endpoint.&#x2F;&#x2F;type Server struct &#123; mu sync.Mutex services map[string]*Service count int &#x2F;&#x2F; incoming RPCs&#125;func MakeServer() *Server &#123; rs :&#x3D; &amp;Server&#123;&#125; rs.services &#x3D; map[string]*Service&#123;&#125; return rs&#125; server 是由一系列的service组成的 12345678910111213141516&#x2F;&#x2F;&#x2F;&#x2F; a server is a collection of services, all sharing&#x2F;&#x2F; the same rpc dispatcher. so that e.g. both a Raft&#x2F;&#x2F; and a k&#x2F;v server can listen to the same rpc endpoint.&#x2F;&#x2F;type Server struct &#123; mu sync.Mutex services map[string]*Service count int &#x2F;&#x2F; incoming RPCs&#125;func MakeServer() *Server &#123; rs :&#x3D; &amp;Server&#123;&#125; rs.services &#x3D; map[string]*Service&#123;&#125; return rs&#125; server 是由一系列的service组成的 123456func (rs *Server) AddService(svc *Service) &#123; rs.mu.Lock() defer rs.mu.Unlock() rs.services[svc.name] &#x3D; svc&#125; server的一个重要方法是调用dispatch ，找到client具体是调用的哪个servise的哪个方法 eg.“Raft.AppendEntries” 123456789101112131415161718192021222324252627func (rs *Server) dispatch(req reqMsg) replyMsg &#123; rs.mu.Lock() rs.count +&#x3D; 1 &#x2F;&#x2F; split Raft.AppendEntries into service and method dot :&#x3D; strings.LastIndex(req.svcMeth, &quot;.&quot;) serviceName :&#x3D; req.svcMeth[:dot] methodName :&#x3D; req.svcMeth[dot+1:] service, ok :&#x3D; rs.services[serviceName] rs.mu.Unlock() if ok &#123; return service.dispatch(methodName, req) &#125; else &#123; choices :&#x3D; []string&#123;&#125; for k, _ :&#x3D; range rs.services &#123; choices &#x3D; append(choices, k) &#125; log.Fatalf(&quot;labrpc.Server.dispatch(): unknown service %v in %v.%v; expecting one of %v\\n&quot;, serviceName, serviceName, methodName, choices) return replyMsg&#123;false, nil&#125; &#125;&#125; build service 12345678&#x2F;&#x2F; an object with methods that can be called via RPC.&#x2F;&#x2F; a single server may have more than one Service.type Service struct &#123; name string rcvr reflect.Value typ reflect.Type methods map[string]reflect.Method&#125; methods 存储所有方法 typ 与 rcvr 存储结构体的反射类型 name 是结构体的名字 makeServise 方法将某个结构体即service的所有方法存起来。 规定函数必须有三个参数 第1个是调用方法的结构体 第2个是request参数 第3个是reply参数 1个返回值 123456789101112131415161718192021222324252627282930func MakeService(rcvr interface&#123;&#125;) *Service &#123; svc :&#x3D; &amp;Service&#123;&#125; svc.typ &#x3D; reflect.TypeOf(rcvr) svc.rcvr &#x3D; reflect.ValueOf(rcvr) svc.name &#x3D; reflect.Indirect(svc.rcvr).Type().Name() svc.methods &#x3D; map[string]reflect.Method&#123;&#125; for m :&#x3D; 0; m &lt; svc.typ.NumMethod(); m++ &#123; method :&#x3D; svc.typ.Method(m) mtype :&#x3D; method.Type mname :&#x3D; method.Name &#x2F;&#x2F;fmt.Printf(&quot;%v pp %v ni %v 1k %v 2k %v no %v\\n&quot;, &#x2F;&#x2F; mname, method.PkgPath, mtype.NumIn(), mtype.In(1).Kind(), mtype.In(2).Kind(), mtype.NumOut()) if method.PkgPath !&#x3D; &quot;&quot; || &#x2F;&#x2F; capitalized? mtype.NumIn() !&#x3D; 3 || &#x2F;&#x2F;mtype.In(1).Kind() !&#x3D; reflect.Ptr || mtype.In(2).Kind() !&#x3D; reflect.Ptr || mtype.NumOut() !&#x3D; 0 &#123; &#x2F;&#x2F; the method is not suitable for a handler &#x2F;&#x2F;fmt.Printf(&quot;bad method: %v\\n&quot;, mname) &#125; else &#123; &#x2F;&#x2F; the method looks like a handler svc.methods[mname] &#x3D; method &#125; &#125; return svc&#125; 测试 用一个简单的例子来测试并说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364type JunkArgs struct &#123; X int&#125;type JunkReply struct &#123; X string&#125;type JunkServer struct &#123; mu sync.Mutex log1 []string log2 []int&#125;&#x2F;&#x2F; args is a pointerfunc (js *JunkServer) Handler4(args *JunkArgs, reply *JunkReply) &#123; reply.X &#x3D; &quot;pointer&quot;&#125;&#x2F;&#x2F; args is a not pointerfunc (js *JunkServer) Handler5(args JunkArgs, reply *JunkReply) &#123; reply.X &#x3D; &quot;no pointer&quot;&#125;func TestTypes(t *testing.T) &#123; &#x2F;&#x2F; 1. create network rn :&#x3D; MakeNetwork() &#x2F;&#x2F; 2、create client e :&#x3D; rn.MakeEnd(&quot;end1-99&quot;) js :&#x3D; &amp;JunkServer&#123;&#125; &#x2F;&#x2F; 3. create service svc :&#x3D; MakeService(js) &#x2F;&#x2F; 4. create server rs :&#x3D; MakeServer() &#x2F;&#x2F; 5. service add to server rs.AddService(svc) &#x2F;&#x2F; 6. server add to network rn.AddServer(&quot;server99&quot;, rs) &#x2F;&#x2F; 7. client connect to server rn.Connect(&quot;end1-99&quot;, &quot;server99&quot;) &#x2F;&#x2F; 8. enable network rn.Enable(&quot;end1-99&quot;, true) &#123; var args JunkArgs var reply JunkReply &#x2F;&#x2F; args must match type (pointer or not) of handler. &#x2F;&#x2F; 9. call the service wait the reply. e.Call(&quot;JunkServer.Handler4&quot;, &amp;args, &amp;reply) if reply.X !&#x3D; &quot;pointer&quot; &#123; t.Fatalf(&quot;wrong reply from Handler4&quot;) &#125; &#125; &#123; var args JunkArgs var reply JunkReply &#x2F;&#x2F; args must match type (pointer or not) of handler. e.Call(&quot;JunkServer.Handler5&quot;, args, &amp;reply) if reply.X !&#x3D; &quot;no pointer&quot; &#123; t.Fatalf(&quot;wrong reply from Handler5&quot;) &#125; &#125;&#125; 总结与使用 此package很好在本地模拟了远程过程调用，为实现分布式的算法奠定了坚实的基础。 使用此package的9个步骤： 123456789 &#x2F;&#x2F; 1. create network &#x2F;&#x2F; 2、create client &#x2F;&#x2F; 3. create service &#x2F;&#x2F; 4. create server &#x2F;&#x2F; 5. service add to server &#x2F;&#x2F; 6. server add to network &#x2F;&#x2F; 7. client connect to server &#x2F;&#x2F; 8. enable network&#x2F;&#x2F; 9. call the service wait the reply. 完整实验代码 https://github.com/dreamerjackson/golang-deep-distributed-lab 后面的测试多参考一下","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[108]-2的幂","slug":"golang-108-pow-of-two","date":"2019-12-17T16:41:10.000Z","updated":"2019-12-18T10:19:04.752Z","comments":true,"path":"2019/12/18/golang-108-pow-of-two/","link":"","permalink":"https://dreamerjonson.com/2019/12/18/golang-108-pow-of-two/","excerpt":"","text":"单精度浮点数可以表达的范围是：2^-149 - 2^127 Denormalized number 从2^-149 - 2^-127 Normal number 2 ^-126 - 2^127 Power of Two – 指数位Exponent 小数位Fraction -149 0 00000000 00000000000000000000001 -148 0 00000000 00000000000000000000010 -147 0 00000000 00000000000000000000100 … … … … -128 0 00000000 01000000000000000000000 -127 0 00000000 10000000000000000000000 -126 0 00000001 00000000000000000000000 -125 0 00000010 00000000000000000000000 -124 0 00000011 00000000000000000000000 … … … … -2 0 01111101 00000000000000000000000 -1 0 01111110 00000000000000000000000 0 0 01111111 00000000000000000000000 1 0 10000000 00000000000000000000000 2 0 10000001 00000000000000000000000 3 0 10000010 00000000000000000000000 4 0 10000011 00000000000000000000000 … … … … 125 0 11111100 00000000000000000000000 126 0 11111101 00000000000000000000000 127 0 11111110 00000000000000000000000 从上表中可以看出，以2为底的单精度指数有以下特点： 1、指数位为0，而小数位只有一个1位 2、指数位介于1到254之间，小数位为0. Power of Two – Exponent Fraction -1074 0 00000000000 0000000000000000000000000000000000000000000000000001 -1073 0 00000000000 0000000000000000000000000000000000000000000000000010 -1072 0 00000000000 0000000000000000000000000000000000000000000000000100 … … … … -1024 0 00000000000 0100000000000000000000000000000000000000000000000000 -1023 0 00000000000 1000000000000000000000000000000000000000000000000000 -1022 0 00000000001 0000000000000000000000000000000000000000000000000000 -1021 0 00000000010 0000000000000000000000000000000000000000000000000000 -1020 0 00000000011 0000000000000000000000000000000000000000000000000000 … … … … -2 0 01111111101 0000000000000000000000000000000000000000000000000000 -1 0 01111111110 0000000000000000000000000000000000000000000000000000 0 0 01111111111 0000000000000000000000000000000000000000000000000000 1 0 10000000000 0000000000000000000000000000000000000000000000000000 2 0 10000000001 0000000000000000000000000000000000000000000000000000 3 0 10000000010 0000000000000000000000000000000000000000000000000000 4 0 10000000011 0000000000000000000000000000000000000000000000000000 … … … … 1021 0 11111111100 0000000000000000000000000000000000000000000000000000 1022 0 11111111101 0000000000000000000000000000000000000000000000000000 1023 0 11111111110 0000000000000000000000000000000000000000000000000000 从上表中可以看出，以2为底的双精度指数有以下特点： 1、指数位为0，而小数位只有一个1位 2、指数位介于1到2046之间，小数位为0. 字节序 指定数字二进制编码内的字节如何在内存中排序。有大端序与小端序之分。 大端序 ： 高位高字节 小端序： 高位低字节 2^-2 大端排序为 00111110100000000000000000000000 2^2 小端排序为 00000000000000001000000000111110 判断2的幂的10种方法 以单精度浮点数为例。 方法1 看成是10进制，不断除以2。 2的次方数除到最后为1 123456func isPowerOfTwo( x uint64) bool &#123; for x % 2 ==0 &amp;&amp; x &gt; 1 &#123; x /= 2 &#125; return x == 1&#125; 方法2 单精度浮点数最多31个数。 1234567891011func isPowerOfTwo2( x uint32) bool &#123; return x == 1 || x == 2 || x == 4 || x == 8 || x == 16 || x == 32 || x == 64 || x == 128 || x == 256 || x == 512 || x == 1024 || x == 2048 || x == 4096 || x == 8192 || x == 16384 || x == 32768 || x == 65536 || x == 131072 || x == 262144 || x == 524288 || x == 1048576 || x == 2097152 || x == 4194304 || x == 8388608 || x == 16777216 || x == 33554432 || x == 67108864 || x == 134217728 || x == 268435456 || x == 536870912 || x == 1073741824 || x == 2147483648&#125; 方法3 12345678// 不断乘以2,逼近参入参数func isPowerOfTwo3( x uint32) bool &#123; var powerOfTwo uint32 = 1; for powerOfTwo &lt; x &amp;&amp; powerOfTwo &lt; 2147483648&#123; powerOfTwo *= 2; &#125; return (x == powerOfTwo);&#125; 方法4 123456789101112// 事先存好数组，遍历不断逼近参入参数func isPowerOfTwo4( x uint32) bool &#123; powerOfTwo := [32]uint32&#123;1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768, 65536,131072,262144,524288,1048576,2097152,4194304,8388608, 16777216,33554432,67108864,134217728,268435456,536870912, 1073741824,2147483648&#125; var exponent = 0; for powerOfTwo[exponent] &lt; x &amp;&amp; exponent &lt; 31&#123; exponent++; &#125; return (x == powerOfTwo[exponent])&#125; 方法5 1234567891011121314151617181920212223242526272829// 二分查找func isPowerOfTwo5( x uint32) bool &#123; powerOfTwo := [32]uint32&#123;1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768, 65536,131072,262144,524288,1048576,2097152,4194304,8388608, 16777216,33554432,67108864,134217728,268435456,536870912, 1073741824,2147483648&#125; isAPowerOfTwo := false interval := 16; exponent := interval; switch x &#123; case 0: isAPowerOfTwo = false case 1: isAPowerOfTwo = true break default: for x != powerOfTwo[exponent] &amp;&amp; interval&gt;1&#123; if x &lt; powerOfTwo[exponent]&#123; exponent -= interval / 2 &#125;else &#123; exponent += interval / 2 &#125; interval /= 2 &#125; isAPowerOfTwo = (x == powerOfTwo[exponent]) &#125; return isAPowerOfTwo&#125; 方法6 1234567891011121314&#x2F;&#x2F; math.log函数求出2的幂,与2的次方作对比func isPowerOfTwo6( x uint32) bool &#123; powerOfTwo :&#x3D; [32]uint32&#123;1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768, 65536,131072,262144,524288,1048576,2097152,4194304,8388608, 16777216,33554432,67108864,134217728,268435456,536870912, 1073741824,2147483648&#125; isAPowerOfTwo :&#x3D; false if x&gt;0 &amp;&amp; x &lt; 2147483648&#123; exponent :&#x3D; uint32(math.Log2(float64(x))) isAPowerOfTwo &#x3D; (x &#x3D;&#x3D; powerOfTwo[exponent] || x &#x3D;&#x3D; powerOfTwo[exponent+1]) &#125; return isAPowerOfTwo&#125; 方法7 123456789101112&#x2F;&#x2F; 统计2进制位的个数,2的次方只有1个2进制位func isPowerOfTwo7( x uint32) bool &#123; numberOfOneBits :&#x3D; 0 for x &gt; 0 &amp;&amp; numberOfOneBits &lt;&#x3D;1&#123; if ( x &amp; 1 ) &#x3D;&#x3D; 1 &#123; numberOfOneBits++ &#125; x &gt;&gt;&#x3D; 1 &#125; return numberOfOneBits &#x3D;&#x3D; 1&#125; 方法8 2的次方第一位是1，其他位为0. 123456func isPowerOfTwo8( x uint32) bool &#123; for (x &amp; 1) &#x3D;&#x3D; 0 &amp;&amp; x &gt; 1&#123; x &gt;&gt;&#x3D; 1 &#125; return x &#x3D;&#x3D; 1&#125; 方法9 malloc.c in the GNU C Library 中的实现方法。 123func isPowerOfTwo9( x uint32) bool &#123; return (x !&#x3D; 0) &amp;&amp; x &amp; (x - 1) &#x3D;&#x3D; 0 &#125; 下面简单说明一下x &amp; (x - 1) == 0 的原理。 x的二进制从左到右 至少有一个为1的位，标记为i。如果i右边的位都为0，正好是2的次方数。那么 x - 1 在i处为0，在 i右边都为1，这时满足 (x &amp; x - 1) ==0 假设 i右边至少有一位不为0， 那么 x - 1 在i 位仍然为 1 ，这时不满足 (x &amp; x -1) == 0 得证。 方法10 123func isPowerOfTwo10( x uint32) bool &#123; return ((x !&#x3D; 0) &amp;&amp; ((x &amp; (^x + 1)) &#x3D;&#x3D; x))&#125; 证明方法和方法9相似。 10的正次方数与2进制之间的有趣性质 从下表中我们能够发现，10的正次方数转换为2的次方数后，末尾都是相同的。 原因在于 10^n = 2^n * 5^n 5的次方数总是以1结尾的。 而2^n 相当于左移n位 Power of Ten (in Decimal) Power of Ten (in Binary) 1 1 10 10 10 100 1100 100 1000 111110 1000 10000 100111000 10000 100000 11000011010 100000 因此10^n - 1 有如下性质: n 10n-1 (in decimal) 10n-1 (in binary) 1 9 1001 2 99 1100011 3 999 1111100111 4 9999 10011100001111 5 99999 11000011010011111 6 999999 11110100001000111111 7 9999999 100110001001011001111111 8 99999999 101111101011110000011111111 9 999999999 111011100110101100100111111111 10 9999999999 1001010100000010111110001111111111 11 99999999999 1011101001000011101101110011111111111 12 999999999999 1110100011010100101001010000111111111111 在google中做计算 Expression Result Notes 2^32 4 294 967 296 Positive power of two 2^-6 0.015625 Negative power of two 1/2^6 0.015625 Negative power of two (22)3 64 Composed power of two 8^7 2 097 152 Power of eight 716^2 + 1316 + 9 2 009 Convert 0x7D9 to decimal by hand lg(256)/lg(16) 2 Change of base computes log16(256) = 2 15/2^6 0.234375 Dyadic fraction lg(65536) 16 log2(216) = 16 log(2^32) 9.63295986 232 is 10 digits long in base 10 10进制转2进制 Expression Result 2009 to binary 0b11111011001 0x07D9 to binary 0b11111011001 0o3731 to binary 0b11111011001 10进制转16净值 Expression Result 2009 to hex 0x7D9 0b11111011001 to hex 0x7D9 0o3731 to hex 0x7D9 10进制转16进制 Expression Result 2009 to octal 0o3731 0b11111011001 to octal 0o3731 0x07D9 to octal 0o3731 转10进制 Expression Result 0b11111011001 to decimal 2009 0x07D9 to decimal 2009 0o3731 to decimal 2009 计算加进制转换 Expression Result 0b1010 + 0b1011 to decimal 21 0xA * 0xF to binary 0b10010110 0o24 / 0o12 to hex 0x2 2^10 + 2^8 + 2^1 to binary 0b10100000010","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[107]-约瑟夫问题与2的次方的特性","slug":"golang-107-Josephus-problem","date":"2019-12-14T13:12:12.000Z","updated":"2019-12-25T03:18:08.399Z","comments":true,"path":"2019/12/14/golang-107-Josephus-problem/","link":"","permalink":"https://dreamerjonson.com/2019/12/14/golang-107-Josephus-problem/","excerpt":"","text":"问题描述 约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。 人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。 问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。 13人的例子，最后赢家为11号 我们以k = 2 即跳过1人后 执行下一个人为例，来探讨一个有趣的性质。 假设参与人数为2的次方数。 参与人数为8人的情形 每回合消除的人数与二叉树类似。 Pass 1 four people: 2, 4, 6, 8. Pass 2 two people: 3, 7 Pass 3 one person: 5 最后剩下的人数为1号，这不是偶然的。 我们可以用归纳法证明： 当参与人数是2^m+1, 经过一轮后，减少人数到2^m，并且减少的都是偶数的编号，编号1保留。 因此总会到达上面我们讨论的8人数，得证。 当参与人数不是2的幂 有一点我们是肯定的，当参数人数不是2的幂后，编号1一定不是最后的幸存者。 这是由于总有一次参数会是一个奇数，编号1就会被下一轮干掉。 参数人数不是2的幂 Pass 1 eliminates six people: 2, 4, 6, 8, 10, 12. Pass 2 eliminates four people: 1, 5, 9, 13. Pass 3 eliminates one person: 7. Pass 4 eliminates one person: 3. 分析：当参与人数不是2的幂时, 到某一时刻总会变为2的幂。 变为2的幂后就会符合上面我们指出的规律。 分析 分析 假设参数人数是n = 2^m + k 那么 在 k 次消除后， n = 2 ^ m 次数编码到达了2k + 1。 因此可以证明编号2k + 1 就是幸存者。 假设n = 2^m + k m = 2k + 1 可证 w = 2（n - 2^m）+1 即 w = 2（n - 2^(log2(n))）+1 编程求最后一个安全数 编程求最后一个安全数的最快方法是 假设 n = 0x1 0 1 0 0 1 则安全数为 = 0x010011 即将最前面的1移动到最后方。 (bits.Len64(x) 计算x的最高位。 ( 1 &lt;&lt; (bits.Len64(x)) -1 ) 最高位变为0 (x &lt;&lt; 1 | 1) 最低位加1。 123func calEndVal(x uint64) uint64&#123; return ( 1 &lt;&lt; (bits.Len64(x)) -1 ) &amp; (x &lt;&lt; 1 | 1)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[106]-深入浮点数","slug":"golang-106-IEE754-float","date":"2019-12-11T07:49:51.000Z","updated":"2020-01-10T10:13:17.105Z","comments":true,"path":"2019/12/11/golang-106-IEE754-float/","link":"","permalink":"https://dreamerjonson.com/2019/12/11/golang-106-IEE754-float/","excerpt":"","text":"引言 下面的一段简单程序 0.3 + 0.6 结果是什么？ 123var f1 float64 = 0.3var f2 float64 = 0.6fmt.Println(f1 + f2) 有人会天真的认为是0.9，但实际输出却是0.8999999999999999（go 1.13.5） 问题在于大多数小数表示成二进制之后是近似且无限的。 以0.1为例。它可能是你能想到的最简单的十进制之一，但是二进制看起来却非常复杂：0.0001100110011001100… 其是一串连续循环无限的数字（涉及到10进制转换为2进制,暂不介绍）。 结果的荒诞性告诉我们，必须深入理解浮点数在计算机中的存储方式及其性质，才能正确处理数字的计算。 golang 与其他很多语言（C、C++、Python…）一样，使用了IEEE-754标准存储浮点数。 IEEE-754 如何存储浮点数 IEEE-754规范使用特殊的以2为基数的科学表示法表示浮点数。 基本的10进制数字 科学计数法表示 指数表示 系数 底数 指数 小数 700 7e+2 7 * 10^2 7 10 2 0 4,900,000,000 4.9e+9 4.9 * 10^9 4.9 10 9 .9 5362.63 5.36263e+3 5.36263 * 10^3 5.36263 10 3 .36263 -0.00345 3.45e-3 3.45 * 10^-3 3.45 10 -3 .45 0.085 1.36e-4 1.36 * 2^-4 1.36 2 -4 .36 32位的单精度浮点数 与 64位的双精度浮点数的差异 精度 符号位 指数位 小数位 偏移量 Single (32 Bits) 1 [31] 8 [30-23] 23 [22-00] 127 Double (64 Bits) 1 [63] 11 [62-52] 52 [51-00] 1023 符号位： 1 为 负数， 0 为正数。 指数位： 存储 指数加上偏移量，偏移量是为了表达负数而设计的。 小数位： 存储系数的小数位的准确或者最接近的值。 以 数字 0.085 为例。 符号位 指数位(123) 小数位 (.36) 0 0111 1011 010 1110 0001 0100 0111 1011 小数位的表达方式 以0.36 为例: 010 1110 0001 0100 0111 1011 = 0.36 (第一位数字代表1/2,第二位数字是1/4…，0.36 是所有位相加) 分解后的计算步骤为: 第n位 2的幂 分数 10进制 求和 2 4 1⁄4 0.25 0.25 4 16 1⁄16 0.0625 0.3125 5 32 1⁄32 0.03125 0.34375 6 64 1⁄64 0.015625 0.359375 11 2048 1⁄2048 0.00048828125 0.35986328125 13 8192 1⁄8192 0.0001220703125 0.3599853515625 17 131072 1⁄131072 0.00000762939453 0.35999298095703 18 262144 1⁄262144 0.00000381469727 0.3599967956543 19 524288 1⁄524288 0.00000190734863 0.35999870300293 20 1048576 1⁄1048576 0.00000095367432 0.35999965667725 22 4194304 1⁄4194304 0.00000023841858 0.35999989509583 23 8388608 1⁄8388608 0.00000011920929 0.36000001430512 go语言显示浮点数 - 验证之前的理论 接下来用一个案例有助于我们理解并验证IEEE-754 浮点数的表示方式。 math.Float32bits 可以为我们打印出32位数据的二进制表示。(注：math.Float64bits可以打印64位数据的二进制) 下面的go代码将输出0.085的浮点数二进制表达，并且为了验证之前理论的正确性，根据二进制表示反向推导出其所表示的原始十进制0.085 12345678910111213141516171819202122232425262728293031323334353637var number float32 = 0.085// 打印出32位数据的二进制表示。bits := math.Float32bits(number)binary := fmt.Sprintf(\"%.32b\", bits) // 打印浮点数的符号位、指数位 、小数位fmt.Printf(\"Bit Pattern: %s | %s %s | %s %s %s %s %s %s\\n\\n\", binary[0:1], binary[1:5], binary[5:9], binary[9:12], binary[12:16], binary[16:20], binary[20:24], binary[24:28], binary[28:32]) // 偏移量bias := 127 // 获取符号位sign := bits &amp; (1 &lt;&lt; 31)exponentRaw := int(bits &gt;&gt; 23) // 获取指数位exponent := exponentRaw - biasvar mantissa float64 // 小数位求和for index, bit := range binary[9:32] &#123; if bit == 49 &#123; position := index + 1 bitValue := math.Pow(2, float64(position)) fractional := 1 / bitValue mantissa = mantissa + fractional &#125;&#125; // 反向求出最终10进制表示value := (1 + mantissa) * math.Pow(2, float64(exponent))fmt.Printf(\"Sign: %d Exponent: %d (%d) Mantissa: %f Value: %f\\n\\n\", sign, exponentRaw, exponent, mantissa, value) 输出： 表明我们对于浮点数的理解正确。 123Starting Number: 0.085000Bit Pattern: 0 | 0111 1011 | 010 1110 0001 0100 0111 1011Sign: 0 Exponent: 123 (-4) Mantissa: 0.360000 Value: 0.085000 经典问题：如何判断一个浮点数其实存储的是整数 下面是一个有趣的问题，如何判断一个浮点数其实存储的是整数？ 思考10秒钟… 下面是一段判断浮点数是否为整数的go代码实现，我们接下来逐行分析函数。 它可以加深对于浮点数的理解。 12345678910111213141516171819202122func IsInt(bits uint32, bias int) &#123; exponent := int(bits &gt;&gt; 23) - bias - 23 coefficient := (bits &amp; ((1 &lt;&lt; 23) - 1)) | (1 &lt;&lt; 23) intTest := (coefficient &amp; (1 &lt;&lt; uint32(-exponent) - 1)) fmt.Printf(\"\\nExponent: %d Coefficient: %d IntTest: %d\\n\", exponent, coefficient, intTest) if exponent &lt; -23 &#123; fmt.Printf(\"NOT INTEGER\\n\") return &#125; if exponent &lt; 0 &amp;&amp; intTest != 0 &#123; fmt.Printf(\"NOT INTEGER\\n\") return &#125; fmt.Printf(\"INTEGER\\n\")&#125; 1、要保证是整数，一个重要的条件是必须要指数位大于127。指数位大于127，代表指数大于0， 反之指数小于0. 下面我们以数字234523为例子： 12345Starting Number: 234523.000000Bit Pattern: 0 | 1001 0000 | 110 0101 0000 0110 1100 0000Sign: 0 Exponent: 144 (17) Mantissa: 0.789268 Value: 234523.000000Exponent: -6 Coefficient: 15009472 IntTest: 0INTEGER 第一步,计算指数。 由于exponent多减去了23，所以在第一个判断中 判断条件为 exponent &lt; -23 exponent := int(bits &gt;&gt; 23) - bias - 23 第二步， (bits &amp; ((1 &lt;&lt; 23) - 1)) 计算小数位。 12345coefficient :&#x3D; (bits &amp; ((1 &lt;&lt; 23) - 1)) | (1 &lt;&lt; 23)Bits: 01001000011001010000011011000000(1 &lt;&lt; 23) - 1: 00000000011111111111111111111111bits &amp; ((1 &lt;&lt; 23) - 1): 00000000011001010000011011000000 | (1 &lt;&lt; 23) 代表 将1加在前方。 1 + 小数 = 系数。 123bits &amp; ((1 &lt;&lt; 23) - 1): 00000000011001010000011011000000(1 &lt;&lt; 23): 00000000100000000000000000000000coefficient: 00000000111001010000011011000000 第三步，计算intTest 只有当指数的倍数可以弥补最小的小数位的时候，才是一个整数。 如下，指数是17位，其不能够弥补最后6位的小数。即不能弥补1/2^18 以后的小数。 但是由于代表2^18的位之后为0.所以是整数。 1234567exponent: (144 - 127 - 23) &#x3D; -61 &lt;&lt; uint32(-exponent): 000000(1 &lt;&lt; uint32(-exponent)) - 1: 111111coefficient: 000000001110010100000110110000001 &lt;&lt; uint32(-exponent)) - 1: 00000000000000000000000000111111intTest: 00000000000000000000000000000000 golang decimal 包详解 要理解decimal包，首先需要知道两个重要的概念，Normal number、denormal (or subnormal) number 以及精度。 Normal number and denormal (or subnormal) number wiki的解释是： 1In computing, a normal number is a non-zero number in a floating-point representation which is within the balanced range supported by a given floating-point format: it is a floating point number that can be represented without leading zeros in its significand. 什么意思呢？在IEEE-754中指数位有一个偏移量，偏移量是为了表达负数而设计的。 比如单精度中的0.085，实际的指数是 -3， 存储到浮点数的指数位是123。 所以表达的负数就是有上限的。这个上限就是2^-126。 如果比这个负数还要小，例如2^-127,这个时候应该表达为0.1 * 2 ^ -126. 这时系数变为了不是1为前导的数，这个数就叫做denormal (or subnormal) number。 正常的系数是以1为前导的数就叫做Normal number。 概念：精度 精度是一个非常复杂的概念，在这里笔者讨论的是2进制浮点数的10进制精度。 精度为d表示的是在一个范围内，如果我们将d位10进制（按照科学计数法表达）转换为二进制。再将二进制转换为d位10进制。如果数据没有不损失意味着在此范围内是有d精度的。 精度的原因在于，数据在进制之间相互转换时，是不能够精准匹配的，而是只能匹配到一个最近的数。如图所示： 精度转换 在这里暂时不深入探讨，而是给出结论：（注：精度是动态变化的，不同的范围可能有不同的精度。这是由于 2的幂 与 10的幂之间的交错是不同的。） float32的精度为6-8位， float64的精度为15-17位 目前使用比较多的精准操作浮点数的decimal包是shopspring/decimal。链接:https://github.com/shopspring/decimal decimal包使用math/big包存储大整数并进行大整数的计算。 比如对于字符串 “123.45” 我们可以将其转换为12345这个大整数，以及-2代表指数。参考decimal结构体： 1234type Decimal struct &#123; value *big.Int exp int32&#125; 在本文中，笔者不会探讨math/big是如何进行大整数运算的，而是探讨decimal包一个非常重要的函数： NewFromFloat(value float64) Decimal 其主要调用了下面的函数： 12345678910111213141516171819202122232425262728293031323334353637func newFromFloat(val float64, bits uint64, flt *floatInfo) Decimal &#123; if math.IsNaN(val) || math.IsInf(val, 0) &#123; panic(fmt.Sprintf(&quot;Cannot create a Decimal from %v&quot;, val)) &#125; exp :&#x3D; int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1) mant :&#x3D; bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1) switch exp &#123; case 0: exp++ default: mant |&#x3D; uint64(1) &lt;&lt; flt.mantbits &#125; exp +&#x3D; flt.bias var d decimal d.Assign(mant) d.Shift(exp - int(flt.mantbits)) d.neg &#x3D; bits&gt;&gt;(flt.expbits+flt.mantbits) !&#x3D; 0 roundShortest(&amp;d, mant, exp, flt) if d.nd &lt; 19 &#123; tmp :&#x3D; int64(0) m :&#x3D; int64(1) for i :&#x3D; d.nd - 1; i &gt;&#x3D; 0; i-- &#123; tmp +&#x3D; m * int64(d.d[i]-&#39;0&#39;) m *&#x3D; 10 &#125; if d.neg &#123; tmp *&#x3D; -1 &#125; return Decimal&#123;value: big.NewInt(tmp), exp: int32(d.dp) - int32(d.nd)&#125; &#125; dValue :&#x3D; new(big.Int) dValue, ok :&#x3D; dValue.SetString(string(d.d[:d.nd]), 10) if ok &#123; return Decimal&#123;value: dValue, exp: int32(d.dp) - int32(d.nd)&#125; &#125; return NewFromFloatWithExponent(val, int32(d.dp)-int32(d.nd))&#125; 此函数会将浮点数转换为Decimal结构。 读者想象一下这个问题：如果存储到浮点数中的值（例如0.1）本身就是一个近似值，为什么decimal包能够解决计算的准确性？ 原因在于，deciimal包可以精准的将一个浮点数转换为10进制。这就是NewFromFloat为我们做的事情。 下面我将对此函数做逐行分析。 1234&#x2F;&#x2F;2-4行判断浮点数有效性，不能为NAN或INF if math.IsNaN(val) || math.IsInf(val, 0) &#123; panic(fmt.Sprintf(&quot;Cannot create a Decimal from %v&quot;, val))&#125; 第5行：剥离出IEEE浮点数的指数位 exp := int(bits&gt;&gt;flt.mantbits) &amp; (1&lt;&lt;flt.expbits - 1) 第6行：剥离出浮点数的系数的小数位 mant := bits &amp; (uint64(1)&lt;&lt;flt.mantbits - 1) 第7行：如果是指数位为0，代表浮点数是denormal (or subnormal) number； 默认情况下会在mant之前加上1，因为mant只是系数的小数，在前面加上1后，代表真正的小数位。 现在 mant = IEEE浮点数系数 * 2^53 第13行： 加上偏移量，exp现在代表真正的指数。 第14行： 引入了一个中间结构decimal 1234567type decimal struct &#123; d [800]byte nd int dp int neg bool trunc bool&#125; 第15行： 调用d.Assign(mant) , 将mant作为10进制数，存起来。 10进制数的每一位都作为一个字符存储到 decimal的byte数组中 12345678910111213141516171819202122func (a *decimal) Assign(v uint64) &#123; var buf [24]byte &#x2F;&#x2F; Write reversed decimal in buf. n :&#x3D; 0 for v &gt; 0 &#123; v1 :&#x3D; v &#x2F; 10 v -&#x3D; 10 * v1 buf[n] &#x3D; byte(v + &#39;0&#39;) n++ v &#x3D; v1 &#125; &#x2F;&#x2F; Reverse again to produce forward decimal in a.d. a.nd &#x3D; 0 for n--; n &gt;&#x3D; 0; n-- &#123; a.d[a.nd] &#x3D; buf[n] a.nd++ &#125; a.dp &#x3D; a.nd trim(a)&#125; 第16行： 调用shift函数，这个函数非常难理解。 1234567891011121314151617func (a *decimal) Shift(k int) &#123; switch &#123; case a.nd &#x3D;&#x3D; 0: case k &gt; 0: for k &gt; maxShift &#123; leftShift(a, maxShift) k -&#x3D; maxShift &#125; leftShift(a, uint(k)) case k &lt; 0: for k &lt; -maxShift &#123; rightShift(a, maxShift) k +&#x3D; maxShift &#125; rightShift(a, uint(-k)) &#125;&#125; 此函数的功能是为了获取此浮点数代表的10进制数据的整数位个数以及小数位个数，此函数的完整证明附后。（注1) exp是真实的指数，其也是能够覆盖小数部分2进制位的个数。（参考前面如何判断浮点数是整数） exp - int(flt.mantbits)代表不能被exp覆盖的2进制位的个数 如果exp - int(flt.mantbits) &gt; 0 代表exp能够完全覆盖小数位 因此 浮点数是一个非常大的整数，这时会调用leftShift(a, uint(k))。否则将调用rightShift(a, uint(-k)), 常规rightShift会调用得更多。因此我们来看看rightShift函数的实现。 第5行： 此for循环将计算浮点数10进制表示的小数部分的有效位为 r-1 。 n &gt;&gt; k 是一个重要的衡量指标，代表了小数部分与整数部分的分割。 此函数的完整证明附后。（注1) 第21行：此时整数部分所占的有效位数为a.dp -=（r-1） 第24行：这两个循环做了2件事情： 1、计算10进制表示的有效位数 2、将10进制表示存入bytes数组中。例如对于浮点数64.125，现在byte数组存储的前5位就是64125 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func rightShift(a *decimal, k uint) &#123; r :&#x3D; 0 w :&#x3D; 0 var n uint for ; n&gt;&gt;k &#x3D;&#x3D; 0; r++ &#123; if r &gt;&#x3D; a.nd &#123; if n &#x3D;&#x3D; 0 &#123; a.nd &#x3D; 0 return &#125; for n&gt;&gt;k &#x3D;&#x3D; 0 &#123; n &#x3D; n * 10 r++ &#125; break &#125; c :&#x3D; uint(a.d[r]) n &#x3D; n*10 + c - &#39;0&#39; &#125; &#x2F;&#x2F; 整数部分的有效位数 a.dp -&#x3D; r - 1 var mask uint &#x3D; (1 &lt;&lt; k) - 1 &#x2F;&#x2F; 整数部分 for ; r &lt; a.nd; r++ &#123; c :&#x3D; uint(a.d[r]) dig :&#x3D; n &gt;&gt; k n &amp;&#x3D; mask a.d[w] &#x3D; byte(dig + &#39;0&#39;) w++ n &#x3D; n*10 + c - &#39;0&#39; &#125; &#x2F;&#x2F; 小数部分 for n &gt; 0 &#123; dig :&#x3D; n &gt;&gt; k n &amp;&#x3D; mask if w &lt; len(a.d) &#123; a.d[w] &#x3D; byte(dig + &#39;0&#39;) w++ &#125; else if dig &gt; 0 &#123; a.trunc &#x3D; true &#125; n &#x3D; n * 10 &#125; &#x2F;&#x2F; 有效位 a.nd &#x3D; w trim(a)&#125; 继续回到newFromFloat函数，第18行，调用了roundShortest函数， 此函数非常关键。其会将浮点数转换为离其最近的十进制数。 这是为什么decimal.NewFromFloat(0.1)能够精准表达0.1的原因。 参考上面的精度，此函数主要考察了2的幂与10的幂之间的交错关系。四舍五入到最接近的10进制值。 此函数实质实现的是Grisu3 算法,有想深入了解的可以去看看论文。笔者在这里提示几点： 1、2^exp &lt;= d &lt; 10^dp。 2、10进制数之间至少相聚10^(dp-nd) 3、2的幂之间的最小间距至少为2^(exp-mantbits) 4、什么时候d就是最接近2进制的10进制数？ 如果10^(dp-nd) &gt; 2^(exp-mantbits)，表明 当十进制下降一个最小位数时，匹配到的是更小的数字value - 2^(exp-mantbits)，所以d就是最接近浮点数的10进制数。 12345678910111213141516171819202122232425262728293031323334353637func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) &#123; if mant &#x3D;&#x3D; 0 &#123; d.nd &#x3D; 0 return &#125; &#x2F;&#x2F; d 是否就是最接近的2进制数。 minexp :&#x3D; flt.bias + 1 &#x2F;&#x2F; minimum possible exponent if exp &gt; minexp &amp;&amp; 332*(d.dp-d.nd) &gt;&#x3D; 100*(exp-int(flt.mantbits)) &#123; &#x2F;&#x2F; The number is already shortest. return &#125; &#x2F;&#x2F; 计算最接近的大于d的10进制数 upper :&#x3D; new(decimal) upper.Assign(mant*2 + 1) upper.Shift(exp - int(flt.mantbits) - 1) var mantlo uint64 var explo int if mant &gt; 1&lt;&lt;flt.mantbits || exp &#x3D;&#x3D; minexp &#123; mantlo &#x3D; mant - 1 explo &#x3D; exp &#125; else &#123; mantlo &#x3D; mant*2 - 1 explo &#x3D; exp - 1 &#125; &#x2F;&#x2F; 计算最接近的小于d的10进制数 lower :&#x3D; new(decimal) lower.Assign(mantlo*2 + 1) lower.Shift(explo - int(flt.mantbits) - 1) inclusive :&#x3D; mant%2 &#x3D;&#x3D; 0 &#x2F;&#x2F;进行四舍五入 ... &#125; &#125;&#125; 继续回到newFromFloat函数，第19行 如果精度小于19，是位于int64范围内的，可以使用快速路径，否则使用math/big包进行赋值操作，效率稍微要慢一些。 第36行，正常情况几乎不会发生。如果setstring在异常的情况下会调用NewFromFloatWithExponent 指定精度进行四舍五入截断。 注一：证明shift函数：快速的获取一个浮点数代表的十进制 以典型的数字64.125 为例 ， 它可以被浮点数二进制精准表达为： Bit Patterns: 0 | 10000000101 | 0000000010000000000000000000000000000000000000000000 Sign: 0 | Exponent: 1029 (6) | Mantissa: 0.001953 即 64.125 = 1.001953125 * 2^6 注意观察浮点数的小数位在第九位有1, 代表2^-9 即 0.001953125. 我们在浮点数的小数位前 附上数字1，10000000010000000000000000000000000000000000000000000 代表其为1 / 2^0 . 此时我们可以认为这个数代表的是1.001953125. 那么这样长的二进制数变为10进制又是多少呢:4512395720392704。 即 1.001953125 = 4512395720392704 * 2^(-52) 所以64.125 = 4512395720392704 * 2^(-52) * 2^6 = 4512395720392704 * 2^(-46) 在这里，有一种重要的等式。 即 (2 ^ -46) 等价于向左移动了46位。 并且移动后剩下的部分即为64,而舍弃的部分其实是小数部分0.125。 这个等式看似复杂其实很好证明，即第46位其实代表的是2^45。 其除以2^46后是一个小数。依次类推… 因此对于数字 4512395720392704 ， 我们可以用4，45，451，4512 … 依次除以 2 ^ 46. 一直到找到数451239572039270 其除以2^46不为0。这个不为0的数一定为6。 接着我们保留后46位，其实是保留了小数位。 假设 4512395720392704 / 2^46 = (6 + num) 64.125 =(6 + num) * 10 + C = 60 + 10* num + C 当我们将通过位运算保留后46位，设为A, 则 A / 2^46 = num 所以 (A * 10 + C) / 2 ^46 =(num * 10 +C) = 4.125 因此此我们又可以把4提取出来，实在精彩。 10进制小数位的提取是一样的，留给读者自己探索。 这样，就可以快速的把对应的10进制数的每一位都找出来… 总结 1、本文介绍了go语言使用的IEEE-754标准存储浮点数的具体存储方式。 2、本文通过实际代码片段和一个脑筋急转弯帮助读者理解浮点数的存储方式。 3、本文介绍了normal number 以及精度这两个重要概念。 4、本文详细介绍了shopspring/decimal的实现方式，即借助了big.int，以及进制的巧妙精准转换。 5、shopspring/decimal其实在精度的巧妙转换方面参考了go源码ftoa函数的实现。 读者可以参考go源码 6、shopspring/decimal目前roundShortest函数有一个bug，笔者已经提交了pr，此bug已在go源码中得到了修复。 7、big.int计算存在效率问题，如果遇到特殊的快速大量计算的场景可能不太适合。 8、还有一些decimal的实现，例如tibd/decimal,代码实在不忍淬读。 9、浮点数计算，除了要解决进制的转换外，还需要解决重要的溢出问题，例如相乘常常要超过int64的范围，这就是为什么shopspring/decimal使用了big.int,而tibd/decimal将数据转换为了很多的word（int32），导致其计算非常复杂。 参考资料 深入浮点数 我将此文章放在了github上：github地址 Why 0.1 Does Not Exist In Floating-Point Normal number 7-bits-are-not-enough-for-2-digit-accuracy Decimal Precision of Binary Floating-Point Numbers Introduction To Numeric Constants In Go","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[105]-stack-trace","slug":"golang-105-stack-trace","date":"2019-12-05T14:10:18.000Z","updated":"2019-12-11T07:35:58.679Z","comments":true,"path":"2019/12/05/golang-105-stack-trace/","link":"","permalink":"https://dreamerjonson.com/2019/12/05/golang-105-stack-trace/","excerpt":"","text":"Introduction Having some basic skills in debugging Go programs can save any programmer a good amount of time trying to identify problems. I believe in logging as much information as you can, but sometimes a panic occurs and what you logged is not enough. Understanding the information in a stack trace can sometimes mean the difference between finding the bug now or needing to add more logging and waiting for it to happen again I have been seeing stack traces since I started writing Go. At some point we all do something silly that causes the runtime to kill our program and throw a stack trace. I am going to show you the information the stack trace provides, including how to identify the value for each parameter that was passed into each function. Functions Let’s start with a small piece of code that will produce a stack trace: Listing 1 12345678package mainfunc main() &#123; slice :&#x3D; make([]string, 2, 4) Example(slice, “hello”, 10)&#125;func Example(slice []string, str string, i int) &#123; panic(“Want stack trace”)&#125; Listing 1 shows a program where the main function calls the Example function on line 05. The Example function is declared on line 08 and accepts three parameters, a slice of strings, a string and an integer. The only code Example executes is a call to the built-in function panic on line 09, which immediately produces a stack trace: Listing 2 1234567891011121314151617181920Panic: Want stack tracegoroutine 1 [running]:main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa) &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:9 +0x64main.main() &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:5 +0x85goroutine 2 [runnable]:runtime.forcegchelper() &#x2F;Users&#x2F;bill&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go:90runtime.goexit() &#x2F;Users&#x2F;bill&#x2F;go&#x2F;src&#x2F;runtime&#x2F;asm_amd64.s:2232 +0x1goroutine 3 [runnable]:runtime.bgsweep() &#x2F;Users&#x2F;bill&#x2F;go&#x2F;src&#x2F;runtime&#x2F;mgc0.go:82runtime.goexit() &#x2F;Users&#x2F;bill&#x2F;go&#x2F;src&#x2F;runtime&#x2F;asm_amd64.s:2232 +0x1 The stack trace in listing 2 shows all the goroutines that existed at the time of the panic, the status of each routine and the call stack under that respective goroutine. The goroutines that were running and the one that caused the stack trace will be at the top. Let’s focus on the goroutine that panicked. list3 1234567goroutine 1 [running]:main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa) &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:9 +0x64main.main() &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:5 +0x85 The stack trace on line 01 in listing 3 is showing that goroutine 1 was running prior to the panic. On line 02, we see that the code that panicked was in the Example function in package main. The line indented shows the code file and path this function is located in, plus the line of code that was executing. In this case, the code on line 09 was running which is the call to panic. Line 03 shows the name of the function that called Example. This is the main function in the main package. Underneath the function name once again, the line that is indented shows the code file, path and line of code where the call to Example was made. The stack trace is showing the chain of function calls in the scope of that goroutine up to the time the panic occurred. Now, let’s focus on the values for each parameter that was passed into the Example function: Listing 4 123456789&#x2F;&#x2F; Declarationmain.Example(slice []string, str string, i int)&#x2F;&#x2F; Call to Example by main.slice :&#x3D; make([]string, 2, 4)Example(slice, &quot;hello&quot;, 10)&#x2F;&#x2F; Stack tracemain.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa) Listing 4 shows the values from the stack trace that were passed into the Example function when the call was made by main and the declaration of the function. When you compare the values from the stack trace with the function declaration, it doesn’t seem to match up. The declaration of the Example function accepts three parameters but the stack trace is showing six hexadecimal values. The key to understanding how the values do match up with the parameters requires knowing the implementation for each parameter type. Let’s start with the first parameter which is a slice of strings. A slice is a reference type in Go. This means the value for a slice is a header value with a pointer to some underlying data. In the case of a slice, the header value is a three word structure that contains a pointer to an underlying array, the length of the slice and the capacity. The values associated with the slice header are represented by the first three values in the stack trace: Listing 5 // Slice parameter value slice := make([]string, 2, 4) // Slice header values Pointer: 0x2080c3f50 Length: 0x2 Capacity: 0x4 // Declaration main.Example(slice []string, str string, i int) // Stack trace main.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa) Listing 5 shows how the first three values in the stack trace do match up with the slice parameter. The first value represents the pointer to the underlying array of strings. The length and capacity numbers used to initialize the slice match with the second and third values. Those three values represent each value of the slice header, the first parameter. Now let’s look at the second parameter which is a string. A string is also a reference type but this header value is immutable. The header value for a string is declared as a two word structure that contains a pointer to an underlying byte array and the length of the string: Listing 6 123456789101112&#x2F;&#x2F; String parameter value&quot;hello&quot;&#x2F;&#x2F; String header valuesPointer: 0x425c0Length: 0x5&#x2F;&#x2F; Declarationmain.Example(slice []string, str string, i int)&#x2F;&#x2F; Stack tracemain.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa) Listing 6 shows how the fourth and fifth values in the stack trace do match up with the string parameter. The fourth value represents the pointer to the underlying array of bytes and the fifth value is the length of the string which was 5. The string “hello” requires 5 bytes. Those two values represent each value of the string header, the second parameter. The third parameter is an integer which is a single word value: Listing 7 1234567891011&#x2F;&#x2F; Integer parameter value10&#x2F;&#x2F; Integer valueBase 16: 0xa&#x2F;&#x2F; Declarationmain.Example(slice []string, str string, i int)&#x2F;&#x2F; Stack tracemain.Example(0x2080c3f50, 0x2, 0x4, 0x425c0, 0x5, 0xa) Listing 7 shows how the last value in the stack trace matches up with the integer parameter. The very last value in the trace is hexadecimal number 0xa, which is the value of 10. The same value that was passed in for that parameter. That value represents the third parameter. Methods Let’s change the program so the Example function is now a method: Listing 8 123456789101112package mainimport &quot;fmt&quot;type trace struct&#123;&#125;func main() &#123; slice :&#x3D; make([]string, 2, 4) var t trace t.Example(slice, &quot;hello&quot;, 10)&#125;func (t *trace) Example(slice []string, str string, i int) &#123; fmt.Printf(&quot;Receiver Address: %p\\n&quot;, t) panic(&quot;Want stack trace&quot;)&#125; Listing 8 changes the original program by declaring a new type named trace on line 05 and converting the Example function into a method on line 14. The conversion is accomplished by re-declaring the function with a pointer receiver of type trace. Then on line 10, a variable named t is declared of type trace and the method call is made with the variable on line 11. Since the method is declared with a pointer receiver, Go will take the address of the t variable to support the receiver type, even though the method call is made with a value. This time when the program is run, the stack trace is a little different: Listing 9 123456789Receiver Address: 0x1553a8panic: Want stack tracegoroutine 1 [running]:main.(*trace).Example(0x1553a8, 0x2081b7f50, 0x2, 0x4, 0xdc1d0, 0x5, 0xa) &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:16 +0x116main.main() &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:11 +0xae The first thing you should notice in listing 9 is that the stack trace on line 02 is making it clear this was a method call using a pointer receiver. The name of the function is now displayed with (*trace) between the package name and the method name. The second thing to notice is how the value list now shows the value of the receiver first. Method calls are really function calls with the first parameter being the receiver value. We are seeing this implementation detail in action from the stack trace. Since nothing else changed with the declaration or call to the Example method, all the other values remain the same. The line numbers where the call to Example is made and where the panic occurred changed and reflects the new code. Packing When you have multiple parameters that fit inside of a single word, then the values for the parameters in the stack trace will be packed together: Listing 10 1234567package mainfunc main() &#123; Example(true, false, true, 25)&#125;func Example(b1, b2, b3 bool, i uint8) &#123; panic(&quot;Want stack trace&quot;)&#125; Listing 10 shows a new sample program that changes the Example function to accept four parameters. The first three are booleans and the last one is an eight bit unsigned integer. A boolean value is also an eight bit value, so all four parameters fit inside of a single word on both 32 and 64 bit architectures. When the program runs, it produces an interesting stack trace: Listing 11 1234567goroutine 1 [running]:main.Example(0x19010001) &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:8 +0x64main.main() &#x2F;Users&#x2F;bill&#x2F;Spaces&#x2F;Go&#x2F;Projects&#x2F;src&#x2F;github.com&#x2F;goinaction&#x2F;code&#x2F; temp&#x2F;main.go:4 +0x32 Instead of there being four values in the stack trace for the call to Example, there is a single value. All four individual 8 bit values were packed together into a single word: 123456789101112131415&#x2F;&#x2F; Parameter valuestrue, false, true, 25&#x2F;&#x2F; Word valueBits Binary Hex Value00-07 0000 0001 01 true08-15 0000 0000 00 false16-23 0000 0001 01 true24-31 0001 1001 19 25&#x2F;&#x2F; Declarationmain.Example(b1, b2, b3 bool, i uint8)&#x2F;&#x2F; Stack tracemain.Example(0x19010001) Listing 12 shows how the value in the stack trace matches up with all four parameter values that were passed in. The value of true is an 8 bit value that is represented with the value of 1 and the value of false is represented with the value of 0. The value of 25 in binary is 11001 which converts to 19 in hexadecimal. Now when we look at the hexadecimal value represented in the stack trace, we see how it does represent the values that were passed in. Conclusion The Go runtime provides a great deal of information to help us debug our programs. In this post we concentrated on stack traces. The ability to decode the values that were passed into each function throughout the call stack is huge. It has helped me more than once to identify my bug very quickly. Now that you know how to read stack traces, hopefully you can leverage this knowledge the next time a stack trace happens to you.","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[104]-go语言渐入佳境-网络[16]-获取本机地址","slug":"golang-104-go语言渐入佳境-网络-16-获取本机地址","date":"2019-12-04T06:15:17.000Z","updated":"2019-12-04T06:26:43.026Z","comments":true,"path":"2019/12/04/golang-104-go语言渐入佳境-网络-16-获取本机地址/","link":"","permalink":"https://dreamerjonson.com/2019/12/04/golang-104-go%E8%AF%AD%E8%A8%80%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83-%E7%BD%91%E7%BB%9C-16-%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E5%9C%B0%E5%9D%80/","excerpt":"","text":"什么是外网IP和内网IP? tcp/ip协议中，专门保留了三个IP地址区域作为私有地址，其地址范围如下： 10.0.0.0/8：10.0.0.0～10.255.255.255 172.16.0.0/12：172.16.0.0～172.31.255.255 192.168.0.0/16：192.168.0.0～192.168.255.255 什么是内网IP 一些小型企业或者学校，通常都是申请一个固定的IP地址，然后通过IP共享（IP Sharing），使用整个公司或学校的机器都能够访问互联网。而这些企业或学校的机器使用的IP地址就是内网IP，内网IP是在规划IPv4协议时，考虑到IP地址资源可能不足，就专门为内部网设计私有IP地址（或称之为保留地址），一般常用内网IP地址都是这种形式的：10.X.X.X、172.16.X.X-172.31.X.X、192.168.X.X等。需要注意的是，内网的计算机可向Internet上的其他计算机发送连接请求，但Internet上其他的计算机无法向内网的计算机发送连接请求。我们平时可能在内网机器上搭建过网站或者FTP服务器，而在外网是不能访问该网站和FTP服务器的，原因就在于此。 什么是公网IP 公网IP就是除了保留IP地址以外的IP地址，可以与Internet上的其他计算机随意互相访问。我们通常所说的IP地址，其实就是指的公网IP。互联网上的每台计算机都有一个独立的IP地址，该IP地址唯一确定互联网上的一台计算机。这里的IP地址就是指的公网IP地址。 怎样理解互联网上的每台计算机都有一个唯一的IP地址 其实，互联网上的计算机是通过“公网IP＋内网IP”来唯一确定的，就像很多大楼都是201房间一样，房间号可能一样，但是大楼肯定是唯一的。公网IP地址和内网IP地址也是同样，不同企业或学校的机器可能有相同的内网IP地址，但是他们的公网IP地址肯定不同。那么这些企业或学校的计算机是怎样IP地址共享的呢？这就需要使用NAT（Network Address Translation,网络地址转换）功能。当内部计算机要连接互联网时，首先需要通过NAT技术，将内部计算机数据包中有关IP地址的设置都设成NAT主机的公共IP地址，然后再传送到Internet，虽然内部计算机使用的是私有IP地址，但在连接Internet时，就可以通过NAT主机的NAT技术，将内网我IP地址修改为公网IP地址，如此一来，内网计算机就可以向Internet请求数据了。 ———————————————— What Is a Network Interface? A network interface is the point of interconnection between a computer and a private or public network. A network interface is generally a network interface card (NIC), but does not have to have a physical form. Instead, the network interface can be implemented in software. For example, the loopback interface (127.0.0.1 for IPv4 and ::1 for IPv6) is not a physical device but a piece of software simulating a network interface. The loopback interface is commonly used in test environments. 获取本地ip 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"errors\" \"fmt\" \"net\")func main() &#123; ip, err := externalIP() if err != nil &#123; fmt.Println(err) &#125; fmt.Println(ip)&#125;func externalIP() (string, error) &#123; // get all interface. ifaces, err := net.Interfaces() if err != nil &#123; return \"\", err &#125; for _, iface := range ifaces &#123; if iface.Flags&amp;net.FlagUp == 0 &#123; continue // interface down &#125; if iface.Flags&amp;net.FlagLoopback != 0 &#123; continue // loopback interface &#125; addrs, err := iface.Addrs() if err != nil &#123; return \"\", err &#125; for _, addr := range addrs &#123; var ip net.IP switch v := addr.(type) &#123; case *net.IPNet: ip = v.IP case *net.IPAddr: ip = v.IP &#125; if ip == nil || ip.IsLoopback() &#123; continue &#125; ip = ip.To4() if ip == nil &#123; continue // not an ipv4 address &#125; fmt.Println(\" ip.String()\", ip.String()) // return ip.String(), nil &#125; &#125; return \"\", errors.New(\"are you connected to the network?\")&#125; 获取外网ip 123456789101112func get_external() string &#123; resp, err := http.Get(\"http://myexternalip.com/raw\") if err != nil &#123; return \"\" &#125; defer resp.Body.Close() content, _ := ioutil.ReadAll(resp.Body) buf := new(bytes.Buffer) buf.ReadFrom(resp.Body) //s := buf.String() return string(content)&#125; 10进制与ip相互转换 12345678910111213141516171819202122232425262728func inet_ntoa(ipnr int64) net.IP &#123; var bytes [4]byte bytes[0] &#x3D; byte(ipnr &amp; 0xFF) bytes[1] &#x3D; byte((ipnr &gt;&gt; 8) &amp; 0xFF) bytes[2] &#x3D; byte((ipnr &gt;&gt; 16) &amp; 0xFF) bytes[3] &#x3D; byte((ipnr &gt;&gt; 24) &amp; 0xFF) return net.IPv4(bytes[3], bytes[2], bytes[1], bytes[0])&#125;func inet_aton(ipnr net.IP) int64 &#123; bits :&#x3D; strings.Split(ipnr.String(), &quot;.&quot;) b0, _ :&#x3D; strconv.Atoi(bits[0]) b1, _ :&#x3D; strconv.Atoi(bits[1]) b2, _ :&#x3D; strconv.Atoi(bits[2]) b3, _ :&#x3D; strconv.Atoi(bits[3]) var sum int64 sum +&#x3D; int64(b0) &lt;&lt; 24 sum +&#x3D; int64(b1) &lt;&lt; 16 sum +&#x3D; int64(b2) &lt;&lt; 8 sum +&#x3D; int64(b3) return sum&#125; 判断是否公网ip 123456789101112131415161718func IsPublicIP(IP net.IP) bool &#123; if IP.IsLoopback() || IP.IsLinkLocalMulticast() || IP.IsLinkLocalUnicast() &#123; return false &#125; if ip4 :&#x3D; IP.To4(); ip4 !&#x3D; nil &#123; switch true &#123; case ip4[0] &#x3D;&#x3D; 10: return false case ip4[0] &#x3D;&#x3D; 172 &amp;&amp; ip4[1] &gt;&#x3D; 16 &amp;&amp; ip4[1] &lt;&#x3D; 31: return false case ip4[0] &#x3D;&#x3D; 192 &amp;&amp; ip4[1] &#x3D;&#x3D; 168: return false default: return true &#125; &#125; return false&#125; ip在区间内 12345678910111213141516171819func IpBetween(from net.IP, to net.IP, test net.IP) bool &#123; if from == nil || to == nil || test == nil &#123; fmt.Println(\"An ip input is nil\") // or return an error!? return false &#125; from16 := from.To16() to16 := to.To16() test16 := test.To16() if from16 == nil || to16 == nil || test16 == nil &#123; fmt.Println(\"An ip did not convert to a 16 byte\") // or return an error!? return false &#125; if bytes.Compare(test16, from16) &gt;= 0 &amp;&amp; bytes.Compare(test16, to16) &lt;= 0 &#123; return true &#125; return false&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[103]-ldflags技巧","slug":"golang-103-ldflags技巧","date":"2019-12-03T08:27:35.000Z","updated":"2019-12-03T12:47:15.352Z","comments":true,"path":"2019/12/03/golang-103-ldflags技巧/","link":"","permalink":"https://dreamerjonson.com/2019/12/03/golang-103-ldflags%E6%8A%80%E5%B7%A7/","excerpt":"","text":"+X 12345678package mainimport \"fmt\"var ServerBaseURL stringfunc main()&#123;fmt.Println(ServerBaseURL)&#125; 其中-w为去掉调试信息（无法使用gdb调试），-s为去掉符号表（暂未清楚具体作用）。 go build --ldflags “-s -w -X main.ServerBaseURL=http://localhost:8080 -X main.UseTor=” -o test main.go ./test: output: 1http:&#x2F;&#x2F;localhost:8080 打印日期 go build --ldflags “-s -w -X ‘main.ServerBaseURL=date’” -o test6 main.go output： 1Tue Dec 3 16:37:08 CST 2019 打印go语言版本 go build --ldflags “-s -w -X ‘main.ServerBaseURL=$(go version)’” -o test7 main.go output: 1go version go1.12.9 darwin&#x2F;amd64 link https://github.com/golang/go/wiki/GcToolchainTricks https://ms2008.github.io/2018/10/08/golang-build-version/ 可以使用 go tool link --help 查看 ldflags 各参数含义 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-B note add an ELF NT_GNU_BUILD_ID note when using ELF-D address set data segment address (default -1)-E entry set entry symbol name-H type set header type-I linker use linker as ELF dynamic linker-L directory add specified directory to library path-R quantum set address rounding quantum (default -1)-T address set text segment address (default -1)-V print version and exit-X definition add string value definition of the form importpath.name&#x3D;value-a disassemble output-buildid id record id as Go toolchain build id-buildmode mode set build mode-c dump call graph-compressdwarf compress DWARF if possible (default true)-cpuprofile file write cpu profile to file-d disable dynamic executable-debugtramp int debug trampolines-dumpdep dump symbol dependency graph-extar string archive program for buildmode&#x3D;c-archive-extld linker use linker when linking in external mode-extldflags flags pass flags to external linker-f ignore version mismatch-g disable go package data checks-h halt on error-importcfg file read import configuration from file-installsuffix suffix set package directory suffix-k symbol set field tracking symbol-libgcc string compiler support lib for internal linking; use &quot;none&quot; to disable-linkmode mode set link mode-linkshared link against installed Go shared libraries-memprofile file write memory profile to file-memprofilerate rate set runtime.MemProfileRate to rate-msan enable MSan interface-n dump symbol table-o file write output to file-pluginpath string full path name for plugin-r path set the ELF dynamic linker search path to dir1:dir2:...-race enable race detector-s disable symbol table-tmpdir directory use directory for temporary files-u reject unsafe packages-v print link trace-w disable DWARF generation 禁止gc优化和内联 1go build -gcflags &#39;-N -l&#39; 说明: -N 禁止编译优化 -l 禁止内联,禁止内联也可以一定程度上减小可执行程序大小 可以使用 go tool compile --help 查看 gcflags 各参数含义","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[102]-assembly-汇编教程","slug":"golang-102-assembly-compile","date":"2019-11-30T05:15:47.000Z","updated":"2019-12-04T10:43:49.265Z","comments":true,"path":"2019/11/30/golang-102-assembly-compile/","link":"","permalink":"https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/","excerpt":"","text":"introduce golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编主要了解各种寄存器的使用跟寻址方式。根据汇编我们能够一探golang的底层实现。比如内存如何分配，栈如何扩张。接口如何转变。 register 各种伪计数器: FP: Frame pointer: arguments and locals.(指向当前栈帧) PC: Program counter: jumps and branches.(指向指令地址) SB: Static base pointer: global symbols.(指向全局符号表) SP: Stack pointer: top of stack.(指向当前栈顶部) 注意: 栈是向下整长 golang的汇编是调用者维护参数返回值跟返回地址。所以FP的值小于参数跟返回值。 analysis for add think about this simple program: 123456package main//go:noinlinefunc add(a, b int32) (int32, bool) &#123; return a + b, true &#125;func main() &#123; add(10, 32) &#125; generate assemly code in linux: 1GOOS&#x3D;linux GOARCH&#x3D;amd64 go tool compile -S main.go this is the logic of add function 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;&#x2F; 0x0000: Offset of the current instruction, relative to the start of the function.&#x2F;&#x2F; TEXT &quot;&quot;.add: The TEXT directive declares the &quot;&quot;.add symbol as part of the .text section (i.e. runnable code) and indicates that the instructions that follow are the body of the function.&#x2F;&#x2F; The empty string &quot;&quot; will be replaced by the name of the current package at link-time: i.e., &quot;&quot;.add will become main.add once linked into our final binary.&#x2F;&#x2F; (SB): SB is the virtual register that holds the &quot;static-base&quot; pointer, i.e. the address of the beginning of the address-space of our program.&#x2F;&#x2F; &quot;&quot;.add(SB) declares that our symbol is located at some constant offset (computed by the linker) from the start of our address-space. &#x2F;&#x2F; NOSPLIT: Indicates to the compiler that it should not insert the stack-split preamble, which checks whether the current stack needs to be grown.&#x2F;&#x2F; In the case of our add function, the compiler has set the flag by itself: it is smart enough to figure that, since add has no local variables and no stack-frame of its own, it simply cannot outgrow the current stack; thus it&#39;d be a complete waste of CPU cycles to run these checks at each call site.&#x2F;&#x2F; $0-16: $0 denotes the size in bytes of the stack-frame that will be allocated; while $16 specifies the size of the arguments passed in by the caller.&#x2F;&#x2F; In the general case, the frame size is followed by an argument size, separated by a minus sign. (It&#39;s not a subtraction, just idiosyncratic syntax.)&#x2F;&#x2F; The frame size $24-8 states that the function has a 24-byte frame and is called with 8 bytes of argument, which live on the caller&#39;s frame.&#x2F;&#x2F; If NOSPLIT is not specified for the TEXT, the argument size must be provided. For assembly functions with Go prototypes, go vet will check that the argument size is correct.0x0000 00000 (main.go:4) TEXT &quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-16&#x2F;&#x2F;for GOLANG GC0x0000 00000 (main.go:4) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)0x0000 00000 (main.go:4) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)0x0000 00000 (main.go:4) FUNCDATA $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)&#x2F;&#x2F; 0x0000 00000 (main.go:4) PCDATA $2, $0 0x0000 00000 (main.go:4) PCDATA $0, $0 &#x2F;&#x2F; The Go calling convention mandates that every argument must be passed on the stack, using the pre-reserved space on the caller&#39;s stack-frame.&#x2F;&#x2F; It is the caller&#39;s responsibility to grow (and shrink back) the stack appropriately so that arguments can be passed to the callee, and potential return-values passed back to the caller.&#x2F;&#x2F; The Go compiler never generates instructions from the PUSH&#x2F;POP family: the stack is grown or shrunk by respectively decrementing or incrementing the virtual hardware stack pointer SP.&#x2F;&#x2F; The SP pseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls.&#x2F;&#x2F; It points to the top of the local stack frame, so references should use negative offsets in the range [−framesize, 0): x-8(SP), y-4(SP), and so on.&#x2F;&#x2F; &quot;&quot;.b+12(SP) and &quot;&quot;.a+8(SP) respectively refer to the addresses 12 bytes and 8 bytes below the top of the stack (remember: it grows downwards!).&#x2F;&#x2F; .a and .b are arbitrary aliases given to the referred locations; although they have absolutely no semantic meaning whatsoever, they are mandatory when using relative addressing on virtual registers. The documentation about the virtual frame-pointer has some to say about this:&#x2F;&#x2F; The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset —offset from the frame pointer— distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument&#39;s name.&#x2F;&#x2F; The first argument a is not located at 0(SP), but rather at 8(SP); that&#39;s because the caller stores its return-address in 0(SP) via the CALL pseudo-instruction.&#x2F;&#x2F; Arguments are passed in reverse-order; i.e. the first argument is the closest to the top of the stack.0x0000 00000 (main.go:4) MOVL &quot;&quot;.b+12(SP), AX0x0004 00004 (main.go:4) MOVL &quot;&quot;.a+8(SP), CX&#x2F;&#x2F; ADDL does the actual addition of the two Long-words (i.e. 4-byte values) stored in AX and CX, then stores the final result in AX.0x0008 00008 (main.go:4) ADDL CX, AX&#x2F;&#x2F; That result is then moved over to &quot;&quot;.~r2+16(SP), where the caller had previously reserved some stack space and expects to find its return values. Once again, &quot;&quot;.~r2 has no semantic meaning here.0x000a 00010 (main.go:4) MOVL AX, &quot;&quot;.~r2+16(SP)0x000e 00014 (main.go:4) MOVB $1, &quot;&quot;.~r3+20(SP)&#x2F;&#x2F; A final RET pseudo-instruction tells the Go assembler to insert whatever instructions are required by the calling convention of the target platform in order to properly return from a subroutine call.&#x2F;&#x2F; Most likely this will cause the code to pop off the return-address stored at 0(SP) then jump back to it.0x0013 00019 (main.go:4) RET look at more concise version： 123456789101112;; Declare global function symbol &quot;&quot;.add (actually main.add once linked);; Do not insert stack-split preamble;; 0 bytes of stack-frame, 16 bytes of arguments passed in;; func add(a, b int32) (int32, bool)0x0000 TEXT &quot;&quot;.add(SB), NOSPLIT, $0-16 ;; ...omitted FUNCDATA stuff... 0x0000 MOVL &quot;&quot;.b+12(SP), AX ;; move second Long-word (4B) argument from caller&#39;s stack-frame into AX 0x0004 MOVL &quot;&quot;.a+8(SP), CX ;; move first Long-word (4B) argument from caller&#39;s stack-frame into CX 0x0008 ADDL CX, AX ;; compute AX&#x3D;CX+AX 0x000a MOVL AX, &quot;&quot;.~r2+16(SP) ;; move addition result (AX) into caller&#39;s stack-frame 0x000e MOVB $1, &quot;&quot;.~r3+20(SP) ;; move &#96;true&#96; boolean (constant) into caller&#39;s stack-frame 0x0013 RET ;; jump to return address stored at 0(SP) 123456789101112131415161718192021222324252627 | +-------------------------+ &lt;-- 32(SP) | | | G | | | R | | | O | | main.main&#39;s saved | W | | frame-pointer (BP) | S | |-------------------------| &lt;-- 24(SP) | | [alignment] | D | | &quot;&quot;.~r3 (bool) &#x3D; 1&#x2F;true | &lt;-- 21(SP) O | |-------------------------| &lt;-- 20(SP) W | | | N | | &quot;&quot;.~r2 (int32) &#x3D; 42 | W | |-------------------------| &lt;-- 16(SP) A | | | R | | &quot;&quot;.b (int32) &#x3D; 32 | D | |-------------------------| &lt;-- 12(SP) S | | | | | &quot;&quot;.a (int32) &#x3D; 10 | | |-------------------------| &lt;-- 8(SP) | | | | | | | | | \\ | &#x2F; | return address to | \\|&#x2F; | main.main + 0x30 | - +-------------------------+ &lt;-- 0(SP) (TOP OF STACK)(diagram made with https:&#x2F;&#x2F;textik.com) analysis for main 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 &#x2F;&#x2F; &quot;&quot;.main (main.main once linked) is a global function symbol in the .text section, whose address is some constant offset from the beginning of our address-space.&#x2F;&#x2F; It allocates a 24 bytes stack-frame and doesn&#39;t receive any argument nor does it return any value &#x2F;&#x2F; As we mentioned above, the Go calling convention mandates that every argument must be passed on the stack.&#x2F;&#x2F; Our caller, main, grows its stack-frame by 24 bytes (remember that the stack grows downwards, so SUBQ here actually makes the stack-frame bigger) by decrementing the virtual stack-pointer. Of those 24 bytes:&#x2F;&#x2F; 8 bytes (16(SP)-24(SP)) are used to store the current value of the frame-pointer BP (the real one!) to allow for stack-unwinding and facilitate debugging&#x2F;&#x2F; 1+3 bytes (12(SP)-16(SP)) are reserved for the second return value (bool) plus 3 bytes of necessary alignment on amd64&#x2F;&#x2F; 4 bytes (8(SP)-12(SP)) are reserved for the first return value (int32)&#x2F;&#x2F; 4 bytes (4(SP)-8(SP)) are reserved for the value of argument b (int32)&#x2F;&#x2F; 4 bytes (0(SP)-4(SP)) are reserved for the value of argument a (int32). 0x0000 00000 (main.go:6) TEXT &quot;&quot;.main(SB), ABIInternal, $24-0 &#x2F;&#x2F; ;; stack-split prologue... &#x2F;&#x2F; The prologue checks whether the goroutine is running out of space and, if it&#39;s the case, jumps to the epilogue. &#x2F;&#x2F; TLS is a virtual register maintained by the runtime that holds a pointer to the current g, i.e. the data-structure that keeps track of all the state of a goroutine. &#x2F;&#x2F; Looking at the definition of g from the source code of the runtime: &#x2F;&#x2F; type g struct &#123;&#x2F;&#x2F; stack stack &#x2F;&#x2F; 16 bytes &#x2F;&#x2F; stackguard0 is the stack pointer compared in the Go stack growth prologue. &#x2F;&#x2F; It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.&#x2F;&#x2F; stackguard0 uintptr&#x2F;&#x2F; stackguard1 uintptr &#x2F;&#x2F; ...omitted dozens of fields...&#x2F;&#x2F; &#125; &#x2F;&#x2F; We can see that 16(CX) corresponds to g.stackguard0, which is the threshold value maintained by the runtime that, when compared to the stack-pointer, indicates whether or not a goroutine is about to run out of space.&#x2F;&#x2F; The prologue thus checks if the current SP value is less than or equal to the stackguard0 threshold (that is, it&#39;s bigger), then jumps to the epilogue if it happens to be the case. 0x0000 00000 (main.go:6) MOVQ (TLS), CX ;; store current *g in CX0x0009 00009 (main.go:6) CMPQ SP, 16(CX) ;; compare SP and g.stackguard00x000d 00013 (main.go:6) JLS 58 ;; jumps to 0x3a if SP &lt;&#x3D; g.stackguard0 &#x2F;&#x2F; 把栈减了24个字节。增大了栈空间。 0x000f 00015 (main.go:6) SUBQ $24, SP &#x2F;&#x2F; 保存老的bp设置新的bp。这里的bp是真实的寄存器0x0013 00019 (main.go:6) MOVQ BP, 16(SP)0x0018 00024 (main.go:6) LEAQ 16(SP), BP &#x2F;&#x2F; ;; ... PCDATA stuff...0x001d 00029 (main.go:6) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)0x001d 00029 (main.go:6) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)0x001d 00029 (main.go:6) FUNCDATA $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)0x001d 00029 (main.go:6) PCDATA $2, $00x001d 00029 (main.go:6) PCDATA $0, $0 &#x2F;&#x2F;Finally, following the growth of the stack, LEAQ computes the new address of the frame-pointer and stores it in BP. &#x2F;&#x2F; The caller pushes the arguments for the callee as a Quad word (i.e. an 8-byte value) at the top of the stack that it has just grown.&#x2F;&#x2F; Although it might look like random garbage at first, 137438953482 actually corresponds to the 10 and 32 4-byte values concatenated into one 8-byte value: &#x2F;&#x2F; $ echo &#39;obase&#x3D;2;137438953482&#39; | bc&#x2F;&#x2F;10000000000000000000000000000000001010&#x2F;&#x2F; \\____&#x2F;\\______________________________&#x2F;&#x2F;&#x2F; 32 10 0x001d 00029 (main.go:6) MOVQ $137438953482, AX0x0027 00039 (main.go:6) MOVQ AX, (SP)0x002b 00043 (main.go:6) CALL &quot;&quot;.add(SB) &#x2F;&#x2F; 恢复BP寄存器，缩减栈空间0x0030 00048 (main.go:6) MOVQ 16(SP), BP0x0035 00053 (main.go:6) ADDQ $24, SP0x0039 00057 (main.go:6) RET ;; ... stack-split epilogue... &#x2F;&#x2F; The epilogue, on the other hand, triggers the stack-growth machinery and then jumps back to the prologue. &#x2F;&#x2F; This creates a feedback loop that goes on for as long as a large enough stack hasn&#39;t been allocated for our starved goroutine. &#x2F;&#x2F; The body of the epilogue is pretty straightforward: it calls into the runtime, which will do the actual work of growing the stack, then jumps back to the first instruction of the function (i.e. to the prologue).&#x2F;&#x2F; The NOP instruction just before the CALL exists so that the prologue doesn&#39;t jump directly onto a CALL instruction. On some platforms, doing so can lead to very dark places; it&#39;s a common pratice to set-up a noop instruction right before the actual call and land on this NOP instead. 0x003a 00058 (main.go:6) NOP0x003a 00058 (main.go:6) PCDATA $0, $-10x003a 00058 (main.go:6) PCDATA $2, $-10x003a 00058 (main.go:6) CALL runtime.morestack_noctxt(SB)0x003f 00063 (main.go:6) JMP 0 reciever method 12345678910111213141516171819202122package main&#x2F;&#x2F;go:noinlinefunc Add(a, b int32) int32 &#123; return a + b &#125;type Adder struct&#123; id int32 &#125;&#x2F;&#x2F;go:noinlinefunc (adder *Adder) AddPtr(a, b int32) int32 &#123; return a + b &#125;&#x2F;&#x2F;go:noinlinefunc (adder Adder) AddVal(a, b int32) int32 &#123; return a + b &#125;func main() &#123; Add(10, 32) &#x2F;&#x2F; direct call of top-level function adder :&#x3D; Adder&#123;id: 6754&#125; adder.AddPtr(10, 32) &#x2F;&#x2F; direct call of method with pointer receiver adder.AddVal(10, 32) &#x2F;&#x2F; direct call of method with value receiver (&amp;adder).AddVal(10, 32) &#x2F;&#x2F; implicit dereferencing&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374750x0000 00000 (main.go:14) TEXT &quot;&quot;.main(SB), ABIInternal, $40-0 0x0000 00000 (main.go:14) MOVQ (TLS), CX 0x0009 00009 (main.go:14) CMPQ SP, 16(CX) 0x000d 00013 (main.go:14) JLS 161 &#x2F;&#x2F; 把栈减了40个字节。增大了栈空间。 0x0013 00019 (main.go:14) SUBQ $40, SP 0x0017 00023 (main.go:14) MOVQ BP, 32(SP) 0x001c 00028 (main.go:14) LEAQ 32(SP), BP 0x0021 00033 (main.go:14) FUNCDATA $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0021 00033 (main.go:14) FUNCDATA $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0021 00033 (main.go:14) FUNCDATA $3, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB) 0x0021 00033 (main.go:15) PCDATA $2, $0 0x0021 00033 (main.go:15) PCDATA $0, $0 &#x2F;&#x2F; move (10,32) to 0x0021 00033 (main.go:15) MOVQ $137438953482, AX 0x002b 00043 (main.go:15) MOVQ AX, (SP) 0x002f 00047 (main.go:15) CALL &quot;&quot;.Add(SB) &#x2F;&#x2F; First things first, the receiver is initialized via adder :&#x3D; Adder&#123;id: 6754&#125;: 0x0034 00052 (main.go:17) MOVL $0, &quot;&quot;.adder+28(SP) 0x003c 00060 (main.go:17) MOVL $6754, &quot;&quot;.adder+28(SP) 0x0044 00068 (main.go:18) PCDATA $2, $1 &#x2F;&#x2F; recieve address to the AX,8 bytes. 0x0044 00068 (main.go:18) LEAQ &quot;&quot;.adder+28(SP), AX 0x0049 00073 (main.go:18) PCDATA $2, $0 0x0049 00073 (main.go:18) MOVQ AX, (SP) 0x004d 00077 (main.go:18) MOVQ $137438953482, AX 0x0057 00087 (main.go:18) MOVQ AX, 8(SP) 0x005c 00092 (main.go:18) CALL &quot;&quot;.(*Adder).AddPtr(SB) &#x2F;&#x2F; value to the AX. 0x0061 00097 (main.go:19) MOVL &quot;&quot;.adder+28(SP), AX 0x0065 00101 (main.go:19) MOVL AX, (SP) 0x0068 00104 (main.go:19) MOVQ $137438953482, AX 0x0072 00114 (main.go:19) MOVQ AX, 4(SP) 0x0077 00119 (main.go:19) CALL &quot;&quot;.Adder.AddVal(SB) &#x2F;&#x2F; Somehow, Go automagically dereferences our pointer and manages to make the call. How so?&#x2F;&#x2F; How the compiler handles this kind of situation depends on whether or not the receiver being pointed to has escaped to the heap or not. &#x2F;&#x2F; Case A: The receiver is on the stack&#x2F;&#x2F; If the receiver is still on the stack and its size is sufficiently small that it can be copied in a few instructions, as is the case here, the compiler simply copies its value over to the top of the stack then does a straightforward method call to &quot;&quot;.Adder.AddVal (i.e. the one with a value receiver).&#x2F;&#x2F; (&amp;adder).AddVal(10, 32) thus looks like this in this situation:&#x2F;&#x2F; 0x0074 MOVL &quot;&quot;.adder+28(SP), AX ;; move (i.e. copy) adder (note the MOV instead of a LEA) to..&#x2F;&#x2F; 0x0078 MOVL AX, (SP) ;; ..the top of the stack (argument #1)&#x2F;&#x2F; 0x007b MOVQ $137438953482, AX ;; move (32,10) to..&#x2F;&#x2F; 0x0085 MOVQ AX, 4(SP) ;; ..the top of the stack (arguments #3 &amp; #2)&#x2F;&#x2F; 0x008a CALL &quot;&quot;.Adder.AddVal(SB)&#x2F;&#x2F; Boring (although efficient). Let&#39;s move on to case B.&#x2F;&#x2F; Case B: The receiver is on the heap&#x2F;&#x2F; If the receiver has escaped to the heap then the compiler has to take a cleverer route: it generates a new method (with a pointer receiver, this time) that wraps &quot;&quot;.Adder.AddVal, and replaces the original call to &quot;&quot;.Adder.AddVal (the wrappee) with a call to &quot;&quot;.(*Adder).AddVal (the wrapper).&#x2F;&#x2F; The wrapper&#39;s sole mission, then, is to make sure that the receiver gets properly dereferenced before being passed to the wrappee, and that any arguments and return values involved are properly copied back and forth between the caller and the wrappee.&#x2F;&#x2F; (NOTE: In assembly outputs, these wrapper methods are marked as &lt;autogenerated&gt;.)0x007c 00124 (main.go:21) MOVL &quot;&quot;.adder+28(SP), AX0x0080 00128 (main.go:21) MOVL AX, (SP)0x0083 00131 (main.go:21) MOVQ $137438953482, AX0x008d 00141 (main.go:21) MOVQ AX, 4(SP)0x0092 00146 (main.go:21) CALL &quot;&quot;.Adder.AddVal(SB)0x0097 00151 (main.go:22) MOVQ 32(SP), BP0x009c 00156 (main.go:22) ADDQ $40, SP0x00a0 00160 (main.go:22) RET0x00a1 00161 (main.go:22) NOP0x00a1 00161 (main.go:14) PCDATA $0, $-10x00a1 00161 (main.go:14) PCDATA $2, $-10x00a1 00161 (main.go:14) CALL runtime.morestack_noctxt(SB)0x00a6 00166 (main.go:14) JMP 0 Here’s an annotated listing of the generated wrapper that should hopefully clear things up a bit: 1234567891011121314151617181920212223242526270x0000 TEXT &quot;&quot;.(*Adder).AddVal(SB), DUPOK|WRAPPER, $32-24 ;; ...omitted preambles... 0x0026 MOVQ &quot;&quot;..this+40(SP), AX ;; check whether the receiver.. 0x002b TESTQ AX, AX ;; ..is nil 0x002e JEQ 92 ;; if it is, jump to 0x005c (panic) 0x0030 MOVL (AX), AX ;; dereference pointer receiver.. 0x0032 MOVL AX, (SP) ;; ..and move (i.e. copy) the resulting value to argument #1 ;; forward (copy) arguments #2 &amp; #3 then call the wrappee 0x0035 MOVL &quot;&quot;.a+48(SP), AX 0x0039 MOVL AX, 4(SP) 0x003d MOVL &quot;&quot;.b+52(SP), AX 0x0041 MOVL AX, 8(SP) 0x0045 CALL &quot;&quot;.Adder.AddVal(SB) ;; call the wrapped method ;; copy return value from wrapped method then return 0x004a MOVL 16(SP), AX 0x004e MOVL AX, &quot;&quot;.~r2+56(SP) ;; ...omitted frame-pointer stuff... 0x005b RET ;; throw a panic with a detailed error 0x005c CALL runtime.panicwrap(SB) ;; ...omitted epilogues... Obviously, this kind of wrapper can induce quite a bit of overhead considering all the copying that needs to be done in order to pass the arguments back and forth; especially if the wrappee is just a few instructions. Fortunately, in practice, the compiler would have inlined the wrappee directly into the wrapper to amortize these costs (when feasible, at least). Note the WRAPPER directive in the definition of the symbol, which indicates that this method shouldn’t appear in backtraces (so as not to confuse the end-user), nor should it be able to recover from panics that might be thrown by the wrappee. WRAPPER: This is a wrapper function and should not count as disabling recover. The runtime.panicwrap function, which throws a panic if the wrapper’s receiver is nil, is pretty self-explanatory; here’s its complete listing for reference (src/runtime/error.go): 123456789101112131415161718192021222324252627282930&#x2F;&#x2F; panicwrap generates a panic for a call to a wrapped value method&#x2F;&#x2F; with a nil pointer receiver.&#x2F;&#x2F;&#x2F;&#x2F; It is called from the generated wrapper code.func panicwrap() &#123; pc :&#x3D; getcallerpc() name :&#x3D; funcname(findfunc(pc)) &#x2F;&#x2F; name is something like &quot;main.(*T).F&quot;. &#x2F;&#x2F; We want to extract pkg (&quot;main&quot;), typ (&quot;T&quot;), and meth (&quot;F&quot;). &#x2F;&#x2F; Do it by finding the parens. i :&#x3D; stringsIndexByte(name, &#39;(&#39;) if i &lt; 0 &#123; throw(&quot;panicwrap: no ( in &quot; + name) &#125; pkg :&#x3D; name[:i-1] if i+2 &gt;&#x3D; len(name) || name[i-1:i+2] !&#x3D; &quot;.(*&quot; &#123; throw(&quot;panicwrap: unexpected string after package name: &quot; + name) &#125; name &#x3D; name[i+2:] i &#x3D; stringsIndexByte(name, &#39;)&#39;) if i &lt; 0 &#123; throw(&quot;panicwrap: no ) in &quot; + name) &#125; if i+2 &gt;&#x3D; len(name) || name[i:i+2] !&#x3D; &quot;).&quot; &#123; throw(&quot;panicwrap: unexpected string after type name: &quot; + name) &#125; typ :&#x3D; name[:i] meth :&#x3D; name[i+2:] panic(plainError(&quot;value method &quot; + pkg + &quot;.&quot; + typ + &quot;.&quot; + meth + &quot; called using nil *&quot; + typ + &quot; pointer&quot;))&#125; Anatomy of an interface Overview of the datastructures Before we can understand how they work, we first need to build a mental model of the datastructures that make up interfaces and how they’re laid out in memory. To that end, we’ll have a quick peek into the runtime package to see what an interface actually looks like from the standpoint of the Go implementation. The iface structure iface is the root type that represents an interface within the runtime (src/runtime/runtime2.go). Its definition goes like this: 1234type iface struct &#123; &#x2F;&#x2F; 16 bytes on a 64bit arch tab *itab data unsafe.Pointer&#125; An interface is thus a very simple structure that maintains 2 pointers: tab holds the address of an itab object, which embeds the datastructures that describe both the type of the interface as well as the type of the data it points to. data is a raw (i.e. unsafe) pointer to the value held by the interface. More often than not, this will result in a heap allocation as the compiler takes the conservative route and forces the receiver to escape. This holds true even for scalar types! We can prove that with a few lines of code (escape.go): 1234567891011type Addifier interface&#123; Add(a, b int32) int32 &#125;type Adder struct&#123; name string &#125;&#x2F;&#x2F;go:noinlinefunc (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;func main() &#123; adder :&#x3D; Adder&#123;name: &quot;myAdder&quot;&#125; adder.Add(10, 32) &#x2F;&#x2F; doesn&#39;t escape Addifier(adder).Add(10, 32) &#x2F;&#x2F; escapes&#125; One could even visualize the resulting heap allocation using a simple benchmark (escape_test.go): 12345678910111213func BenchmarkDirect(b *testing.B) &#123; adder :&#x3D; Adder&#123;id: 6754&#125; for i :&#x3D; 0; i &lt; b.N; i++ &#123; adder.Add(10, 32) &#125;&#125;func BenchmarkInterface(b *testing.B) &#123; adder :&#x3D; Adder&#123;id: 6754&#125; for i :&#x3D; 0; i &lt; b.N; i++ &#123; Addifier(adder).Add(10, 32) &#125;&#125; 1234$ GOOS&#x3D;linux GOARCH&#x3D;amd64 go test -bench&#x3D;. -benchmem .&#x2F;escape_test.goBenchmarkDirect-8 2000000000 1.60 ns&#x2F;op 0 B&#x2F;op 0 allocs&#x2F;opBenchmarkInterface-8 100000000 15.0 ns&#x2F;op 4 B&#x2F;op 1 allocs&#x2F;op We can clearly see how each time we create a new Addifier interface and initialize it with our adder variable, a heap allocation of sizeof(Adder) actually takes place. Later in this chapter, we’ll see how even simple scalar types can lead to heap allocations when used with interfaces. Let’s turn our attention towards the next datastructure: itab. The itab structure itab is defined thusly (src/runtime/runtime2.go): 1234567type itab struct &#123; &#x2F;&#x2F; 40 bytes on a 64bit arch inter *interfacetype _type *_type hash uint32 &#x2F;&#x2F; copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr &#x2F;&#x2F; variable sized. fun[0]&#x3D;&#x3D;0 means _type does not implement inter.&#125; An itab is the heart &amp; brain of an interface. First, it embeds a _type, which is the internal representation of any Go type within the runtime. A _type describes every facets of a type: its name, its characteristics (e.g. size, alignment…), and to some extent, even how it behaves (e.g. comparison, hashing…)! In this instance, the _type field describes the type of the value held by the interface, i.e. the value that the data pointer points to. Second, we find a pointer to an interfacetype, which is merely a wrapper around _type with some extra information that are specific to interfaces. As you’d expect, the inter field describes the type of the interface itself. Finally, the fun array holds the function pointers that make up the virtual/dispatch table of the interface. Notice the comment that says // variable sized, meaning that the size with which this array is declared is irrelevant. We’ll see later in this chapter that the compiler is responsible for allocating the memory that backs this array, and does so independently of the size indicated here. Likewise, the runtime always accesses this array using raw pointers, thus bounds-checking does not apply here. The _type structure As we said above, the _type structure gives a complete description of a Go type. It’s defined as such (src/runtime/type.go): 12345678910111213141516type _type struct &#123; &#x2F;&#x2F; 48 bytes on a 64bit arch size uintptr ptrdata uintptr &#x2F;&#x2F; size of memory prefix holding all pointers hash uint32 tflag tflag align uint8 fieldalign uint8 kind uint8 alg *typeAlg &#x2F;&#x2F; gcdata stores the GC type data for the garbage collector. &#x2F;&#x2F; If the KindGCProg bit is set in kind, gcdata is a GC program. &#x2F;&#x2F; Otherwise it is a ptrmask bitmap. See mbitmap.go for details. gcdata *byte str nameOff ptrToThis typeOff&#125; Thankfully, most of these fields are quite self-explanatory. The nameOff &amp; typeOff types are int32 offsets into the metadata embedded into the final executable by the linker. This metadata is loaded into runtime.moduledata structures at run time (src/runtime/symtab.go), which should look fairly similar if you’ve ever had to look at the content of an ELF file. The runtime provide helpers that implement the necessary logic for following these offsets through the moduledata structures, such as e.g. resolveNameOff (src/runtime/type.go) and resolveTypeOff (src/runtime/type.go): func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {} func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {} I.e., assuming t is a _type, calling resolveTypeOff(t, t.ptrToThis) returns a copy of t. The interfacetype structure Finally, here’s the interfacetype structure (src/runtime/type.go): type interfacetype struct { // 80 bytes on a 64bit arch typ _type pkgpath name mhdr []imethod } type imethod struct { name nameOff ityp typeOff } As mentioned, an interfacetype is just a wrapper around a _type with some extra interface-specific metadata added on top. In the current implementation, this metadata is mostly composed of a list of offsets that points to the respective names and types of the methods exposed by the interface ([]imethod). Conclusion Here’s an overview of what an iface looks like when represented with all of its sub-types inlined; this hopefully should help connect all the dots: 1234567891011121314151617181920212223242526272829303132333435363738394041type iface struct &#123; // `iface` tab *struct &#123; // `itab` inter *struct &#123; // `interfacetype` typ struct &#123; // `_type` size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldalign uint8 kind uint8 alg *typeAlg gcdata *byte str nameOff ptrToThis typeOff &#125; pkgpath name mhdr []struct &#123; // `imethod` name nameOff ityp typeOff &#125; &#125; _type *struct &#123; // `_type` size uintptr ptrdata uintptr hash uint32 tflag tflag align uint8 fieldalign uint8 kind uint8 alg *typeAlg gcdata *byte str nameOff ptrToThis typeOff &#125; hash uint32 _ [4]byte fun [1]uintptr &#125; data unsafe.Pointer&#125; This section glossed over the different data-types that make up an interface to help us to start building a mental model of the various cogs involved in the overall machinery, and how they all work with each other. Creating an interface Now that we’ve had a quick look at all the datastructures involved, we’ll focus on how they actually get allocated and initiliazed. Consider the following program (iface.go): 1234567891011121314151617181920type Mather interface &#123; Add(a, b int32) int32 Sub(a, b int64) int64&#125;type Adder struct&#123; id int32 &#125;&#x2F;&#x2F;go:noinlinefunc (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;&#x2F;&#x2F;go:noinlinefunc (adder Adder) Sub(a, b int64) int64 &#123; return a - b &#125;func main() &#123; m :&#x3D; Mather(Adder&#123;id: 6754&#125;) &#x2F;&#x2F; This call just makes sure that the interface is actually used. &#x2F;&#x2F; Without this call, the linker would see that the interface defined above &#x2F;&#x2F; is in fact never used, and thus would optimize it out of the final &#x2F;&#x2F; executable. m.Add(10, 32)&#125; NOTE: For the remainder of this chapter, we will denote an interface I that holds a type T as &lt;I,T&gt;. E.g. Mather(Adder{id: 6754}) instantiates an iface&lt;Mather, Adder&gt;. Let’s zoom in on the instantiation of iface&lt;Mather, Adder&gt;: m := Mather(Adder{id: 6754}) This single line of Go code actually sets off quite a bit of machinery, as the assembly listing generated by the compiler can attest: 123456789101112131415161718192021222324;; part 1: allocate the receiver;; A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame.;; It&#39;s stored there so that the compiler will later be able to reference it by its address;0x001d MOVL $6754, &quot;&quot;..autotmp_1+36(SP);; part 2: set up the itab;; Semantically, this gives us something along the lines of the following pseudo-code:;; tab :&#x3D; getSymAddr(&#96;go.itab.main.Adder,main.Mather&#96;).(*itab);; That&#39;s half of our interface right there!;; Now, while we&#39;re at it, let&#39;s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol.;; As usual, the -S flag of the compiler can tell us a lot:0x0025 LEAQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX0x002c MOVQ AX, (SP);; part 3: set up the data0x0030 LEAQ &quot;&quot;..autotmp_1+36(SP), AX0x0035 MOVQ AX, 8(SP)0x003a CALL runtime.convT2I32(SB)0x003f MOVQ 16(SP), AX0x0044 MOVQ 24(SP), CX Part 1: Allocate the receiver 10x001d MOVL $6754, &quot;&quot;..autotmp_1+36(SP) A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame. It’s stored there so that the compiler will later be able to reference it by its address; we’ll see why in part 3. Part 2: Set up the itab 120x0025 LEAQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX0x002c MOVQ AX, (SP) It looks like the compiler has already created the necessary itab for representing our iface&lt;Mather, Adder&gt; interface, and made it available to us via a global symbol: go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather. We’re in the process of building an iface&lt;Mather, Adder&gt; interface and, in order to do so, we’re loading the effective address of this global go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol at the top of the current stack-frame. Once again, we’ll see why in part 3. Semantically, this gives us something along the lines of the following pseudo-code: tab := getSymAddr(go.itab.main.Adder,main.Mather).(*itab) That’s half of our interface right there! Now, while we’re at it, let’s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol. As usual, the -S flag of the compiler can tell us a lot: 123456789$ GOOS&#x3D;linux GOARCH&#x3D;amd64 go tool compile -S iface.go | grep -A 7 &#39;^go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&#39;go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size&#x3D;40 0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00 .&#x3D;_a............ 0x0020 00 00 00 00 00 00 00 00 ........ rel 0+8 t&#x3D;1 type.&quot;&quot;.Mather+0 rel 8+8 t&#x3D;1 type.&quot;&quot;.Adder+0 rel 24+8 t&#x3D;1 &quot;&quot;.(*Adder).Add+0 rel 32+8 t&#x3D;1 &quot;&quot;.(*Adder).Sub+0 Neat. Let’s analyze this piece by piece. The first piece declares the symbol and its attributes: go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40 As usual, since we’re looking directly at the intermediate object file generated by the compiler (i.e. the linker hasn’t run yet), symbol names are still missing package names. Nothing new on that front. Other than that, what we’ve got here is a 40-byte global object symbol that will be stored in the .rodata section of our binary. Note the dupok directive, which tells the linker that it is legal for this symbol to appear multiple times at link-time: the linker will have to arbitrarily choose one of them over the others. The second piece is a hexdump of the 40 bytes of data associated with the symbol. I.e., it’s a serialized representation of an itab structure: 1230x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00 .&#x3D;_a............0x0020 00 00 00 00 00 00 00 00 As you can see, most of this data is just a bunch of zeros at this point. The linker will take care of filling them up, as we’ll see in a minute. Notice how, among all these zeros, 4 bytes actually have been set though, at offset 0x10+4. If we take a look back at the declaration of the itab structure and annotate the respective offsets of its fields: 12345678type itab struct &#123; &#x2F;&#x2F; 40 bytes on a 64bit arch inter *interfacetype &#x2F;&#x2F; offset 0x00 ($00) _type *_type &#x2F;&#x2F; offset 0x08 ($08) hash uint32 &#x2F;&#x2F; offset 0x10 ($16) _ [4]byte &#x2F;&#x2F; offset 0x14 ($20) fun [1]uintptr &#x2F;&#x2F; offset 0x18 ($24) &#x2F;&#x2F; offset 0x20 ($32)&#125; We see that offset 0x10+4 matches the hash uint32 field: i.e., the hash value that corresponds to our main.Adder type is already right there in our object file. The third and final piece lists a bunch of relocation directives for the linker: 1234rel 0+8 t&#x3D;1 type.&quot;&quot;.Mather+0rel 8+8 t&#x3D;1 type.&quot;&quot;.Adder+0rel 24+8 t&#x3D;1 &quot;&quot;.(*Adder).Add+0rel 32+8 t&#x3D;1 &quot;&quot;.(*Adder).Sub+0 rel 0+8 t=1 type.&quot;&quot;.Mather+0 tells the linker to fill up the first 8 bytes (0+8) of the contents with the address of the global object symbol type.&quot;&quot;.Mather. rel 8+8 t=1 type.&quot;&quot;.Adder+0 then fills the next 8 bytes with the address of type.&quot;&quot;.Adder, and so on and so forth. Once the linker has done its job and followed all of these directives, our 40-byte serialized itab will be complete. Overall, we’re now looking at something akin to the following pseudo-code: 123456789101112tab :&#x3D; getSymAddr(&#96;go.itab.main.Adder,main.Mather&#96;).(*itab)&#x2F;&#x2F; NOTE: The linker strips the &#96;type.&#96; prefix from these symbols when building&#x2F;&#x2F; the executable, so the final symbol names in the .rodata section of the&#x2F;&#x2F; binary will actually be &#96;main.Mather&#96; and &#96;main.Adder&#96; rather than&#x2F;&#x2F; &#96;type.main.Mather&#96; and &#96;type.main.Adder&#96;.&#x2F;&#x2F; Don&#39;t get tripped up by this when toying around with objdump.tab.inter &#x3D; getSymAddr(&#96;type.main.Mather&#96;).(*interfacetype)tab._type &#x3D; getSymAddr(&#96;type.main.Adder&#96;).(*_type)tab.fun[0] &#x3D; getSymAddr(&#96;main.(*Adder).Add&#96;).(uintptr)tab.fun[1] &#x3D; getSymAddr(&#96;main.(*Adder).Sub&#96;).(uintptr) We’ve got ourselves a ready-to-use itab, now if we just had some data to along with it, that’d make for a nice, complete interface. Remember from part 1 that the top of the stack (SP) currently holds the address of go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather (argument #1). Also remember from part 2 that we had stored a $6754 decimal constant in “”…autotmp_1+36(SP): we now load the effective address of this constant just below the top of the stack-frame, at 8(SP) (argument #2). These two pointers are the two arguments that we pass into runtime.convT2I32, which will apply the final touches of glue to create and return our complete interface. Let’s have a closer look at it (src/runtime/iface.go): 1234567891011121314func convT2I32(tab *itab, elem unsafe.Pointer) (i iface) &#123; t :&#x3D; tab._type &#x2F;* ...omitted debug stuff... *&#x2F; var x unsafe.Pointer if *(*uint32)(elem) &#x3D;&#x3D; 0 &#123; x &#x3D; unsafe.Pointer(&amp;zeroVal[0]) &#125; else &#123; x &#x3D; mallocgc(4, t, false) *(*uint32)(x) &#x3D; *(*uint32)(elem) &#125; i.tab &#x3D; tab i.data &#x3D; x return&#125; So runtime.convT2I32 does 4 things: It creates a new iface structure i (to be pedantic, its caller creates it… same difference). It assigns the itab pointer we just gave it to i.tab. It allocates a new object of type i.tab._type on the heap, then copy the value pointed to by the second argument elem into that new object. It returns the final interface. This process is quite straightforward overall, although the 3rd step does involve some tricky implementation details in this specific case, which are caused by the fact that our Adder type is effectively a scalar type. We’ll look at the interactions of scalar types and interfaces in more details in the section about the special cases of interfaces. Conceptually, we’ve now accomplished the following (pseudo-code): 12345678tab :&#x3D; getSymAddr(&#96;go.itab.main.Adder,main.Mather&#96;).(*itab)elem :&#x3D; getSymAddr(&#96;&quot;&quot;..autotmp_1+36(SP)&#96;).(*int32)i :&#x3D; runtime.convTI32(tab, unsafe.Pointer(elem))assert(i.tab &#x3D;&#x3D; tab)assert(*(*int32)(i.data) &#x3D;&#x3D; 6754) &#x2F;&#x2F; same value..assert((*int32)(i.data) !&#x3D; elem) &#x2F;&#x2F; ..but different (al)locations! To summarize all that just went down, here’s a complete, annotated version of the assembly code for all 3 parts: 123456780x001d MOVL $6754, &quot;&quot;..autotmp_1+36(SP) ;; create an addressable $6754 value at 36(SP)0x0025 LEAQ go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX ;; set up go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather..0x002c MOVQ AX, (SP) ;; ..as first argument (tab *itab)0x0030 LEAQ &quot;&quot;..autotmp_1+36(SP), AX ;; set up &amp;36(SP)..0x0035 MOVQ AX, 8(SP) ;; ..as second argument (elem unsafe.Pointer)0x003a CALL runtime.convT2I32(SB) ;; call convT2I32(go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather, &amp;$6754)0x003f MOVQ 16(SP), AX ;; AX now holds i.tab (go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather)0x0044 MOVQ 24(SP), CX ;; CX now holds i.data (&amp;$6754, somewhere on the heap)","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"emacs-package-for-golang","slug":"emacs-package-for-golang","date":"2019-11-24T01:15:15.000Z","updated":"2019-12-04T09:13:17.413Z","comments":true,"path":"2019/11/24/emacs-package-for-golang/","link":"","permalink":"https://dreamerjonson.com/2019/11/24/emacs-package-for-golang/","excerpt":"","text":"ivy-mode 123456789101112131415161718192021222324252627282930313233;;;; ivy mode;;(use-package ivy :ensure t :diminish (ivy-mode . &quot;&quot;) :config (ivy-mode 1) (setq ivy-use-virutal-buffers t) (setq enable-recursive-minibuffers t) (setq ivy-height 10) (setq ivy-initial-inputs-alist nil) (setq ivy-count-format &quot;%d&#x2F;%d&quot;) (setq ivy-re-builders-alist &#96;((t . ivy--regex-ignore-order))) );;;; counsel;;(use-package counsel :ensure t :bind ((&quot;M-x&quot; . counsel-M-x) (&quot;\\C-x \\C-f&quot; . counsel-find-file)));;;; swiper;;(use-package swiper :ensure t :bind ((&quot;\\C-s&quot; . swiper)) ) gomode + goimport自动导入 + godef跳转 go get -u github.com/rogpeppe/godef go get -u golang.org/x/tools/cmd/goimports 12345678910111213141516(use-package go-mode ;; :load-path &quot;~&#x2F;.emacs.d&#x2F;vendor&#x2F;go-mode&quot; :mode (&quot;\\\\.go\\\\&#39;&quot; . go-mode) :ensure-system-package ((goimports . &quot;go get -u golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;goimports&quot;) (godef . &quot;go get -u github.com&#x2F;rogpeppe&#x2F;godef&quot;)) :init (setq gofmt-command &quot;goimports&quot; indent-tabs-mode t) :config (add-hook &#39;before-save-hook &#39;gofmt-before-save) :bind (:map go-mode-map (&quot;\\C-c \\C-c&quot; . compile) (&quot;\\C-c \\C-g&quot; . go-goto-imports) (&quot;\\C-c \\C-k&quot; . godoc) (&quot;M-j&quot; . godef-jump))) M-n find引用 M-x lsp-find-ref M-. find 实现 gocode+company 自动补全 1234567891011121314151617181920;;;; company;;(use-package company :ensure t :config (global-company-mode t) (setq company-idle-delay 0) (setq company-minimum-prefix-length 3) (setq company-backends &#39;((company-files company-yasnippet company-keywords company-capf ) (company-abbrev company-dabbrev))))(add-hook &#39;emacs-lisp-mode-hook (lambda () (add-to-list (make-local-variable &#39;company-backends) &#39;(company-elisp)))) gocode go get -u github.com/stamblerre/gocode # for go-eldoc/company-go // this feel better than nsf/gocde gocode 是守护进程，查看是否在后台运行 1ps -e | grep gocode 语法检查 C-c ! l C-c ! v 12345(use-package flycheck :ensure t :config (global-flycheck-mode t) ) gotest 12345678910(use-package gotest :after go-mode :bind (:map go-mode-map (&quot;C-c C-f&quot; . go-test-current-file) (&quot;C-c C-t&quot; . go-test-current-test) (&quot;C-c C-p&quot; . go-test-current-project) (&quot;C-c C-b&quot; . go-test-current-benchmark) (&quot;C-x x&quot; . go-run)) :config (setq go-test-verbose t)) gorename go get -u golang.org/x/tools/cmd/gorename 12345(use-package go-rename :after go-mode :ensure-system-package (gorename . &quot;go get -u golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;gorename&quot;) :bind (:map go-mode-map (&quot;C-c C-r&quot; . go-rename))) errorcheck go get -u github.com/kisielk/errcheck 12345(use-package go-errcheck :after go-mode :ensure-system-package (errcheck . &quot;go get -u github.com&#x2F;kisielk&#x2F;errcheck&quot;) :bind (:map go-mode-map (&quot;C-c C-e&quot; . go-errcheck))) go-imenu go get -u github.com/lukehoban/go-outline 12345(use-package go-imenu :ensure-system-package (go-outline . &quot;go get -u github.com&#x2F;lukehoban&#x2F;go-outline&quot;) :after go-mode :config (add-hook &#39;go-mode-hook &#39;go-imenu-setup)) gtags 安装GUN global though source code 注意不要用brew安装，因为必须要配置sqlite3 123456wget http:&#x2F;&#x2F;tamacom.com&#x2F;global&#x2F;global-6.5.7.tar.gztar xvf global-6.5.7.tar.gzcd global-6.5.7.&#x2F;configure --with-sqlite3makesudo make install 1go get github.com&#x2F;juntaki&#x2F;gogtags 在项目目录中输入： gogtags -v 会生成GTAGS等文件 12345678910111213141516(use-package helm-gtags :config (setq helm-gtags-ignore-case t helm-gtags-auto-update t helm-gtags-use-input-at-cursor t helm-gtags-pulse-at-cursor t helm-gtags-prefix-key &quot;\\C-cg&quot; helm-gtags-suggested-key-mapping t) :bind (:map helm-gtags-mode-map (&quot;C-c g a&quot; . helm-gtags-tags-in-this-function) (&quot;C-j&quot; . helm-gtags-select) (&quot;M-.&quot; . helm-gtags-dwim) (&quot;M-,&quot; . helm-gtags-pop-stack) (&quot;C-c &lt;&quot; . helm-gtags-previous-history) (&quot;C-c &gt;&quot; . helm-gtags-next-history)) :hook ((dired-mode eshell-mode c-mode c++-mode asm-mode) . helm-gtags-mode)) 这时候再项目中即可使用 M-x helm-gtags finn partern 等查找tags projecttle 在项目中切换 1234567891011(use-package dumb-jump :bind ((&quot;M-g o&quot; . dumb-jump-go-other-window) (&quot;M-g j&quot; . dumb-jump-go) (&quot;M-g x&quot; . dumb-jump-go-prefer-external) (&quot;M-g z&quot; . dumb-jump-go-prefer-external-other-window)) :config ;; (setq dumb-jump-selector &#39;ivy) ;; (setq dumb-jump-selector &#39;helm):initny(dumb-jump-mode) :ensure) dumb-jump 跳转OB 1234567891011(use-package dumb-jump :bind ((&quot;M-g o&quot; . dumb-jump-go-other-window) (&quot;M-g j&quot; . dumb-jump-go) (&quot;M-g x&quot; . dumb-jump-go-prefer-external) (&quot;M-g z&quot; . dumb-jump-go-prefer-external-other-window)) :config ;; (setq dumb-jump-selector &#39;ivy) ;; (setq dumb-jump-selector &#39;helm):init(dumb-jump-mode) :ensure)","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"mac install tor","slug":"mac-install-tor","date":"2019-11-18T04:27:45.000Z","updated":"2019-11-20T02:58:54.961Z","comments":true,"path":"2019/11/18/mac-install-tor/","link":"","permalink":"https://dreamerjonson.com/2019/11/18/mac-install-tor/","excerpt":"","text":"install brew install tor config You will find a sample Tor configuration file at /usr/local/etc/tor/torrc.sample. Remove the .sample extension to make it effective. man tor simple excute tor github though socket 测试通过之后，你可以修改 SSH 的配置文件，就不用每次都在命令行参数中指定密钥文件的路径了。如果你用 SSH 方式操作2个以上的项目，很有必要进行如下定制，可以节省很多命令行输入。 SSH 配置文件的路径是： ~/.ssh/config 如果你系统中没有这个文件，就创建一个。然后用你熟悉的文本编辑器修改这个文件。 下面俺给出一个示例： 你需要把示例中的“别名”改为你自己起的名字（用一个可读性好点的名字）； 把“私钥文件路径”也同样替换为你本机所使用的文件路径。 其它部分【不要】改动。 Host 别名 HostName ssh.github.com Port 443 User git PreferredAuthentications publickey IdentityFile 私钥文件路径 所谓的“别名”，用来替换 URL 中的主机名。比如俺那个 zhao 项目，俺在 ~/.ssh/config 中使用的别名就是 zhao 之后俺如果要 clone 该项目，只需用如下命令： git clone ssh://zhao/programthink/zhao 看到没？俺在 URL 中就不写 github.com 而改为 zhao，那么 openssh 就会去 ~/.ssh/config 中找到 zhao 这个配置项，然后用对应的私钥文件进行 SSH 连接， ★针对不同的 Git 使用方式，如何配置代理？ B/S 方式（Web 方式） 这种方式最简单——就跟你翻墙访问其它网站类似——只需要让你的浏览器通过 Tor 的线路访问 GitHub 的页面，就 OK 了。 没用过 Tor 的同学，先去看俺的扫盲教程《戴“套”翻墻的方法》。 C/S 方式 下的 HTTPS 协议 对于这种方式，你需要修改 Git 的配置参数，让 Git 知道 Tor 代理的 IP 和 端口。 具体的配置命令如下： git config --global http.proxy SOCKS5h://代理地址:端口号 注意1： 假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为： 127.0.0.1 否则就替换为：运行 Tor 客户端的主机的 IP 地址。 注意2： 如果你的 Tor 客户端用的是【Tor Browser】，“端口号”必须用 9150 如果你用的是 Tor 的其它软件包（比如：Tor Expert Bundle），则“端口号”使用 9050 C/S 方式下的 SSH 协议 要让 SSH 通过 Tor 的代理，稍微麻烦一点。因为 Tor 默认提供的是 SOCKS 代理，而 OpenSSH 客户端默认又【不】支持 SOCKS 代理。 因此，得依靠第三方的工具，来实现“SSH through SOCKS”。 这里要提醒一下列位看官： 俺说的是“SSH through SOCKS”，而【不是】“SOCKS through SSH”（这两者完全不同） 为了搞定“SSH through SOCKS”，俺选用大名鼎鼎的 netcat（俗称“网猫”）。 由于这个 netcat 名气很大，主流 Linux 发行版的软件仓库中都有它。你只需要用发行版自带的软件包管理器，把 netcat 装上。 说到 netcat，有一个“原版的”以及非常多的【变种】。“原版的 netcat”【不】支持代理，必须用某些支持代理的【变种】。俺推荐的是 OpenBSD 社区开发的 netcat 变种（也叫“OpenBSD netcat”或“netcat-openbsd”）。 如何判断你是否装对了捏？ 在装好 netcat 之后，先运行如下命令（命令中的 nc 就是 netcat 的缩写）。如果输出的第一行能看到 OpenBSD 这个单词，就说明你装对了。 nc -h 接下来，用如下命令测试“SSH through Tor SOCKS”是否成功。 ssh -o “ProxyCommand=nc -X 5 -x 代理地址:端口号 %h %p” -T ssh.github.com 注意1： 假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为 127.0.0.1 否则就替换为：运行 Tor 客户端的主机的 IP 地址。 注意2： 如果你的 Tor 客户端用的是 Tor Browser，“端口号”必须用 9150 如果你用的是 Tor 的其它软件包（比如：Tor Expert Bundle），则“端口号”使用 9050 上述测试命令如果最终显示 Permession denied 就说明已经通过 SOCKS 代理连接到 GitHub 了（也就是说，你的 SSH 已经能够走 SOCKS 代理联网了）。 如果没有显示这个信息，而是显示了其它其它信息，你再用如下命令重新试一次 ssh -o “ProxyCommand=nc -X 5 -x 代理地址:端口号 %h %p” -Tv ssh.github.com 这次俺加了一个 v 选项，可以打印出详细的诊断信息（不过都是洋文）。如果你略懂洋文并略懂网络技术，或许能判断出错的原因所在。 搞定之后，为了方便起见，同样可以把 SSH 的这个 ProxyCommand 命令行选项加入到 SSH 的配置文件。如此一来，以后每次你要连接 GitHub 的服务器，都会自动走 Tor 提供的 SOCKS 代理。 前面俺已经给出了 SSH 配置文件的示例，俺把之前那个示例文件，加上 ProxyCommand 选项之后，变为如下 Host 别名 HostName ssh.github.com Port 443 User git PreferredAuthentications publickey IdentityFile 私钥文件路径 ProxyCommand nc -X 5 -x 代理地址:端口号 %h %p 注意1： 假如你的 Tor 客户端运行在【本机】，那么上述命令中的“代理地址”就替换为 127.0.0.1 否则就替换为：Tor 客户端所在主机的 IP 地址。 注意2： 如果你的 Tor 客户端用的是 Tor Browser，“端口号”必须是 9150 如果你用的是 Tor 的其它软件包，则“端口号”使用 9050","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"扫盲 netcat（网猫）的 N 种用法——从网络诊断”到“系统入侵","slug":"扫盲-netcat（网猫）的-N-种用法——从网络诊断”到“系统入侵","date":"2019-11-14T15:49:56.000Z","updated":"2019-11-29T13:11:27.698Z","comments":true,"path":"2019/11/14/扫盲-netcat（网猫）的-N-种用法——从网络诊断”到“系统入侵/","link":"","permalink":"https://dreamerjonson.com/2019/11/14/%E6%89%AB%E7%9B%B2-netcat%EF%BC%88%E7%BD%91%E7%8C%AB%EF%BC%89%E7%9A%84-N-%E7%A7%8D%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E4%BB%8E%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E2%80%9D%E5%88%B0%E2%80%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E4%BE%B5/","excerpt":"","text":"★招数1：（网络诊断）测试某个远程主机的【监听】端口是否可达 ◇使用场景 经常有这种需求，要判断某个主机的监听端口是否能连上。 导致监听端口【无法】，通常有两种原因： 其一，这个监听端口根本就【没开启】； 其二，监听端口虽然开启，但是被防火墙阻拦了。 对第1个原因，（如果你能在该主机上运行命令）可以直接用 netstat 这个命令查看监听端口是否开启（不懂 netstat 命令的同学，可以看这篇博文） 但对于第2个原因，netstat 就用不上了。这时候就可以用 nc 来帮你搞定。 ◇方法 用如下命令可以测试某个 IP 地址（x.x.x.x）上的某个监听端口（xx）是否开启。 1nc -nv x.x.x.x xx 上述命令用到了如下几个选项： 选项 -v 如果你是 nc 的新手，俺建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。 在本文后续的举例中，俺会尽量都加上这个选项（但这段话就不再重复唠叨啦） 选项 -n 由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析； 反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”。 ◇补充说明：超时设置 在测试链接的时候，如果你【没】使用 -w 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。 如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“-w 选项”，设置一个比较小的超时值。在下面的例子中，超时值设为3秒。 nc -nv -w 3 x.x.x.x xx ★招数2：（网络诊断）判断防火墙是否“允许 or 禁止”某个端口 ◇使用场景 前一个章节（招数1）的场景是——已经有某个网络软件开启了监听端口，然后用 nc 测试端口是否可达。 现在换另一个场景： 假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何【验证】自己的配置是 OK 滴？ 更进一步说：如果当前【没有】任何软件开启 8080 这个监听端口，你如何判断：该端口号是否会被防火墙阻拦？ 为了叙述方便，设想如下场景： 有两台主机——“主机C”充当客户端，“主机S”充当服务端。 然后要判断“主机S”上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。 ◇方法 在“主机S”上运行 nc，让它在 8080 端口，命令如下： 1nc -lv -p 8080 选项 -l 这个选项会让 nc 进入监听模式。 选项 -p 这个选项有“选项值”，也就是具体端口号。 然后在“主机C”上运行 nc，测试“主机S”上的 8080 端口是否可达（具体的命令行参见前一章节“招数1”） ◇补充说明：如何让 nc 的监听端口【持续开启】 在默认情况下，nc 开启 listen 模式充当服务端，在接受【第一次】客户端连接之后，就会把监听端口关闭。 为啥会这样捏？因为当年设计 nc 更多的是作为某种网络诊断/配置工具，并【不是】真拿它当服务端软件来用的。 如果你想要让 nc 始终监听模式，使之能【重复】接受客户端发起的连接，可以追加 -k 选项。 ◇补充说明：UDP 上述举例是基于 TCP 协议。如果你要测试 UDP 协议，要记得【两边】的 nc 都要追加 -u 选项。 ★招数3：（渗透测试）用 nc 玩“端口扫描” ◇使用场景 在“招数1”里面介绍了：如何测试【单个】端口是否可达。 扩展一下：如果你要测试的不止一个端口，而是某个【范围】的端口。这种行为有个专门的术语叫【端口扫描】。 “端口扫描”是一把双刃剑——“黑帽子”用这招进行信息收集，为后续的入侵做铺垫；“白帽子”用这招来进行“渗透测试”，以排查自己系统中【尚未屏蔽】的对外监听端口。 作为一款牛逼的网络瑞士军刀，nc 当然可以用来干这事儿啦。 顺便说一下： 不论是 TCP 还是 UDP，协议规定的【有效】端口号范围都是：1 ~ 65535 ◇方法 下面这个命令，用来扫描 IP 地址为 x.x.x.x 的主机，扫描的端口范围从 1 到 1024 1nc -znv x.x.x.x 1-1024 选项 -z 意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。 选项 -n （前面已聊过，参见“招数1”） 选项 -v -v 选项前面也聊过，这里要特地强调一下。 对 nc 的其它用法，-v 选项是可加可不加滴；但对于“端口扫描”而言，一定要有这个选项——否则你【看不到】扫描结果。 ◇补充说明：优化输出 玩“端口扫描”的时候，“-v 选项”会把“成功/失败”的结果统统打印出来。 通常大伙儿关注的都是“扫描成功”的那些端口。因此，可以用如下命令过滤一下，只打印扫出来的端口。 nc -znv x.x.x.x 1-1024 2&gt;&amp;1 | grep succeeded 由于“-v 选项”产生的输出位于【stderr】，上述命令中的 2&gt;&amp;1 用来把【stderr】合并到【stdout】（注：这种写法只适用于 POSIX 系统上的 shell） grep 命令用来进行【过滤】。对于 Windows 系统，默认【没有】grep 命令，需改用 find 命令过滤。 ◇补充说明：超时设置 如果你要扫描的端口范围，跨度比较大，超时值要【恰到好处】—— 超时值太大，会浪费时间；超时值太小，可能会遗漏某些端口（端口本身开放，但 nc 还没来得及连上就超时了） 具体如何设置，参见“招数1”的“补充说明”。 ◇补充说明：【并发】扫描 如果你设置了较小的超时值，依然嫌慢，还可以用【并发】扫描的方式，进一步提升效率。 简而言之就是：同时运行多个 nc，分别扫描不同的端口范围。 ★招数4：（隐匿性）如何让 nc 走暗网（以 Tor 为例） ◇方法 为了支持代理，nc 的“OpenBSD 变种”增加了两个选项：-X 与 -x 选项 -x 该选项表示【代理的位置】，以 x.x.x.x:xxx 的形式表示（中间是【半角冒号】）。 选项 -X 该选项表示【代理的类型】，含义如下： 选项值 含义 5 SOCKS5 代理 4 SOCKS4 代理 connect CONNECT 型的 HTTP 代理 上述这几种类型的代理，功能上有啥差异，参见下面这篇博文开头部分的★预备知识章节。 《如何让【不支持】代理的网络软件，通过代理进行联网（不同平台的 N 种方法）》 首先，确保你本机已经运行了 Tor； 然后，拿俺的域名测试一下。如果 nc 的输出中包含 succeeded（参见下面的第2行），说明 OK 啦——nc 已经能通过 Tor 联网。 nc -X 5 -x 127.0.0.1:9050 -q 3 -v program-think.blogspot.com 443 Connection to program-think.blogspot.com 443 port [tcp/https] succeeded! ◇补充说明：Tor 暗网的好处 关于 Tor 的用处/好处，俺在博客上重复唠叨的次数，已经数不清了。 （简而言之）由于 Tor 暗网的线路会经历“三级跳”＆“三重套”，而且其线路每隔10分钟就会【随机】变换一次。这种变态的玩法，可以让【网络层面】的逆向追溯变得非常非常困难。 对这方面的更多介绍，参见：《关于 Tor 的常见问题解答》 ◇补充说明：域名解析 当你用刚才的招数做到【nc over Tor】之后，一旦 nc 的网络行为需要解析域名，会自动通过 Tor 的 SOCKS 代理进行【远程域名解析】。 也就是说，“DNS 协议”相关数据流也经过 Tor 暗网——这样既可以【防止】“域名解析”暴露你的网络行为，还可以避免 GFW 的“域名污染”。 关于“DNS 协议”的引申阅读，可以看如下几篇： 《扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗／域名污染”》 《对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS》 ◇补充说明：设置别名（alias） 如果你比较懒，觉得每次都输入上述两个代理选项太麻烦，可以为 nc 设置一个【别名】（命令如下） alias nc-tor=‘nc -X 5 -x 127.0.0.1:9050’ 设置好之后，你只要用 nc-tor 就可以自动追加代理选项。 如果想让别名【永久】生效，要把上述命令加入到：你当前使用的 shell 的启动文件中。 再次唠叨：“裸 Tor”与“Tor Browser”的监听端口有差异。俺上述命令的 9050 是用于“裸 Tor”。 ★招数5（信息收集）用 nc 探测“服务器类型”和“软件版本”（以 SSH 为例） 如今要【远程管理】服务器，最常用的大概就是 SSH 这种方式了。 如果某个服务器运行了 SSH 服务端（默认监听端口是 22），那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。 12Connection to 192.168.1.25 port 22 [tcp&#x2F;*] succeeded!SSH-2.0-OpenSSH_for_Windows_7.7 ◇补充说明：批处理 ＆ 自动化 某些“有心人”甚至可以搞一个脚本，批量探测某个 IP 地址段的 22 端口，然后把找到的服务器信息保存在某个文件中。 另外， 有的系统管理员会把 sshd 的监听端口从 22 改为其它数值，想要迷惑攻击者。但这么干，【效果不大】。 攻击者可以先进行端口扫描，拿到所有已开启的 TCP 监听端口；然后利用上述方法，对这些 TCP 端口进行【自动化】探测，从而判断出哪个端口是 SSH Server。 ◇补充说明：防范措施 本章节以“SSH Server”举例来说明入侵者如何探测服务端的软件版本。 除了“SSH Server”，很多其它的服务端软件，也存在类似的【信息暴露】。 一个谨慎的系统管理员，应该通过定制，【消除 or 伪造】这些信息，从而增加入侵者的攻击成本。 ★招数7：（网络配置）基于 nc 的端口转发（Port Forward） ◇原理 用 nc 进行端口转发，需要运行【两个】nc 进程，一个充当“服务端”，另一个是“客户端”，然后用【管道】让把两个进程的“标准输入输出”交叉配对。所谓的“交叉配对”就是——每一个 nc 进程的“标准输出”都【对接】到另一个 nc 进程的“标准输入”。如此一来，就可以完美地建立【双向通讯】。 玩过命令行的同学，应该都知道：大部分 shell 都支持【管道符】（就是那个竖线符号 |），可以把某个进程的标准输出，重定向给另一个进程的标准输入。但是 shell 的“管道符”只能做到“单向配对”，【无法】做到“交叉配对”。所以还需要再借助另一个管道——也就是“命名管道”。 “命名管道”洋文叫做“named pipe”，是一种进程间通讯（IPC）的机制。顾名思义，“命名管道”就是有名号滴，而 shell 中使用的那个【管道符】，其本质上是“匿名管道”（无名管道）。 主流的操作系统（Windows、Linux、UNIX）都支持“命名管道”这种机制。由于俺本人的环境是 Linux，下面只以 Linux 举例。 ◇方法 步骤1：创建命名管道 用下面这个简单的命令创建一个“命名管道”，其名称叫做 nc_pipe。（俺用这个名称只是为了举例，你也可以用别的名称） mkfifo nc_pipe 步骤2：同时启动两个 nc nc -l -p 1234 &lt; nc_pipe | nc 127.0.0.1 5678 &gt; nc_pipe 运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。 这个命令有点复杂。技术菜鸟如果看不懂，就算了（没关系滴，不影响你看后续的章节）。 如果你比较喜欢刨根问底，俺稍微解释一下： 上述命令行中，前一个 nc 充当【服务端】，后一个 nc 充当【客户端】。命令行中的“管道符”使得“服务端 nc”的输出绑定到“客户端 nc”的输入。然后再用 nc_pipe 这个命名管道做中转，使得“客户端 nc”的输出绑定到“服务端 nc”的输入。从而完成了【交叉配对】。 ◇补充说明：如何让 nc 的监听端口【持续开启】 参见“招数2”章节中的“补充说明”。 1netstat -an | grep &quot;LISTEN&quot; 招数9：（系统管理）用 nc 传输文件 ◇使用场景 有时候，你需要在两台电脑之间传输文件。也可以用 nc 搞定。 俺猜到某些技术小白会问：为啥不用 Windows 的共享目录？ 反驳的理由很多—— 反驳1：这个玩意儿只能在 Windows 上用。 反驳2：为了使用“共享目录”，需要启用（Enable）系统中的好几个 service，这会增加你系统的【攻击面】。 反驳3：启用的 service 越多，占用的内容也越多，影响性能。 … 还有些同学会问：为啥不用 FTP、SSH（或诸如此类的东东）？ 俺觉得： 1、如果只是临时传一个文件，还要额外再去装某某软件的客户端/服务端，岂不是很蛋疼？ 2、任何服务端软件，（从某种意义上说）都是在【增加攻击面】。 ◇方法 为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2 你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号） nc -l -p xxx &gt; file2 然后在【发送端】（A 主机）运行如下命令。 nc x.x.x.x xxx &lt; file1 第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。 ◇补充说明：nc 的性能优势 用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。 （不熟悉网络分层的同学，再去复习一下本文开头的 OSI 模型） 如果你传输的文件【超级大】或者文件数量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言） 招数10：（系统管理）用 nc 远程备份整个磁盘 ◇使用场景 当你学会“用 nc 传输文件”，还可以用 nc【复制整个硬盘】。 无论是对“系统管理员”，还是对“入侵者”甚至是“数据取证人员”，这招都是蛮有用滴。 考虑到某些读者是“技术菜鸟”，俺稍微说明一下。 “磁盘复制”【不同于】“在两块磁盘之间复制文件”。两者之间有很多差别，至少包括： 性能差异——如果“源盘”上有非常多的小文件，“在两块磁盘之间复制文件”就会【非常慢】。 完整性差异——“磁盘复制”可以确保两块盘的内容是完全一致滴。而如果你仅仅在两块磁盘之间复制文件，很多信息都损失掉了。 一般来说，“系统管理员”和“入侵者”更看重第1个差异（性能）；而“数据取证人员”更看重第2个差异（完整性）。 ◇原理 为了传输整个磁盘，你需要用到 dd 命令。这玩意儿源自 UNIX，后来也移植到 Linux 和 Windows。 俺曾经在如下博文中稍微介绍过 dd 命令的使用。 《如何用 ISO 镜像制作 U 盘安装盘（通用方法、无需 WinPE）》 关于 dd 命令的更详细介绍，可以参见“维基百科”（这里）或“Gnu 官网”（这里）。 通过 dd 命令，你可以把“整个硬盘”（或者硬盘上的某个“物理分区”、“逻辑分区”）dump 成一个文件。 在本章节，由于最终目的是要【跨主机备份磁盘】，所以并【不】需要真的把 dd 命令的输出保存成文件，而是把 dd 的输出通过管道符（|）重定向给【本机】的 nc，然后让【本机】的 nc 发送到另一台主机的 nc（参见前一个招数）。 ◇方法 由于操作物理磁盘会涉及到操作系统的差异，下面俺以 Linux 举例。 假设你要把 A 主机 /dev/sda 磁盘的【原始数据】整个复制到 B 主机的 /dev/sdb 磁盘。 你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号） nc -l -p xxx | dd of=/dev/sdb 然后在【发送端】（A 主机）运行如下命令。 dd if=/dev/sda | nc x.x.x.x xxx 第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。 ◇补充说明：nc 的性能优势 如今的存储设备越来越大了。“磁盘”或者“分区”，动不动都是几百个 GB，这时候 nc 的【性能优势】就体现出来啦。 （具体的原因，前一个章节已经分析过了） 招数11：（入侵手法）用 nc 开启【被动】连接型后门 既然聊 netcat，很自然地会聊到“黑客/骇客”的入侵招数。 做这方面的介绍，并【不是】为了传授入侵技巧；而是为了——让那些注重安全性的同学，能做到“知己知彼”。 ◇使用场景 假设1：你使用的浏览器存在某个安全漏洞，并且该漏洞会让攻击者获得【执行代码】的机会。 假设2：你在某个公共场合使用某个 wifi 热点上网。遗憾的是，这个热点是攻击者设置的陷阱。 假设3：设置该陷阱的攻击者，正好也知道：如何利用上述漏洞。 当这三个假设都成立，攻击者就可以获得在你【本机】执行代码的机会。这时候，攻击者可以下载一个 nc 到你本机，然后用 nc 开启一个【被动】连接型后门。所谓的“【被动】连接型”就是指——nc 开启对外监听端口。 在该场景中，因为攻击者与你处于【同一个局域网】，攻击者自然能从自己的机器访问到你本机的 nc 后门。 ◇原理 为了让后门能工作，通常会使用 nc 的 -e 选项，该选项的“选项值”是一个可执行文件的路径。 设置了该选项之后，当处于监听状态的 nc 接受到某个连接，会启动“选项值”对应的可执行文件（并得到某个进程），nc 会把该进程的“标准输入输出”与网络通讯【对接】。 为了让这个后门用起来足够爽，攻击者通常会让 nc 去启动一个【shell 进程】。对 Windows 系统而言，就是 cmd.exe；对 POSIX 系统（Linux or UNIX）而言，就是 /bin/sh 在这种情况下（nc 挂载 shell），攻击者远程连入 nc 的端口，就可以直接在这个 shell 上进行各种操作，其效果类似于 SSH 或（老式的）telnet。 ◇入侵方法 步骤1 如果受害者是 Windows 系统，只须如下命令就可以开启一个后门（其中的 xxx 是端口号） nc.exe -l -p xxx -e cmd.exe 如果受害者是 POSIX 系统（Linux or UNIX），则用如下命令： nc -l -p xxx -e /bin/sh 步骤2 后门创建好之后，攻击者在自己机器上也运行 nc（客户端 nc），然后连接到作为后门的 nc（服务端 nc）。一旦连上之后，攻击者就可以在自己的 nc 上看到对方（受害者机器）的 shell 提示符。 ◇补充说明：-e 选项 据说是考虑到 -e 选项太过危险，nc 的 OpenBSD 变种（在多年前）已经【移除】了该选项。但其实捏，还是可以用间接的方式达到同样的效果（具体如何做，俺就不透露啦）。 另，“原版 nc”依然有这个选项；nc 的很多其它变种，也依然有这个选项。 ◇【不够】靠谱的防范措施 在这个场景中，大伙儿可能会想到三个值得改进之处： 1、浏览器的漏洞 2、使用公共 wifi 热点的习惯 3、防火墙的设置 对第1点 其实是【无解】滴！因为任何人都无法确保浏览器是【零漏洞】； 对第2点 要看每个人的具体情况而定。对有些人而言，“用公共热点上网”属于【刚需】。那就没办法了。 对第3点 “防火墙”这招，似乎是比较通用的解决之道。对大部分人而言，桌面 PC 根本就【不必】开启对外监听端口。因此，你可以配置操作系统自带防火墙，禁止【所有的】对外监听端口。 但是！（俺要开始说【但是】了） 操作系统自带的防火墙，本身也运行在操作系统【之内】。如果你是以【管理员身份】遭遇入侵，入侵者在进行【代码执行】的时候，就已经具有了【管理员权限】。在这个权限下，入侵者完全有可能“搞定”防火墙。方法有很多种—— 比如说：把用作后门的端口号，悄悄加入到防火墙的白名单中； 再比如说：直接把防火墙的过滤模块干掉； 更牛逼的入侵者，甚至可以在【网卡驱动】上做文章——因为网卡驱动位于防火墙的过滤模块【之下】（比防火墙更底层） ◇【靠谱】的防范措施——NAT 模式的虚拟机（Guest OS） 首先，这里所说的“NAT 模式”指的是【虚拟机的网卡模式】。如果你不熟悉虚拟机的网卡模式，建议先看俺写的《扫盲操作系统虚拟机》系列教程。 要想用这招，步骤如下： 1、当然先要安装【虚拟化软件】（VBox、VMware …）， 2、安装一个虚拟的操作系统（洋文叫“Guest OS”） 3、虚拟系统的网卡设置为【NAT】模式 完成上述步骤后，你就可以在这个虚拟系统中上网。 NAT 的好处在于【单向可见】。也就是说，Guest OS 可以访问到物理系统（Host OS）【外部】的网络环境；但外部网络环境只能看到 Host OS，看不到 Guest OS。 在这种配置下，就算某个入侵者完全控制了你的 Guest OS，他/她也【没】办法在 Guest OS 中搭建“被动连接型后门”。换句话说，即使入侵者运行了这种后门，（但由于 NAT 的缘故）后门【无法】接受外部网络的连接，这个后门就【失去意义】啦。 ◇补充说明：“NAT 模式”如何搭配“系统防火墙”？ 上述“NAT 招数”与“系统防火墙”并【不】矛盾。 也就是说，即使你用了这招，你的物理系统（Host OS）还是要配置系统防火墙，并禁止【所有的】对外监听端口。 https://program-think.blogspot.com/2019/09/Netcat-Tricks.html https://program-think.blogspot.com/2016/03/GitHub-Security-Tips.html https://program-think.blogspot.com/2019/09/Netcat-Tricks.html https://program-think.blogspot.com/2013/11/tor-faq.html https://program-think.blogspot.com/2009/09/break-through-gfw-with-tor.html https://program-think.blogspot.com/2019/04/Proxy-Tricks.html","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[101]-redis","slug":"golang-101-redis","date":"2019-11-07T10:46:19.000Z","updated":"2019-11-09T13:50:07.818Z","comments":true,"path":"2019/11/07/golang-101-redis/","link":"","permalink":"https://dreamerjonson.com/2019/11/07/golang-101-redis/","excerpt":"","text":"Redis is an “advanced key-value store” Redis Data Types 12345StringsListsSetsSorted&#x2F;Scored SetsHashes type 12345 string: page:index.html -&gt; &lt;html&gt;&lt;head&gt;[...] login_count -&gt; 7464 set: users_logged_in_today -&gt; &#123; 1, 2, 3, 4, 5 &#125;List: latest_post_ids -&gt; [201, 204, 209,..]Hashes user:123:session : time &#x3D;&gt; 10927353 username &#x3D;&gt; joeSorted Set joe ~ 1.3483 bert ~ 93.4 fred ~ 283.22 chris ~ 23774.17 golang redis helloworld 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;github.com&#x2F;go-redis&#x2F;redis&quot;)func main() &#123; fmt.Println(&quot;Go Redis Tutorial&quot;) client :&#x3D; redis.NewClient(&amp;redis.Options&#123; Addr: &quot;localhost:6379&quot;, Password: &quot;&quot;, DB: 0, &#125;) pong, err :&#x3D; client.Ping().Result() fmt.Println(pong, err)&#125; 使用 Docker 配置 Redis 主从复制 配置 master 节点 编辑 redis-master.conf，修改下列配置： 123456789101112131415161718192021222324252627# 监听来自外部的连接bind 0.0.0.0# 启用保护模式# 即在没有使用bind指令绑定具体地址时# 或在没有设定密码时# Redis将拒绝来自外部的连接protected-mode yes# 监听端口port 6379# 启动时不打印logo# 这个不重要，想看logo就打开它always-show-logo no# 设定密码认证requirepass redis# 禁用KEYS命令# 一方面 KEYS * 命令可以列出所有的键，会影响数据安全# 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间# 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃rename-command KEYS &quot;&quot;# 此外还应禁止 FLUSHALL 和 FLUSHDB 命令# 这两个命令会清空数据，并且不会失败 配置 slave 节点 创建 redis-slave1.conf，修改下列配置： 12345678910111213141516171819202122232425262728293031323334353637# 监听来自外部的连接bind 0.0.0.0# 启用保护模式# 即在没有使用bind指令绑定具体地址时# 或在没有设定密码时# Redis将拒绝来自外部的连接protected-mode yes# 监听端口port 6380# 启动时不打印logo# 这个不重要，想看logo就打开它always-show-logo no# 设定密码认证requirepass redis# 禁用KEYS命令# 一方面 KEYS * 命令可以列出所有的键，会影响数据安全# 另一方面 KEYS 命令会阻塞数据库，在数据库中存储了大量数据时，该命令会消耗很长时间# 期间对Redis的访问也会被阻塞，而当锁释放的一瞬间，大量请求涌入Redis，会造成Redis直接崩溃rename-command KEYS &quot;&quot;# 此外还应禁止 FLUSHALL 和 FLUSHDB 命令# 这两个命令会清空数据，并且不会失败# 配置master节点信息# 格式：#slaveof &lt;masterip&gt; &lt;masterport&gt;# 此处masterip所指定的redis-server-master是运行master节点的容器名# Docker容器间可以使用容器名代替实际的IP地址来通信slaveof redis-server-master 6379# 设定连接主节点所使用的密码masterauth &quot;redis&quot; 创建 redis-slave2.conf，修改监听端口号为 6381，其余配置与 redis-slave1.conf 相同。 编写 docker-compose.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475---version: &#39;3&#39;services: # 主节点的容器 redis-server-master: image: redis container_name: redis-server-master restart: always ports: - 6379:6379 networks: redis-cluster: # 为容器指定一个静态IP ipv4_address: 10.1.0.2 environment: TZ: &quot;Asia&#x2F;Shanghai&quot; volumes: # 映射配置文件和数据目录 - .&#x2F;redis-master.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf - ..&#x2F;data&#x2F;redis-master:&#x2F;data sysctls: # 必要的内核参数 net.core.somaxconn: &#39;511&#39; command: [&quot;redis-server&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf&quot;] # 从节点1的容器 redis-server-slave-1: image: redis container_name: redis-server-slave-1 restart: always depends_on: - redis-server-master ports: - 6380:6380 networks: redis-cluster: ipv4_address: 10.1.0.3 environment: TZ: &quot;Asia&#x2F;Shanghai&quot; volumes: - .&#x2F;redis-slave1.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf - ..&#x2F;data&#x2F;redis-slave-1:&#x2F;data sysctls: net.core.somaxconn: &#39;511&#39; command: [&quot;redis-server&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf&quot;] # 从节点2的容器 redis-server-slave-2: image: redis container_name: redis-server-slave-2 restart: always depends_on: - redis-server-master ports: - 6381:6381 networks: redis-cluster: ipv4_address: 10.1.0.4 environment: TZ: &quot;Asia&#x2F;Shanghai&quot; volumes: - .&#x2F;redis-slave2.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf - ..&#x2F;data&#x2F;redis-slave-2:&#x2F;data sysctls: net.core.somaxconn: &#39;511&#39; command: [&quot;redis-server&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf&quot;]networks: redis-cluster: # IP Address Management ipam: config: # 为容器分配一个独立的子网，用来方便为容器指定静态IP # 使用独立的子网可以避免IP地址冲突的问题 - subnet: 10.1.0.0&#x2F;16 启动容器 在 docker-compose.yml 所在位置执行 docker-compose up 即可启动上述三个容器，docker-compose 会将容器日志打印到终端，在日志中可以看到三个 Redis 服务器在启动过程中的动作，以及从节点加入主节点的信息。 启动成功后，可以在本机使用 redis-cli 连接至主节点。连接成功后，可以使用 info replication 命令检查主从复制的信息。 12345678910111213141516127.0.0.1:6379&gt; auth redisOK127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip&#x3D;10.1.0.3,port&#x3D;6380,state&#x3D;online,offset&#x3D;476,lag&#x3D;1slave1:ip&#x3D;10.1.0.4,port&#x3D;6381,state&#x3D;online,offset&#x3D;476,lag&#x3D;0master_replid:f29d9059a286deb4bbe5360f9c673a2484370205master_replid2:0000000000000000000000000000000000000000master_repl_offset:476second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:476 启动容器 在 docker-compose.yml 所在位置执行 docker-compose up 即可启动上述三个容器，docker-compose 会将容器日志打印到终端，在日志中可以看到三个 Redis 服务器在启动过程中的动作，以及从节点加入主节点的信息。 启动成功后，可以在本机使用 redis-cli 连接至主节点。连接成功后，可以使用 info replication 命令检查主从复制的信息。 1234567891011121314151617127.0.0.1:6379 &gt; redis-cli -h 127.0.0.1 -p 6379 -a redis127.0.0.1:6379&gt; auth redisOK127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip&#x3D;10.1.0.3,port&#x3D;6380,state&#x3D;online,offset&#x3D;476,lag&#x3D;1slave1:ip&#x3D;10.1.0.4,port&#x3D;6381,state&#x3D;online,offset&#x3D;476,lag&#x3D;0master_replid:f29d9059a286deb4bbe5360f9c673a2484370205master_replid2:0000000000000000000000000000000000000000master_repl_offset:476second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:476 12345678910111213141516171819202122232425262728测试一下光是启动成功还不够，还需要测试一下从节点是否能同步主节点的数据。首先连接到主节点，新增一个 set：127.0.0.1:6379&gt; auth redisOK127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; get foo&quot;bar&quot;好的，在主节点里面成功添加了一条数据。那么接下来连接到 slave-1，看一下数据有没有同步过去：127.0.0.1:6380&gt; auth redisOK127.0.0.1:6380&gt; get foo&quot;bar&quot;127.0.0.1:6380&gt; set foo baz(error) READONLY You can&#39;t write against a read only replica.看来 slave-1 成功的从主节点同步了数据，并且这个节点也按照设定，是一个只读的节点。那么 slave-2 呢？127.0.0.1:6381&gt; auth redisOK127.0.0.1:6381&gt; get foo&quot;bar&quot;127.0.0.1:6381&gt; set foo baz(error) READONLY You can&#39;t write against a read only replica.OK，slave-2 也成功的同步了数据，并且正在作为一个只读节点运行着。 使用 Docker 配置 Redis 哨兵 编辑 redis-sentinel.conf，修改下列配置： 12345678910111213141516171819# 接受来自外部的连接bind 0.0.0.0# 哨兵的端口号# 因为各个哨兵节点会运行在单独的Docker容器中# 所以无需担心端口重复使用port 26379# 配置哨兵的监控参数# 格式：sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;# master-name是为这个被监控的master起的名字# ip是被监控的master的IP或主机名。因为Docker容器之间可以使用容器名访问，所以这里写master节点的容器名# redis-port是被监控节点所监听的端口号# quorom设定了当几个哨兵判定这个节点失效后，才认为这个节点真的失效了sentinel monitor local-master redis-server-master 6379 2# 连接主节点的密码# 格式：sentinel auth-pass &lt;master-name&gt; &lt;password&gt;sentinel auth-pass local-master redis 配置及启动容器 编写 docker-compose.yml 这里继续使用 docker-compose 管理容器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263---version: &#39;3&#39;services: # 哨兵的数量应是奇数，以便于哨兵通过投票来作出决策 redis-sentinel-1: image: redis container_name: redis-sentinel-1 restart: always ports: # 向外暴露26379端口 - 26379:26379 networks: default: ipv4_address: 10.1.0.5 volumes: # 将哨兵配置文件和存放数据的文件夹挂载到容器内 - .&#x2F;redis-sentinel.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis-sentinel.conf - ..&#x2F;data&#x2F;redis-sentinel-1:&#x2F;data sysctls: # 设定容器的内核参数，以消除Redis启动过程中的一个warning net.core.somaxconn: &#39;511&#39; # 根据指定的配置文件来启动Redis哨兵 command: [&quot;redis-sentinel&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis-sentinel.conf&quot;] redis-sentinel-2: image: redis container_name: redis-sentinel-2 restart: always ports: - 26380:26379 networks: default: ipv4_address: 10.1.0.6 volumes: - .&#x2F;redis-sentinel.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis-sentinel.conf - ..&#x2F;data&#x2F;redis-sentinel-2:&#x2F;data sysctls: net.core.somaxconn: &#39;511&#39; command: [&quot;redis-sentinel&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis-sentinel.conf&quot;] redis-sentinel-3: image: redis container_name: redis-sentinel-3 restart: always ports: - 26381:26379 networks: default: ipv4_address: 10.1.0.7 volumes: - .&#x2F;redis-sentinel.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis-sentinel.conf - ..&#x2F;data&#x2F;redis-sentinel-3:&#x2F;data sysctls: net.core.somaxconn: &#39;511&#39; command: [&quot;redis-sentinel&quot;, &quot;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis-sentinel.conf&quot;]networks: default: external: # 因为哨兵容器需要与服务端容器运行在同一网络内 # 所以这里指定了一个外部的网络 # 网络名参考《使用Docker配置Redis主从复制》中的注释 name: server_redis-cluster 启动容器 这里同样使用 docker-compose up -d 启动容器，然后使用 redis-cli 连接到哨兵节点，连接成功后，可以使用 info sentinel 检查哨兵的信息。 12345678127.0.0.1:26379&gt; info sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name&#x3D;local-master,status&#x3D;ok,address&#x3D;10.1.0.2:6379,slaves&#x3D;2,sentinels&#x3D;1 其中，sentinel_masters:1 说明这个哨兵在监控一个 master，最后一行中写明了 master0 这个节点别名为 local-master，状态为 OK，地址是 10.1.0.2:6379，有 2 个从节点。 测试一下 哨兵光是启动了还是不够的，还需要测试一下当被监控节点下线之后，哨兵是否能作出反应。 首先，停掉 master，slave-1，slave-2，然后观察哨兵的日志，在经过一段时间之后，哨兵宣布有节点下线： 123456789redis-sentinel-3 | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:43:13.487 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:43:13.502 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:43:13.581 # +sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:43:13.582 # +sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:43:14.429 # +sdown master local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:43:14.439 # +sdown master local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:43:14.470 # +sdown master local-master 10.1.0.2 6379 然后再启动 master，slave-1，slave-2，并观察哨兵的日志，在节点上线之后，哨兵宣布了节点重启，并解除了节点的下线状态： 123456789101112131415161718redis-sentinel-2 | 1:X 19 Aug 2019 11:49:45.040 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:49:45.081 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:49:45.082 * +reboot slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:49:45.132 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:49:45.133 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:49:45.140 # -sdown slave 10.1.0.3:6380 10.1.0.3 6380 @ local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:49:45.141 * +reboot slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:49:45.231 # -sdown slave 10.1.0.4:6381 10.1.0.4 6381 @ local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:49:45.960 * +reboot master local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:49:45.963 * +reboot master local-master 10.1.0.2 6379redis-sentinel-1 | 1:X 19 Aug 2019 11:49:46.043 # -sdown master local-master 10.1.0.2 6379redis-sentinel-3 | 1:X 19 Aug 2019 11:49:46.046 # -sdown master local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:49:46.054 * +reboot master local-master 10.1.0.2 6379redis-sentinel-2 | 1:X 19 Aug 2019 11:49:46.144 # -sdown master local-master 10.1.0.2 6379","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[100]-jaeger","slug":"golang-100-jaeger","date":"2019-11-04T09:33:50.000Z","updated":"2019-11-05T14:54:56.052Z","comments":true,"path":"2019/11/04/golang-100-jaeger/","link":"","permalink":"https://dreamerjonson.com/2019/11/04/golang-100-jaeger/","excerpt":"","text":"jaeger 1、jaeger是uber公司开发的一种链路追踪工具，是为了应对当前微服务的架构而设计。 2、jaeger是opentracing协议的一种实现，opentracing对链路追踪定义了协议。 要使用jaeger的第一步是搭建jager服务 docker安装jaeger server 1234567docker run \\ --rm \\ -p 6831:6831&#x2F;udp \\ -p 6832:6832&#x2F;udp \\ -p 16686:16686 \\ jaegertracing&#x2F;all-in-one:1.7 \\ --log-level&#x3D;debug UI界面 http://localhost:16686/ jaeger的使用 trace： 需要首先初始化trace，trace可以理解为span构成的有向无环图。 span： span是具体业务的一种抽象 A trace is a directed acyclic graph of spans. A span is a logical representation of some work done in your application. Each span has these minimum attributes: an operation name, a start time, and a finish time. 12345678910111213tp, error := jaeger.NewUDPTransport(cfg.JaegerUrl, 0) if error != nil &#123; return errors.New(\"jaeger NewUDPTransport error\") &#125; tracer, close := jaeger.NewTracer( serviceName, jaeger.NewConstSampler(true), jaeger.NewRemoteReporter(tp), jaeger.TracerOptions.MaxTagValueLength(1024), ) cl.AppendCloser(close) opentracing.InitGlobalTracer(tracer) 可以通过多种方式创建jaeger，StartSpan(serviceName)创建一个root span 我们也可以通过下面的方法创建一个child span。child span 可以理解为父节点的子节点。 12StartSpanFromContext、opentracing.GlobalTracer().StartSpan(req.Method(), ext.RPCServerOption(spCtx)) jaeger要实现不同程序之间的链路关系，需要主动推送信息到server In order to continue the trace over the process boundaries and RPC calls, we need a way to propagate the span context over the wire. The OpenTracing API provides two functions in the Tracer interface to do that, Inject(spanContext, format, carrier) and Extract(format, carrier). format 和 carrier 就是附带的一些参数，这些参数会被下一个程序接收到。 format是这些参数的格式，在openntraceing中有3个标准的格式。 The format parameter refers to one of the three standard encodings the OpenTracing API defines: TextMap where span context is encoded as a collection of string key-value pairs, Binary where span context is encoded as an opaque byte array, HTTPHeaders, which is similar to TextMap except that the keys must be safe to be used as HTTP headers. carrier是附带的内容 The carrier is an abstraction over the underlying RPC framework. For example, a carrier for TextMap format is an interface that allows the tracer to write key-value pairs via Set(key, value) function, while a carrier for Binary format is simply an io.Writer. Extract 12carrier :&#x3D; opentracing.TextMapCarrier(md)clientContext, err :&#x3D; tracer.Extract(opentracing.TextMap, carrier) Inject 123456hash :&#x3D; make(map[string]string) carrier :&#x3D; opentracing.TextMapCarrier(hash) e :&#x3D; tracer.Inject( sp.Context(), opentracing.TextMap, carrier) 在golang中，大量使用了context来进行操作。 在golang实现的jaeger客户端和opentracing中，需要注意span与context的大量api。 例如StartSpanFromContext会从context中读取父节点，并生成一个子节点。 在opentracing.StartSpan中 example 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"os\" \"github.com/opentracing/opentracing-go/log\" \"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing\")func main() &#123; if len(os.Args) != 2 &#123; panic(\"ERROR: Expecting one argument\") &#125; tracer, closer := tracing.Init(\"hello-world\") defer closer.Close() helloTo := os.Args[1] span := tracer.StartSpan(\"say-hello\") span.SetTag(\"hello-to\", helloTo) helloStr := fmt.Sprintf(\"Hello, %s!\", helloTo) span.LogFields( log.String(\"event\", \"string-format\"), log.String(\"value\", helloStr), ) println(helloStr) span.LogKV(\"event\", \"println\") span.Finish()&#125; 2、子关系的span 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"context\" \"fmt\" \"os\" \"github.com/opentracing/opentracing-go\" \"github.com/opentracing/opentracing-go/log\" \"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing\")func main() &#123; if len(os.Args) != 2 &#123; panic(\"ERROR: Expecting one argument\") &#125; tracer, closer := tracing.Init(\"hello-world\") defer closer.Close() opentracing.SetGlobalTracer(tracer) helloTo := os.Args[1] span := tracer.StartSpan(\"say-hello\") span.SetTag(\"hello-to\", helloTo) defer span.Finish() ctx := opentracing.ContextWithSpan(context.Background(), span) helloStr := formatString(ctx, helloTo) printHello(ctx, helloStr)&#125;//StartSpanFromContext 建立一个span，是父亲节点的一个child。// If we think of the trace as a directed acyclic graph where nodes are the spans and edges are the causal relationships between them, then the ChildOf option is used to create one such edge between span and rootSpan. In the API the edges are represented by SpanReference type that consists of a SpanContext and a label. The SpanContext represents an immutable, thread-safe portion of the span that can be used to establish references or to propagate it over the wire. The label, or ReferenceType, describes the nature of the relationship. ChildOf relationship means that the rootSpan has a logical dependency on the child span before rootSpan can complete its operation. Another standard reference type in OpenTracing is FollowsFrom, which means the rootSpan is the ancestor in the DAG, but it does not depend on the completion of the child span, for example if the child represents a best-effort, fire-and-forget cache write.func formatString(ctx context.Context, helloTo string) string &#123; span, _ := opentracing.StartSpanFromContext(ctx, \"formatString\") defer span.Finish() helloStr := fmt.Sprintf(\"Hello, %s!\", helloTo) span.LogFields( log.String(\"event\", \"string-format\"), log.String(\"value\", helloStr), ) return helloStr&#125;func printHello(ctx context.Context, helloStr string) &#123; span, _ := opentracing.StartSpanFromContext(ctx, \"printHello\") defer span.Finish() println(helloStr) span.LogKV(\"event\", \"println\")&#125; 3、 模拟rpc， 跨程序进行追踪。 1首先启动publisher与formatter，接着执行master master 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package mainimport ( \"context\" \"net/http\" \"net/url\" \"os\" \"github.com/opentracing/opentracing-go\" \"github.com/opentracing/opentracing-go/ext\" \"github.com/opentracing/opentracing-go/log\" \"github.com/yurishkuro/opentracing-tutorial/go/lib/http\" \"github.com/yurishkuro/opentracing-tutorial/go/lib/tracing\")func main() &#123; if len(os.Args) != 2 &#123; panic(\"ERROR: Expecting one argument\") &#125; tracer, closer := tracing.Init(\"hello-world\") defer closer.Close() opentracing.SetGlobalTracer(tracer) helloTo := os.Args[1] span := tracer.StartSpan(\"say-hello\") span.SetTag(\"hello-to\", helloTo) defer span.Finish() ctx := opentracing.ContextWithSpan(context.Background(), span) helloStr := formatString(ctx, helloTo) printHello(ctx, helloStr)&#125;func formatString(ctx context.Context, helloTo string) string &#123; span, _ := opentracing.StartSpanFromContext(ctx, \"formatString\") defer span.Finish() v := url.Values&#123;&#125; v.Set(\"helloTo\", helloTo) url := \"http://localhost:8081/format?\" + v.Encode() req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; panic(err.Error()) &#125; ext.SpanKindRPCClient.Set(span) ext.HTTPUrl.Set(span, url) ext.HTTPMethod.Set(span, \"GET\") span.Tracer().Inject( span.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header), ) resp, err := xhttp.Do(req) if err != nil &#123; panic(err.Error()) &#125; helloStr := string(resp) span.LogFields( log.String(\"event\", \"string-format\"), log.String(\"value\", helloStr), ) return helloStr&#125;func printHello(ctx context.Context, helloStr string) &#123; span, _ := opentracing.StartSpanFromContext(ctx, \"printHello\") defer span.Finish() v := url.Values&#123;&#125; v.Set(\"helloStr\", helloStr) url := \"http://localhost:8082/publish?\" + v.Encode() req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; panic(err.Error()) &#125; ext.SpanKindRPCClient.Set(span) ext.HTTPUrl.Set(span, url) ext.HTTPMethod.Set(span, \"GET\") span.Tracer().Inject(span.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header)) if _, err := xhttp.Do(req); err != nil &#123; panic(err.Error()) &#125;&#125; formatter 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net&#x2F;http&quot; opentracing &quot;github.com&#x2F;opentracing&#x2F;opentracing-go&quot; &quot;github.com&#x2F;opentracing&#x2F;opentracing-go&#x2F;ext&quot; otlog &quot;github.com&#x2F;opentracing&#x2F;opentracing-go&#x2F;log&quot; &quot;github.com&#x2F;yurishkuro&#x2F;opentracing-tutorial&#x2F;go&#x2F;lib&#x2F;tracing&quot;)func main() &#123; tracer, closer :&#x3D; tracing.Init(&quot;formatter&quot;) defer closer.Close() http.HandleFunc(&quot;&#x2F;format&quot;, func(w http.ResponseWriter, r *http.Request) &#123; spanCtx, _ :&#x3D; tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header)) span :&#x3D; tracer.StartSpan(&quot;format&quot;, ext.RPCServerOption(spanCtx)) defer span.Finish() helloTo :&#x3D; r.FormValue(&quot;helloTo&quot;) helloStr :&#x3D; fmt.Sprintf(&quot;Hello, %s!&quot;, helloTo) span.LogFields( otlog.String(&quot;event&quot;, &quot;string-format&quot;), otlog.String(&quot;value&quot;, helloStr), ) w.Write([]byte(helloStr)) &#125;) log.Fatal(http.ListenAndServe(&quot;:8081&quot;, nil))&#125; publisher 1234567891011121314151617181920212223242526package mainimport ( &quot;log&quot; &quot;net&#x2F;http&quot; opentracing &quot;github.com&#x2F;opentracing&#x2F;opentracing-go&quot; &quot;github.com&#x2F;opentracing&#x2F;opentracing-go&#x2F;ext&quot; &quot;github.com&#x2F;yurishkuro&#x2F;opentracing-tutorial&#x2F;go&#x2F;lib&#x2F;tracing&quot;)func main() &#123; tracer, closer :&#x3D; tracing.Init(&quot;publisher&quot;) defer closer.Close() http.HandleFunc(&quot;&#x2F;publish&quot;, func(w http.ResponseWriter, r *http.Request) &#123; spanCtx, _ :&#x3D; tracer.Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(r.Header)) span :&#x3D; tracer.StartSpan(&quot;publish&quot;, ext.RPCServerOption(spanCtx)) defer span.Finish() helloStr :&#x3D; r.FormValue(&quot;helloStr&quot;) println(helloStr) &#125;) log.Fatal(http.ListenAndServe(&quot;:8082&quot;, nil))&#125; 参考资料 jaeger github ：github.com/uber/jaeger-client-go opentracing ：github.com/opentracing/opentracing-go tutorial： github.com/yurishkuro/opentracing-tutorial","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"emacs-studynode","slug":"emacs-studynode","date":"2019-10-29T02:03:35.000Z","updated":"2019-11-19T06:25:15.085Z","comments":true,"path":"2019/10/29/emacs-studynode/","link":"","permalink":"https://dreamerjonson.com/2019/10/29/emacs-studynode/","excerpt":"","text":"QUIT EMACS To quit Emacs, press: . (Be sure to use , not .) 在item2中设置meta键 开启 emacs 开启-不显示splash screen emacs -Q 开启特定的文件 emacs XXX emacs -Q XXX Stopping Emacs C-x C-c save files press y to save and n to not save.To save all of the files at once and then quit, press ! (exclamation mark). To quit immediately, without saving anything more, press q . To save the current file only, but quit without saving anything else, press . (period). c-p previous-line c-n next-line c-f 向后移动一个字符 M-f 向后移动一个word C-x C-b display a list of all your buffers C-x h C-w .清空buffer ( C-x h selects the entire buffer; C-w erases the selection.) C-g 退出指令 C-x k kills (deletes) the current buffer C-x b Switch to buffer C-x 0 (the number zero). This tells Emacs to kill (get rid of) the selected window C-v to scroll down one screenful M-v to scroll up one screenful M-x 输入命令 C-d 消除右边得一个字符 C-o open the new line C-k 删除后面的所有字符 Here are the details for using C-o . If you are at the beginning of a line, C-o creates a new, empty line above the current line. If you are at the end of a line, C-o creates a new, empty line below the current line. If you are within a line, C-o breaks it into two separate lines To insert one of these characters into your text, first press C-q . This tells Emacs that the next character is to be taken literally. (Think of the q as meaning “quote”; that is, to take the next key you type literally.) Thus, to insert a character, type C-q C-c . To insert a , type C-q C-q . To insert a tab, use C-q TAB C-x BS delete from the current position, backwards, to the beginning of the sentence.(从当前点删到尾) 撤销 &amp; 反撤销 C-x u 撤销 C-- 撤销 C-/ 撤销 在撤销的时候如果撤销多了需要进行反撤销 具体是用C-f等打断当前撤销操作，接着进行的撤销动作就是反撤销。 C-x z 重复之前的操作 重复多次可以只按zzzz Windows C-x 0 delete the select window C-x 1 delete all windows excpet select window C-x 2 Split select window verticall C-x 3 Split select window horizontally C-x o move cursor to the next (other) Windows C-x } Make selected windows wider C-x { Make selected windows narrower C-x ^ Make selected windows narrower buffer C-x b When you press C-x b , Emacs will wait for you to enter the name of the buffer with which you want to work. If this buffer already exists, Emacs will just move it into the window. Otherwise, Emacs will create a brand new empty buffer in the window using the name you specified. Thus, C-x b is the command to use when you want to create a new buffer. C-x 4 b tells Emacs to display whichever buffer you specify in a different window C-x 4 C-o command. This is similar to the C-x 4 b command, except that the selected window does not change C-x k kill a buffer file C-x C-f 打开一个文件的buffer C-x C-v replace buffer contents with specified file C-x C-s Save a buffer to file C-x C-w Save a buffer to special file C-x i insert contents of a file into buffer 把文件插入到此buffer中 C-x 4 C-f read a file into next window C-x 4 f same as C-x 4 C-f C-x 4 r same as C-x 4 C-f read-only cursor C-f 后一个字符 C-b 前一个字符 M-f 后一个word M-b 前一个word C-p 前一line C-n 后一line M-a M-e sentence ？ M-{ M-} paragraph 空格分隔段落 C-a C-e 当前行 重复一个命令多次 M-number C-p 重复一个命令多次 C-u number 重复一个命令多次 C-u repeat the command 4 times C-u C-u repeat the command 16 times C-u C-u C-u repeat the command 64 times scroll C-v scroll down M-v scroll up M-C-v scroll down in next windows M- &lt; jump to start of the buffer M- &gt; jump to end of the buffer C-l 将当前行放置在屏幕的中间。 M-g g 跳到指定行 M-x line-number-mode toggle miinbuf下方显示行 C-SPC 标记 M-= 统计字符多少 C-x C-x curson到mark的位置。 再次按C-x C-x 交换位置 M-@ 设置当前curson的单词末尾 M-number M-@ 设置当前curson的number个word后 M-h Put region arounnd paragraph C-x h Put region arounnd entire buffer operating the region C-w kill all the characters C-x C-l Convert the characters to lower C-x C-u Convert the characters to lower M-= count M-| Run the shell command use the characters as data example:M -| sort -u delete delete不会保存 ESC number M-: 删除空格 12345678To continue, the M-\\ (&lt;Meta-Backslash&gt;) command erases any space or tabcharacters that happen to be on either side of point. This command provides a quickway to clean up a section of whitespace. For example, say that you have typed thefollowing text and the cursor is under one of the spaces between tea and ch :Everything we tea ch you is true.If you press M-\\ , Emacs will erase all the surrounding spaces. The line nowlooks like:Everything we teach you is true. M-SPC： 删除空格 保留一个空格 123456The M-SPC (&lt;Meta-Space&gt;) command is similar, except that it leaves exactlyone space. Here is an example. You have just typed the line:The sentence above is only partially correct.You would like to erase the extra spaces. Move the cursor to one of the spacesbetween is and only and press M-SPC . The line is changed to the following:The sentence above is only partially correct. C-x C-o: 删除紧临的空行 1The C-x C-o command performs the analogous operation for blank lines M-^ 合并到一行，注意curson要放在第二行 123456789101112Finally, the M-^ command joins two lines into one long one. This commandjoins the current line to the one immediately above it, while leaving a single spacebetween the two groups of text. Any extra spaces (at the end of the first line or atthe beginning of the second line) are removed. For example, say that you have thefollowing lines of text:This is the first sentence.This is the second sentence.You want to join these two lines. Move the cursor to the second line and press M-^ .You will now have one long line:This is the first sentence. This is the second sentence.The cursor will be at the place where the lines were joined, in this case, at the spacebetween the two sentences. Kill Text 会保留删除的文本 C-k 删除后面的文本 M-d kill word M-BS kill word Forward C-w kill the region M-z char To erase an entire line: if you are at the beginning of the line, press C -k C-k . If you are not at the beginning of the line, press C-a C-k C-k . COPY C-y yank most recently killed text C-u C-y same as . curson at the beging M-y replace the yank test with previous killed Text M-w Copy region to kill ring,without erasing M-C-W Apend next kill to newest kill ring entry correcting M - BS kill the previous word C-x BS kill backwards to beginning of sentence M–M-l change previous word to lower M–M-u change previous word to upper M–M-c change previous word to lower,initial cap M-l change follow word to lower M-u change follow word to upper M-c change follow word to lower,initial Cap ESC 10 M-- M-c chage many times C-t transport two adjaent charactors M-t transport two adjaent words C-x C-t transport two adjaen lin search C-s foword: Incremental search C-s RET foword: no-Incremental search M-s w Foward Non-increment word search M-C-s foword: Incremental regexp search M-C-s RET foword: No-Incremental regexp search The basic type of Emacs search is called an INCREMENTAL SEARCH. That means Emacs starts searching as soon as you type a single character. With each character you type, Emacs refines its search. C-r foword: Incremental search C-r RET foword: no-Incremental search M-r w Foward Non-increment word search M-C-r foword: Incremental regexp search M-C-r foword: No-Incremental regexp search when you searchig: C-s if you do again . search next C-r same as C-w Copy the word afer point to search string C-y Copy kill ring afer point to search string M-y replace next kill ring replace M - % search and replace M-C- % search and replace regexp M-x replace-string M-x replace-regexp • SPC () to make a replacement and continue. • BS () to skip a replacement and continue. • ! (exclamation mark) to make all the rest of the replacements automatically with no more questions. • RET () to quit immediately M-x replace-string makes all the replacements automatically without asking you any questions. M-x replace-regexp makes all the replacements automatically, while allowing you to use a regular expression for the search pattern. Recursive Editing C-r when you searing and want interrupt to do other things M-C-c This will stop recursive editing and return you to the search and replace operation, exactly where you left off.","categories":[{"name":"mac","slug":"mac","permalink":"https://dreamerjonson.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://dreamerjonson.com/tags/mac/"}]},{"title":"mac item2-skill","slug":"item2-skill","date":"2019-10-28T09:55:13.000Z","updated":"2019-10-28T10:26:50.664Z","comments":true,"path":"2019/10/28/item2-skill/","link":"","permalink":"https://dreamerjonson.com/2019/10/28/item2-skill/","excerpt":"","text":"item2技巧 清屏1 command + r 清屏2 ctrl + l 删除到文本末尾 ctrl + k 搜索命令历史 ctrl + r 清除当前行 ctrl + u 可定制化Hotkey, 一键召出iTerm2 (不再需要⌘+Tab 或者 通过spotlight切换) 快捷的组合键 ⌘+Shift+E 召唤时间线 ⌘+Option+b 时光机 ⌘+T 新Tab ⌘+D 水平分屏 ⌘+← 切换Tab / ⌘+shift+← 切换分屏 关闭panel：⌘ + w 最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次还原 按下 Command + T 可以新建一个 Tab，每个标签页的后面都会标记一个序号，通过 Command + 序号 就可以在多个页面之间切换了，或者用 Command + [ 和 Command + ] 来切换到左侧或者右侧的标签页。 同一个 Tab 内，还可以切分出多个 Pane，有两种切分方式： Command + D：水平切分，切分出一左一右两个 Pane Command + Shift + D：垂直切分，切分出一上一下两个 Pane 通过 Command + Ctrl + 方向键 可以调整每个 Pane 的大小，通过 Command + Option + 方向键 可以切换 Pane。","categories":[{"name":"mac","slug":"mac","permalink":"https://dreamerjonson.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://dreamerjonson.com/tags/mac/"}]},{"title":"golang[99]-mapReduce","slug":"golang-99-mapReduce","date":"2019-10-28T04:09:25.000Z","updated":"2019-10-28T06:19:26.254Z","comments":true,"path":"2019/10/28/golang-99-mapReduce/","link":"","permalink":"https://dreamerjonson.com/2019/10/28/golang-99-mapReduce/","excerpt":"","text":"mapReduce简介 MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。概念“Map（映射）”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。 当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组。 上面的说法来自维基百科，mapReduce作为一个成熟、可靠、简单、高效的分布式架构，可以在并行计算上提供超强悍的性能。 抽象表示 map (k1,v1) → list(k2,v2) reduce (k2,list(v2)) → list(v2) 示意图 如上图所示是一个mapReduce模型的示意图，Input files 代表原始数据， Output files 代表最后输出的数据。 worker 既可以执行map,也可以执行reduce,具体依赖master的分配。 在输入输出之间，经历了两个过程。一个是map 一个是reduce。 map的过程是将一个复杂的问题 处理后转换为许多个小文件。例如map是对原始数据按照某种规律进行分类。 a类一个文件，b类一个文件… reduce是对一个分类的问题进行计算的过程。 master是主调度器，例如将map生成的a类文件交由reduce worker去处理。而reduce函数处理的可能就是对a类文件中所有数据进行汇总。 example 伪代码 123456789101112map(String key, String value):&#x2F;&#x2F; key: document name&#x2F;&#x2F; value: document contentsfor each word w in value:EmitIntermediate(w, &quot;1&quot;);reduce(String key, Iterator values):&#x2F;&#x2F; key: a word&#x2F;&#x2F; values: a list of countsint result &#x3D; 0;for each v in values:result +&#x3D; ParseInt(v);Emit(AsString(result)); golang简单实现 master 1234567891011121314151617181920// Master holds all the state that the master needs to keep track of.type Master struct &#123; sync.Mutex address string doneChannel chan bool // protected by the mutex newCond *sync.Cond // signals when Register() adds to workers[] workers []string // each worker's UNIX-domain socket name -- its RPC address // Per-task information jobName string // Name of currently executing job files []string // Input files nReduce int // Number of reduce partitions shutdown chan struct&#123;&#125; l net.Listener stats []int&#125; master的 rpc方法 注册worker 12345678910111213// Register is an RPC method that is called by workers after they have started// up to report that they are ready to receive tasks.func (mr *Master) Register(args *RegisterArgs, _ *struct&#123;&#125;) error &#123; mr.Lock() defer mr.Unlock() debug(\"Register: worker %s\\n\", args.Worker) mr.workers = append(mr.workers, args.Worker) // tell forwardRegistrations() that there's a new workers[] entry. mr.newCond.Broadcast() return nil&#125; master schedule 调度。 1、维护是否有任务 以及 空闲worker 2、调用失败会分配给其他worker 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// schedule() starts and waits for all tasks in the given phase (Map// or Reduce). the mapFiles argument holds the names of the files that// are the inputs to the map phase, one per map task. nReduce is the// number of reduce tasks. the registerChan argument yields a stream// of registered workers; each item is the worker's RPC address,// suitable for passing to call(). registerChan will yield all// existing registered workers (if any) and new ones as they register.//func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) &#123; var ntasks int var n_other int // number of inputs (for reduce) or outputs (for map) switch phase &#123; case mapPhase: ntasks = len(mapFiles) n_other = nReduce case reducePhase: ntasks = nReduce n_other = len(mapFiles) &#125; fmt.Printf(\"Schedule: %v %v tasks (%d I/Os)\\n\", ntasks, phase, n_other) // All ntasks tasks have to be scheduled on workers, and only once all of // them have been completed successfully should the function return. // Remember that workers may fail, and that any given worker may finish // multiple tasks. // schedule will wait until all worker has done their jobs var wg sync.WaitGroup // RPC call parameter var task DoTaskArgs task.JobName = jobName task.NumOtherPhase = n_other task.Phase = phase // task id will get from this channel var taskChan = make(chan int) go func() &#123; for i := 0; i &lt; ntasks; i++ &#123; wg.Add(1) taskChan &lt;- i &#125; // wait all workers have done their job, then close taskChan wg.Wait() close(taskChan) &#125;() // assign all task to worker for i := range taskChan &#123; // get a worker from register channel worker := &lt;-registerChan task.TaskNumber = i if phase == mapPhase &#123; task.File = mapFiles[i] &#125; // Note: must use parameter go func(worker string, task DoTaskArgs) &#123; if call(worker, \"Worker.DoTask\", &amp;task, nil) &#123; // only successful call will call wg.Done() wg.Done() // put idle worker back to register channel registerChan &lt;- worker; &#125; else &#123; log.Printf(\"Schedule: assign %s task %v to %s failed\", phase, task.TaskNumber, worker) // put failed task back to task channel taskChan &lt;- task.TaskNumber &#125; &#125;(worker, task) &#125; fmt.Printf(\"Schedule: %v phase done\\n\", phase)&#125; worker worker是一个rpc服务，DoTask is called by the master when a new task is being scheduled on this worker. worker可以是map worker 也可以是reduce worker 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;&#x2F; Worker holds the state for a server waiting for DoTask or Shutdown RPCstype Worker struct &#123; sync.Mutex name string Map func(string, string) []KeyValue Reduce func(string, []string) string nRPC int &#x2F;&#x2F; quit after this many RPCs; protected by mutex nTasks int &#x2F;&#x2F; total tasks executed; protected by mutex concurrent int &#x2F;&#x2F; number of parallel DoTasks in this worker; mutex l net.Listener&#125;&#x2F;&#x2F; DoTask is called by the master when a new task is being scheduled on this&#x2F;&#x2F; worker.func (wk *Worker) DoTask(arg *DoTaskArgs, _ *struct&#123;&#125;) error &#123; fmt.Printf(&quot;%s: given %v task #%d on file %s (nios: %d)\\n&quot;, wk.name, arg.Phase, arg.TaskNumber, arg.File, arg.NumOtherPhase) wk.Lock() wk.nTasks +&#x3D; 1 wk.concurrent +&#x3D; 1 nc :&#x3D; wk.concurrent wk.Unlock() if nc &gt; 1 &#123; &#x2F;&#x2F; schedule() should never issue more than one RPC at a &#x2F;&#x2F; time to a given worker. log.Fatal(&quot;Worker.DoTask: more than one DoTask sent concurrently to a single worker\\n&quot;) &#125; switch arg.Phase &#123; case mapPhase: doMap(arg.JobName, arg.TaskNumber, arg.File, arg.NumOtherPhase, wk.Map) case reducePhase: doReduce(arg.JobName, arg.TaskNumber, mergeName(arg.JobName, arg.TaskNumber), arg.NumOtherPhase, wk.Reduce) &#125; wk.Lock() wk.concurrent -&#x3D; 1 wk.Unlock() fmt.Printf(&quot;%s: %v task #%d done\\n&quot;, wk.name, arg.Phase, arg.TaskNumber) return nil&#125; 简单的mapreduce实现 12345678910// reduceName constructs the name of the intermediate file which map task// &lt;mapTask&gt; produces for reduce task &lt;reduceTask&gt;.func reduceName(jobName string, mapTask int, reduceTask int) string &#123; return \"mrtmp.\" + jobName + \"-\" + strconv.Itoa(mapTask) + \"-\" + strconv.Itoa(reduceTask)&#125;// mergeName constructs the name of the output file of reduce task &lt;reduceTask&gt;func mergeName(jobName string, reduceTask int) string &#123; return \"mrtmp.\" + jobName + \"-res-\" + strconv.Itoa(reduceTask)&#125; map 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// doMap manages one map task: it reads one of the input files// (inFile), calls the user-defined map function (mapF) for that file's// contents, and partitions the output into nReduce intermediate files.func doMap( jobName string, // the name of the MapReduce job mapTaskNumber int, // which map task this is inFile string, nReduce int, // the number of reduce task that will be run (\"R\" in the paper) mapF func(file string, contents string) []KeyValue,) &#123; // // You will need to write this function. // // The intermediate output of a map task is stored as multiple // files, one per destination reduce task. The file name includes // both the map task number and the reduce task number. Use the // filename generated by reduceName(jobName, mapTaskNumber, r) as // the intermediate file for reduce task r. Call ihash() (see below) // on each key, mod nReduce, to pick r for a key/value pair. // // mapF() is the map function provided by the application. The first // argument should be the input file name, though the map function // typically ignores it. The second argument should be the entire // input file contents. mapF() returns a slice containing the // key/value pairs for reduce; see common.go for the definition of // KeyValue. // // Look at Go's ioutil and os packages for functions to read // and write files. // // Coming up with a scheme for how to format the key/value pairs on // disk can be tricky, especially when taking into account that both // keys and values could contain newlines, quotes, and any other // character you can think of. // // One format often used for serializing data to a byte stream that the // other end can correctly reconstruct is JSON. You are not required to // use JSON, but as the output of the reduce tasks *must* be JSON, // familiarizing yourself with it here may prove useful. You can write // out a data structure as a JSON string to a file using the commented // code below. The corresponding decoding functions can be found in // common_reduce.go. // // enc := json.NewEncoder(file) // for _, kv := ... &#123; // err := enc.Encode(&amp;kv) // // Remember to close the file after you have written all the values! // contents, err := ioutil.ReadFile(inFile) if err != nil &#123; log.Printf(\"read file %s failed\", inFile) return &#125; kvs := mapF(inFile, string(contents)) var imm = make([]*os.File, nReduce) var enc = make([]*json.Encoder, nReduce) for i := 0; i &lt; nReduce; i++ &#123; if f, err := os.Create(reduceName(jobName, mapTaskNumber, i)); err != nil &#123; log.Printf(\"create file %s failed\", reduceName(jobName, mapTaskNumber, i)) &#125; else &#123; imm[i] = f enc[i] = json.NewEncoder(f) &#125; &#125; for _, kv := range kvs &#123; r := ihash(kv.Key) % nReduce if enc[r] != nil &#123; if err := enc[r].Encode(&amp;kv); err != nil &#123; log.Printf(\"wirte %v to file %s failed\", kv, reduceName(jobName, mapTaskNumber, r)) &#125; &#125; &#125; // close immediate files for i := 0; i &lt; nReduce; i++ &#123; if imm[i] != nil &#123; imm[i].Close() &#125; &#125;&#125;func ihash(s string) int &#123; h := fnv.New32a() h.Write([]byte(s)) return int(h.Sum32() &amp; 0x7fffffff)&#125; reduce 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// doReduce manages one reduce task: it reads the intermediate// key/value pairs (produced by the map phase) for this task, sorts the// intermediate key/value pairs by key, calls the user-defined reduce function// (reduceF) for each key, and writes the output to disk.func doReduce( jobName string, // the name of the whole MapReduce job reduceTaskNumber int, // which reduce task this is outFile string, // write the output here nMap int, // the number of map tasks that were run (\"M\" in the paper) reduceF func(key string, values []string) string,) &#123; // // You will need to write this function. // // You'll need to read one intermediate file from each map task; // reduceName(jobName, m, reduceTaskNumber) yields the file // name from map task m. // // Your doMap() encoded the key/value pairs in the intermediate // files, so you will need to decode them. If you used JSON, you can // read and decode by creating a decoder and repeatedly calling // .Decode(&amp;kv) on it until it returns an error. // // You may find the first example in the golang sort package // documentation useful. // // reduceF() is the application's reduce function. You should // call it once per distinct key, with a slice of all the values // for that key. reduceF() returns the reduced value for that key. // // You should write the reduce output as JSON encoded KeyValue // objects to the file named outFile. We require you to use JSON // because that is what the merger than combines the output // from all the reduce tasks expects. There is nothing special about // JSON -- it is just the marshalling format we chose to use. Your // output code will look something like this: // // enc := json.NewEncoder(file) // for key := ... &#123; // enc.Encode(KeyValue&#123;key, reduceF(...)&#125;) // &#125; // file.Close() // var keys []string // store all keys in this partition var kvs = make(map[string][]string) // store all key-value pairs from nMap imm files // read nMap imm files from map workers for i := 0; i &lt; nMap; i++ &#123; fn := reduceName(jobName, i, reduceTaskNumber) fmt.Println(\"reduce fn\",fn) imm, err := os.Open(fn) if err != nil &#123; log.Printf(\"open immediate file %s failed\", fn) continue &#125; var kv KeyValue dec := json.NewDecoder(imm) err = dec.Decode(&amp;kv) for err == nil &#123; // is this key seen? if _, ok := kvs[kv.Key]; !ok &#123; keys = append(keys, kv.Key) &#125; kvs[kv.Key] = append(kvs[kv.Key], kv.Value) // decode repeatedly until an error err = dec.Decode(&amp;kv) &#125; &#125; // Original MapReduce Paper 4.2 Ordering Guarantees // Keys in one partition are processed in increasing key order sort.Strings(keys) out, err := os.Create(outFile) if err != nil &#123; log.Printf(\"create output file %s failed\", outFile) return &#125; enc := json.NewEncoder(out) for _, key := range keys &#123; if err = enc.Encode(KeyValue&#123;key, reduceF(key, kvs[key])&#125;); err != nil &#123; log.Printf(\"write [key: %s] to file %s failed\", key, outFile) &#125; &#125; out.Close()&#125; 完整例子 https://github.com/dreamerjackson/theWayToGolang 原始论文 参考资料 https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf https://pdos.csail.mit.edu/6.824/labs/lab-1.html","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[98]-拉取gitlab中的merge代码","slug":"golang-98-拉取gitlab中的merge代码","date":"2019-10-25T07:15:06.000Z","updated":"2019-10-28T04:07:56.913Z","comments":true,"path":"2019/10/25/golang-98-拉取gitlab中的merge代码/","link":"","permalink":"https://dreamerjonson.com/2019/10/25/golang-98-%E6%8B%89%E5%8F%96gitlab%E4%B8%AD%E7%9A%84merge%E4%BB%A3%E7%A0%81/","excerpt":"","text":"有时候，需要拉取gitlab上的merge代码。而这些merge常常是私人分支合并过来的，不能直接拉取。那么如何在本地pull这些分支的代码呢？ 例如PR是/merge_requests/6 那么git pull remote refs/merge-requests/6/head 即可。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[97]-http-client-keeplive","slug":"golang-97-http-client-keeplive","date":"2019-10-20T06:04:27.000Z","updated":"2019-10-20T06:08:45.937Z","comments":true,"path":"2019/10/20/golang-97-http-client-keeplive/","link":"","permalink":"https://dreamerjonson.com/2019/10/20/golang-97-http-client-keeplive/","excerpt":"","text":"Go HTTP Client 持久连接 调用 Go 的 HTTP Client 的 Get\\Post 之类的方法时，默认是开启 HTTP keepalive 的，不过直接使用还是会遇到一些情况导致持久连接失效。首先，Client 构造好 HTTP 请求后，利用 Transport 来发送请求并等待结果，默认使用 DefaultTransport 来实现，大多数情况下，自定义 Client 时，配置一下自带的 Transport 即可。 transport 主要围绕着 persistConn 来实现，通过当前请求的 proxy, scheme, addr 作为 Key，对已经建立的连接进行缓存，新的请求来时，先从缓存中取一个连接，如果没有，再新发起一个连接。按照 Go 的基本法，毫无疑问会有两个 goroutine 来分别处理连接上的读和写，然后各种 channel 就开始飞来飞去，于是便让人深思这真的会比基于事件回调的实现简单吗。 好了，这里还是简单写点代码浅显的试验一下可能会导致持久连接失效的一些情况。 准备工作 在发送请求建立 TCP 连接时输出一些提示消息，这样便可以确定是否发起了新连接。自定义一个 Transport 的 Dial 方法就好了。这里输出连接的 LocalAddr，代码如下： 123456789101112131415func PrintLocalDial(network, addr string) (net.Conn, error) &#123; dial := net.Dialer&#123; Timeout: 30 * time.Second, KeepAlive: 30 * time.Second, &#125; conn, err := dial.Dial(network, addr) if err != nil &#123; return conn, err &#125; fmt.Println(\"connect done, use\", conn.LocalAddr().String()) return conn, err&#125; 本地起了个在 8888 端口监听的 Web Server。好了，现在使用的 http.Client 如下： 12345client :&#x3D; &amp;http.Client&#123; Transport: &amp;http.Transport&#123; Dial: PrintLocalDial, &#125;,&#125; 发起请求 一个三观正确的，具有普遍意义的请求步骤如下所示： 12345678910111213func doGet(client *http.Client, url string, id int) &#123; resp, err :&#x3D; client.Get(url) if err !&#x3D; nil &#123; fmt.Println(err) return &#125; buf, err :&#x3D; ioutil.ReadAll(resp.Body) fmt.Printf(&quot;%d: %s -- %v\\n&quot;, id, string(buf), err) if err :&#x3D; resp.Body.Close(); err !&#x3D; nil &#123; fmt.Println(err) &#125;&#125; 调用 Get 进入 RoundTrip，首先会找到个 persistConn (从缓存中找个已经存在的或者新建一个)，再调用它的 roundTrip，这时会把这个请求发送到 writeLoop，然后等待响应的到来，当 readLoop 中读到响应数据时，便会把响应 Response 发到 roundTrip，自此，Get 方法返回，不过事情还没有结束，响应的 Body 还没有读取，readLoop 会一直阻塞等待读取数据，也就是当前这个 persistConn 一直被占用着，当读取完 resp.Body，readLoop 就会把 persistConn 放回连接缓存中，以便下个请求继续使用。 持续发几个请求试试： 1234567const URL &#x3D; &quot;http:&#x2F;&#x2F;localhost:8888&#x2F;&quot;for &#123; go doGet(client, URL, 1) go doGet(client, URL, 2) time.Sleep(2 * time.Second)&#125; 每次同时发送两个请求，并等待请求完成，输出结果如下： 12345678$ go run client.goconnect done, use [::1]:57571connect done, use [::1]:575702: Hello, world -- &lt;nil&gt;1: Hello, world -- &lt;nil&gt;2: Hello, world -- &lt;nil&gt;1: Hello, world -- &lt;nil&gt;... 可见此时建立了两条 TCP 持久连接，后面的请求都复用了一开始建立好的连接。如果再加一个请求呢，每次同时发送三个请求，输出结果如下： 12345678910111213141516$ go run client.goconnect done, use [::1]:57582connect done, use [::1]:57583connect done, use [::1]:575842: Hello, world -- &lt;nil&gt;1: Hello, world -- &lt;nil&gt;3: Hello, world -- &lt;nil&gt;connect done, use [::1]:575852: Hello, world -- &lt;nil&gt;1: Hello, world -- &lt;nil&gt;3: Hello, world -- &lt;nil&gt;connect done, use [::1]:575861: Hello, world -- &lt;nil&gt;2: Hello, world -- &lt;nil&gt;3: Hello, world -- &lt;nil&gt;... 可见每次都会有一个请求是新建了个 TCP 连接的，也就是说默认只保持两条持久连接，这是因为这里自定义的的 http.Transport 没有设置 MaxIdleConnsPerHost，于是便采用了默认的 DefaultMaxIdleConnsPerHost，这个值是 2，这是 RFC2616 建议的单个客户端发起的持久连接数，不过在大部分情况下，这个值有点过于保守了。如果把 MaxIdleConnsPerHost 设置为 3，结果便和第一种情况一样。 三观不正的请求 这里来一个三观不正的请求： 1234567891011func doGet(client *http.Client, url string, id int) &#123; resp, err :&#x3D; client.Get(url) if err !&#x3D; nil &#123; fmt.Println(err) return &#125; if err :&#x3D; resp.Body.Close(); err !&#x3D; nil &#123; fmt.Println(err) &#125; fmt.Printf(&quot;%d: done\\n&quot;, id)&#125; 这里并不读取 resp.Body，因为读来也没用，但是也没法用 HEAD 请求(当然，这只是示例)。每次同时发送两个请求，结果如下： 123456789101112$ go run client.goconnect done, use [::1]:57974connect done, use [::1]:579732: done1: doneconnect done, use [::1]:57975connect done, use [::1]:579762: done1: doneconnect done, use [::1]:57978connect done, use [::1]:57977... 额，每次都是新建的 TCP 连接，看来持久连接没用上。考虑到 TCP 接收到的数据，应用层并没有主动去读取，如果再次复用这个连接发送数据，那么上一次的数据要怎么处理？要么 Go 在库里默默的给读了，要么直接断开连接新建一条。在 Go 1.0 中就是在库里默默的读，想象一下正在 Get 的是几个 G 的东西，调用 Close 的时候… 所以最好的方法还是断开这个没有读取 Body 就直接 Close 的连接。 这里实现上利用 bodyEOFSignal 这个数据类型来包装 readLoop 生成的响应 Body，并设置回调函数 earlyCloseFn，如果 Body 并没有读取完便 Close，这个函数将执行并通知 readLoop，然后 readLoop 关闭连接并退出。所以如果想要使用持久连接，还得处理掉 Body，这就看应用的取舍了，尽量使用 HEAD 代替，也可以读取来丢弃掉。 n, err := io.Copy(ioutil.Discard, resp.Body) 后话 当然，可以设置 http.Transport 的 DisableKeepAlives 来禁用掉持久连接。前面废话说的有点多，总结一下无非就下面几条： Web Server 得支持持久连接 如果有需要，加大 DefaultMaxIdleConnsPerHost 或者设置 MaxIdleConnsPerHost 读完 Response Body 再 Close 参考资料 https://serholiu.com/go-http-client-keepalive https://www.cnblogs.com/gaorong/p/10887021.html","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[96]-http.RoundTripper","slug":"golang-96-http-RoundTripper","date":"2019-10-19T07:54:47.000Z","updated":"2019-10-19T07:59:51.052Z","comments":true,"path":"2019/10/19/golang-96-http-RoundTripper/","link":"","permalink":"https://dreamerjonson.com/2019/10/19/golang-96-http-RoundTripper/","excerpt":"","text":"I have written quite a bit on HTTP. And this blog post is just yet another one that talks about another interesting concept in the way Go deals with HTTP and how it makes HTTP related stuffs even much more fun. In this post, I would be covering what Round tripping is, it’s applicable usecases and a tiny demo that shows it’s application. This concept I want to talk about is called Round tripping or as the godoc describes it the ability to execute a single HTTP transaction, obtaining the Response for a given Request. Basically, what this means is being able to hook into what happens between making an HTTP request and receiving a response. In lay man terms, it’s like middleware but for an http.Client. I say this since round tripping occurs before the request is actually sent. Although, it is possible to do anything within the RoundTrip method (as in like middleware for your HTTP handlers), it is recommended you don’t inspect the response, return an error (nil or non nil) and shouldn’t do stuffs like user auth (or cookies handling)… Since http.RoundTripper is an interface. All you have to do to get this functionality is implement RoundTrip 123456type SomeClient struct &#123;&#125;func (s *SomeClient) RoundTrip(r *http.Request)(*Response, error) &#123; &#x2F;&#x2F;Something comes here...Maybe&#125; And this is just keeping in line with other one method interfaces in the stdlib… Small and concise. Usecases Caching http responses. For example, your web app has to connect to Github’s API in other to fetch stuffs (with the trending repos one of it). In real life, this changes quite often but let’s assume they rebuild that trending board once every 30 minutes and your app has tons of users. You obviously don’t want to have to hit the api every time to request for the trending leaderboard. since it is always the same in a 30 minutes window and also considering the fact that API calls are rate limited and due to the high usage of your app, you almost always hit / cross the limit. A solution to this is to make use of http.RoundTripper. You could configure your http.Client with a RoundTripper that does the following : Does the cache store have this item ? Don’t make the HTTP request. Return a new response by reading the data from the cache into the body of the response. The cache store doesn’t have this item (probably because the cache is invalidated every 31 minutes) Make the HTTP request to the api. Cache the data received from the api. You don’t have to make use of a RoundTripper for this as (inside a handler) you can check the cache for the existence of an item before you make the HTTP request at all. But with a RoundTripper implementation, you are probably distributing responsibilities properly[0] Adding appropriate (authorization) headers to the request as need be… An example that readily comes to mind is google/go-github, a Golang client for Github’s api. Some part of Github’s api require the request be authenticated, some don’t. By default, the library doesn’t handle authentication, it uses a default HTTP client, if you need to be able to access authenticated sections of the api, you bring your own HTTP client along, for example with oauth2 protected endpoints… So how does this concern Round tripping, there is this ghinstallation that allows you authenticate Github apps with go-github. If you look at it’s codebase, all it does is provide an http.Client that implements http.RoundTripper. After which it set the appropriate headers (and values) in the RoundTrip method. Rate limiting. This is quite similar to the above, maybe you have a bucket where you keep the number of connections you have made recently. You check if you are still in acceptable standing with the API and decide if you should make the request, pull back from making the request or scheduling it to run in future. Whatever have you… Maybe not. Real world usage We would be looking at caching HTTP responses with an implementation of http.RoundTripper. We would be creating a server that responds to just one route, then a client package that connects to that server. THe client would make use of it’s own implementation of http.Client so we can be able to provide our own RoundTripper, since we are trying to cache responses. So here is what it is going to look like, The client makes a request to the server. If the response for that url exists in the cache store ? Don’t make the call to the server. Fetch the item from the store. Write it into the response and return it straight off. If the response for that url does not exist in the cache store Make the request to the server. Write the body of the response into the cache store. Return the response. We would be building the server first since it’s implementation is quite simple 1234567891011121314151617181920import ( &quot;fmt&quot; &quot;net&#x2F;http&quot;)func main() &#123; &#x2F;&#x2F; server&#x2F;main.go mux :&#x3D; http.NewServeMux() mux.HandleFunc(&quot;&#x2F;&quot;, func(w http.ResponseWriter, r *http.Request) &#123; &#x2F;&#x2F; This is here so we can actually see that the responses that have been cached don&#39;t get here fmt.Println(&quot;The request actually got here&quot;) w.Write([]byte(&quot;You got here&quot;)) &#125;) http.ListenAndServe(&quot;:8000&quot;, mux)&#125; Then we would build the client package. This is the most interesting part, while it is quite long (130+ LOCs), It should be relatively easy to follow.I highly recommend you head to the github repo. First of all, we would need a cache store. Since this is a minimal project, a dictionary/map can help us get away ASAP. We would create a http.Transport that implements http.RoundTripper but is also a cache store. In real life you’d want to separate them from each other though. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172func cacheKey(r *http.Request) string &#123; return r.URL.String()&#125;type cacheTransport struct &#123; data map[string]string mu sync.RWMutex originalTransport http.RoundTripper&#125;func (c *cacheTransport) Set(r *http.Request, value string) &#123; c.mu.Lock() defer c.mu.Unlock() c.data[cacheKey(r)] = value&#125;func (c *cacheTransport) Get(r *http.Request) (string, error) &#123; c.mu.RLock() defer c.mu.RUnlock() if val, ok := c.data[cacheKey(r)]; ok &#123; return val, nil &#125; return \"\", errors.New(\"key not found in cache\")&#125;// Here is the main functionalityfunc (c *cacheTransport) RoundTrip(r *http.Request) (*http.Response, error) &#123; // Check if we have the response cached.. // If yes, we don't have to hit the server // We just return it as is from the cache store. if val, err := c.Get(r); err == nil &#123; fmt.Println(\"Fetching the response from the cache\") return cachedResponse([]byte(val), r) &#125; // Ok, we don't have the response cached, the store was probably cleared. // Make the request to the server. resp, err := c.originalTransport.RoundTrip(r) if err != nil &#123; return nil, err &#125; // Get the body of the response so we can save it in the cache for the next request. buf, err := httputil.DumpResponse(resp, true) if err != nil &#123; return nil, err &#125; // Saving it to the cache store c.Set(r, string(buf)) fmt.Println(\"Fetching the data from the real source\") return resp, nil&#125;func (c *cacheTransport) Clear() error &#123; c.mu.Lock() defer c.mu.Unlock() c.data = make(map[string]string) return nil&#125;func cachedResponse(b []byte, r *http.Request) (*http.Response, error) &#123; buf := bytes.NewBuffer(b) return http.ReadResponse(bufio.NewReader(buf), r)&#125; Then the main function where we bootstrap the program. We would set a timer to clear out the cache store, so we can make requests to the server, this is to enable us view which requests are being served from the cache or the original server. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364func main() &#123; //client/main/go cachedTransport := newTransport() //Create a custom client so we can make use of our RoundTripper //If you make use of http.Get(), the default http client located at http.DefaultClient is used instead //Since we have special needs, we have to make use of our own http.RoundTripper implementation client := &amp;http.Client&#123; Transport: cachedTransport, Timeout: time.Second * 5, &#125; // Time to clear the cache store so we can make request to the original server rather than fetch from the cache store // This is to replicate real expiration of data in a cache store cacheClearTicker := time.NewTicker(time.Second * 5) //Make a new request every second //This would help demonstrate if the response is coming from the real server or the cache reqTicker := time.NewTicker(time.Second * 1) terminateChannel := make(chan os.Signal, 1) signal.Notify(terminateChannel, syscall.SIGTERM, syscall.SIGHUP) req, err := http.NewRequest(http.MethodGet, \"http://localhost:8000\", strings.NewReader(\"\")) if err != nil &#123; panic(\"Whoops\") &#125; for &#123; select &#123; case &lt;-cacheClearTicker.C: // Clear the cache so we can hit the original server cachedTransport.Clear() case &lt;-terminateChannel: cacheClearTicker.Stop() reqTicker.Stop() return case &lt;-reqTicker.C: resp, err := client.Do(req) if err != nil &#123; log.Printf(\"An error occurred.... %v\", err) continue &#125; buf, err := ioutil.ReadAll(resp.Body) if err != nil &#123; log.Printf(\"An error occurred.... %v\", err) continue &#125; fmt.Printf(\"The body of the response is \\\"%s\\\" \\n\\n\", string(buf)) &#125; &#125;&#125; 参考资料 https://lanre.wtf/blog/2017/07/24/roundtripper-go/ 源代码 https://github.com/dreamerjackson/rounder","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[95]-golang-优秀代码赏析-检测goroutine溢出","slug":"golang-95-golang-优秀代码赏析-检测goroutine溢出","date":"2019-10-12T09:12:28.000Z","updated":"2019-10-12T09:16:36.781Z","comments":true,"path":"2019/10/12/golang-95-golang-优秀代码赏析-检测goroutine溢出/","link":"","permalink":"https://dreamerjonson.com/2019/10/12/golang-95-golang-%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E8%B5%8F%E6%9E%90-%E6%A3%80%E6%B5%8Bgoroutine%E6%BA%A2%E5%87%BA/","excerpt":"","text":"在latern中看到了这段代码，防止协程溢出。 原理是利用了pprof.lookup() 此会将存在的goroutine的stacktrace打印出来。 通过对比代码前与代码后的goroutine number。 即可得知是否有新的goroutine创建出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Package grtrack provides a utility that helps check for goroutine leaks.package grtrackimport ( \"bytes\" \"regexp\" \"runtime/pprof\" \"strings\" \"testing\" \"time\" \"github.com/stretchr/testify/assert\")var ( goroutineNumber = regexp.MustCompile(`goroutine ([0-9]+)`))// Object that can be used to check whether goroutines have leaked at any point// in time.type Checker interface &#123; // Check immediately checks whether there's been a leak Check(t *testing.T) // CheckAfter waits wait and then checks CheckAfter(t *testing.T, wait time.Duration)&#125;type checker struct &#123; check func(t *testing.T)&#125;func Start() Checker &#123; var buf bytes.Buffer _ = pprof.Lookup(\"goroutine\").WriteTo(&amp;buf, 2) before := buf.String() check := func(t *testing.T) &#123; var buf bytes.Buffer _ = pprof.Lookup(\"goroutine\").WriteTo(&amp;buf, 2) after := buf.String() beforeGoroutines := make(map[string]bool) beforeMatches := goroutineNumber.FindAllStringSubmatch(before, -1) for _, match := range beforeMatches &#123; beforeGoroutines[match[1]] = true &#125; afterMatches := goroutineNumber.FindAllStringSubmatchIndex(after, -1) for i := 0; i &lt; len(afterMatches); i++ &#123; idx := afterMatches[i][0] nextIdx := len(after) last := i == len(afterMatches)-1 if !last &#123; nextIdx = afterMatches[i+1][0] &#125; matches := goroutineNumber.FindAllStringSubmatch(after[idx:], 1) num := matches[0][1] _, exists := beforeGoroutines[num] if !exists &#123; delta := after[idx:nextIdx] if !strings.Contains(delta, \"net/http/server.go\") &#123; assert.Fail(t, \"Leaked Goroutine\", delta) &#125; &#125; &#125; &#125; return &amp;checker&#123;check&#125;&#125;func (c *checker) Check(t *testing.T) &#123; c.check(t)&#125;func (c *checker) CheckAfter(t *testing.T, wait time.Duration) &#123; time.Sleep(wait) c.check(t)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[94]-golang-优秀代码赏析-eventually等待获取最后存储起来的value","slug":"golang-94-golang-优秀代码赏析","date":"2019-10-11T08:36:18.000Z","updated":"2019-10-12T09:10:53.029Z","comments":true,"path":"2019/10/11/golang-94-golang-优秀代码赏析/","link":"","permalink":"https://dreamerjonson.com/2019/10/11/golang-94-golang-%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81%E8%B5%8F%E6%9E%90/","excerpt":"","text":"并发获取最后存储起来的value，如果获取不到就会陷入等待一段时间。 source 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171// Package eventual provides values that eventually have a value.package eventualimport ( \"math\" \"sync\" \"sync/atomic\" \"time\")// Value is an eventual value, meaning that callers wishing to access the value// block until the value is available.type Value interface &#123; // Set sets this Value to the given val. Set(val interface&#123;&#125;) // Get waits up to timeout for the value to be set and returns it, or returns // nil if it times out or Cancel() is called. valid will be false in latter // case. If timeout is 0, Get won't wait. If timeout is -1, Get will wait // forever. Get(timeout time.Duration) (ret interface&#123;&#125;, valid bool) // Cancel cancels this value, signaling any waiting calls to Get() that no // value is coming. If no value was set before Cancel() was called, all future // calls to Get() will return nil, false. Subsequent calls to Set after Cancel // have no effect. Cancel()&#125;// Getter is a functional interface for the Value.Get functiontype Getter func(time.Duration) (interface&#123;&#125;, bool)type value struct &#123; state atomic.Value waiters []chan interface&#123;&#125; mutex sync.Mutex&#125;type stateholder struct &#123; val interface&#123;&#125; set bool canceled bool&#125;// NewValue creates a new Value.func NewValue() Value &#123; result := &amp;value&#123;waiters: make([]chan interface&#123;&#125;, 0)&#125; result.state.Store(&amp;stateholder&#123;&#125;) return result&#125;// DefaultGetter builds a Getter that always returns the supplied value.func DefaultGetter(val interface&#123;&#125;) Getter &#123; return func(time.Duration) (interface&#123;&#125;, bool) &#123; return val, true &#125;&#125;// DefaultUnsetGetter builds a Getter that always !ok.func DefaultUnsetGetter() Getter &#123; return func(time.Duration) (interface&#123;&#125;, bool) &#123; return nil, false &#125;&#125;func (v *value) Set(val interface&#123;&#125;) &#123; v.mutex.Lock() defer v.mutex.Unlock() state := v.getState() settable := !state.canceled if settable &#123; v.setState(&amp;stateholder&#123; val: val, set: true, canceled: false, &#125;) if v.waiters != nil &#123; // Notify anyone waiting for value for _, waiter := range v.waiters &#123; waiter &lt;- val &#125; // Clear waiters v.waiters = nil &#125; &#125;&#125;func (v *value) Cancel() &#123; v.mutex.Lock() defer v.mutex.Unlock() state := v.getState() v.setState(&amp;stateholder&#123; val: state.val, set: state.set, canceled: true, &#125;) if v.waiters != nil &#123; // Notify anyone waiting for value for _, waiter := range v.waiters &#123; close(waiter) &#125; // Clear waiters v.waiters = nil &#125;&#125;func (v *value) Get(timeout time.Duration) (ret interface&#123;&#125;, valid bool) &#123; state := v.getState() // First check for existing value using atomic operations (for speed) if state.set &#123; // Value found, use it return state.val, true &#125; else if state.canceled &#123; // Value was canceled, return false return nil, false &#125; if timeout == 0 &#123; // Don't wait return nil, false &#125; // If we didn't find an existing value, try again but this time using locking v.mutex.Lock() state = v.getState() if state.set &#123; // Value found, use it v.mutex.Unlock() return state.val, true &#125; else if state.canceled &#123; // Value was canceled, return false v.mutex.Unlock() return nil, false &#125; if timeout == -1 &#123; // Wait essentially forever timeout = time.Duration(math.MaxInt64) &#125; // Value not found, register to be notified once value is set valCh := make(chan interface&#123;&#125;, 1) v.waiters = append(v.waiters, valCh) v.mutex.Unlock() // Wait up to timeout for value to get set select &#123; case v, ok := &lt;-valCh: return v, ok case &lt;-time.After(timeout): return nil, false &#125;&#125;func (v *value) getState() *stateholder &#123; state := v.state.Load() if state == nil &#123; return nil &#125; return state.(*stateholder)&#125;func (v *value) setState(state *stateholder) &#123; v.state.Store(state)&#125; test 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package eventualimport ( \"sync\" \"sync/atomic\" \"testing\" \"time\" \"github.com/getlantern/grtrack\" \"github.com/stretchr/testify/assert\")const ( concurrency = 200)func TestSingle(t *testing.T) &#123; goroutines := grtrack.Start() v := NewValue() go func() &#123; time.Sleep(20 * time.Millisecond) v.Set(\"hi\") &#125;() r, ok := v.Get(0) assert.False(t, ok, \"Get with no timeout should have failed\") r, ok = v.Get(10 * time.Millisecond) assert.False(t, ok, \"Get with short timeout should have timed out\") r, ok = v.Get(-1) assert.True(t, ok, \"Get with really long timeout should have succeeded\") assert.Equal(t, \"hi\", r, \"Wrong result\") // Set a different value v.Set(\"bye\") r, ok = v.Get(0) assert.True(t, ok, \"Subsequent get with no timeout should have succeeded\") assert.Equal(t, \"bye\", r, \"Value should have changed\") goroutines.CheckAfter(t, 50*time.Millisecond)&#125;func TestNoSet(t *testing.T) &#123; goroutines := grtrack.Start() v := NewValue() _, ok := v.Get(10 * time.Millisecond) assert.False(t, ok, \"Get before setting value should not be okay\") goroutines.CheckAfter(t, 50*time.Millisecond)&#125;func TestCancelImmediate(t *testing.T) &#123; v := NewValue() go func() &#123; time.Sleep(10 * time.Millisecond) v.Cancel() &#125;() _, ok := v.Get(200 * time.Millisecond) assert.False(t, ok, \"Get after cancel should have failed\")&#125;func TestCancelAfterSet(t *testing.T) &#123; v := NewValue() v.Set(5) r, ok := v.Get(10 * time.Millisecond) assert.True(t, ok, \"Get before cancel should have succeeded\") assert.Equal(t, 5, r, \"Get got wrong value before cancel\") v.Cancel() r, ok = v.Get(0) assert.True(t, ok, \"Get after cancel should have succeeded\") assert.Equal(t, 5, r, \"Get got wrong value after cancel\") v.Set(10) r, _ = v.Get(0) assert.Equal(t, 5, r, \"Set after cancel should have no effect\")&#125;func BenchmarkGet(b *testing.B) &#123; v := NewValue() go func() &#123; time.Sleep(20 * time.Millisecond) v.Set(\"hi\") &#125;() for i := 0; i &lt; b.N; i++ &#123; v.Get(20 * time.Millisecond) &#125;&#125;func TestConcurrent(t *testing.T) &#123; goroutines := grtrack.Start() v := NewValue() var sets int32 go func() &#123; var wg sync.WaitGroup wg.Add(1) // Do some concurrent setting to make sure that it works for i := 0; i &lt; concurrency; i++ &#123; go func() &#123; // Wait for waitGroup so that all goroutines run at basically the same // time. wg.Wait() v.Set(\"hi\") atomic.AddInt32(&amp;sets, 1) &#125;() &#125; wg.Done() &#125;() for i := 0; i &lt; concurrency; i++ &#123; go func() &#123; r, ok := v.Get(200 * time.Millisecond) assert.True(t, ok, \"Get should have succeed\") assert.Equal(t, \"hi\", r, \"Wrong result\") &#125;() &#125; goroutines.CheckAfter(t, 50*time.Millisecond) assert.EqualValues(t, concurrency, atomic.LoadInt32(&amp;sets), \"Wrong number of successful Sets\")&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[93]-golang-link","slug":"golang-93-golang-link","date":"2019-10-10T13:34:57.000Z","updated":"2019-10-10T13:35:29.098Z","comments":true,"path":"2019/10/10/golang-93-golang-link/","link":"","permalink":"https://dreamerjonson.com/2019/10/10/golang-93-golang-link/","excerpt":"","text":"Link, typically invoked as “go tool link,” reads the Go archive or object for a package main, along with its dependencies, and combines them into an executable binary. Command Line Usage: go tool link [flags] main.a Flags: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110-B note Add an ELF_NT_GNU_BUILD_ID note when using ELF. The value should start with 0x and be an even number of hex digits.-D address Set data segment address.-E entry Set entry symbol name.-H type Set executable format type. The default format is inferred from GOOS and GOARCH. On Windows, -H windowsgui writes a &quot;GUI binary&quot; instead of a &quot;console binary.&quot;-I interpreter Set the ELF dynamic linker to use.-L dir1 -L dir2 Search for imported packages in dir1, dir2, etc, after consulting $GOROOT&#x2F;pkg&#x2F;$GOOS_$GOARCH.-R quantum Set address rounding quantum.-T address Set text segment address.-V Print linker version and exit.-X importpath.name&#x3D;value Set the value of the string variable in importpath named name to value. This is only effective if the variable is declared in the source code either uninitialized or initialized to a constant string expression. -X will not work if the initializer makes a function call or refers to other variables. Note that before Go 1.5 this option took two separate arguments.-a Disassemble output.-buildid id Record id as Go toolchain build id.-buildmode mode Set build mode (default exe).-c Dump call graphs.-compressdwarf Compress DWARF if possible (default true).-cpuprofile file Write CPU profile to file.-d Disable generation of dynamic executables. The emitted code is the same in either case; the option controls only whether a dynamic header is included. The dynamic header is on by default, even without any references to dynamic libraries, because many common system tools now assume the presence of the header.-debugtramp int Debug trampolines.-dumpdep Dump symbol dependency graph.-extar ar Set the external archive program (default &quot;ar&quot;). Used only for -buildmode&#x3D;c-archive.-extld linker Set the external linker (default &quot;clang&quot; or &quot;gcc&quot;).-extldflags flags Set space-separated flags to pass to the external linker.-f Ignore version mismatch in the linked archives.-g Disable Go package data checks.-importcfg file Read import configuration from file. In the file, set packagefile, packageshlib to specify import resolution.-installsuffix suffix Look for packages in $GOROOT&#x2F;pkg&#x2F;$GOOS_$GOARCH_suffix instead of $GOROOT&#x2F;pkg&#x2F;$GOOS_$GOARCH.-k symbol Set field tracking symbol. Use this flag when GOEXPERIMENT&#x3D;fieldtrack is set.-libgcc file Set name of compiler support library. This is only used in internal link mode. If not set, default value comes from running the compiler, which may be set by the -extld option. Set to &quot;none&quot; to use no support library.-linkmode mode Set link mode (internal, external, auto). This sets the linking mode as described in cmd&#x2F;cgo&#x2F;doc.go.-linkshared Link against installed Go shared libraries (experimental).-memprofile file Write memory profile to file.-memprofilerate rate Set runtime.MemProfileRate to rate.-msan Link with C&#x2F;C++ memory sanitizer support.-n Dump symbol table.-o file Write output to file (default a.out, or a.out.exe on Windows).-pluginpath path The path name used to prefix exported plugin symbols.-r dir1:dir2:... Set the ELF dynamic linker search path.-race Link with race detection libraries.-s Omit the symbol table and debug information.-shared Generated shared object (implies -linkmode external; experimental).-tmpdir dir Write temporary files to dir. Temporary files are only used in external linking mode.-u Reject unsafe packages.-v Print trace of linker operations.-w Omit the DWARF symbol table.","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[92]-golang-实现反向代理","slug":"golang-92-golang-reverse-proxy","date":"2019-10-07T07:00:26.000Z","updated":"2019-10-12T14:21:05.854Z","comments":true,"path":"2019/10/07/golang-92-golang-reverse-proxy/","link":"","permalink":"https://dreamerjonson.com/2019/10/07/golang-92-golang-reverse-proxy/","excerpt":"","text":"反向代理 反向代理在计算机网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器集群的存在 golang最简单实现反向代理 golang源码httputils中有对于反向代理的实现，最简单的代理甚至可以一行代码实现。 1、我们首先开启一个web服务器监听127.0.0.1:8999端口 12345678910111213141516171819import ( \"log\" _ \"net/http\")func (this *handle) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprint(w, \"Welcome!\")&#125;func startServer() &#123; err := http.ListenAndServe(\":8999\", h) if err != nil &#123; log.Fatalln(\"ListenAndServe: \", err) &#125;&#125;func main() &#123; startServer()&#125; 2、实现一个简单的代理服务器 下面的程序仍然是一个web服务器，监听8888端口，但是其使用了反向代理，因此对:8888的访问都会转发到:8999，输出“Welcome！”。 核心的操作在于httputil.NewSingleHostReverseProxy 具有serveHttp方法，此方法对request请求进行了重新封装，并且proxy将得到的response转发给client。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"log\" \"net/http\" \"net/http/httputil\" \"net/url\")type handle struct &#123; host string port string&#125;func (this *handle) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; fmt.Printf(\"url:%+v\\n\",r.URL) remote, err := url.Parse(\"http://\" + this.host + \":\" + this.port) if err != nil &#123; panic(err) &#125; fmt.Println(\"hosr::\",remote.Host) proxy := httputil.NewSingleHostReverseProxy(remote) proxy.ServeHTTP(w, r)&#125;func startServer() &#123; //被代理的服务器host和port h := &amp;handle&#123;host: \"127.0.0.1\", port: \"8999\"&#125; err := http.ListenAndServe(\":8888\", h) if err != nil &#123; log.Fatalln(\"ListenAndServe: \", err) &#125;&#125;func main() &#123; startServer()&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"xargs命令详解，xargs与管道的区别","slug":"xargs命令详解，xargs与管道的区别","date":"2019-09-22T15:33:30.000Z","updated":"2019-09-22T15:37:57.836Z","comments":true,"path":"2019/09/22/xargs命令详解，xargs与管道的区别/","link":"","permalink":"https://dreamerjonson.com/2019/09/22/xargs%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%8Cxargs%E4%B8%8E%E7%AE%A1%E9%81%93%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"阅读目录 为什么要用xargs，问题的来源 xargs是什么，与管道有什么不同 xargs的一些有用的选项 为什么要用xargs，问题的来源 在工作中经常会接触到xargs命令，特别是在别人写的脚本里面也经常会遇到，但是却很容易与管道搞混淆，本篇会详细讲解到底什么是xargs命令，为什么要用xargs命令以及与管道的区别。为什么要用xargs呢，我们知道，linux命令可以从两个地方读取要处理的内容，一个是通过命令行参数，一个是标准输入。例如cat、grep就是这样的命令，举个例子： echo ‘main’ | cat test.cpp 这种情况下cat会输出test.cpp的内容，而不是’main’字符串，如果test.cpp不存在则cat命令报告该文件不存在，并不会尝试从标准输入中读取。echo ‘main’ | 会通过管道将 echo 的标准输出(也就是字符串’main’)导入到 cat 的标准输入，也就是说此时cat的标准输入中是有内容的，其内容就是字符串’main’但是上面的内容中cat不会从它的标准输入中读入要处理的内容。(注:标准输入是有一个缓冲区的，就像我们在程序中使用scanf函数从标准输入中读取一样，实际上是从标准输入的缓冲区中读取的)。其实基本上linux的命令中很多的命令的设计是先从命令行参数中获取参数，然后从标准输入中读取，反映在程序上，命令行参数是通过main函数 int main(int argc,char*argv[]) 的函数参数获得的，而标准输入则是通过标准输入函数例如C语言中的scanf读取到的。他们获取的地方是不一样的。例如： echo ‘main’ | cat 这条命令中cat会从其标准输入中读取内容并处理，也就是会输出 ‘main’ 字符串。echo命令将其标准输出的内容 ‘main’ 通过管道定向到 cat 的标准输入中。 cat 如果仅仅输入cat并回车，则该程序会等待输入，我们需要从键盘输入要处理的内容给cat，此时cat也是从标准输入中得到要处理的内容的，因为我们的cat命令行中也没有指定要处理的文件名。大多数命令有一个参数 - 如果直接在命令的最后指定 - 则表示从标准输入中读取，例如： echo ‘main’ | cat - 这样也是可行的，会显示 ‘main’ 字符串，同样输入 cat - 直接回车与输入 cat 直接回车的效果也一样，但是如果这样呢： echo ‘main’ | cat test.cpp - 同时指定test.cpp 和 - 参数，此时cat程序会先输出test.cpp的内容，然后输出标准输入’main’字符串，如果换一下顺序变成这样： echo ‘main’ | cat - test.cpp 则会先输出标准输入’main’字符串，然后输出test.cpp文件的内容。如果去掉这里的 - 参数，则cat只会输出test.cpp文件的内容。另外如果同时传递标准输入和文件名，grep也会同时处理这两个输入，例如： echo ‘main’ | grep ‘main’ test.cpp - 该命令的输出结果是: test.cpp:int main() (standard input):main 此时grep也会同时处理标准输入和文件test.cpp中的内容，也就是说会在标准输入中搜索 ‘main’ 也会在文件 test.cpp (该文件名从grep命令行参数中获得)中搜索 ‘main’。也就是说我们看到当命令行参数与标准输入同时存在的时候grep和cat是会同时处理这两个输入的，但是有很多命令并不是都处理。大多命令一般情况下是首先在命令行中查找要处理的内容的来源(是从文件还是从标准输入，还是都有)，如果在命令行中找不到与要处理的内容的来源相关的参数则默认从标准输入中读取要处理的内容了，当然这取决于命令程序的内部实现，就像cat命令，加不加 - 参数他的表现又不同。 另外很多程序是不处理标准输入的，例如 kill , rm 这些程序如果命令行参数中没有指定要处理的内容则不会默认从标准输入中读取。所以： 1 echo ‘516’ | kill 这种命里是不能执行的。 1 echo ‘test’ | rm -f 这种也是没有效果的。 这两个命令只接受命令行参数中指定的处理内容，不从标准输入中获取处理内容。想想也很正常，kill 是结束进程，rm是删除文件，如果要结束的进程pid和要删除的文件名需要从标准输入中读取，这个也很怪异吧。 但是像 cat与grep这些文字处理工具从标准输入中读取待处理的内容则很自然。 但是有时候我们的脚本却需要 echo ‘516’ | kill 这样的效果，例如 ps -ef | grep ‘ddd’ | kill 这样的效果，筛选出符合某条件的进程pid然后结束。这种需求对于我们来说是理所当然而且是很常见的，那么应该怎样达到这样的效果呢。有几个解决办法： 通过 kill ps -ef | grep 'ddd' 这种形式，这个时候实际上等同于拼接字符串得到的命令，其效果类似于 kill $pid for procid in $(ps -aux | grep “some search” | awk ‘{print $2}’); do kill -9 $procid; done 其实与第一种原理一样，只不过需要多次kill的时候是循环处理的，每次处理一个 ps -ef | grep ‘ddd’ | xargs kill OK，使用了xargs命令，铺垫了这么久终于铺到了主题上。xargs命令可以通过管道接受字符串，并将接收到的字符串通过空格分割成许多参数(默认情况下是通过空格分割) 然后将参数传递给其后面的命令，作为后面命令的命令行参数 xargs是什么，与管道有什么不同 xargs与管道有什么不同呢，这是两个很容易混淆的东西，看了上面的xargs的例子还是有点云里雾里的话，我们来看下面的例子弄清楚为什么需要xargs： echo ‘–help’ | cat 输出： –help echo ‘–help’ | xargs cat 12345678910111213141516171819202122232425262728293031输出：Usage: cat [OPTION]... [FILE]...Concatenate FILE(s), or standard input, to standard output. -A, --show-all equivalent to -vET -b, --number-nonblank number nonempty output lines -e equivalent to -vE -E, --show-ends display $ at end of each line -n, --number number all output lines -s, --squeeze-blank suppress repeated empty output lines -t equivalent to -vT -T, --show-tabs display TAB characters as ^I -u (ignored) -v, --show-nonprinting use ^ and M- notation, except for LFD and TAB --help display this help and exit --version output version information and exitWith no FILE, or when FILE is -, read standard input.Examples: cat f - g Output f&#39;s contents, then standard input, then g&#39;s contents. cat Copy standard input to standard output.Report cat bugs to bug-coreutils@gnu.orgGNU coreutils home page: &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;coreutils&#x2F;&gt;General help using GNU software: &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;gethelp&#x2F;&gt;For complete documentation, run: info coreutils &#39;cat invocation&#39;可以看到 echo &#39;--help&#39; | cat 该命令输出的是echo的内容，也就是说将echo的内容当作cat处理的文件内容了，实际上就是echo命令的输出通过管道定向到cat的输入了。然后cat从其标准输入中读取待处理的文本内容。这等价于在test.txt文件中有一行字符 &#39;--help&#39; 然后运行 cat test.txt 的效果。而 echo &#39;--help&#39; | xargs cat 等价于 cat --help 什么意思呢，就是xargs将其接受的字符串 --help 做成cat的一个命令参数来运行cat命令，同样 echo &#39;test.c test.cpp&#39; | xargs cat 等价于 cat test.c test.cpp 此时会将test.c和test.cpp的内容都显示出来。 xargs的一些有用的选项 相信到这里应该都知道xargs的作用了，那么我们看看xargs还有一些有用的选项： -d 选项 默认情况下xargs将其标准输入中的内容以空白(包括空格、Tab、回车换行等)分割成多个之后当作命令行参数传递给其后面的命令，并运行之，我们可以使用 -d 命令指定分隔符，例如： echo ‘11@22@33’ | xargs echo 输出： 11@22@33 默认情况下以空白分割，那么11@22@33这个字符串中没有空白，所以实际上等价于 echo 11@22@33 其中字符串 ‘11@22@33’ 被当作echo命令的一个命令行参数 echo ‘11@22@33’ | xargs -d ‘@’ echo 输出： 11 22 33 指定以@符号分割参数，所以等价于 echo 11 22 33 相当于给echo传递了3个参数，分别是11、22、33 -p 选项 使用该选项之后xargs并不会马上执行其后面的命令，而是输出即将要执行的完整的命令(包括命令以及传递给命令的命令行参数)，询问是否执行，输入 y 才继续执行，否则不执行。这种方式可以清楚的看到执行的命令是什么样子，也就是xargs传递给命令的参数是什么，例如： echo ‘11@22@33’ | xargs -p -d ‘@’ echo 输出： echo 11 22 33 ?..y ==&gt;这里询问是否执行命令 echo 11 22 33 输入y并回车，则显示执行结果，否则不执行 11 22 33 ==&gt;执行结果 -n 选项 该选项表示将xargs生成的命令行参数，每次传递几个参数给其后面的命令执行，例如如果xargs从标准输入中读入内容，然后以分隔符分割之后生成的命令行参数有10个，使用 -n 3 之后表示一次传递给xargs后面的命令是3个参数，因为一共有10个参数，所以要执行4次，才能将参数用完。例如： echo ‘11@22@33@44@55@66@77@88@99@00’ | xargs -d ‘@’ -n 3 echo 输出结果： 11 22 33 44 55 66 77 88 99 00 等价于： echo 11 22 33 echo 44 55 66 echo 77 88 99 echo 00 实际上运行了4次，每次传递3个参数，最后还剩一个，就直接传递一个参数。 -E 选项，有的系统的xargs版本可能是-e eof-str 该选项指定一个字符串，当xargs解析出多个命令行参数的时候，如果搜索到-e指定的命令行参数，则只会将-e指定的命令行参数之前的参数(不包括-e指定的这个参数)传递给xargs后面的命令 echo ‘11 22 33’ | xargs -E ‘33’ echo 输出： 11 22 可以看到正常情况下有3个命令行参数 11、22、33 由于使用了-E ‘33’ 表示在将命令行参数 33 之前的参数传递给执行的命令，33本身不传递。等价于 echo 11 22 这里-E实际上有搜索的作用，表示只取xargs读到的命令行参数前面的某些部分给命令执行。 注意：-E只有在xargs不指定-d的时候有效，如果指定了-d则不起作用，而不管-d指定的是什么字符，空格也不行。 echo ‘11 22 33’ | xargs -d ’ ’ -E ‘33’ echo =&gt; 输出 11 22 33 echo ‘11@22@33@44@55@66@77@88@99@00 aa 33 bb’ | xargs -E ‘33’ -d ‘@’ -p echo =&gt; 输出 11 22 33 44 55 66 77 88 99 00 aa 33 bb -0 选项表示以 ‘\\0’ 为分隔符，一般与find结合使用 123456789101112131415161718192021find . -name &quot;*.txt&quot;输出：.&#x2F;2.txt.&#x2F;3.txt.&#x2F;1.txt &#x3D;&gt; 默认情况下find的输出结果是每条记录后面加上换行，也就是每条记录是一个新行find . -name &quot;*.txt&quot; -print0输出：.&#x2F;2.txt.&#x2F;3.txt.&#x2F;1.txt &#x3D;&gt; 加上 -print0 参数表示find输出的每条结果后面加上 &#39;\\0&#39; 而不是换行find . -name &quot;*.txt&quot; -print0 | xargs -0 echo输出：.&#x2F;2.txt .&#x2F;3.txt .&#x2F;1.txtfind . -name &quot;*.txt&quot; -print0 | xargs -d &#39;\\0&#39; echo输出：.&#x2F;2.txt .&#x2F;3.txt .&#x2F;1.txtxargs的 -0 和 -d &#39;\\0&#39; 表示其从标准输入中读取的内容使用 &#39;\\0&#39; 来分割，由于 find 的结果是使用 &#39;\\0&#39; 分隔的，所以xargs使用 &#39;\\0&#39; 将 find的结果分隔之后得到3个参数： .&#x2F;2.txt .&#x2F;3.txt .&#x2F;1.txt 注意中间是有空格的。上面的结果就等价于 echo .&#x2F;2.txt .&#x2F;3.txt .&#x2F;1.txt实际上使用xargs默认的空白分隔符也是可以的 find . -name &quot;*.txt&quot; | xargs echo 因为换行符也是xargs的默认空白符的一种。find命令如果不加-print0其搜索结果的每一条字符串后面实际上是加了换行","categories":[{"name":"linux","slug":"linux","permalink":"https://dreamerjonson.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dreamerjonson.com/tags/linux/"}]},{"title":"golang[91]-复杂的json转换为结构体","slug":"golang-91-复杂的json转换为结构体","date":"2019-09-21T09:57:29.000Z","updated":"2019-09-21T10:07:45.099Z","comments":true,"path":"2019/09/21/golang-91-复杂的json转换为结构体/","link":"","permalink":"https://dreamerjonson.com/2019/09/21/golang-91-%E5%A4%8D%E6%9D%82%E7%9A%84json%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"","text":"12345678910111213141516type MultiTransData struct &#123; AccountDetailsMap map[string][]struct &#123; Account int Stretegy int &#125; &#125;to&#123; &quot;AccountDetailsMap&quot;:&#123; &quot;GOLD:&quot;:[ &#123;&quot;Account&quot;:1,&quot;Stretegy&quot;:2&#125;,&#123;&quot;Account&quot;:5,&quot;Stretegy&quot;:6&#125; ], &quot;WTI:&quot;:[&#123;&quot;Account&quot;:3,&quot;Stretegy&quot;:4&#125;] &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849type BackTestRequest struct &#123; StrategyName string Table string Direction int32 Way int32 TradeNum int32 TP int32 SL int32 SLTPIndex int32 Capital float64 StartTime Time EndTime Time RequestId string Callback string SpreadMap map[string]Spread &#96;json:&quot;spread_list&quot;&#96;&#125;type Spread struct &#123; OriginalSpread int32 StrategySpread int32&#125;to&#123; &quot;StrategyName&quot;: &quot;backtest_12&quot;, &quot;Table&quot;: &quot;backtest_12&quot;, &quot;Direction&quot;: 1, &quot;Way&quot;: 2, &quot;TradeNum&quot;: 3, &quot;TP&quot;: 4, &quot;SL&quot;: 5, &quot;SLTPIndex&quot;: 6, &quot;Capital&quot;: 7, &quot;StartTime&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;EndTime&quot;: &quot;0001-01-01T00:00:00Z&quot;, &quot;RequestId&quot;: &quot;&quot;, &quot;Callback&quot;: &quot;&quot;, &quot;spread_list&quot;:&#123; &quot;GOLD:&quot;:&#123; &quot;OriginalSpread&quot;:1, &quot;StrategySpread&quot;:2 &#125;, &quot;WTI:&quot;:&#123; &quot;OriginalSpread&quot;:3, &quot;StrategySpread&quot;:4 &#125; &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[90]-使用wine在linux平台操作windows","slug":"golang-90-使用wine在linux平台操作windows","date":"2019-09-21T09:50:43.000Z","updated":"2019-09-22T04:01:50.842Z","comments":true,"path":"2019/09/21/golang-90-使用wine在linux平台操作windows/","link":"","permalink":"https://dreamerjonson.com/2019/09/21/golang-90-%E4%BD%BF%E7%94%A8wine%E5%9C%A8linux%E5%B9%B3%E5%8F%B0%E6%93%8D%E4%BD%9Cwindows/","excerpt":"","text":"wine镜像1: Dockerfile 12345678910111213141516171819FROM debian:stretch-slimENV TZ&#x3D;Asia&#x2F;ShanghaiENV GOROOT&#x3D;z:\\\\goCOPY .&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;# COPY .&#x2F;go &#x2F;goRUN dpkg --add-architecture i386 &amp;&amp; \\ apt-get update &amp;&amp; \\ apt-get install -y --no-install-recommends \\ wine32 \\ wine \\ ca-certificates &amp;&amp; \\ rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*RUN wine --versionWORKDIR &#x2F;app makefile 123456789101112131415161718all: wine-download wine-unzip wine-build wine-clear wine-pushwine-download: wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.11.linux-amd64.tar.gzwine-unzip: tar zxvf go1.11.linux-amd64.tar.gzwine-build: docker build -t i.wannamake.love&#x2F;library&#x2F;wine .wine-clear: rm -rf go go1.11.linux-amd64.tar.gzwine-push: docker push i.wannamake.love&#x2F;library&#x2F;wine.PHONY: all sources.list 1234567891011deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch main contrib non-freedeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch main contrib non-freedeb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-updates main contrib non-freedeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-updates main contrib non-freedeb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-backports main contrib non-freedeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian&#x2F; stretch-backports main contrib non-freedeb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian-security&#x2F; stretch&#x2F;updates main contrib non-freedeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;debian-security&#x2F; stretch&#x2F;updates main contrib non-free wine镜像2 直接使用外部优秀的镜像： Dockerfile 12345678910111213FROM scottyhardy&#x2F;docker-wine:latestRUN wine --versionCOPY .&#x2F;docker-entrypoint.sh &#x2F;usr&#x2F;local&#x2F;bin&#x2F;COPY .&#x2F;followquant_api.exe &#x2F;app&#x2F;bin&#x2F;COPY .&#x2F;mtmanapi.dll &#x2F;app&#x2F;bin&#x2F;COPY .&#x2F;config.json &#x2F;app&#x2F;WORKDIR &#x2F;appRUN chmod 777 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-entrypoint.sh \\ &amp;&amp; chmod 777 &#x2F;app&#x2F;config.json \\ &amp;&amp; ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-entrypoint.sh &#x2F;ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] docker-entrypoint.sh 1234#!&#x2F;bin&#x2F;shset -eecho &quot;123&quot;exec wine .&#x2F;bin&#x2F;followquant_api.exe 参考资料 https://forum.winehq.org/viewtopic.php?t=28797","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[89]-操作docker容器获取proto的go文件","slug":"golang-89-操作docker容器获取proto的go文件","date":"2019-09-20T06:41:20.000Z","updated":"2019-09-21T06:46:23.477Z","comments":true,"path":"2019/09/20/golang-89-操作docker容器获取proto的go文件/","link":"","permalink":"https://dreamerjonson.com/2019/09/20/golang-89-%E6%93%8D%E4%BD%9Cdocker%E5%AE%B9%E5%99%A8%E8%8E%B7%E5%8F%96proto%E7%9A%84go%E6%96%87%E4%BB%B6/","excerpt":"","text":"公司用的是比较旧的protoc、protoc-gen-go 、micro插件。所以一种办法是直接操作容器，在容器中去生成特定版本的proto文件 docker中： 1234docker run -idt dockerhub.followme-internal.com&#x2F;library&#x2F;golang-builder:alpinedocker exec -it 6c76c145fe71 &#x2F;bin&#x2F;shcd &#x2F;tmpprotoc --micro_out&#x3D;. --go_out&#x3D;plugins&#x3D;grpc:. .&#x2F;guard.proto 外部： 1234docker cp guard.proto 6c76c145fe71:&#x2F;tmp&#x2F;docker cp 6c76c145fe71:&#x2F;tmp&#x2F; .","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"TCPIP-学习笔记","slug":"TCPIP-studynode","date":"2019-09-16T06:25:02.000Z","updated":"2019-09-17T13:22:51.123Z","comments":true,"path":"2019/09/16/TCPIP-studynode/","link":"","permalink":"https://dreamerjonson.com/2019/09/16/TCPIP-studynode/","excerpt":"","text":"On a Linux system, use the route command with the -n option to display the routing table.* The -n option prevents route from converting IP addresses to hostnames, which gives a clearer display. Here is a routing table from a sample Red Hat system: route -n Destination 要访问的目标地址 gateway 要到达目标地址 需要中转的地址 mac : 1234567891011121314151617181920netstat -nrRouting tablesInternet:Destination Gateway Flags Refs Use Netif Expiredefault 192.168.1.1 UGSc 73 0 en7127 127.0.0.1 UCS 0 0 lo0127.0.0.1 127.0.0.1 UH 14 6969684 lo0169.254 link#19 UCS 1 0 en7 !192.168.1 link#19 UCS 2 0 en7 !192.168.1.1&#x2F;32 link#19 UCS 1 0 en7 !192.168.1.1 38:ad:be:c2:56:fa UHLWIir 9 0 en7 1200192.168.1.3&#x2F;32 link#19 UCS 0 0 en7 !192.168.1.7 98:5a:eb:d8:5f:af UHLWI 0 0 en7 911192.168.1.25 e8:6a:64:9:4f:5e UHLWI 0 0 en7 698224.0.0&#x2F;4 link#19 UmCS 2 0 en7 !224.0.0.251 1:0:5e:0:0:fb UHmLWI 0 7 en7239.255.255.250 1:0:5e:7f:ff:fa UHmLWI 0 96 en7255.255.255.255&#x2F;32 link#19 UCS 0 0 en7 ! route cache IP uses the information from the routing table (the forwarding table) to construct the routes used for active connections. The routes associated with active connections are stored in the routing cache. On Linux systems, the routing cache can be examined by adding the -C argument to the route command line: The routing cache is different from the routing table because the cache shows established routes. The routing table is used to make routing decisions; the routing cache is used after the decision is made. The routing cache shows the source and destination of a network connection and the gateway and interface used to make that connection. 1route -Cn Phys Addr arp -a 123456789(172.24.0.4) at 02:42:ac:18:00:04 [ether] on br-0e67b8dd25a6? (172.22.0.2) at 02:42:ac:16:00:02 [ether] on br-56ca89db6d16? (192.168.16.2) at 02:42:c0:a8:10:02 [ether] on br-28e79d560103? (192.168.8.11) at 00:0c:29:74:4e:c9 [ether] on eth0? (192.168.8.14) at 00:0c:29:00:b3:7f [ether] on eth0? (192.168.8.13) at 00:0c:29:d6:b7:bf [ether] on eth0? (192.168.8.9) at 00:0c:29:1b:54:94 [ether] on eth0? (192.168.8.34) at 00:0c:29:2b:ba:43 [ether] on eth0? (192.168.8.12) at 00:0c:29:d2:41:d7 [ether] on eth0 protocols 处理如何解析数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161$ cat &#x2F;etc&#x2F;protocols## Internet protocols## $FreeBSD$# from: @(#)protocols 5.1 (Berkeley) 4&#x2F;17&#x2F;89## See also http:&#x2F;&#x2F;www.iana.org&#x2F;assignments&#x2F;protocol-numbers#ip 0 IP # internet protocol, pseudo protocol number#hopopt 0 HOPOPT # hop-by-hop options for ipv6icmp 1 ICMP # internet control message protocoligmp 2 IGMP # internet group management protocolggp 3 GGP # gateway-gateway protocolipencap 4 IP-ENCAP # IP encapsulated in IP (officially &#96;&#96;IP&#39;&#39;)st2 5 ST2 # ST2 datagram mode (RFC 1819) (officially &#96;&#96;ST&#39;&#39;)tcp 6 TCP # transmission control protocolcbt 7 CBT # CBT, Tony Ballardie &lt;A.Ballardie@cs.ucl.ac.uk&gt;egp 8 EGP # exterior gateway protocoligp 9 IGP # any private interior gateway (Cisco: for IGRP)bbn-rcc 10 BBN-RCC-MON # BBN RCC Monitoringnvp 11 NVP-II # Network Voice Protocolpup 12 PUP # PARC universal packet protocolargus 13 ARGUS # ARGUSemcon 14 EMCON # EMCONxnet 15 XNET # Cross Net Debuggerchaos 16 CHAOS # Chaosudp 17 UDP # user datagram protocolmux 18 MUX # Multiplexing protocoldcn 19 DCN-MEAS # DCN Measurement Subsystemshmp 20 HMP # host monitoring protocolprm 21 PRM # packet radio measurement protocolxns-idp 22 XNS-IDP # Xerox NS IDPtrunk-1 23 TRUNK-1 # Trunk-1trunk-2 24 TRUNK-2 # Trunk-2leaf-1 25 LEAF-1 # Leaf-1leaf-2 26 LEAF-2 # Leaf-2rdp 27 RDP # &quot;reliable datagram&quot; protocolirtp 28 IRTP # Internet Reliable Transaction Protocoliso-tp4 29 ISO-TP4 # ISO Transport Protocol Class 4netblt 30 NETBLT # Bulk Data Transfer Protocolmfe-nsp 31 MFE-NSP # MFE Network Services Protocolmerit-inp 32 MERIT-INP # MERIT Internodal Protocoldccp 33 DCCP # Datagram Congestion Control Protocol3pc 34 3PC # Third Party Connect Protocolidpr 35 IDPR # Inter-Domain Policy Routing Protocolxtp 36 XTP # Xpress Tranfer Protocolddp 37 DDP # Datagram Delivery Protocolidpr-cmtp 38 IDPR-CMTP # IDPR Control Message Transport Prototp++ 39 TP++ # TP++ Transport Protocolil 40 IL # IL Transport Protocolipv6 41 IPV6 # ipv6sdrp 42 SDRP # Source Demand Routing Protocolipv6-route 43 IPV6-ROUTE # routing header for ipv6ipv6-frag 44 IPV6-FRAG # fragment header for ipv6idrp 45 IDRP # Inter-Domain Routing Protocolrsvp 46 RSVP # Resource ReSerVation Protocolgre 47 GRE # Generic Routing Encapsulationdsr 48 DSR # Dynamic Source Routing Protocolbna 49 BNA # BNAesp 50 ESP # encapsulating security payloadah 51 AH # authentication headeri-nlsp 52 I-NLSP # Integrated Net Layer Security TUBAswipe 53 SWIPE # IP with Encryptionnarp 54 NARP # NBMA Address Resolution Protocolmobile 55 MOBILE # IP Mobilitytlsp 56 TLSP # Transport Layer Security Protocolskip 57 SKIP # SKIPipv6-icmp 58 IPV6-ICMP icmp6 # ICMP for IPv6ipv6-nonxt 59 IPV6-NONXT # no next header for ipv6ipv6-opts 60 IPV6-OPTS # destination options for ipv6# 61 # any host internal protocolcftp 62 CFTP # CFTP# 63 # any local networksat-expak 64 SAT-EXPAK # SATNET and Backroom EXPAKkryptolan 65 KRYPTOLAN # Kryptolanrvd 66 RVD # MIT Remote Virtual Disk Protocolippc 67 IPPC # Internet Pluribus Packet Core# 68 # any distributed filesystemsat-mon 69 SAT-MON # SATNET Monitoringvisa 70 VISA # VISA Protocolipcv 71 IPCV # Internet Packet Core Utilitycpnx 72 CPNX # Computer Protocol Network Executivecphb 73 CPHB # Computer Protocol Heart Beatwsn 74 WSN # Wang Span Networkpvp 75 PVP # Packet Video Protocolbr-sat-mon 76 BR-SAT-MON # Backroom SATNET Monitoringsun-nd 77 SUN-ND # SUN ND PROTOCOL-Temporarywb-mon 78 WB-MON # WIDEBAND Monitoringwb-expak 79 WB-EXPAK # WIDEBAND EXPAKiso-ip 80 ISO-IP # ISO Internet Protocolvmtp 81 VMTP # Versatile Message Transportsecure-vmtp 82 SECURE-VMTP # SECURE-VMTPvines 83 VINES # VINESttp 84 TTP # TTP#iptm 84 IPTM # Protocol Internet Protocol Trafficnsfnet-igp 85 NSFNET-IGP # NSFNET-IGPdgp 86 DGP # Dissimilar Gateway Protocoltcf 87 TCF # TCFeigrp 88 EIGRP # Enhanced Interior Routing Protocol (Cisco)ospf 89 OSPFIGP # Open Shortest Path First IGPsprite-rpc 90 Sprite-RPC # Sprite RPC Protocollarp 91 LARP # Locus Address Resolution Protocolmtp 92 MTP # Multicast Transport Protocolax.25 93 AX.25 # AX.25 Framesipip 94 IPIP # Yet Another IP encapsulationmicp 95 MICP # Mobile Internetworking Control Pro.scc-sp 96 SCC-SP # Semaphore Communications Sec. Pro.etherip 97 ETHERIP # Ethernet-within-IP Encapsulationencap 98 ENCAP # Yet Another IP encapsulation# 99 # any private encryption schemegmtp 100 GMTP # GMTPifmp 101 IFMP # Ipsilon Flow Management Protocolpnni 102 PNNI # PNNI over IPpim 103 PIM # Protocol Independent Multicastaris 104 ARIS # ARISscps 105 SCPS # SCPSqnx 106 QNX # QNXa&#x2F;n 107 A&#x2F;N # Active Networksipcomp 108 IPComp # IP Payload Compression Protocolsnp 109 SNP # Sitara Networks Protocolcompaq-peer 110 Compaq-Peer # Compaq Peer Protocolipx-in-ip 111 IPX-in-IP # IPX in IPcarp 112 CARP vrrp # Common Address Redundancy Protocolpgm 113 PGM # PGM Reliable Transport Protocol# 114 # any 0-hop protocoll2tp 115 L2TP # Layer Two Tunneling Protocolddx 116 DDX # D-II Data Exchangeiatp 117 IATP # Interactive Agent Transfer Protocolstp 118 STP # Schedule Transfer Protocolsrp 119 SRP # SpectraLink Radio Protocoluti 120 UTI # UTIsmp 121 SMP # Simple Message Protocolsm 122 SM # SMptp 123 PTP # Performance Transparency Protocolisis 124 ISIS # ISIS over IPv4fire 125 FIREcrtp 126 CRTP # Combat Radio Transport Protocolcrudp 127 CRUDP # Combat Radio User Datagramsscopmce 128 SSCOPMCEiplt 129 IPLTsps 130 SPS # Secure Packet Shieldpipe 131 PIPE # Private IP Encapsulation within IPsctp 132 SCTP # Stream Control Transmission Protocolfc 133 FC # Fibre Channelrsvp-e2e-ignore 134 RSVP-E2E-IGNORE # Aggregation of RSVP for IP reservationsmobility-header 135 Mobility-Header # Mobility Support in IPv6udplite 136 UDPLite # The UDP-Lite Protocolmpls-in-ip 137 MPLS-IN-IP # Encapsulating MPLS in IPmanet 138 MANET # MANET Protocols (RFC5498)hip 139 HIP # Host Identity Protocol (RFC5201)shim6 140 SHIM6 # Shim6 Protocol (RFC5533)wesp 141 WESP # Wrapped Encapsulating Security Payload (RFC5840)rohc 142 ROHC # Robust Header Compression (RFC5858)# 138-254 # Unassignedpfsync 240 PFSYNC # PF Synchronization# 253-254 # Use for experimentation and testing (RFC3692)# 255 # Reserveddivert 258 DIVERT # Divert pseudo-protocol [non IANA] port 为知名的程序保留了端口 1234567891011121314151617181920212223# head -22 &#x2F;etc&#x2F;services# Network services, Internet style## Note that it is presently the policy of IANA to assign a single well-known# port number for both TCP and UDP; hence, officially ports have two entries# even if the protocol doesn&#39;t support UDP operations.## Updated from http:&#x2F;&#x2F;www.iana.org&#x2F;assignments&#x2F;port-numbers and other# sources like http:&#x2F;&#x2F;www.freebsd.org&#x2F;cgi&#x2F;cvsweb.cgi&#x2F;src&#x2F;etc&#x2F;services .# New ports will be added on request if they have been officially assigned# by IANA and used in the real-world or are needed by a debian package.# If you need a huge list of used numbers please install the nmap package.tcpmux 1&#x2F;tcp # TCP port service multiplexerecho 7&#x2F;tcpecho 7&#x2F;udpdiscard 9&#x2F;tcp sink nulldiscard 9&#x2F;udp sink nullsystat 11&#x2F;tcp usersdaytime 13&#x2F;tcpdaytime 13&#x2F;udpnetstat 15&#x2F;tcpqotd 17&#x2F;tcp quote The Host Table The host table is a simple text file that associates IP addresses with hostnames. On most Unix systems, the table is in the file /etc/hosts. Each table entry in /etc/hosts contains an IP address separated by whitespace from a list of hostnames associated with that address. Comments begin with #. 12345678910111213141516head -22 &#x2F;etc&#x2F;hosts### Host Database## localhost is used to configure the loopback interface# when the system is booting. Do not change this entry.##127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhost# 0.0.0.0 account.jetbrains.com# 0.0.0.0 www.jetbrains.com# Added by Docker Desktop# To allow the same kube context to work on the host and the container:127.0.0.1 kubernetes.docker.internal# End of section DNS overcomes both major weaknesses of the host table: • DNSscales well. It doesn’t rely on a single large table; it is a distributed database system that doesn’t bog down as the database grows. DNScurrently provides information on approximately 100,000,000 hosts, while fewer than 10,000 were listed in the host table. • DNSguarantees that new host information will be disseminated to the rest of the network as it is needed. DNSis a distributed hierarchical system for resolving hostnames into IP addresses. Under DNS, there is no central database with all of the Internet host information. The information is distributed among thousands of name servers organized into a hierarchy similar to the hierarchy of the Unix filesystem. DNShas a root domain at the top of the domain hierarchy that is served by a group of name servers called the root servers.","categories":[{"name":"network","slug":"network","permalink":"https://dreamerjonson.com/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://dreamerjonson.com/tags/network/"}]},{"title":"golang[88]-互斥锁与通道锁哪个更快","slug":"golang-88-互斥锁与通道锁哪个更快","date":"2019-09-06T02:22:14.000Z","updated":"2019-09-06T02:23:15.517Z","comments":true,"path":"2019/09/06/golang-88-互斥锁与通道锁哪个更快/","link":"","permalink":"https://dreamerjonson.com/2019/09/06/golang-88-%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E9%80%9A%E9%81%93%E9%94%81%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%BF%AB/","excerpt":"","text":"下面的程序来证明，极端情况下，互斥锁要比通道锁更快。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( \"sync\" \"testing\" \"time\")type center struct &#123; workers []*worker ch chan struct&#123;&#125; ch2 chan struct&#123;&#125; sema chan struct&#123;&#125;&#125;type worker struct &#123; sync.Mutex count int64&#125;func init()&#123; c.ch = make(chan struct&#123;&#125;,10) c.ch2 = make(chan struct&#123;&#125;,10) c.sema = make(chan struct&#123;&#125;,1) for i:=0;i&lt;4;i++&#123; w:= new(worker) c.workers = append(c.workers,w) go w.do() go w.do2() &#125;&#125;func(w *worker) do()&#123; for &#123; select &#123; case &lt;-c.ch: w.Lock() time.Sleep(1*time.Millisecond) w.Unlock() &#125; &#125;&#125;func(w *worker) do2()&#123; for &#123; select &#123; case &lt;-c.ch2: c.sema&lt;- struct&#123;&#125;&#123;&#125; time.Sleep(1*time.Millisecond) &lt;-c.sema &#125; &#125;&#125;var c centerfunc Benchmark1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; c.ch&lt;- struct&#123;&#125;&#123;&#125; &#125;&#125;func Benchmark2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; c.ch2&lt;- struct&#123;&#125;&#123;&#125; &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[87]-git commit提交的模版写法","slug":"golang-87-git提交的模版写法","date":"2019-09-05T14:11:46.000Z","updated":"2019-09-05T14:12:51.416Z","comments":true,"path":"2019/09/05/golang-87-git提交的模版写法/","link":"","permalink":"https://dreamerjonson.com/2019/09/05/golang-87-git%E6%8F%90%E4%BA%A4%E7%9A%84%E6%A8%A1%E7%89%88%E5%86%99%E6%B3%95/","excerpt":"","text":"被大哥教训了，提交的git commit 要规范 git commit提交的模版 1234567891011121314151617181920212223242526272829303132cat ~&#x2F;.git-commit-template.txt # &lt;type&gt;: (If applied, this commit will...) &lt;subject&gt; (Max 50 char)# |&lt;---- Using a Maximum Of 50 Characters ----&gt;|# Explain why this change is being made# |&lt;---- Try To Limit Each Line to a Maximum Of 72 Characters ----&gt;|# Provide links or keys to any relevant tickets, articles or other resources# Example: Github issue #23# --- COMMIT END ---# Type can be# feat (new feature)# fix (bug fix)# refactor (refactoring production code)# style (formatting, missing semi colons, etc; no code change)# docs (changes to documentation)# test (adding or refactoring tests; no production code change)# chore (updating grunt tasks etc; no production code change)# --------------------# Remember to# Capitalize the subject line# Use the imperative mood in the subject line# Do not end the subject line with a period# Separate subject from body with a blank line# Use the body to explain what and why vs. how# Can use multiple lines with &quot;-&quot; for bullet points in body# --------------------# For more information about this template, check out# https:&#x2F;&#x2F;gist.github.com&#x2F;adeekshith&#x2F;cd4c95a064977cdc6c50### ### %","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[86]-go-micro版本差异带来的问题f","slug":"golang-86-go-micro版本差异带来的问题f","date":"2019-08-27T12:03:54.000Z","updated":"2019-08-28T02:16:10.912Z","comments":true,"path":"2019/08/27/golang-86-go-micro版本差异带来的问题f/","link":"","permalink":"https://dreamerjonson.com/2019/08/27/golang-86-go-micro%E7%89%88%E6%9C%AC%E5%B7%AE%E5%BC%82%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98f/","excerpt":"","text":"起因 问题的起因在我的新项目中使用最新microv1.9.1版本调用发送邮件的follow.srv.push服务出现问题： 1&#123;&quot;id&quot;:&quot;go.micro.client&quot;,&quot;code&quot;:500,&quot;detail&quot;:&quot;&quot;,&quot;status&quot;:&quot;Internal Server Error&quot;&#125; 经过排查发现 go-micro 1.7以上含1.7 client发送给服务器端的fullmethod发生了改变。 从 /push.PushSrv/Push =&gt; /followme.srv.push.PushSrv/Push 从 /followme.trade-engine.TradeEngine/Close 到 /tradeengine.TradeEngine/Close 问题追踪 具体出现在 122行 github.com/micro/go-plugins1.0/client/grpc/grpc.go //method：/PushSrv.Push 1err :&#x3D; cc.Invoke(ctx, methodToGRPC(req.Endpoint(), req.Body()), req.Body(), rsp, grpc.CallContentSubtype(cf.String())) 变为了： go-micro@1.9/client/grpc/grpc.go //method：/followme.srv.push.PushSrv/Push 1err :&#x3D; cc.Invoke(ctx, methodToGRPC(req.Service(), req.Endpoint()), req.Body(), rsp, grpc.CallContentSubtype(cf.Name())) 导致访问出现问题。 go-micro代码改变commit地址：https://github.com/micro/go-micro/commit/d3a6297b17cb78602875440b62d88971346a0f05 解决办法 由于新版本的micro，req.Service()其实是注册的microName，那么是否可以将其变为Push？这样传递到服务器的fullmethod就变为了/push.PushSrv/Push。 但是，由于在micro的代码中，registery又需要microName从consul中拿到服务地址，因此可以从这里下手hook去consul中访问的服务名。 下面给出一段micro1.9 调用push的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( \"context\" \"fmt\" \"github.com/micro/go-micro\" \"github.com/micro/go-micro/client/selector\" \"github.com/micro/go-micro/registry\" \"github.com/micro/go-micro/registry/consul\" \"github.com/micro/go-micro/service/grpc\" \"gitlab.followme.com/CopyTradingGo/proto/src/push\" \"strconv\" \"time\")type NewRegistry struct &#123; C registry.Registry&#125;func (c NewRegistry) Init(opts...registry.Option) error &#123; return c.C.Init(opts...)&#125;func (c NewRegistry) Options() registry.Options &#123; return c.C.Options()&#125;func (c NewRegistry) Register(srv *registry.Service,opts ...registry.RegisterOption) error &#123; return c.C.Register(srv,opts...)&#125;func (c NewRegistry) Deregister(srv*registry.Service) error &#123; return c.C.Deregister(srv)&#125;func (c NewRegistry) GetService(s string) ([]*registry.Service, error) &#123; return c.C.GetService(\"followme.srv.push\")&#125;func (c NewRegistry) ListServices() ([]*registry.Service, error) &#123; return c.C.ListServices()&#125;func (c NewRegistry) Watch(opts...registry.WatchOption) (registry.Watcher, error) &#123; return c.C.Watch(opts...)&#125;func (c NewRegistry) String() string &#123; return c.C.String()&#125;func main()&#123; reg := consul.NewRegistry(func(op *registry.Options) &#123; op.Addrs = []string&#123; \"192.168.8.6:8500\", &#125; &#125;) service:= grpc.NewService( micro.Registry(reg), ) newreg:= NewRegistry&#123;C:reg&#125; service.Client().Options().Selector.Init(selector.Registry(newreg)) srv:= push.NewPushSrvService(\"push\", service.Client()) smsParams := []string&#123; \"demo\", strconv.FormatInt(int64(1), 10), strconv.FormatFloat(99.99, 'f', -1, 64), &#125; var req = new(push.PushRequest) req.Type = push.PushType_SMS req.Sender = \"guard\" req.ToUserId = 80 var sms = new(push.SMSRequest) sms.TemplateId = 100401 sms.Params = smsParams req.Sms = sms ctx:=context.Background() cc,_:= context.WithTimeout(ctx,5*time.Minute) result,err:= srv.Push(cc,req) fmt.Println(result,err)&#125; 一开始以为所有高版本的micro 调用低版本的micro都会出现问题。 但是我经过多次实验发现，micro1.9调用 trade-engine micro1.1版本ok。 我接着怀疑是不是trade-engine做了特殊处理。查看代码未发现问题。 我接着自己实验了用1.9版本micro 去调用自己的1.1版本 helloworld服务，仍然OK。 接着查看代码发现，1.9版本传递过来的fullmethod确实是/followme.trade-engine.Say/Hello 但是fullmethod拆分为了servise：Say 以及method：Hello。 只用到了这两个参数。 也就是说不管是1.9版本传递的/followme.trade-engine.Say/Hello 还是1.1版本传递的 /tradeEngine.Say/Hello,服务器只需要最后的Say/Hello。 所以即便是修改了fullmethod，仍然可以用高版本调用低版本。 问题：为何高版本不能调用Push？ push是C#维护，推测是C#对传递过去的fullmethod做了处理，必须要保证匹配。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"docker-push到 dockerhub-Harbor","slug":"docker-push到-dockerhub-Harbor","date":"2019-08-26T09:22:34.000Z","updated":"2019-08-26T09:24:18.067Z","comments":true,"path":"2019/08/26/docker-push到-dockerhub-Harbor/","link":"","permalink":"https://dreamerjonson.com/2019/08/26/docker-push%E5%88%B0-dockerhub-Harbor/","excerpt":"","text":"tag + 版本号 1docker build -t dockerhub.followme-internal.com&#x2F;deploy&#x2F;go-quant-backtest:v2.2.0.1 --no-cache . push 1docker push dockerhub.followme-internal.com&#x2F;deploy&#x2F;go-quant-backtest:v2.2.0.1","categories":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/tags/docker/"}]},{"title":"golang[85]-测试读锁的性能","slug":"golang-85-测试读锁的性能","date":"2019-08-21T12:45:21.000Z","updated":"2019-08-21T12:52:45.341Z","comments":true,"path":"2019/08/21/golang-85-测试读锁的性能/","link":"","permalink":"https://dreamerjonson.com/2019/08/21/golang-85-%E6%B5%8B%E8%AF%95%E8%AF%BB%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD/","excerpt":"","text":"测试读锁的性能 123456789101112131415161718192021222324252627282930313233package mainimport ( \"math/rand\" \"sync\" \"testing\" \"time\")var m map[int]stringvar lock sync.RWMutexfunc init()&#123; rand.Seed(time.Now().Unix()) m:=make(map[int]string,100000) for i:=0;i&lt;100000;i++&#123; m[i] = \"helloworld\" &#125;&#125;func Benchmark1(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; _ = m[rand.Int()%100000] &#125;&#125;func Benchmark2(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; lock.RLock() _ = m[rand.Int()%100000] lock.RUnlock() &#125;&#125; bench 1234567go test . -bench .goos: darwingoarch: amd64pkg: gitlab.followme.com/CopyTradingGo/tools/GRPC_TEST/test3Benchmark1-12 100000000 18.9 ns/opBenchmark2-12 50000000 29.4 ns/opPASS","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"测试读锁的性能","slug":"测试读锁的性能","date":"2019-08-21T12:44:51.000Z","updated":"2019-08-21T12:44:51.799Z","comments":true,"path":"2019/08/21/测试读锁的性能/","link":"","permalink":"https://dreamerjonson.com/2019/08/21/%E6%B5%8B%E8%AF%95%E8%AF%BB%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD/","excerpt":"","text":"","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"docker-save 到远程服务器","slug":"docker-save-到远程服务器","date":"2019-08-16T02:57:42.000Z","updated":"2019-08-21T09:01:07.509Z","comments":true,"path":"2019/08/16/docker-save-到远程服务器/","link":"","permalink":"https://dreamerjonson.com/2019/08/16/docker-save-%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"首先有一个docker Images 123docker build -t backtest --no-cache .docker save -o backtest.tar backtest:latestscp backtest.tar beta-quant:&#x2F;root&#x2F;deploy 另一台服务器解压 1docker load &lt; backtest2.tar 参考资料 https://medium.com/@sh.tsang/docker-tutorial-4-exporting-container-and-saving-image-c3a7d792cfb6","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[84]-http/pprof","slug":"golang-84-http-pprof","date":"2019-08-14T13:35:16.000Z","updated":"2019-09-17T01:33:49.753Z","comments":true,"path":"2019/08/14/golang-84-http-pprof/","link":"","permalink":"https://dreamerjonson.com/2019/08/14/golang-84-http-pprof/","excerpt":"","text":"pprof的使用 1import _ &quot;net&#x2F;http&#x2F;pprof&quot; 如果没有htpp服务器，则需要开一个goroutine 开启http go func() { log.Println(http.ListenAndServe(“localhost:6060”, nil)) }() 如果你本身就是一个http服务器，要注意直接添加可能没效果，因为其使用了默认的mux。 httprouter的使用办法： 123Route&#123;&quot;pprof&quot;, &quot;GET&quot;, &quot;&#x2F;debug&#x2F;*name&quot;, func(writer http.ResponseWriter, request *http.Request, params httprouter.Params) &#123; http.DefaultServeMux.ServeHTTP(writer,request)&#125; &#125;, If you’re using a github.com/gorilla/mux.Router you can simply hand off any request prefixed with /debug/ to the http.DefaultServeMux. 123import _ &quot;net&#x2F;http&#x2F;debug&quot;router :&#x3D; mux.NewRouter()router.PathPrefix(&quot;&#x2F;debug&#x2F;&quot;).Handler(http.DefaultServeMux) or 1234567func init() &#123; http.Handle(&quot;&#x2F;debug&#x2F;pprof&#x2F;&quot;, http.HandlerFunc(Index)) http.Handle(&quot;&#x2F;debug&#x2F;pprof&#x2F;cmdline&quot;, http.HandlerFunc(Cmdline)) http.Handle(&quot;&#x2F;debug&#x2F;pprof&#x2F;profile&quot;, http.HandlerFunc(Profile)) http.Handle(&quot;&#x2F;debug&#x2F;pprof&#x2F;symbol&quot;, http.HandlerFunc(Symbol)) http.Handle(&quot;&#x2F;debug&#x2F;pprof&#x2F;trace&quot;, http.HandlerFunc(Trace))&#125; 使用方式 go tool pprof http://localhost:6060/debug/pprof/goroutine go tool pprof http://localhost:6060/debug/pprof/heap go tool pprof http://localhost:6060/debug/pprof/threadcreate go tool pprof http://localhost:6060/debug/pprof/block go tool pprof http://localhost:6060/debug/pprof/mutex 会进入命令面板 常用的有top 查看cup： go tool pprof ./hyperkube http://192.168.1.7:9970/debug/pprof/profile heap 1234567891011– inuse_space: Means pprof is showing the amount of memory allocatedand not yet released.– inuse_objects: Means pprof is showing the amount of objects allocatedand not yet released.– alloc_space: Means pprof is showing the amount of memory allocated,regardless if it was released or not.– alloc_objects: Means pprof is showing the amount of objects allocated,– flat: Represents the memory allocated by a function and still held by thatfunction.– cum: Represents the memory allocated by a function or any other functionthat is called down the stack. trace 注意下面的代码对于cgo不支持 curl http://127.0.0.1:6060/debug/pprof/trace?seconds=20 &gt; trace.out go tool trace trace.out 如果吧下面的代码写入main函数中，会生成trace文件，但是注意，必须要程序停止后才能执行trace.out 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;os&quot; &quot;runtime&#x2F;trace&quot;)func main() &#123; &#x2F;&#x2F;trace go func() &#123; f, err :&#x3D; os.Create(&quot;trace.out&quot;) if err !&#x3D; nil &#123; panic(err) &#125; err &#x3D; trace.Start(f) if err !&#x3D; nil &#123; panic(err) &#125; defer func() &#123; trace.Stop() panic(f.Close()) &#125;() ch :&#x3D; make(chan os.Signal, 1) &#x2F;&#x2F;系统退出信号 signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT) select &#123; case &lt;-ch: return &#125; &#125;() &#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[83]-golang-mac交叉编译windows程序","slug":"golang-83-golang-mac交叉编译windows程序","date":"2019-07-19T06:31:55.000Z","updated":"2019-08-16T03:55:12.464Z","comments":true,"path":"2019/07/19/golang-83-golang-mac交叉编译windows程序/","link":"","permalink":"https://dreamerjonson.com/2019/07/19/golang-83-golang-mac%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91windows%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"安装mingw： 1$ brew install mingw-w64 编译x64 可执行 1CGO_ENABLED&#x3D;1 CC&#x3D;x86_64-w64-mingw32-gcc CXX&#x3D;x86_64-w64-mingw32-g++ GOOS&#x3D;windows GOARCH&#x3D;amd64 go build -x -v -ldflags &quot;-s -w&quot; -o test_x64.exe 静态库 1$ CGO_ENABLED&#x3D;1 CC&#x3D;x86_64-w64-mingw32-gcc CXX&#x3D;x86_64-w64-mingw32-g++ GOOS&#x3D;windows GOARCH&#x3D;amd64 go build -buildmode&#x3D;c-archive -x -v -ldflags &quot;-s -w&quot; -o bin&#x2F;x64&#x2F;x64.a main.go 动态库 将-buildmode=c-archive改为-buildmode=c-shared即可 编译x86 1$ CGO_ENABLED&#x3D;1 CC&#x3D;i686-w64-mingw32-gcc CXX&#x3D;i686-w64-mingw32-g++ GOOS&#x3D;windows GOARCH&#x3D;386 go build -x -v -ldflags &quot;-s -w&quot; -o test_x86.exe 静态库 1$ CGO_ENABLED&#x3D;1 CC&#x3D;i686-w64-mingw32-gcc CXX&#x3D;i686-w64-mingw32-g++ GOOS&#x3D;windows GOARCH&#x3D;386 go build -buildmode&#x3D;c-archive -x -v -ldflags &quot;-s -w&quot; -o bin&#x2F;x86&#x2F;x86.a main.go 动态库 将-buildmode=c-archive改为-buildmode=c-shared即可 参考资料 https://stackoverflow.com/questions/36915134/go-golang-cross-compile-from-mac-to-windows-fatal-error-windows-h-file-not-f","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"anaconda3-python-install","slug":"python-install","date":"2019-07-18T08:57:14.000Z","updated":"2019-08-05T10:26:18.503Z","comments":true,"path":"2019/07/18/python-install/","link":"","permalink":"https://dreamerjonson.com/2019/07/18/python-install/","excerpt":"","text":"下载适用的安装包 网址：https://www.anaconda.com/download/#macos 安装后 1234export PATH&#x3D;&#x2F;Users&#x2F;jackson&#x2F;anaconda3&#x2F;binconda listconda create env_name python&#x3D;3.7python 参考资料 https://blog.csdn.net/lq_547762983/article/details/81003528","categories":[{"name":"python","slug":"python","permalink":"https://dreamerjonson.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dreamerjonson.com/tags/python/"}]},{"title":"golang[82]-viper-","slug":"golang-82-viper","date":"2019-07-04T07:07:00.000Z","updated":"2019-07-04T07:08:04.375Z","comments":true,"path":"2019/07/04/golang-82-viper/","link":"","permalink":"https://dreamerjonson.com/2019/07/04/golang-82-viper/","excerpt":"","text":"viper中将map[interface{}]interface{}转换为map[string]interface{} 的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138func insensitiviseMap(m map[string]interface&#123;&#125;) &#123; for key, val := range m &#123; switch val.(type) &#123; case map[interface&#123;&#125;]interface&#123;&#125;: // nested map: cast and recursively insensitivise val = ToStringMap(val) insensitiviseMap(val.(map[string]interface&#123;&#125;)) case map[string]interface&#123;&#125;: // nested map: recursively insensitivise insensitiviseMap(val.(map[string]interface&#123;&#125;)) &#125; lower := strings.ToLower(key) if key != lower &#123; // remove old key (not lower-cased) delete(m, key) &#125; // update map m[lower] = val &#125;&#125;// ToString casts an interface to a string type.func ToString(i interface&#123;&#125;) string &#123; v, _ := ToStringE(i) return v&#125;// ToStringMap casts an interface to a map[string]interface&#123;&#125; type.func ToStringMap(i interface&#123;&#125;) map[string]interface&#123;&#125; &#123; v, _ := ToStringMapE(i) return v&#125;// ToStringMapE casts an interface to a map[string]interface&#123;&#125; type.func ToStringMapE(i interface&#123;&#125;) (map[string]interface&#123;&#125;, error) &#123; var m = map[string]interface&#123;&#125;&#123;&#125; switch v := i.(type) &#123; case map[interface&#123;&#125;]interface&#123;&#125;: for k, val := range v &#123; m[ToString(k)] = val &#125; return m, nil case map[string]interface&#123;&#125;: return v, nil case string: err := jsonStringToObject(v, &amp;m) return m, err default: return m, fmt.Errorf(\"unable to cast %#v of type %T to map[string]interface&#123;&#125;\", i, i) &#125;&#125;// ToStringE casts an interface to a string type.func ToStringE(i interface&#123;&#125;) (string, error) &#123; i = indirectToStringerOrError(i) switch s := i.(type) &#123; case string: return s, nil case bool: return strconv.FormatBool(s), nil case float64: return strconv.FormatFloat(s, 'f', -1, 64), nil case float32: return strconv.FormatFloat(float64(s), 'f', -1, 32), nil case int: return strconv.Itoa(s), nil case int64: return strconv.FormatInt(s, 10), nil case int32: return strconv.Itoa(int(s)), nil case int16: return strconv.FormatInt(int64(s), 10), nil case int8: return strconv.FormatInt(int64(s), 10), nil case uint: return strconv.FormatInt(int64(s), 10), nil case uint64: return strconv.FormatInt(int64(s), 10), nil case uint32: return strconv.FormatInt(int64(s), 10), nil case uint16: return strconv.FormatInt(int64(s), 10), nil case uint8: return strconv.FormatInt(int64(s), 10), nil case []byte: return string(s), nil case template.HTML: return string(s), nil case template.URL: return string(s), nil case template.JS: return string(s), nil case template.CSS: return string(s), nil case template.HTMLAttr: return string(s), nil case nil: return \"\", nil case fmt.Stringer: return s.String(), nil case error: return s.Error(), nil default: return \"\", fmt.Errorf(\"unable to cast %#v of type %T to string\", i, i) &#125;&#125;// jsonStringToObject attempts to unmarshall a string as JSON into// the object passed as pointer.func jsonStringToObject(s string, v interface&#123;&#125;) error &#123; data := []byte(s) return json.Unmarshal(data, v)&#125;// From html/template/content.go// Copyright 2011 The Go Authors. All rights reserved.// indirectToStringerOrError returns the value, after dereferencing as many times// as necessary to reach the base type (or nil) or an implementation of fmt.Stringer// or error,func indirectToStringerOrError(a interface&#123;&#125;) interface&#123;&#125; &#123; if a == nil &#123; return nil &#125; var errorType = reflect.TypeOf((*error)(nil)).Elem() var fmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem() v := reflect.ValueOf(a) for !v.Type().Implements(fmtStringerType) &amp;&amp; !v.Type().Implements(errorType) &amp;&amp; v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() &#123; v = v.Elem() &#125; return v.Interface()&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[81]-mac检查端口暴露","slug":"golang-81-golang-docker","date":"2019-06-18T03:59:30.000Z","updated":"2019-06-18T04:06:17.426Z","comments":true,"path":"2019/06/18/golang-81-golang-docker/","link":"","permalink":"https://dreamerjonson.com/2019/06/18/golang-81-golang-docker/","excerpt":"","text":"查看正在监听的端口 1lsof -iTCP -sTCP:LISTEN -n -P 查看端口是否在监听 12curl -v 192.168.5.192:11111lsof -i tcp:11111","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[80]-项目查看过时mod","slug":"golang-80-tips-go-mod","date":"2019-06-13T07:07:53.000Z","updated":"2019-06-14T02:13:03.218Z","comments":true,"path":"2019/06/13/golang-80-tips-go-mod/","link":"","permalink":"https://dreamerjonson.com/2019/06/13/golang-80-tips-go-mod/","excerpt":"","text":"I’m working on a large (oldish) project that I’ve just migrated to go modules ✅ The conversion of the old vendored files (govendor) has produced a large go.mod file with about 100 direct requires. Is there a tool/way of going through this list of requires and printing current version versus latest github version (ie find out-of-date modules)? For example: 12345678require ( github.com&#x2F;foo&#x2F;bar v1.2.0 ...)The latest tagged version of foo&#x2F;bar on github is v1.3.1, I&#39;d like to get a list like:package current latestgithub.com&#x2F;foo&#x2F;bar v1.2.0 v1.3.1 解决方案 123456go list -m -u all | column -tfubarcloud.google.com&#x2F;go v0.26.0 [v0.40.0]github.com&#x2F;BurntSushi&#x2F;toml v0.3.1github.com&#x2F;PuerkitoBio&#x2F;purell v1.1.0 [v1.1.1] 查看版本依赖 下面可以看出项目依赖了protobuf@v1.2.0版本 123456789&gt; go mod graph | grep github.com&#x2F;golang&#x2F;protobuf gitlab.followme.com&#x2F;FollowmeGo&#x2F;utils@v0.0.0-20190608152033-4ef278ca4fca github.com&#x2F;golang&#x2F;protobuf@v1.2.0gopkg.in&#x2F;gorethink&#x2F;gorethink.v4@v4.1.0 github.com&#x2F;golang&#x2F;protobuf@v1.2.0github.com&#x2F;hashicorp&#x2F;go-discover@v0.0.0-20190117190025-e88f86e24f50 github.com&#x2F;golang&#x2F;protobuf@v1.2.0github.com&#x2F;hashicorp&#x2F;go-plugin@v0.0.0-20190212232519-b838ffee39ce github.com&#x2F;golang&#x2F;protobuf@v1.2.0github.com&#x2F;onsi&#x2F;gomega@v1.4.3 github.com&#x2F;golang&#x2F;protobuf@v1.2.0google.golang.org&#x2F;appengine@v1.2.0 github.com&#x2F;golang&#x2F;protobuf@v1.2.0github.com&#x2F;hashicorp&#x2F;go-plugin@v0.0.0-20181030172320-54b6ff97d818 github.com&#x2F;golang&#x2F;protobuf@v1.2.0 参考 https://www.reddit.com/r/golang/comments/c00fw6/finding_whats_outofdate_in_gomod/","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"search-update-mod","slug":"search-update-mod","date":"2019-06-13T07:04:37.000Z","updated":"2019-06-13T07:04:37.073Z","comments":true,"path":"2019/06/13/search-update-mod/","link":"","permalink":"https://dreamerjonson.com/2019/06/13/search-update-mod/","excerpt":"","text":"","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"mac-info","slug":"mac-info","date":"2019-06-11T10:13:35.000Z","updated":"2019-06-11T10:18:12.409Z","comments":true,"path":"2019/06/11/mac-info/","link":"","permalink":"https://dreamerjonson.com/2019/06/11/mac-info/","excerpt":"","text":"##exec format error: 当出现这一个错误的时候，首先检查文件格式： file program 查看系统： uname -a mac cpu info 1sysctl machdep.cpu","categories":[{"name":"macOS","slug":"macOS","permalink":"https://dreamerjonson.com/categories/macOS/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://dreamerjonson.com/tags/macOS/"}]},{"title":"golang[79]-mac安装指定版本的protobuf","slug":"golang-79-protobuf","date":"2019-06-11T07:19:59.000Z","updated":"2019-12-11T07:35:57.461Z","comments":true,"path":"2019/06/11/golang-79-protobuf/","link":"","permalink":"https://dreamerjonson.com/2019/06/11/golang-79-protobuf/","excerpt":"","text":"查看版本 1protoc --version brew 安装 brew install protobuf brew 安装指定版本 12brew search protobufbrew reinstall protobuf@2.5 卸载 brew uninstall protobuf 方法2:源代码编译 1234567brew install automakehttps:&#x2F;&#x2F;github.com&#x2F;google&#x2F;protobuf&#x2F;releases 找到对应版本下载.&#x2F;autogen.sh.&#x2F;configuremakemake installprotoc --version &#x2F;&#x2F;如果有之前的版本记得删除 go-gen-protobuf https://github.com/golang/protobuf 12345git checkout v1.3.0cd proto-gen-gogo buildgo install即可在$GOPATH&#x2F;bin中看到 参考资料 https://blog.csdn.net/qq_21383435/article/details/81035852","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[78]-alfred-awgo","slug":"golang-78-alfred-awgo","date":"2019-05-24T03:11:34.000Z","updated":"2019-05-24T03:25:41.030Z","comments":true,"path":"2019/05/24/golang-78-alfred-awgo/","link":"","permalink":"https://dreamerjonson.com/2019/05/24/golang-78-alfred-awgo/","excerpt":"","text":"2、安装 go get -u github.com/jason0x43/go-alfred/alfred 3、任意位置新建一个工作目录alfred-web-searches，在内部新建一个文件夹workflow 4、alfred中新建workflow，打开其文件夹，将文件夹中的plist文件以及icon文件移动到 workflow 中 5、 工作目录alfred-web-searches中编写go文件 使用awgo 6、在alfred-web-searches所在目录执行 12&gt; alfred link&gt; alfred build go的执行文件会出现在workflow中 7、打开alfred，会看到多了一个workflow，双击打开。 会看到./alfred-web-searches $1 代表执行的文件以及输入参数等。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[77]-sed快速替换指定字母","slug":"golang-77-sed","date":"2019-05-20T12:25:10.000Z","updated":"2020-02-20T06:48:54.841Z","comments":true,"path":"2019/05/20/golang-77-sed/","link":"","permalink":"https://dreamerjonson.com/2019/05/20/golang-77-sed/","excerpt":"","text":"快速替换 快速替换当前文件夹中包含gitlab.followme.com/CopyTradingGo字符的所有go文件 的gitlab.followme.com/CopyTradingGo 替换为fmgo.io/trade 1sed -i &quot;&quot; &#39;s&#x2F;gitlab.followme.com\\&#x2F;CopyTradingGo&#x2F;fmgo.io\\&#x2F;trade&#x2F;g&#39; &#96;grep -Rl gitlab.followme.com&#x2F;CopyTradingGo . | grep &quot;.go&quot;&#96;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[76]-Reflection反射","slug":"golang-76-reflection","date":"2019-05-18T01:12:41.000Z","updated":"2019-05-28T06:27:20.334Z","comments":true,"path":"2019/05/18/golang-76-reflection/","link":"","permalink":"https://dreamerjonson.com/2019/05/18/golang-76-reflection/","excerpt":"","text":"Reflection is one of the advanced topics in Go. I will try to make it as simple as possible. This tutorial has the following sections. What is reflection? What is the need to inspect a variable and find its type? reflect package reflect.Type and reflect.Value reflect.Kind NumField() and Field() methods Int() and String() methods Complete program Should reflection be used? Let’s discuss these sections one by one now. What is reflection? Reflection is the ability of a program to inspect its variables and values at run time and find their type. You might not understand what this means but that’s alright. You will get a clear understanding of reflection by the end of this tutorial, so stay with me. What is the need to inspect a variable and find its type? The first question anyone gets when learning about reflection is why do we even need to inspect a variable and find its type at runtime when each and every variable in our program is defined by us and we know its type at compile time itself. Well this is true most of the times, but not always. Let me explain what I mean. Let’s write a simple program. 12345678910package mainimport ( &quot;fmt&quot;)func main() &#123; i :&#x3D; 10 fmt.Printf(&quot;%d %T&quot;, i, i)&#125; In the program above, the type of i is known at compile time and we print it in the next line. Nothing magical here. Now let’s understand the need to know the type of a variable at run time. Let’s say we want to write a simple function which will take a struct as argument and will create a SQL insert query using it. Consider the following program, 123456789101112131415161718package mainimport ( \"fmt\")type order struct &#123; ordId int customerId int&#125;func main() &#123; o := order&#123; ordId: 1234, customerId: 567, &#125; fmt.Println(o)&#125; We need to write a function which will take the struct o in the program above as an argument and return the following SQL insert query, insert into order values(1234, 567) This function is simple to write. Lets do that now. 1234567891011121314151617181920212223package mainimport ( \"fmt\")type order struct &#123; ordId int customerId int&#125;func createQuery(o order) string &#123; i := fmt.Sprintf(\"insert into order values(%d, %d)\", o.ordId, o.customerId) return i&#125;func main() &#123; o := order&#123; ordId: 1234, customerId: 567, &#125; fmt.Println(createQuery(o))&#125; The createQuery function in line no. 12 creates the insert query by using the ordId and customerId fields of o. This program will output, 1insert into order values(1234, 567) Now lets take our query creator to the next level. What if we want to generalize our query creator and make it work on any struct. Let me explain what I mean using a program. 123456789101112131415161718192021package maintype order struct &#123; ordId int customerId int&#125;type employee struct &#123; name string id int address string salary int country string&#125;func createQuery(q interface&#123;&#125;) string &#123; &#125;func main() &#123;&#125; Our objective is to finish the createQuery function in line no. 16 of the above program so that it takes any struct as argument and creates an insert query based on the struct fields. For example, if we pass the struct below 12345o :&#x3D; order &#123; ordId: 1234, customerId: 567&#125;&#96;&#96; Our createQuery function should return, insert into order values (1234, 567) 123456789Similarly if we passe :&#x3D; employee &#123; name: &quot;Naveen&quot;, id: 565, address: &quot;Science Park Road, Singapore&quot;, salary: 90000, country: &quot;Singapore&quot;, &#125; it should return, 1insert into employee values(&quot;Naveen&quot;, 565, &quot;Science Park Road, Singapore&quot;, 90000, &quot;Singapore&quot;) Since the createQuery function should work with any struct, it takes a interface{} as argument. For simplicity, we will only deal with structs that contain fields of type string and int but this can be extended for any type. The createQuery function should work on any struct. The only way to write this function is to examine the type of the struct argument passed to it at run time, find its fields and then create the query. This is where reflection is useful. In the next steps of the tutorial, we will learn how we can achieve this using the reflect package. reflect package The reflect package implements run-time reflection in Go. The reflect package helps to identify the underlying concrete type and the value of a interface{} variable. This is exactly what we need. The createQuery function takes a interface{} argument and the query needs to be created based on the concrete type and value of the interface{} argument. This is exactly what the reflect package helps in doing. There are a few types and methods in the reflect package which we need to know first before writing our generic query generator program. Lets look at them one by one. reflect.Type and reflect.Value The concrete type of interface{} is represented by reflect.Type and the underlying value is represented by reflect.Value. There are two functions reflect.TypeOf() and reflect.ValueOf() which return the reflect.Type and reflect.Value respectively. These two types are the base to create our query generator. Let’s write a simple example to understand these two types. 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"reflect\")type order struct &#123; ordId int customerId int&#125;func createQuery(q interface&#123;&#125;) &#123; t := reflect.TypeOf(q) v := reflect.ValueOf(q) fmt.Println(\"Type \", t) fmt.Println(\"Value \", v)&#125;func main() &#123; o := order&#123; ordId: 456, customerId: 56, &#125; createQuery(o)&#125; In the program above, the createQuery function in line no. 13 takes a interface{} as argument. The function reflect.TypeOf in line no. 14 takes a interface{} as argument and returns the reflect.Type containing the concrete type of the interface{} argument passed. Similarly the reflect.ValueOf function in line no. 15 takes a interface{} as argument and returns the reflect.Value which contains the underlying value of the interface{} argument passed. The above program prints, Type main.order Value {456 56} From the output, we can see that the program prints the concrete type and the value of the interface. reflect.Kind There is one more important type in the reflection package called Kind. The types Kind and Type in the reflection package might seem similar but they have a difference which will be clear from the program below. 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type order struct &#123; ordId int customerId int&#125;func createQuery(q interface&#123;&#125;) &#123; t :&#x3D; reflect.TypeOf(q) k :&#x3D; t.Kind() fmt.Println(&quot;Type &quot;, t) fmt.Println(&quot;Kind &quot;, k)&#125;func main() &#123; o :&#x3D; order&#123; ordId: 456, customerId: 56, &#125; createQuery(o)&#125; The program above outputs, Type main.order Kind struct I think you will now be clear about the differences between the two. Type represents the actual type of the interface{}, in this case main.Order and Kind represents the specific kind of the type. In this case, it’s a struct. NumField() and Field() methods The NumField() method returns the number of fields in a struct and the Field(i int) method returns the reflect.Value of the ith field. 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"reflect\")type order struct &#123; ordId int customerId int&#125;func createQuery(q interface&#123;&#125;) &#123; if reflect.ValueOf(q).Kind() == reflect.Struct &#123; v := reflect.ValueOf(q) fmt.Println(\"Number of fields\", v.NumField()) for i := 0; i &lt; v.NumField(); i++ &#123; fmt.Printf(\"Field:%d type:%T value:%v\\n\", i, v.Field(i), v.Field(i)) &#125; &#125;&#125;func main() &#123; o := order&#123; ordId: 456, customerId: 56, &#125; createQuery(o)&#125; In the program above, in line no. 14 we first check whether the Kind of q is a struct because the NumField method works only on struct. The rest of the program is self explanatory. This program outputs, Number of fields 2 Field:0 type:reflect.Value value:456 Field:1 type:reflect.Value value:56 Int() and String() methods The methods Int and String help extract the reflect.Value as an int64 and string respectively. 12345678910111213141516package mainimport ( \"fmt\" \"reflect\")func main() &#123; a := 56 x := reflect.ValueOf(a).Int() fmt.Printf(\"type:%T value:%v\\n\", x, x) b := \"Naveen\" y := reflect.ValueOf(b).String() fmt.Printf(\"type:%T value:%v\\n\", y, y)&#125; In the program above, in line no. 10, we extract the reflect.Value as an int64 and in line no. 13, we extract it as string. This program prints, 12type:int64 value:56 type:string value:Naveen Complete Program Now that we have enough knowledge to finish our query generator, lets go ahead and do it. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"fmt\" \"reflect\")type order struct &#123; ordId int customerId int&#125;type employee struct &#123; name string id int address string salary int country string&#125;func createQuery(q interface&#123;&#125;) &#123; if reflect.ValueOf(q).Kind() == reflect.Struct &#123; t := reflect.TypeOf(q).Name() query := fmt.Sprintf(\"insert into %s values(\", t) v := reflect.ValueOf(q) for i := 0; i &lt; v.NumField(); i++ &#123; switch v.Field(i).Kind() &#123; case reflect.Int: if i == 0 &#123; query = fmt.Sprintf(\"%s%d\", query, v.Field(i).Int()) &#125; else &#123; query = fmt.Sprintf(\"%s, %d\", query, v.Field(i).Int()) &#125; case reflect.String: if i == 0 &#123; query = fmt.Sprintf(\"%s\\\"%s\\\"\", query, v.Field(i).String()) &#125; else &#123; query = fmt.Sprintf(\"%s, \\\"%s\\\"\", query, v.Field(i).String()) &#125; default: fmt.Println(\"Unsupported type\") return &#125; &#125; query = fmt.Sprintf(\"%s)\", query) fmt.Println(query) return &#125; fmt.Println(\"unsupported type\")&#125;func main() &#123; o := order&#123; ordId: 456, customerId: 56, &#125; createQuery(o) e := employee&#123; name: \"Naveen\", id: 565, address: \"Coimbatore\", salary: 90000, country: \"India\", &#125; createQuery(e) i := 90 createQuery(i)&#125; In line no. 22, we first check whether the passed argument is a struct. In line no. 23 we get the name of the struct from its reflect.Type using the Name() method. In the next line, we use t and start creating the query. The case statement in line. 28 checks whether the current field is reflect.Int, if that’s the case we extract the value of that field as int64 using the Int() method. The if else statement is used to handle edge cases. Please add logs to understand why it is needed. Similar logic is used to extract the string in line no. 34. We have also added checks to prevent the program from crashing when unsupported types are passed to the createQuery function. The rest of the program is self explanatory. I recommend adding logs at appropriate places and checking their output to understand this program better. This program prints, 123insert into order values(456, 56) insert into employee values(&quot;Naveen&quot;, 565, &quot;Coimbatore&quot;, 90000, &quot;India&quot;) unsupported type I would leave it as an exercise for the reader to add the field names to the output query. Please try changing the program to print query of the format, insert into order(ordId, customerId) values(456, 56) Should reflection be used? Having shown a practical use of reflection, now comes the real question. Should you be using reflection? I would like to quote Rob Pike’s proverb on the use of reflection which answers this question. Clear is better than clever. Reflection is never clear. Reflection is a very powerful and advanced concept in Go and it should be used with care. It is very difficult to write clear and maintainable code using reflection. It should be avoided wherever possible and should be used only when absolutely necessary. This brings us to and end of this tutorial. Hope you enjoyed it. Have a good day. Like my tutorials? Please show your support by donating. Your donations will help me create more awesome tutorials.","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[75]-docker中编译go mod","slug":"golang-75-useDocker","date":"2019-05-16T14:19:47.000Z","updated":"2019-05-28T05:59:33.057Z","comments":true,"path":"2019/05/16/golang-75-useDocker/","link":"","permalink":"https://dreamerjonson.com/2019/05/16/golang-75-useDocker/","excerpt":"","text":"在docker中编译 Go mod程序。 并且可以用到gitlab的私有仓库： 123456789101112131415FROM golang:alpineRUN apk updateRUN apk add --no-cache gitRUN apk add opensshADD id_ed25519 &#x2F;root&#x2F;.ssh&#x2F;id_ed25519RUN chmod 600 &#x2F;root&#x2F;.ssh&#x2F;id_ed25519RUN echo -e &quot;[url \\&quot;git@gitlab.followme.com:\\&quot;]\\n\\tinsteadOf &#x3D; https:&#x2F;&#x2F;gitlab.followme.com&#x2F;&quot; &gt;&gt; &#x2F;root&#x2F;.gitconfig# Skip Host verification for gitRUN echo &quot;StrictHostKeyChecking no &quot; &gt; &#x2F;root&#x2F;.ssh&#x2F;configWORKDIR &#x2F;contourCOPY . .RUN go build -o remote -v viperRemote&#x2F;viperRemote.goENTRYPOINT [&quot;.&#x2F;remote&quot;] https://medium.com/paperchain/fetching-private-github-repos-from-a-docker-container-273f25ec5a74","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"mac-effitive","slug":"a-mac-effitive","date":"2019-05-15T07:20:17.000Z","updated":"2019-07-01T03:23:11.251Z","comments":true,"path":"2019/05/15/a-mac-effitive/","link":"","permalink":"https://dreamerjonson.com/2019/05/15/a-mac-effitive/","excerpt":"","text":"按住 ⌥Option 键来快捷缩放窗口 窗口管理应该是每个用户都会有的需求，如果你还没有窗口管理工具，可以在我派搜索到许多款质量不俗的。但如果你不想受制于这些工具硬性规定的窗口尺寸，在某些场景下需要手动调整，按住 ⌥Option 键再缩放窗口则可以获得更加快捷的体验。 而除此之外，你还可以将常用的文件及文件夹拖拽到 Finder 工具栏，形成快捷入口，只要按住 ⌘Command 键并拖动目标，看到绿色的加号再释放即可，下次使用就不用再「翻箱倒柜」一番了。 Parallels Desktop 共享文件夹 下载ubuntu 共享目录挂载在/media/psf 链接 ln -srf /media/psf/src $GOPATH/src 在ubuntu中使用桥接模式 步骤 命令 说明 步骤1 sudo su 切换至root用户，ubuntu缺省下root用户有所限制，使用sudo su可以使用当前管理用户的密码切换至root用户，也可以在需要安装权限的命令前加sudo 步骤2 apt install openssh-server 安装openssh-server 步骤3 ssh -V 确认openssh-server版本 步骤4 /etc/init.d/ssh status 确认openssh-server状态 步骤5 /etc/init.d/ssh restart 重新启动 openssh-server 步骤6 vim /etc/ssh/sshd.config 添加：PermisionRootLogin YES 步骤7 passwd 输入新的密码 步骤8 ifconfig 获取ip 步骤9 ssh root@10.211.55.4 输入新设置的密码 从终端使用ssh命令连接确认ssh -p 22 userkunyu@119.29.37.63 输入密码： 任务管理工具——things 3 快捷键： ⌘ + N Create a new to-do Space Create a new to-do below selection ⌘ + ⇧ + C Create a checklist in an open to-do ⌘ + ⇧ + N Create a new heading in a project ⌘ + D Duplicate a to-do or project ⌘ + C Copy a to-do or project ⌘ + V Paste a to-do or project ⌘ + . Complete selected items ⌘ + ⌥ + . Cancel selected items Delete Delete selected items ⇧ + ↑ Extend selection upwards ⇧ + ↓ Extend selection downwards ⌥ + ⇧ + ↑ Extend selection to the top ⌥ + ⇧ + ↓ Extend selection to the bottom ⌘ + A Select everything ⌘ + S Show Jump Start ⌘ + T Start Today","categories":[{"name":"mac","slug":"mac","permalink":"https://dreamerjonson.com/categories/mac/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://dreamerjonson.com/tags/mac/"}]},{"title":"golang[74]-goland-技巧","slug":"golang-74-goland-tips","date":"2019-05-11T01:59:34.000Z","updated":"2019-07-04T09:36:48.502Z","comments":true,"path":"2019/05/11/golang-74-goland-tips/","link":"","permalink":"https://dreamerjonson.com/2019/05/11/golang-74-goland-tips/","excerpt":"","text":"Implement Interface Implement Interface is a hidden gem that can be found by using the common Intellij keystroke combo ⌥ (Option/Alt) + Enter on the struct that you wish to implement the interface. This will open a search window, and you can type the interface that you wish to implement. Extract Interface I wish this had a great keyboard combination, but it doesn’t currently by default. If you wish to extract an interface, then you need to Right-Click on struct → Refactor → Extract → Interface. Once the menu pops up it asks you more information, name, file to add to, package…etc. I still use this quite often. you can consider Ctrl+T 6 (Refactor this) as a shortcut for Extract interface Live Templates Live templates are awesome for quickly generating some code that you commonly use. In general, you type in a few characters and then hit tab. Some built in live templates are forr which generates a for range loop (you need the extra “r”) and err which allow you to handle errors quickly. These are really powerful because you can also create your own live templates. For example, if you have a common logging framework when you logged “info” you could create logi as your own template which would generate your “log.info” statement. If you have a hard time remembering these, just remember one keyboard combo: ⌘ (Command) + j — this will show you all available templates within the context of the block of code where your cursor is at. Enjoy these examples below: forr — for range loop To execute this live template, just type “forr” + tab 3b. err — check for error and handle To execute this live template, just type “err” + tab Fill Struct I am not exactly sure when this was released, but it is glorious. If are familiar constructors in Java or C#, then you were used to a little IDE help when you instantiated a new class. This gives you that same power (albeit a little more clunky). In this case, if you have a struct that you are creating, then if you put your cursor between the brackets {}, then hit ⌥ (Option/Alt) + Enter, it will give you the option of “Fill Struct” or “Fill Struct Recursively”. Choose one. Save your typing for some other fun code, and let this thing do its work! Generate test cases/test file This is probably my favorite. I am pretty passionate about writing testable code and unit testing in general. I really think that writing testable code using SOLID principles will help you design better and more maintainable code. I found this nugget pretty early in my golang learnings, but it is definitely my most used feature. If you put your cursor on a method, type ⌘ (Command) + n , and this will bring up the “Generate” menu, and from here you can select “Test for function” or “Test for file” and if the _test.go file doesn’t exist, it will create it for you along with the outline of parameterized/table tests for your functions. Pretty awesome. Refactorings Refactorings is another fundamental need one may have when making changes to a program. With GoLand, you can extract a function from an expression at the caret, or from a group of selected statements, by using the dedicated Extract action (Alt+Ctrl+M for Windows/Linux and Alt+Cmd+M for macOS), or selecting the Method option in the generic Refactor This popup (Ctrl+T): The same refactoring is available for variables (Alt+Ctrl+V for Windows/Linux and Alt+Cmd+V for macOS) and constants (Alt+Ctrl+V for Windows/Linux and Alt+Cmd+V for macOS). You can inline a constant, or variable at the caret by using the dedicated Extract action (Alt+Ctrl+M for Windows/Linux and Alt+Cmd+M for macOS), or select the Inline option in the generic Refactor This popup (Ctrl+T). The IDE will update all references to the symbol and replace them with the value: Navigation One thing that you do more often than write code is read code. GoLand helps here as well. For example, the IDE lets you instantly navigate to an interface implemented by the type at the caret with one click: either by clicking the icon on the left side of the editor, using the dedicated Show Interfaces (Ctrl+U for Windows/Linux and Cmd+U for macOS) action, or by using the corresponding intention action: A similar icon, dedicated action (Show Implementations via Ctrl+B for Windows/Linux and Cmd+B for macOS) and intention action can navigate you to types that implement the interface at the caret. Every time you see a popup with a list of symbols, be it usages, implementations, implemented interfaces or completion suggestions, you can call Quick Definition (Ctrl+Shift+I for Windows/Linux or Cmd+Y for macOS) or Quick Documentation (Ctrl+Q for Windows/Linux and Ctrl+J for macOS) to have another popup open aside it with the definition or documentation for the selected symbol: Navigate back/forward ⌘[ ⌘] Expand or collapse a code block in the editor ⌘+ ⌘- shift Show implementation ⌥⌘B ⌘B Quick definition ⌥Space Search everywhere Double Shift importtant ⌘E Navigate to type hierarchy ⌃H Move the current line of code ⇧⌘↑ ⇧⌘↓ Duplicate a line of code ⌘D Remove a line of code ⌘⌫ Comment or uncomment a line of code ⌘/ Comment a block of code ⌥⌘/ Find in the currently opened file ⌘F Find and replace in the current file ⌘R Next occurrence ⌘G Previous occurrence ⇧⌘G Navigate between opened tabs ⇧⌘] ⇧⌘[ Navigate back/forward ⌘[ ⌘] Expand or collapse a code block in the editor ⌘+ ⌘- Create new... ⌘N When you access Basic Completion by pressing ⌃Space, you get basic suggestions for variables, types, methods, expressions, and so on. The Smart Completion feature is aware of the expected type and data flow, and offers the options relevant to the context. To call Smart Completion, press ⌃⇧Space. Quick definition ⌥Space Show implementation ⌥⌘B Extract variable ⌥⌘V Extract constant ⌥⌘C Extract function ⌥⌘M If what you're looking for is plain text, use Find in Path by pressing ⇧⌘F. Just press ⌥F7 and get a list of references grouped by usage type, Run ⌃R Debug ⌃D ⌥+F7 查看引用 参考 https://medium.com/@andrey_cheptsov/golands-take-on-go-development-7d2611b14b99 https://www.jetbrains.com/help/go/discover-goland.html select in project view","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[73]-context详解","slug":"golang-73-context","date":"2019-05-09T09:12:56.000Z","updated":"2019-10-19T07:55:01.659Z","comments":true,"path":"2019/05/09/golang-73-context/","link":"","permalink":"https://dreamerjonson.com/2019/05/09/golang-73-context/","excerpt":"","text":"背景 golang在1.6.2的时候还没有自己的context，在1.7的版本中就把golang.org/x/net/context包被加入到了官方的库中。golang 的 Context包，是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。 比如有一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。这样的话， 我们就可以通过Context，来跟踪这些goroutine，并且通过Context来控制他们的目的，这就是Go语言为我们提供的Context，中文可以称之为“上下文”。 另外一个实际例子是，在Go服务器程序中，每个请求都会有一个goroutine去处理。然而，处理程序往往还需要创建额外的goroutine去访问后端资源，比如数据库、RPC服务等。由于这些goroutine都是在处理同一个请求，所以它们往往需要访问一些共享的资源，比如用户身份信息、认证token、请求截止时间等。而且如果请求超时或者被取消后，所有的goroutine都应该马上退出并且释放相关的资源。这种情况也需要用Context来为我们取消掉所有goroutine 如果要使用可以通过 go get golang.org/x/net/context 命令获取这个包。 Context 定义 ontext的主要数据结构是一种嵌套的结构或者说是单向的继承关系的结构，比如最初的context是一个小盒子，里面装了一些数据，之后从这个context继承下来的children就像在原本的context中又套上了一个盒子，然后里面装着一些自己的数据。或者说context是一种分层的结构，根据使用场景的不同，每一层context都具备有一些不同的特性，这种层级式的组织也使得context易于扩展，职责清晰。 context 包的核心是 struct Context，声明如下： 1234567891011type Context interface &#123;Deadline() (deadline time.Time, ok bool)Done() &lt;-chan struct&#123;&#125;Err() errorValue(key interface&#123;&#125;) interface&#123;&#125;&#125; 可以看到Context是一个interface，在golang里面，interface是一个使用非常广泛的结构，它可以接纳任何类型。Context定义很简单，一共4个方法，我们需要能够很好的理解这几个方法 Deadline方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。 Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。 Err方法返回取消的错误原因，因为什么Context被取消。 Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。 Context 的实现方法 Context 虽然是个接口，但是并不需要使用方实现，golang内置的context 包，已经帮我们实现了2个方法，一般在代码中，开始上下文的时候都是以这两个作为最顶层的parent context，然后再衍生出子context。这些 Context 对象形成一棵树：当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。两个实现如下： 12345678910111213141516var ( background = new(emptyCtx) todo = new(emptyCtx))func Background() Context &#123; return background&#125;func TODO() Context &#123; return todo&#125; 一个是Background，主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。 一个是TODO，如果我们不知道该使用什么Context的时候，可以使用这个，但是实际应用中，暂时还没有使用过这个TODO。 他们两个本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。 123456789101112131415161718192021type emptyCtx intfunc (*emptyCtx) Deadline() (deadline time.Time, ok bool) &#123; return&#125;func (*emptyCtx) Done() &lt;-chan struct&#123;&#125; &#123; return nil&#125;func (*emptyCtx) Err() error &#123; return nil&#125;func (*emptyCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123; return nil&#125; Context 的 继承 有了如上的根Context，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。 1234567func WithCancel(parent Context) (ctx Context, cancel CancelFunc)func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)func WithValue(parent Context, key, val interface&#123;&#125;) Context 通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。 WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。 WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。 WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。 WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。 With 系列函数详解 WithCancel context.WithCancel生成了一个withCancel的实例以及一个cancelFuc，这个函数就是用来关闭ctxWithCancel中的 Done channel 函数。 下面来分析下源码实现，首先看看初始化，如下： 123456789101112func newCancelCtx(parent Context) cancelCtx &#123; return cancelCtx&#123; Context: parent, done: make(chan struct&#123;&#125;), &#125;&#125;func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123; c :&#x3D; newCancelCtx(parent) propagateCancel(parent, &amp;c) return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;&#125; newCancelCtx返回一个初始化的cancelCtx，cancelCtx结构体继承了Context，实现了canceler方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//*cancelCtx 和 *timerCtx 都实现了canceler接口，实现该接口的类型都可以被直接canceledtype canceler interface &#123; cancel(removeFromParent bool, err error) Done() &lt;-chan struct&#123;&#125;&#125;type cancelCtx struct &#123; Context done chan struct&#123;&#125; // closed by the first cancel call. mu sync.Mutex children map[canceler]bool // set to nil by the first cancel call err error // 当其被cancel时将会把err设置为非nil&#125;func (c *cancelCtx) Done() &lt;-chan struct&#123;&#125; &#123; return c.done&#125;func (c *cancelCtx) Err() error &#123; c.mu.Lock() defer c.mu.Unlock() return c.err&#125;func (c *cancelCtx) String() string &#123; return fmt.Sprintf(\"%v.WithCancel\", c.Context)&#125;//核心是关闭c.done//同时会设置c.err = err, c.children = nil//依次遍历c.children，每个child分别cancel//如果设置了removeFromParent，则将c从其parent的children中删除func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123; if err == nil &#123; panic(\"context: internal error: missing cancel error\") &#125; c.mu.Lock() if c.err != nil &#123; c.mu.Unlock() return // already canceled &#125; c.err = err close(c.done) for child := range c.children &#123; // NOTE: acquiring the child's lock while holding parent's lock. child.cancel(false, err) &#125; c.children = nil c.mu.Unlock() if removeFromParent &#123; removeChild(c.Context, c) // 从此处可以看到 cancelCtx的Context项是一个类似于parent的概念 &#125;&#125; 可以看到，所有的children都存在一个map中；Done方法会返回其中的done channel， 而另外的cancel方法会关闭Done channel并且逐层向下遍历，关闭children的channel，并且将当前canceler从parent中移除。 WithCancel初始化一个cancelCtx的同时，还执行了propagateCancel方法，最后返回一个cancel function。 propagateCancel 方法定义如下： 123456789101112131415161718192021222324252627// propagateCancel arranges for child to be canceled when parent is.func propagateCancel(parent Context, child canceler) &#123; if parent.Done() == nil &#123; return // parent is never canceled &#125; if p, ok := parentCancelCtx(parent); ok &#123; p.mu.Lock() if p.err != nil &#123; // parent has already been canceled child.cancel(false, p.err) &#125; else &#123; if p.children == nil &#123; p.children = make(map[canceler]struct&#123;&#125;) &#125; p.children[child] = struct&#123;&#125;&#123;&#125; &#125; p.mu.Unlock() &#125; else &#123; go func() &#123; select &#123; case &lt;-parent.Done(): child.cancel(false, parent.Err()) case &lt;-child.Done(): &#125; &#125;() &#125;&#125; propagateCancel 的含义就是传递cancel，从当前传入的parent开始（包括该parent），向上查找最近的一个可以被cancel的parent， 如果找到的parent已经被cancel，则将方才传入的child树给cancel掉，否则，将child节点直接连接为找到的parent的children中（Context字段不变，即向上的父亲指针不变，但是向下的孩子指针变直接了）； 如果没有找到最近的可以被cancel的parent，即其上都不可被cancel，则启动一个goroutine等待传入的parent终止，则cancel传入的child树，或者等待传入的child终结。 WithDeadLine 在withCancel的基础上进行的扩展，如果时间到了之后就进行cancel的操作，具体的操作流程基本上与withCancel一致，只不过控制cancel函数调用的时机是有一个timeout的channel所控制的。 Context 使用原则 和 技巧 不要把Context放在结构体中，要以参数的方式传递，parent Context一般为Background 应该要把Context作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名建议都统一，如ctx。 给一个函数方法传递Context的时候，不要传递nil，否则在tarce追踪的时候，就会断了连接 Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递 Context是线程安全的，可以放心的在多个goroutine中传递 可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。 Context的常用方法实例 调用Context Done方法取消 12345678910111213141516func Stream(ctx context.Context, out chan&lt;- Value) error &#123; for &#123; v, err := DoSomething(ctx) if err != nil &#123; return err &#125; select &#123; case &lt;-ctx.Done(): return ctx.Err() case out &lt;- v: &#125; &#125;&#125; 2、通过 context.WithValue 来传值 12345678910111213141516171819202122232425262728func main() &#123; ctx, cancel := context.WithCancel(context.Background()) valueCtx := context.WithValue(ctx, key, \"add value\") go watch(valueCtx) time.Sleep(10 * time.Second) cancel() time.Sleep(5 * time.Second)&#125;func watch(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): //get value fmt.Println(ctx.Value(key), \"is cancel\") return default: //get value fmt.Println(ctx.Value(key), \"int goroutine\") time.Sleep(2 * time.Second) &#125; &#125;&#125; 3、超时取消 context.WithTimeout 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"fmt\" \"sync\" \"time\" \"golang.org/x/net/context\")var ( wg sync.WaitGroup)func work(ctx context.Context) error &#123; defer wg.Done() for i := 0; i &lt; 1000; i++ &#123; select &#123; case &lt;-time.After(2 * time.Second): fmt.Println(\"Doing some work \", i) // we received the signal of cancelation in this channel case &lt;-ctx.Done(): fmt.Println(\"Cancel the context \", i) return ctx.Err() &#125; &#125; return nil&#125;func main() &#123; ctx, cancel := context.WithTimeout(context.Background(), 4*time.Second) defer cancel() fmt.Println(\"Hey, I'm going to do some work\") wg.Add(1) go work(ctx) wg.Wait() fmt.Println(\"Finished. I'm going home\")&#125; 4、截止时间 取消 context.WithDeadline 123456789101112131415161718192021222324package mainimport ( \"context\" \"fmt\" \"time\")func main() &#123; d := time.Now().Add(1 * time.Second) ctx, cancel := context.WithDeadline(context.Background(), d) // Even though ctx will be expired, it is good practice to call its // cancelation function in any case. Failure to do so may keep the // context and its parent alive longer than necessary. defer cancel() select &#123; case &lt;-time.After(2 * time.Second): fmt.Println(\"oversleep\") case &lt;-ctx.Done(): fmt.Println(ctx.Err()) &#125;&#125; 5、 12345678910111213141516171819202122232425func main() &#123; ctx, cancel :&#x3D; context.WithCancel(context.Background()) go watch(ctx,&quot;【监控1】&quot;) go watch(ctx,&quot;【监控2】&quot;) go watch(ctx,&quot;【监控3】&quot;) time.Sleep(10 * time.Second) fmt.Println(&quot;可以了，通知监控停止&quot;) cancel() &#x2F;&#x2F;为了检测监控过是否停止，如果没有监控输出，就表示停止了 time.Sleep(5 * time.Second)&#125;func watch(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(name,&quot;监控退出，停止了...&quot;) return default: fmt.Println(name,&quot;goroutine监控中...&quot;) time.Sleep(2 * time.Second) &#125; &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[72]-理解Go标准库中的atomic.Value类型","slug":"golang-72-atomic-Value","date":"2019-05-09T05:49:43.000Z","updated":"2019-05-09T06:12:12.482Z","comments":true,"path":"2019/05/09/golang-72-atomic-Value/","link":"","permalink":"https://dreamerjonson.com/2019/05/09/golang-72-atomic-Value/","excerpt":"","text":"前言 在 Go 语言标准库中, sync/atomic包将底层硬件提供的原子操作封装成了 Go 的函数。但这些操作只支持几种基本数据类型，因此为了扩大原子操作的适用范围，Go 语言在 1.4 版本的时候向sync/atomic包中添加了一个新的类型Value。此类型的值相当于一个容器，可以被用来“原子地”存储（Store）和加载（Load）任意类型的值。 历史起源 我在golang-dev邮件列表中翻到了14年的这段讨论，有人报告了encoding/gob包在多核机器上（80-core）上的性能问题，认为encoding/gob之所以不能完全利用到多核的特性是因为它里面使用了大量的互斥锁（mutex），如果把这些互斥锁换成用atomic.LoadPointer/StorePointer来做并发控制，那性能将能提升20倍。 针对这个问题，有人提议在已有的atomic包的基础上封装出一个atomic.Value类型，这样用户就可以在不依赖 Go 内部类型unsafe.Pointer的情况下使用到atomic提供的原子操作。所以我们现在看到的atomic包中除了atomic.Value外，其余都是早期由汇编写成的，并且atomic.Value类型的底层实现也是建立在已有的atomic包的基础上。 那为什么在上面的场景中，atomic会比mutex性能好很多呢？作者 Dmitry Vyukov 总结了这两者的一个区别： Mutexes do no scale. Atomic loads do. Mutex由操作系统实现，而atomic包中的原子操作则由底层硬件直接提供支持。在 CPU 实现的指令集里，有一些指令被封装进了atomic包，这些指令在执行的过程中是不允许中断（interrupt）的，因此原子操作可以在lock-free的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。 好了，说了这么多的原子操作，我们先来看看什么样的操作能被叫做原子操作 。 一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为原子性（atomicity） 。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。而在现实世界中，CPU 不可能不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣称他们拥有了”不可分割”的原子性。 有些朋友可能不知道，在 Go（甚至是大部分语言）中，一条普通的赋值语句其实不是一个原子操作。例如，在32位机器上写int64类型的变量有中间状态，它会被拆成两次写操作（MOV）——写低 32 位和写高 32 位，如下图所示： 如果一个线程刚写完低32位，还没来得及写高32位时，另一个线程读取了这个变量，那它得到的就是一个毫无逻辑的中间变量，这很有可能使我们的程序出现诡异的 Bug。 这还只是一个基础类型，如果我们对一个结构体进行赋值，那它出现并发问题的概率就更高了。很可能写线程刚写完一小半的字段，读线程就来读取这个变量，那么就只能读到仅修改了一部分的值。这显然破坏了变量的完整性，读出来的值也是完全错误的。 面对这种多线程下变量的读写问题，我们的主角——atomic.Value登场了，它使得我们可以不依赖于不保证兼容性的unsafe.Pointer类型，同时又能将任意数据类型的读写操作封装成原子性操作（让中间状态对外不可见）。 使用姿势 atomic.Value类型对外暴露的方法就两个： v.Store© - 写操作，将原始的变量c存放到一个atomic.Value类型的v里。 c = v.Load() - 读操作，从线程安全的v中读取上一步存放的内容。 简洁的接口使得它的使用也很简单，只需将需要作并发保护的变量读取和赋值操作用Load()和Store()代替就行了。 下面是一个常见的使用场景。应用程序定期的从外界获取最新的配置信息，然后更改自己内存中维护的配置变量。工作线程根据最新的配置来处理请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"sync/atomic\" \"time\")func loadConfig() map[string]string &#123; // 从数据库或者文件系统中读取配置信息，然后以map的形式存放在内存里 return make(map[string]string)&#125;func requests() chan int &#123; // 将从外界中接受到的请求放入到channel里 return make(chan int)&#125;func main() &#123; // config变量用来存放该服务的配置信息 var config atomic.Value // 初始化时从别的地方加载配置文件，并存到config变量里 config.Store(loadConfig()) go func() &#123; // 每10秒钟定时的拉取最新的配置信息，并且更新到config变量里 for &#123; time.Sleep(10 * time.Second) // 对应于赋值操作 config = loadConfig() config.Store(loadConfig()) &#125; &#125;() // 创建工作线程，每个工作线程都会根据它所读取到的最新的配置信息来处理请求 for i := 0; i &lt; 10; i++ &#123; go func() &#123; for r := range requests() &#123; // 对应于取值操作 c := config // 由于Load()返回的是一个interface&#123;&#125;类型，所以我们要先强制转换一下 c := config.Load().(map[string]string) // 这里是根据配置信息处理请求的逻辑... _, _ = r, c &#125; &#125;() &#125;&#125; 数据结构 atomic.Value被设计用来存储任意类型的数据，所以它内部的字段是一个interface{}类型，非常的简单粗暴。 123 type Value struct &#123; v interface&#123;&#125;&#125; 除了Value外，这个文件里还定义了一个ifaceWords类型，这其实是一个空interface (interface{}）的内部表示格式（参见runtime/runtime2.go中eface的定义）。它的作用是将interface{}类型分解，得到其中的两个字段。 1234type ifaceWords struct &#123; typ unsafe.Pointer data unsafe.Pointer&#125; 写入（Store）操作 在介绍写入之前，我们先来看一下 Go 语言内部的unsafe.Pointer类型。 unsafe.Pointer 出于安全考虑，Go 语言并不支持直接操作内存，但它的标准库中又提供一种不安全（不保证向后兼容性） 的指针类型unsafe.Pointer，让程序可以灵活的读取/操作内存。 unsafe.Pointer的特别之处在于，它可以绕过 Go 语言类型系统的检查，与任意的指针类型互相转换。也就是说，如果两种类型具有相同的内存结构，我们可以将unsafe.Pointer当做桥梁，让这两种类型的指针相互转换，从而实现同一份内存拥有两种不同的解读方式。 比如说，[]byte和string其实内部的存储结构都是一样的，但 Go 语言的类型系统禁止他俩互换。如果借助unsafe.Pointer，我们就可以实现在零拷贝的情况下，将[]byte数组直接转换成string类型。 12345bytes := []byte&#123;104, 101, 108, 108, 111&#125;p := unsafe.Pointer(&amp;bytes) //强制转换成unsafe.Pointer，编译器不会报错str := *(*string)(p) //然后强制转换成string类型的指针，再将这个指针的值当做string类型取出来fmt.Println(str) //输出 \"hello\" 知道了unsafe.Pointer的作用，我们可以直接来看代码了： 1234567891011121314151617181920212223242526272829303132333435363738func (v *Value) Store(x interface&#123;&#125;) &#123; if x == nil &#123; panic(\"sync/atomic: store of nil value into Value\") &#125; vp := (*ifaceWords)(unsafe.Pointer(v)) // Old value xp := (*ifaceWords)(unsafe.Pointer(&amp;x)) // New value for &#123; typ := LoadPointer(&amp;vp.typ) if typ == nil &#123; // Attempt to start first store. // Disable preemption so that other goroutines can use // active spin wait to wait for completion; and so that // GC does not see the fake type accidentally. runtime_procPin() if !CompareAndSwapPointer(&amp;vp.typ, nil, unsafe.Pointer(^uintptr(0))) &#123; runtime_procUnpin() continue &#125; // Complete first store. StorePointer(&amp;vp.data, xp.data) StorePointer(&amp;vp.typ, xp.typ) runtime_procUnpin() return &#125; if uintptr(typ) == ^uintptr(0) &#123; // First store in progress. Wait. // Since we disable preemption around the first store, // we can wait with active spinning. continue &#125; // First store completed. Check type and overwrite data. if typ != xp.typ &#123; panic(\"sync/atomic: store of inconsistently typed value into Value\") &#125; StorePointer(&amp;vp.data, xp.data) return &#125;&#125; 大概的逻辑： 第5~6行 - 通过unsafe.Pointer将现有的和要写入的值分别转成ifaceWords类型，这样我们下一步就可以得到这两个interface{}的原始类型（typ）和真正的值（data）。 从第7行开始就是一个无限 for 循环。配合CompareAndSwap食用，可以达到乐观锁的功效。 第8行，我们可以通过LoadPointer这个原子操作拿到当前Value中存储的类型。下面根据这个类型的不同，分3种情况处理。 第一次写入（第9~24行） - 一个Value实例被初始化后，它的typ字段会被设置为指针的零值 nil，所以第9行先判断如果typ是 nil 那就证明这个Value还未被写入过数据。那之后就是一段初始写入的操作： runtime_procPin()这是runtime中的一段函数，具体的功能我不是特别清楚，也没有找到相关的文档。这里猜测一下，一方面它禁止了调度器对当前 goroutine 的抢占（preemption），使得它在执行当前逻辑的时候不被打断，以便可以尽快地完成工作，因为别人一直在等待它。另一方面，在禁止抢占期间，GC 线程也无法被启用，这样可以防止 GC 线程看到一个莫名其妙的指向^uintptr(0)的类型（这是赋值过程中的中间状态）。 使用CAS操作，先尝试将typ设置为^uintptr(0)这个中间状态。如果失败，则证明已经有别的线程抢先完成了赋值操作，那它就解除抢占锁，然后重新回到 for 循环第一步。 如果设置成功，那证明当前线程抢到了这个”乐观锁”，它可以安全的把v设为传入的新值了（19~23行）。注意，这里是先写data字段，然后再写typ字段。因为我们是以typ字段的值作为写入完成与否的判断依据的。 第一次写入还未完成（第25~30行）- 如果看到typ字段还是^uintptr(0)这个中间类型，证明刚刚的第一次写入还没有完成，所以它会继续循环，”忙等”到第一次写入完成。 第一次写入已完成（第31行及之后） - 首先检查上一次写入的类型与这一次要写入的类型是否一致，如果不一致则抛出异常。反之，则直接把这一次要写入的值写入到data字段。 读取（Load）操作 12345678910111213func (v *Value) Load() (x interface&#123;&#125;) &#123; vp := (*ifaceWords)(unsafe.Pointer(v)) typ := LoadPointer(&amp;vp.typ) if typ == nil || uintptr(typ) == ^uintptr(0) &#123; // First store not yet completed. return nil &#125; data := LoadPointer(&amp;vp.data) xp := (*ifaceWords)(unsafe.Pointer(&amp;x)) xp.typ = typ xp.data = data return&#125; 读取相对就简单很多了，它有两个分支： 如果当前的typ是 nil 或者^uintptr(0)，那就证明第一次写入还没有开始，或者还没完成，那就直接返回 nil （不对外暴露中间状态）。 否则，根据当前看到的typ和data构造出一个新的interface{}返回出去。 总结 本文从邮件列表中的一段讨论开始，介绍了atomic.Value的被提出来的历史缘由。然后由浅入深的介绍了它的使用姿势，以及内部实现。让大家不仅知其然，还能知其所以然。 另外，再强调一遍，原子操作由底层硬件支持，而锁则由操作系统提供的 API 实现。若实现相同的功能，前者通常会更有效率，并且更能利用计算机多核的优势。所以，以后当我们想并发安全的更新一些变量的时候，我们应该优先选择用atomic.Value来实现。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"mac远程windwos","slug":"windwos远程登陆","date":"2019-05-02T13:47:12.000Z","updated":"2019-05-02T13:48:07.413Z","comments":true,"path":"2019/05/02/windwos远程登陆/","link":"","permalink":"https://dreamerjonson.com/2019/05/02/windwos%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/","excerpt":"","text":"windwos设置 windows远程登时，如果同一个用户名远程登录用户名或密码不正确，但是直接在机器上却登陆正常。 有可能是用户名错误了，有可能是密码错误。 当用户名和你的全称不一样时，就很容易出现这种情况。 解决方法： 直接在命令行输入lusrmgr.msc或者右键点击我的电脑选择管理,选择本地用户和组.右键点击你的用户名，选择修改密码。或者尝试一下使用户名与全称一致","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"mac环境配置","slug":"mac环境配置","permalink":"https://dreamerjonson.com/tags/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"MAC环境配置","slug":"tmux","date":"2019-04-25T05:44:19.000Z","updated":"2019-07-26T14:17:42.123Z","comments":true,"path":"2019/04/25/tmux/","link":"","permalink":"https://dreamerjonson.com/2019/04/25/tmux/","excerpt":"","text":"注意：本文内容适用于 Tmux 2.3 及以上的版本，但是绝大部分的特性低版本也都适用，鼠标支持、VI 模式、插件管理在低版本可能会与本文不兼容。 Tmux 快捷键 &amp; 速查表 启动新会话： tmux [new -s 会话名 -n 窗口名] 恢复会话： tmux at [-t 会话名] 列出所有会话： tmux ls 关闭会话： tmux kill-session -t 会话名 关闭所有会话： tmux ls | grep : | cut -d. -f1 | awk '{print substr($1, 0, length($1)-1)}' | xargs kill 在 Tmux 中，按下 Tmux 前缀 ctrl+b，然后： 会话 :new&lt;回车&gt; 启动新会话 s 列出所有会话 $ 重命名当前会话 窗口 (标签页) c 创建新窗口 w 列出所有窗口 n 后一个窗口 p 前一个窗口 f 查找窗口 , 重命名当前窗口 &amp; 关闭当前窗口 调整窗口排序 swap-window -s 3 -t 1 交换 3 号和 1 号窗口 swap-window -t 1 交换当前和 1 号窗口 move-window -t 1 移动当前窗口到 1 号 窗格（分割窗口） % 垂直分割 &quot; 水平分割 o 交换窗格 x 关闭窗格 ⍽ 左边这个符号代表空格键 - 切换布局 q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格 { 与上一个窗格交换位置 } 与下一个窗格交换位置 z 切换窗格最大化/最小化 同步窗格 这么做可以切换到想要的窗口，输入 Tmux 前缀和一个冒号呼出命令提示行，然后输入： 1:setw synchronize-panes 你可以指定开或关，否则重复执行命令会在两者间切换。 这个选项值针对某个窗口有效，不会影响别的会话和窗口。 完事儿之后再次执行命令来关闭。帮助 调整窗格尺寸 如果你不喜欢默认布局，可以重调窗格的尺寸。虽然这很容易实现，但一般不需要这么干。这几个命令用来调整窗格： PREFIX : resize-pane -D 当前窗格向下扩大 1 格 PREFIX : resize-pane -U 当前窗格向上扩大 1 格 PREFIX : resize-pane -L 当前窗格向左扩大 1 格 PREFIX : resize-pane -R 当前窗格向右扩大 1 格 PREFIX : resize-pane -D 20 当前窗格向下扩大 20 格 PREFIX : resize-pane -t 2 -L 20 编号为 2 的窗格向左扩大 20 格 文本复制模式： 按下 PREFIX-[ 进入文本复制模式。可以使用方向键在屏幕中移动光标。默认情况下，方向键是启用的。在配置文件中启用 Vim 键盘布局来切换窗口、调整窗格大小。Tmux 也支持 Vi 模式。要是想启用 Vi 模式，只需要把下面这一行添加到 .tmux.conf 中： setw -g mode-keys vi 启用这条配置后，就可以使用 h、j、k、l 来移动光标了。 想要退出文本复制模式的话，按下回车键就可以了。然后按下 PREFIX-] 粘贴刚才复制的文本。 一次移动一格效率低下，在 Vi 模式启用的情况下，可以辅助一些别的快捷键高效工作。 例如，可以使用 w 键逐词移动，使用 b 键逐词回退。使用 f 键加上任意字符跳转到当前行第一次出现该字符的位置，使用 F 键达到相反的效果。 vi emacs 功能 ^ M-m 反缩进 Escape C-g 清除选定内容 Enter M-w 复制选定内容 j Down 光标下移 h Left 光标左移 l Right 光标右移 L 光标移到尾行 M M-r 光标移到中间行 H M-R 光标移到首行 k Up 光标上移 d C-u 删除整行 D C-k 删除到行末 $ C-e 移到行尾 : g 前往指定行 C-d M-Down 向下滚动半屏 C-u M-Up 向上滚动半屏 C-f Page down 下一页 w M-f 下一个词 p C-y 粘贴 C-b Page up 上一页 b M-b 上一个词 q Escape 退出 C-Down or J C-Down 向下翻 C-Up or K C-Up 向下翻 n n 继续搜索 ? C-r 向前搜索 / C-s 向后搜索 0 C-a 移到行首 Space C-Space 开始选中 C-t 字符调序 杂项： d 退出 tmux（tmux 仍在后台运行） t 窗口中央显示一个数字时钟 ? 列出所有快捷键 : 命令提示符 配置选项： # 鼠标支持 - 设置为 on 来启用鼠标(与 2.1 之前的版本有区别，请自行查阅 man page) * set -g mouse on # 设置默认终端模式为 256color set -g default-terminal &quot;screen-256color&quot; # 启用活动警告 setw -g monitor-activity on set -g visual-activity on # 居中窗口列表 set -g status-justify centre # 最大化/恢复窗格 unbind Up bind Up new-window -d -n tmp \\; swap-pane -s tmp.1 \\; select-window -t tmp unbind Down bind Down last-window \\; swap-pane -s tmp.1 \\; kill-window -t tmp 参考配置文件（~/.tmux.conf）： 下面这份配置是我使用 Tmux 几年来逐渐精简后的配置，请自取。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -----------------------------------------------------------------------------# Tmux 基本配置 - 要求 Tmux &gt;= 2.3# 如果不想使用插件，只需要将此节的内容写入 ~/.tmux.conf 即可# -----------------------------------------------------------------------------# C-b 和 VIM 冲突，修改 Prefix 组合键为 Control-Z，按键距离近set -g prefix C-zset -g base-index 1 # 窗口编号从 1 开始计数set -g display-panes-time 10000 # PREFIX-Q 显示编号的驻留时长，单位 msset -g mouse on # 开启鼠标set -g pane-base-index 1 # 窗格编号从 1 开始计数set -g renumber-windows on # 关掉某个窗口后，编号重排setw -g allow-rename off # 禁止活动进程修改窗口名setw -g automatic-rename off # 禁止自动命名新窗口setw -g mode-keys vi # 进入复制模式的时候使用 vi 键位（默认是 EMACS）# -----------------------------------------------------------------------------# 使用插件 - via tpm# 1. 执行 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm# 2. 执行 bash ~/.tmux/plugins/tpm/bin/install_plugins# -----------------------------------------------------------------------------setenv -g TMUX_PLUGIN_MANAGER_PATH '~/.tmux/plugins'# 推荐的插件（请去每个插件的仓库下读一读使用教程）set -g @plugin 'seebi/tmux-colors-solarized'set -g @plugin 'tmux-plugins/tmux-pain-control'set -g @plugin 'tmux-plugins/tmux-prefix-highlight'set -g @plugin 'tmux-plugins/tmux-resurrect'set -g @plugin 'tmux-plugins/tmux-sensible'set -g @plugin 'tmux-plugins/tmux-yank'set -g @plugin 'tmux-plugins/tpm'# tmux-resurrectset -g @resurrect-dir '~/.tmux/resurrect'# tmux-prefix-highlightset -g status-right '#&#123;prefix_highlight&#125; #H | %a %Y-%m-%d %H:%M'set -g @prefix_highlight_show_copy_mode 'on'set -g @prefix_highlight_copy_mode_attr 'fg=white,bg=blue'# 初始化 TPM 插件管理器 (放在配置文件的最后)run '~/.tmux/plugins/tpm/tpm'# -----------------------------------------------------------------------------# 结束# ----------------------------------------------------------------------------- fzf 官方文档给的基本操作是 cd**+Tab生成列表+Enter生成命令+Enter执行 快捷键可以把4步变成两步 还是很Nice ctrl+R ctrl+T 特别介绍一下Preview 功能 我们知道在Unix环境下 我们要看文件的时候 必须一个个打开 当文件数量较大的场景 比如说 我们调了10个参数 做了20组实验 每组实验拿到30轮结果 这时候 一个个vim开 怕不是要吐了 这时候你是不是开始怀念有GUI的世界 当然 你可以写个bash脚本 把所有的文件合到一个文件 然后 只看一个file就行了 fzf给出了另外一个炫酷的解决方案 set alias 1234$ vim ~&#x2F;.zshrcalias pp&#x3D;&#39;fzf --preview &#39;&quot;&#39;&quot;&#39;[[ $(file --mime &#123;&#125;) &#x3D;~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || rougify &#123;&#125; || cat &#123;&#125;) 2&gt; &#x2F;dev&#x2F;null | head -500&#39;&quot;&#39;&quot;alias oo&#x3D;&#39;fzf --preview &#39;&quot;&#39;&quot;&#39;[[ $(file --mime &#123;&#125;) &#x3D;~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (highlight -O ansi -l &#123;&#125; || coderay &#123;&#125; || rougify &#123;&#125; || tac &#123;&#125;) 2&gt; &#x2F;dev&#x2F;null | head -500&#39;&quot;&#39;&quot; # flashback$ source ~&#x2F;.zshrc ITerm2 可定制化Hotkey, 一键召出iTerm2 (不再需要⌘+Tab 或者 通过spotlight切换) 快捷的组合键 ⌘+Shift+E 召唤时间线 ⌘+Option+b 时光机 ⌘+T 新Tab ⌘+D 水平分屏 ⌘+← 切换Tab / ⌘+shift+← 切换分屏 关闭panel：⌘ + w 最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次还原 按下 Command + T 可以新建一个 Tab，每个标签页的后面都会标记一个序号，通过 Command + 序号 就可以在多个页面之间切换了，或者用 Command + [ 和 Command + ] 来切换到左侧或者右侧的标签页。 同一个 Tab 内，还可以切分出多个 Pane，有两种切分方式： Command + D：水平切分，切分出一左一右两个 Pane Command + Shift + D：垂直切分，切分出一上一下两个 Pane 通过 Command + Ctrl + 方向键 可以调整每个 Pane 的大小，通过 Command + Option + 方向键 可以切换 Pane。 MAC系统快捷键进阶 除了 Command + C/V 这种入门必备的快捷键，还有一些系统级的常用快捷键是有必要掌握一下的。 光标移动 这里比较推荐使用 Emacs 系的快捷键而不是传统的 Command + ←/→/Delete之类的。因为后者并不通用，比如在终端中就无法使用，而 Emacs 系的快捷键则在几乎所有系统级别的输入框内都通用。 常见的几个行级别操作有： Ctrl + A：移动到行首 Ctrl + E：移动到行尾 Ctrl + K：删除到行尾 Ctrl + N：移动到下一行 Ctrl + P：移动到上一行 前三个命令在终端中非常常用，能大幅度提高工作效率。后两个命令则在 Vim 系列中很常见，多用于上下切换列表中的选项。 几个比较常见的字母级别操作有： Ctrl + F：向右（Forward）移动一个字母，等价于方向键 → Ctrl + B：向左（Backward）移动一个字母，等价于方向键 ← Ctrl + D：向右删除一个字母，等价于 → + Delete这个快捷键也很常用 Ctrl + H：向左删除一个字母，等价于 Delete 使用 Option 键 如果觉得按字母操作太过于细粒度，按行操作又太粗粒度，那么 Option 键绝对算得上神器，因为它可以按单词操作。 Option + ←：光标向左移动一个单词 Option + →：光标向右移动一个单词 Option + Delete：删除一个单词 使用 Shift 键 Shift 键类似于可视模式，比如在某个位置点击光标并按住 shift 键不松开，再去另一个位置点击一次，就可以选中两次点击位置之间的文本内容。 注意，shift 键可视模式还可以和 Option 键一起合用，感兴趣的读者可以自行尝试。 max连接 visulBOX中的Ubuntu 使用ssh服务器 在ubuntu中使用桥接模式 步骤 命令 说明 步骤1 sudo su 切换至root用户，ubuntu缺省下root用户有所限制，使用sudo su可以使用当前管理用户的密码切换至root用户，也可以在需要安装权限的命令前加sudo 步骤2 apt install openssh-server 安装openssh-server 步骤3 ssh -V 确认openssh-server版本 步骤4 /etc/init.d/ssh status 确认openssh-server状态 步骤5 /etc/init.d/ssh restart 重新启动 openssh-server vim /etc/ssh/sshd.config permisionRootLogin YES 修改unixpassword ifconfig获取ip 从终端使用ssh命令连接确认ssh -p 22 userkunyu@119.29.37.63 输入密码： virsualBox共享文件夹 共享文件夹为：go文件 sudo su 挂载：mount -t vboxsf go /mnt 软连接：ln -s /mnt/go /home/jackson/go mac 通过ssh连接windwos &amp; windwos 的环境配置 1、安装 OpenSSH Server 2、开启服务 安装完成后打开服务管理器，把 OpenSSH Authentication Agent 服务和 OpenSSH SSH Server 服务都设置为自启动，并启动这两个服务： OPENSSH Authentication OpenSSH SSH server 3、监听端口 启动服务后可以通过 netstat 命令查看 SSH Server 服务是不是已经开始监听默认的 22 号端口了： 4、防火墙规则 或者关闭所有防火墙 在安装 OpenSSH Server 的时候会在防火墙的入站规则中添加一条记录让防火墙放行对 22 号端口的访问： 服务器端的配置文件目录 服务器端的配置文件在 C:\\ProgramData\\ssh 目录中，注意 C:\\ProgramData 是一个隐藏目录： 5、安装目录 Windows 系统中 OpenSSH 的安装目录为 C:\\Windows\\System32\\OpenSSH，不管是客户端程序还是服务器端程序都这这个目录中： OpenSSH 服务器端程序的默认配置文件 sshd_config_default 也在这个目录中。这个目录会被添加到 PATH 环境变量中： 前面我们介绍的 ssh 命令都是通过密码认证连接服务器的，下面介绍通过秘钥认证的方式登录服务器。 1、在 PowerShell 中执行 notepad .ssh\\authorized_keys 命令创建文本文件，把客户端的公钥复制到这个文件中并保存。 把文本文件的名称修改为 authorized_keys： 2、修改 ssh 服务的配置文件 以管理员权限打开 PowerShell，执行命令 notepad C:\\ProgramData\\ssh\\sshd_config。 注释掉配置文件中的最后两行然后保存： Match Group administrators AuthorizedKeysFile PROGRAMDATA/ssh/administrators_authorized_keys 3、最后在服务管理器器中重启 OpenSSH SSH Server 服务，然后客户端就可以通过公钥认证的方式登录到远程服务器了。 最后 在 Windows 系统中，PowerShell 已逐渐成为主流，我们可以把默认的 shell 设置为 PowerShell。其实就是在运行 OpenSSH Server 的 Windows 系统的注册表中添加一个配置项，注册表路径为 HKEY_LOCAL_MACHINE\\SOFTWARE\\OpenSSH，项的名称为 DefaultShell，项的值为 C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe。我们可以以管理员身份启动 PowerShell 然后执行下面的命令完成注册表项的添加： 参考 https://www.cnblogs.com/sparkdev/p/10166061.html","categories":[{"name":"开发配置","slug":"开发配置","permalink":"https://dreamerjonson.com/categories/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"开发配置","slug":"开发配置","permalink":"https://dreamerjonson.com/tags/%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"}]},{"title":"git操作github-gitlab","slug":"connect-github-gitlab","date":"2019-04-02T07:43:32.000Z","updated":"2019-11-07T16:10:14.584Z","comments":true,"path":"2019/04/02/connect-github-gitlab/","link":"","permalink":"https://dreamerjonson.com/2019/04/02/connect-github-gitlab/","excerpt":"","text":"克隆 有两种方式，一种是通过ssh,一种是通过http 使用ssh的方式需要在本机生成ssh文件， 参考资料：https://gitlab.followme.com/help/ssh/README#generating-a-new-ssh-key-pair 产生SSH To create a new SSH key pair: Open a terminal on Linux or macOS, or Git Bash / WSL on Windows. 12345Generate a new ED25519 SSH key pair:ssh-keygen -t ed25519 -C &quot;email@example.com&quot;Or, if you want to use RSA:ssh-keygen -o -t rsa -b 4096 -C &quot;email@example.com&quot; Adding an SSH key to your GitLab account Copy your public SSH key to the clipboard by using one of the commands below depending on your Operating System: 12345678macOS:pbcopy &lt; ~&#x2F;.ssh&#x2F;id_ed25519.pubWSL &#x2F; GNU&#x2F;Linux (requires the xclip package):xclip -sel clip &lt; ~&#x2F;.ssh&#x2F;id_ed25519.pubGit Bash on Windows:cat ~&#x2F;.ssh&#x2F;id_ed25519.pub | clip go mod 中下载依赖包时，可以使用 go build . 但是下载有时候会出现问题，例如： 我运行go mod download 提示 fatal: could not read Username for ‘https://gitlab.XXX.com’: terminal prompts disabled 这时，需要通过ssh的方式下载gitlab中的数据： 1vim ~&#x2F;.gitconfig 添加： 12[url &quot;ssh:&#x2F;&#x2F;git@gitlab.XXX.com&#x2F;&quot;] insteadOf &#x3D; https:&#x2F;&#x2F;gitlab.XXX.com&#x2F; 查看分支 1git branch -a 将远程分支 dev 到本地dev 并切换到dev分支 123git fetch origin dev 存疑git checkout -b dev origin&#x2F;dev 123git push origin devgit push -f origin dev 强制更新 删除文件 1git rm --cached -r .idea 添加远程 12345git remote add camel-snipet git@gitlab.followme.com:camel&#x2F;go-snipet.git git remote -v git push camel-snipet dev 回退 12git refloggit reset --hard a7e1d279 mac添加环境变量 1234567操作步骤:1、打开Terminal（终端）2、输入：vim ~&#x2F;.bash_profile3、设置PATH：export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin:$PATH4、输入：:wq &#x2F;&#x2F;保存并退出vi5、修改立即生效：source ~&#x2F;.bash_profile6、查看环境变量的值：echo $PATH go run main.go --registry=consul --registry_address=“127.0.0.1:8500” consul： 自动将服务添加到consul UI ：http://localhost:8500 ##gitlab Runner To install GitLab Runner using Homebrew: Install the GitLab Runner. brew install gitlab-runner Install the Runner as a service and start it. brew services start gitlab-runner Runner is installed and running. gitlab-runner register gitlab-runner stop gitlab-runner register gitlab-runner unregister --all-runners ./gitlab-runner run 当远程分支有冲突，强制 git fetch --all git reset --hard origin/master merge git merge -Xtheirs dev git merge -Xou rs dev 工作区回到最后一次提交的状态。 git checkout . git log --pretty=oneline 但最有意思的是 format，可以定制要显示的记录格式，这样的输出便于后期编程提取分析，像这样： $ git log --pretty=format:&quot;%h - %an, %ar : %s&quot; ca82a6d - Scott Chacon, 11 months ago : changed the version number 085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code a11bef0 - Scott Chacon, 11 months ago : first commit makefile 代码片段 1234567891011121314151617181920proto: for d in api srv; do \\ for f in $$d/**/proto/*.proto; do \\ protoc --proto_path=$&#123;GOPATH&#125;/src --micro_out=. --go_out=. $$f; \\ echo compiled: $$f; \\ done \\ donelint: ./bin/lint.shbuild: ./bin/build.shdata: go-bindata -o data/bindata.go -pkg data data/*.jsonrun: docker-compose build docker-compose up 删除git记录 find . -name “.git” | xargs rm -rf j sbin ./rabbitmq-server ./rabbitmqctl list_queues brew install gnatsd gnatsd consul agent -dev -client=0.0.0.0 撤销 事情是这样的，刚刚自己在执行git commit -m “提交信息” 命令时，将里面的提交信息写错，此时并没有执行git push命令，基于这种需求的解决方案为执行如下命令即可 git commit --amend -m “新的提交信息”","categories":[{"name":"git","slug":"git","permalink":"https://dreamerjonson.com/categories/git/"},{"name":"mac环境配置","slug":"git/mac环境配置","permalink":"https://dreamerjonson.com/categories/git/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"git","slug":"git","permalink":"https://dreamerjonson.com/tags/git/"},{"name":"mac环境配置","slug":"mac环境配置","permalink":"https://dreamerjonson.com/tags/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"golang[71]-golang操作mysql数据库","slug":"golang-71-sql","date":"2019-04-01T09:38:37.000Z","updated":"2019-04-28T02:47:05.425Z","comments":true,"path":"2019/04/01/golang-71-sql/","link":"","permalink":"https://dreamerjonson.com/2019/04/01/golang-71-sql/","excerpt":"","text":"安装 https://dev.mysql.com/downloads Installing MySQL on macOS 推荐使用dmg文件安装 https://dev.mysql.com/doc/refman/5.7/en/osx-installation.html 安装完毕有默认密码 连接 PATH=&quot;$PATH&quot;:/usr/local/mysql/bin sudo su mysql -u root -p 123456 create database test; use test; create table user_info(id int(11),username varchar(20),create_time timestamp ,primary key(id)); INSERT INTO user_info(id,username) VALUES(5,“jonson”); select * from user_info; create table user_info(id int(11),username varchar(20),create_time timestamp ,primary key(id)); 插入 123456789101112131415161718192021package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\")func main() &#123; db, err := sql.Open(\"mysql\", \"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8\") if err != nil &#123; panic(err) &#125; stmt, err := db.Prepare(`INSERT user_info (id,username) values (?,?)`) res, err := stmt.Exec(88,\"olaya\") id, err := res.LastInsertId() fmt.Println(id)&#125; 删除 12345678910111213141516171819202122232425package mainimport ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\")func main() &#123; db, err := sql.Open(\"mysql\", \"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8\") if err != nil &#123; panic(err) &#125; stmt, err := db.Prepare(\"delete from user_info where id=?\") res, err := stmt.Exec(88) id, err := res.RowsAffected() if err != nil &#123; panic(err) &#125; fmt.Println(id)&#125; 更新 1234567891011121314151617181920212223242526// mysql.gopackage mainimport ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\")func main() &#123; db, err := sql.Open(\"mysql\", \"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8\") if err != nil &#123; panic(err) &#125; stmt, err := db.Prepare(\"update user_info set id=? where id=?\") res, err := stmt.Exec(5, 99) id, err := res.RowsAffected() if err != nil &#123; panic(err) &#125; fmt.Println(id)&#125; 查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// mysql.gopackage mainimport ( \"database/sql\" \"fmt\" _ \"github.com/go-sql-driver/mysql\")func main() &#123; db, err := sql.Open(\"mysql\", \"root:123456@tcp(127.0.0.1:3306)/test?charset=utf8\") if err != nil &#123; panic(err) &#125; rows, err := db.Query(\"SELECT * FROM user_info\") if err != nil &#123; panic(err) &#125; for rows.Next() &#123; var id int var username string var create_time string err = rows.Scan(&amp;id, &amp;username, &amp;create_time) if err != nil &#123; panic(err) &#125; fmt.Println(id, username, create_time) &#125; //for rows.Next() &#123; // var userId int // var userName string // var userAge int // var userSex int // rows.Columns() // err = rows.Scan(&amp;userId, &amp;userName, &amp;userAge, &amp;userSex) // checkErr(err) // fmt.Println(userId) // fmt.Println(userName) // fmt.Println(userAge) // fmt.Println(userSex) //&#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"k8s","slug":"k8s","date":"2019-03-14T03:29:49.000Z","updated":"2019-03-18T13:29:32.931Z","comments":true,"path":"2019/03/14/k8s/","link":"","permalink":"https://dreamerjonson.com/2019/03/14/k8s/","excerpt":"","text":"mac平台 安装brew 。。。 安装 1brew install kubectl 1brew cask install minikube 12$ which minikube$ minikube start 错误提示 1stderr: failed to pull image &quot;k8s.gcr.io&#x2F;kube-apiserver:v1.13.4&quot;: output: Error response from daemon: Get https:&#x2F;&#x2F;k8s.gcr.io&#x2F;v2&#x2F;: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 打印日志 1minikube logs 使用代理： 12$ minikube delete$ minikube start --docker-env HTTP_PROXY&#x3D;http:&#x2F;&#x2F;10.0.2.2:1087 --docker-env HTTPS_PROXY&#x3D;http:&#x2F;&#x2F;10.0.2.2:1087 代理参考资料 https://github.com/kubernetes/minikube/blob/master/docs/http_proxy.md https://my.oschina.net/csq/blog/3014879 配置pod client-pod.yaml 123456789101112apiVersion: v1kind: Podmetadata: name: client-pod labels: component: webspec: containers: - name: client image: stephengrider/multi-worker ports: - containerPort: 3000 配置server 123456789101112apiVersion: v1kind: Servicemetadata: name: client-node-portspec: type: NodePort ports: - port: 3050 targetPort: 3000 nodePort: 31515 selector: component: web 1234$ kubectl apply -f client-pod.yaml$ kubectl apply -f client-node-port.yaml$ kubectl get pods$ kubectl get services 修改client-pod.yaml中的images,重新执行配置文件即可更新 1$ kubectl apply -f client-pod.yaml 获取ip 1$ minikube ip 获取pod详细描述 1$ kubectl describe pod client-pod 删除pod 1$ kubectl delete -f client-pod.yaml 书写deployment 12345678910111213141516171819202122apiVersion: apps&#x2F;v1kind: Deploymentmetadata: name: client-deploymentspec: replicas: 1 selector: matchLabels: component: web template: metadata: labels: component: web spec: containers: - name: client image: stephengrider&#x2F;multi-client ports: - containerPort: 3000&#96;&#96;&#96; ## 应用deployment $ kubectl apply -f client-deployment.yaml $ kubectl get pods $ kubectl get deployments NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE client-deployment 1 1 1 1 30s 12如果image有更新，可以采取下面的方式强制更新： docker build -t stephengrider/multi-client:v5 . docker push stephengrider/multi-client:v5 $ kubectl set image deployment/client-deployment client=stephengrider/multi-client:v5 ## docker ps 得到k8s虚拟机的信息","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go-数据结构[15]-归并排序","slug":"go-struture-15-merge-sort","date":"2019-03-11T14:01:51.000Z","updated":"2019-03-11T14:19:02.441Z","comments":true,"path":"2019/03/11/go-struture-15-merge-sort/","link":"","permalink":"https://dreamerjonson.com/2019/03/11/go-struture-15-merge-sort/","excerpt":"","text":"pre,code { font-family: \"Source Code Pro\", Consolas, Monaco, Menlo, Consolas, monospace !important; } 归并排序（Merge Sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 归并操作(Merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序 , 可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。 算法思路： 1、把 n 个记录看成 n 个长度为 l 的有序子表 2、进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表 3、重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。 实例分析 以数组 array = [6, 5, 3, 1, 8, 7, 2, 4] 为例，首先将数组分为长度为 2 的子数组，并使每个子数组有序： 123[6, 5] [3, 1] [8, 7] [2, 4] ↓ ↓ ↓ ↓[5, 6] [1, 3] [7, 8] [2, 4] 然后再两两合并： 123[6, 5, 3, 1] [8, 7, 2, 4] ↓ ↓[1, 3, 5, 6] [2, 4, 7, 8] 最后将两个子数组合并： 123[6, 5, 3, 1, 8, 7, 2, 4] ↓[1, 2, 3, 4, 5, 6, 7, 8] 排序过程动画演示如下：","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go-数据结构[14]-希尔排序","slug":"go-struture-14-shell-sort","date":"2019-03-11T10:25:53.000Z","updated":"2019-03-11T14:19:14.462Z","comments":true,"path":"2019/03/11/go-struture-14-shell-sort/","link":"","permalink":"https://dreamerjonson.com/2019/03/11/go-struture-14-shell-sort/","excerpt":"","text":"希尔排序 希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布，是插入排序的一种更高效的改进版本。它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置；然后增量缩小；最后增量为 1 ，这样记录移动次数大大减少，提高了排序效率。希尔排序对增量序列的选择没有严格规定。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 1、插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 2、但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 算法思路： 先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序 然后取 d2(d2 &lt; d1) 重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。 实例分析 go语言实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport \"fmt\"//打印func print(arr []int)&#123; for _,data := range arr&#123; fmt.Printf(\"%d \",data) &#125; fmt.Println()&#125;func main()&#123; //arr:= []int&#123;8, 5, 2, 6, 9, 3, 1, 4, 0, 7,6,3,10&#125; arr:=[]int&#123;1,3,2,4,9,2,6,5,4,8&#125; print(arr) shellsort(arr) print(arr)&#125;//希尔排序func shellsort(arr []int)&#123; gap:=4 length:= len(arr) for gap &gt;0&#123; for i:=gap;i&lt;length;i+=1&#123; j:= i temp:= arr[i] for;j&gt;0;j-=gap&#123; if j-gap&gt;=0 &amp;&amp; arr[j] &lt; arr[j-gap]&#123; tmp:= arr[j] arr[j] = arr[j-gap] arr[j-gap] = tmp &#125;else&#123; break &#125; &#125; &#125; gap = gap/2 &#125;&#125; javascript实现 123456789101112131415161718192021222324252627function shellSort(array) &#123; function swap(array, i, k) &#123; var temp = array[i]; array[i] = array[k]; array[k] = temp; &#125; var length = array.length, gap = Math.floor(length / 2); while (gap &gt; 0) &#123; for (var i = gap; i &lt; length; i++) &#123; for (var j = i; 0 &lt; j; j -= gap) &#123; if (array[j - gap] &gt; array[j]) &#123; swap(array, j - gap, j); &#125; else &#123; break; &#125; &#125; &#125; gap = Math.floor(gap / 2); &#125; return array;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go-数据结构[13]-二分插入排序","slug":"go-struture-13-binary-sort","date":"2019-03-11T10:14:01.000Z","updated":"2019-03-18T13:30:01.616Z","comments":true,"path":"2019/03/11/go-struture-13-binary-sort/","link":"","permalink":"https://dreamerjonson.com/2019/03/11/go-struture-13-binary-sort/","excerpt":"","text":"二分插入排序 go实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport \"fmt\"//打印func print(arr []int)&#123; for _,data := range arr&#123; fmt.Printf(\"%d \",data) &#125; fmt.Println()&#125;func main()&#123; arr:= []int&#123;2, 6, 9, 3, 1, 4, 0, 7,2, 6, 9, 3, 1,8, 5, 8, 5, 2, 6, 9, 3, 1, 4, 0, 7,2, 6, 9, 3, 1, 4, 0, 7,8, 5, 2, 6, 9, 3, 1, 4, 0, 7&#125; //arr:=[]int&#123;1,3,2,4,9,2,6,5,4,8&#125; print(arr) binarysort(arr) print(arr)&#125;// 插入排序func binarysort(arr []int)&#123; //print(arr) length := len(arr) for i:= 1;i&lt;length;i++&#123; tmp:= arr[i] j:= i-1 if arr[j] &gt; arr[i]&#123; index:= binarysearch(arr,0,i-1,arr[i]) for k:= i-1;k&gt;=index;k--&#123; arr[k+1] =arr[k] &#125; arr[index] = tmp &#125; &#125;&#125;func binarysearch(arr []int, low int, high int, data int) int&#123; for low &lt;=high&#123; mid:= low + (high-low)/2 if data &gt; arr[mid]&#123; if mid+1&lt; len(arr) &amp;&amp; data &lt;=arr[mid+1]&#123; return mid+1 &#125;else&#123; low = mid + 1 &#125; &#125;else&#123; if mid == 0&#123; return 0 &#125;else&#123; high = mid - 1 &#125; &#125; &#125; return 0&#125; JavaScript实现 123456789101112131415161718192021222324252627282930313233343536373839404142function insertionSort2(array) &#123; function binarySearch(array, start, end, temp) &#123; var middle; while (start &lt;= end) &#123; middle = Math.floor((start + end) / 2); if (array[middle] &lt; temp) &#123; if (temp &lt;= array[middle + 1]) &#123; return middle + 1; &#125; else &#123; start = middle + 1; &#125; &#125; else &#123; if (end === 0) &#123; return 0; &#125; else &#123; end = middle; &#125; &#125; &#125; &#125; function binarySort(array) &#123; var length = array.length, i, j, k, temp; for (i = 1; i &lt; length; i++) &#123; temp = array[i]; if (array[i - 1] &lt;= temp) &#123; k = i; &#125; else &#123; k = binarySearch(array, 0, i - 1, temp); for (j = i; j &gt; k; j--) &#123; array[j] = array[j - 1]; &#125; &#125; array[k] = temp; &#125; return array; &#125; return binarySort(array);&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"kali-科学—上网","slug":"kali-shadow","date":"2019-03-10T13:19:38.000Z","updated":"2019-03-10T13:32:02.118Z","comments":true,"path":"2019/03/10/kali-shadow/","link":"","permalink":"https://dreamerjonson.com/2019/03/10/kali-shadow/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940root@kali:# sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontendroot@kali:# sudo apt-get install shadowsocks -yroot@kali:&#x2F;etc# sudo apt-get install privoxyroot@kali:~# vim &#x2F;etc&#x2F;privoxy&#x2F;config配置Privoxy, 打开 &#x2F;etc&#x2F;privoxy&#x2F;config,注释掉listen-address localhost:8118#listen-address localhost:8118在最后一行后边加上forward-socks5 &#x2F; 127.0.0.1:1080 .listen-address 127.0.0.1:8118root@kali:&#x2F;etc# cd shadowsocks&#x2F;root@kali:&#x2F;etc&#x2F;shadowsocks# cp local.json US.json配置ss服务器地址、服务器端口、密码、ss监听端口root@kali:&#x2F;etc&#x2F;shadowsocks# vim US.json&#123;&quot;server&quot;:&quot;&quot;,&quot;server_port&quot;:,&quot;local_address&quot;: &quot;127.0.0.1&quot;,&quot;local_port&quot;:9050, &quot;password&quot;:&quot;&quot;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;: false,&quot;workers&quot;: 1,&quot;prefer_ipv6&quot;: false&#125;开启root@kali:&#x2F;etc&#x2F;shadowsocks# systemctl start privoxy.serviceroot@kali:&#x2F;etc&#x2F;shadowsocks# sslocal -c US.json 设置系统代理 socket与配置&quot;local_port&quot;:9050,相同","categories":[{"name":"kali","slug":"kali","permalink":"https://dreamerjonson.com/categories/kali/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://dreamerjonson.com/tags/kali/"}]},{"title":"go-数据结构[12]-二分查找","slug":"go-struture-12-binary-search","date":"2019-03-10T10:30:27.000Z","updated":"2019-03-11T10:28:17.806Z","comments":true,"path":"2019/03/10/go-struture-12-binary-search/","link":"","permalink":"https://dreamerjonson.com/2019/03/10/go-struture-12-binary-search/","excerpt":"","text":"go语言实现二分查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport \"fmt\"func main() &#123; arr:= []int&#123;1,3,4,6,7,8,10,13,14&#125; for index,data:= range arr&#123; i:= binarySearch(arr,data) fmt.Printf(\"实际序号：%d,找到序号为：%d\\n\",index,i) &#125; fmt.Println(\"-------------------------\") for index,data:= range arr&#123; i:= binarySearch2(arr,0,len(arr)-1,data) fmt.Printf(\"实际序号：%d,找到序号为：%d\\n\",index,i) &#125;&#125;func binarySearch( arr []int, data int ) int&#123; low:= 0 high:= len(arr) - 1 for low &lt;= high&#123; mid:= low + (high-low)/2 if data &gt; arr[mid]&#123; low= mid+1 &#125;else if data &lt; arr[mid]&#123; high= mid - 1 &#125;else&#123; return mid &#125; &#125; return -1&#125;func binarySearch2( arr []int,low,high, data int ) int&#123; ret:= -1 if low &lt;= high&#123; mid := low + (high-low)/2 if data &gt; arr[mid]&#123; ret = binarySearch2(arr,mid+1,high,data) &#125;else if data &lt; arr[mid]&#123; ret = binarySearch2(arr,low,mid-1,data) &#125;else&#123; return mid &#125; &#125; return ret&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go-数据结构[11]-直接插入排序","slug":"go-struture-11-Insertion-Sort","date":"2019-03-10T06:04:58.000Z","updated":"2019-03-10T09:48:53.868Z","comments":true,"path":"2019/03/10/go-struture-11-Insertion-Sort/","link":"","permalink":"https://dreamerjonson.com/2019/03/10/go-struture-11-Insertion-Sort/","excerpt":"","text":"pre,code { font-family: \"Source Code Pro\", Consolas, Monaco, Menlo, Consolas, monospace !important; } 具体算法描述 设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K3 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 Kn 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。 具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤 2~5 如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找排序。 二分查找法，是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 实例分析 现有一组数组 arr = [5, 6, 3, 1, 8, 7, 2, 4]，共有八个记录，排序过程如下： 1234567891011121314151617181920212223[5] 6 3 1 8 7 2 4 ↑ │ └───┘[5, 6] 3 1 8 7 2 4↑ │└────────┘[3, 5, 6] 1 8 7 2 4↑ │└──────────┘[1, 3, 5, 6] 8 7 2 4 ↑ │ └──┘[1, 3, 5, 6, 8] 7 2 4 ↑ │ └────┘[1, 3, 5, 6, 7, 8] 2 4 ↑ │ └────────────────┘[1, 2, 3, 5, 6, 7, 8] 4 ↑ │ └─────────────┘[1, 2, 3, 4, 5, 6, 7, 8] 动画演示 go语言实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport \"fmt\"//打印func print(arr []int)&#123; for _,data := range arr&#123; fmt.Printf(\"%d \",data) &#125; fmt.Println()&#125;func main()&#123; arr:= []int&#123;8, 5, 2, 6, 9, 3, 1, 4, 0, 7&#125; //arr:=[]int&#123;1,3,2,4,9,2,6,5,4,8&#125; print(arr) insertsort2(arr) print(arr)&#125;// 插入排序func insertsort(arr []int)&#123; //print(arr) length := len(arr) for i:= 1;i&lt;length;i++&#123; temp := arr[i] index:=i for j:= i-1;j&gt;=0;j--&#123; if arr[j] &gt;temp&#123; arr[j+1] = arr[j] &#125;else&#123; break &#125; index-- &#125; arr[index] = temp &#125;&#125;//推荐func insertsort2(arr []int)&#123; //print(arr) length := len(arr) for i:= 1;i&lt;length;i++&#123; temp := arr[i] j:=i-1 for j&gt;=0 &amp;&amp; arr[j] &gt; temp&#123; arr[j+1] = arr[j] j-- &#125; arr[j+1] = temp &#125;&#125; JavaScript 语言实现 直接插入排序 JavaScript 实现代码： 1234567891011121314151617181920function insertionSort(array) &#123; function swap(array, i, j) &#123; var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; var length = array.length, i, j; for (i = 1; i &lt; length; i++) &#123; for (j = i; j &gt; 0; j--) &#123; if (array[j - 1] &gt; array[j]) &#123; swap(array, j - 1, j); &#125; else &#123; break; &#125; &#125; &#125; return array;&#125; 下面这种方式可以减少交换次数： 123456789101112131415161718function insertionSort(array) &#123; var length = array.length, i, j, temp; for (i = 1; i &lt; length; i++) &#123; temp = array[i]; for (j = i; j &gt;= 0; j--) &#123; if (array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; &#125; else &#123; array[j] = temp; break; &#125; &#125; &#125; return array;&#125; 利用二分查找法实现的插入排序，二分查找排序： 123456789101112131415161718192021222324252627282930313233343536373839404142function insertionSort2(array) &#123; function binarySearch(array, start, end, temp) &#123; var middle; while (start &lt;= end) &#123; middle = Math.floor((start + end) / 2); if (array[middle] &lt; temp) &#123; if (temp &lt;= array[middle + 1]) &#123; return middle + 1; &#125; else &#123; start = middle + 1; &#125; &#125; else &#123; if (end === 0) &#123; return 0; &#125; else &#123; end = middle; &#125; &#125; &#125; &#125; function binarySort(array) &#123; var length = array.length, i, j, k, temp; for (i = 1; i &lt; length; i++) &#123; temp = array[i]; if (array[i - 1] &lt;= temp) &#123; k = i; &#125; else &#123; k = binarySearch(array, 0, i - 1, temp); for (j = i; j &gt; k; j--) &#123; array[j] = array[j - 1]; &#125; &#125; array[k] = temp; &#125; return array; &#125; return binarySort(array);&#125; 资料 Wikipedia 维基百科 - 插入排序 维基百科 - 二分查找法 排序算法–折半插入排序（二分查找排序） 直接插入排序 直接插入排序基本思想","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go-数据结构[10]-快速排序","slug":"go-struture-10-quicksort","date":"2019-03-10T04:29:02.000Z","updated":"2019-03-10T05:35:30.288Z","comments":true,"path":"2019/03/10/go-struture-10-quicksort/","link":"","permalink":"https://dreamerjonson.com/2019/03/10/go-struture-10-quicksort/","excerpt":"","text":"pre,code { font-family: \"Source Code Pro\", Consolas, Monaco, Menlo, Consolas, monospace !important; } 快速排序 快速排序是图灵奖得主 C. R. A. Hoare 于 1960 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。 分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 利用分治法可将快速排序的分为三步： 在数据集之中，选择一个元素作为”基准”（pivot）。 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 分区是快速排序的主要内容，用伪代码可以表示如下： 12345678910function partition(a, left, right, pivotIndex) pivotValue :&#x3D; a[pivotIndex] swap(a[pivotIndex], a[right]) &#x2F;&#x2F; 把 pivot 移到結尾 storeIndex :&#x3D; left for i from left to right-1 if a[i] &lt; pivotValue swap(a[storeIndex], a[i]) storeIndex :&#x3D; storeIndex + 1 swap(a[right], a[storeIndex]) &#x2F;&#x2F; 把 pivot 移到它最後的地方 return storeIndex &#x2F;&#x2F; 返回 pivot 的最终位置 首先，把基准元素移到結尾（如果直接选择最后一个元素为基准元素，那就不用移动），然后从左到右（除了最后的基准元素），循环移动小于等于基准元素的元素到数组的开头，每次移动 storeIndex 自增 1，表示下一个小于基准元素将要移动到的位置。循环结束后 storeIndex 所代表的的位置就是基准元素的所有摆放的位置。所以最后将基准元素所在位置（这里是 right）与 storeIndex 所代表的的位置的元素交换位置。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。 一旦我们有了这个分区算法，要写快速排列本身就很容易： 123456procedure quicksort(a, left, right) if right &gt; left select a pivot value a[pivotIndex] pivotNewIndex :&#x3D; partition(a, left, right, pivotIndex) quicksort(a, left, pivotNewIndex-1) quicksort(a, pivotNewIndex+1, right) 过程 举例来说，现有数组 arr = [3,7,8,5,2,1,9,5,4]，分区可以分解成以下步骤： 首先选定一个基准元素，这里我们元素 5 为基准元素（基准元素可以任意选择）： 123 pivot ↓3 7 8 5 2 1 9 5 4 将基准元素与数组中最后一个元素交换位置，如果选择最后一个元素为基准元素可以省略该步： 123 pivot ↓3 7 8 4 2 1 9 5 5 从左到右（除了最后的基准元素），循环移动小于基准元素 5 的所有元素到数组开头，留下大于等于基准元素的元素接在后面。在这个过程它也为基准元素找寻最后摆放的位置。循环流程如下： 循环 i == 0 时，storeIndex == 0，找到一个小于基准元素的元素 3，那么将其与 storeIndex 所在位置的元素交换位置，这里是 3 自身，交换后将 storeIndex 自增 1，storeIndex == 1： 12345 pivot ↓ 3 7 8 4 2 1 9 5 5 ↑storeIndex 循环 i == 3 时，storeIndex == 1，找到一个小于基准元素的元素 4： 12345 ┌───────┐ pivot ↓ ↓ ↓ 3 7 8 4 2 1 9 5 5 ↑ ↑storeIndex i 交换位置后，storeIndex 自增 1，storeIndex == 2： 12345 pivot ↓3 4 8 7 2 1 9 5 5 ↑ storeIndex 循环 i == 4 时，storeIndex == 2，找到一个小于基准元素的元素 2： 12345 ┌───────┐ pivot ↓ ↓ ↓3 4 8 7 2 1 9 5 5 ↑ ↑ storeIndex i 交换位置后，storeIndex 自增 1，storeIndex == 3： 12345 pivot ↓3 4 2 7 8 1 9 5 5 ↑ storeIndex 循环 i == 5 时，storeIndex == 3，找到一个小于基准元素的元素 1： 12345 ┌───────┐ pivot ↓ ↓ ↓3 4 2 7 8 1 9 5 5 ↑ ↑ storeIndex i 交换后位置后，storeIndex 自增 1，storeIndex == 4： 12345 pivot ↓3 4 2 1 8 7 9 5 5 ↑ storeIndex 循环 i == 7 时，storeIndex == 4，找到一个小于等于基准元素的元素 5： 12345 ┌───────────┐ pivot ↓ ↓ ↓3 4 2 1 8 7 9 5 5 ↑ ↑ storeIndex i 交换后位置后，storeIndex 自增 1，storeIndex == 5： 12345 pivot ↓3 4 2 1 5 7 9 8 5 ↑ storeIndex 循环结束后交换基准元素和 storeIndex 位置的元素的位置： 12345 pivot ↓3 4 2 1 5 5 9 8 7 ↑ storeIndex 那么 storeIndex 的值就是基准元素的最终位置，这样整个分区过程就完成了。 go语言实现1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport \"fmt\"//打印func print(arr []int)&#123; for _,data := range arr&#123; fmt.Printf(\"%d \",data) &#125; fmt.Println()&#125;func main()&#123; //arr:= []int&#123;8, 5, 2, 6, 9, 3, 1, 4, 0, 7&#125; arr:=[]int&#123;1,3,2,4,9,2,6,5,4,8&#125; print(arr) quicksort(arr) print(arr)&#125;//快速排序func quicksort(arr []int)&#123; //print(arr) length := len(arr) if length &lt;2&#123; return &#125; index:= 0 start := 0 for i:=1;i&lt;length;i++&#123; if arr[i] &lt;= arr[start]&#123; index++ temp:= arr[index] arr[index] = arr[i] arr[i] = temp &#125; &#125; tmp:= arr[index] arr[index] = arr[start] arr[start] = tmp quicksort(arr[start:index]) quicksort(arr[index+1:length])&#125; 快速排序第二种方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*Copyright © 2018 jonson*/package mainimport \"fmt\"//打印func show(arr []int)&#123; for i:=0;i&lt;len(arr);i++&#123; fmt.Println(arr[i]) &#125; fmt.Println(\"----------------------------------------------\")&#125;func main()&#123; k := []int&#123;1,3,2,4,9,2,6,5,4,8&#125; show(k) quicksort(k) show(k)&#125;func quicksort(arr []int)&#123; if len(arr) &gt;1&#123;//必须要长度大于1才有意义。 end := len(arr) i := 0 j := len(arr) for i&lt;j&#123; for i &lt; end-1&#123; i++ if arr[i] &lt;= arr[0]&#123; break &#125; &#125; for j&gt;0&#123; j-- if arr[j]&gt;=arr[0]&#123; break &#125; &#125; //如果i&lt;j，说明要将这两个元素交换 if i &lt; j&#123; temp :=arr[i] arr[i] = arr[j] arr[j] = temp &#125; &#125; //交换start和 j 。 到此为止， j之前为小于start元素的，j之后为大于start元素的。 tmp := arr[j] arr[j] = arr[0] arr[0] = tmp //递归下去 if j &gt;0 &#123; quicksort(arr[0:j]) &#125; if j+1 &lt; end&#123; quicksort(arr[j+1:end]) &#125; &#125;&#125; c语言实现1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//打印void show(int *a,int length)&#123; for (int i = 0; i &lt; length; i++) &#123; printf(\"%d\\n\", a[i]); &#125; printf(\"---------------------------\\n\");&#125;//快速排序,不仅要写出来，而且要优美//arr 为数组//start 为开始的元素的下标//end 为结束的元素的下标+1void quick_sort(int *arr, int start, int end)&#123; if (start &lt; end) //必须要开始的元素 &lt;结束的元素才有意义。 &#123; //赋值 int i = start; int j = end; //i在++，j在--。第一个do为当i&lt;j时就继续下去。 do &#123; do //此do一直让i++，直到，发现大于start的 &#123; i++; &#125; while (i &lt; end &amp;&amp; arr[i] &lt; arr[start]); do//此do一直让j--，直到，发现小于start的元素 &#123; j--; &#125; while (j&gt;start &amp;&amp; arr[j]&gt;arr[start]); //如果i&lt;j，说明要将这两个元素交换 if (i &lt; j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; while (i&lt;j); //交换start和 j 。 到此为止， j之前为小于start元素的，j之后为大于start元素的。 int temp = arr[j]; arr[j] = arr[start]; arr[start] = temp; //递归下去 quick_sort(arr, start, j); quick_sort(arr, j + 1, end); &#125;&#125;void main()&#123; int a[10] = &#123; 1,3,2,4,9,2,6,5,4,8 &#125;; show(a, 10); quick_sort(a, 0,10); show(a, 10); system(\"pause\");&#125; c语言实现2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//打印void show(int *a,int length)&#123; for (int i = 0; i &lt; length; i++) &#123; printf(\"%d\\n\", a[i]); &#125; printf(\"---------------------------\\n\");&#125;//快速排序,不仅要写出来，而且要优美//arr 为数组//start 为开始的元素的下标//end 为结束的元素的下标+1void quick_sort2(int *arr, int start, int end)&#123; if (start &lt; end) &#123; //start &lt; end 才有进新下去的意义。 //i从第一个开始，记录下标。 int i = start; //从第二个元素开始，循环到末尾 for (int j = start+1; j &lt; end; j++) &#123; //一旦发现比其start小的 if (arr[j] &gt; arr[start]) &#123; //i++,很重要的一步，也就是让发现的小于start的数，依次放置在第2个，第3个....位置上。 i++; //交换 int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; ////交换start和i 。 到此为止， i之前为小于start元素的，i之后为大于start元素的。 int temp = arr[i]; arr[i] = arr[start]; arr[start] = temp; //递归 quick_sort2(arr, start, i); quick_sort2(arr, i+1, end); &#125;&#125;void main()&#123; int a[10] = &#123; 1,3,2,4,9,2,6,5,4,8 &#125;; show(a, 10); quick_sort2(a, 0,10); show(a, 10); system(\"pause\");&#125; JavaScript 语言实现 1234567891011121314151617function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125; JavaScript 语言实现2 123456789101112131415161718192021222324252627282930313233//上面简单版本的缺点是，它需要Ω(n)的额外存储空间，也就跟归并排序一样不好。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和高速缓存的性能。function quickSort(array) &#123; // 交换元素位置 function swap(array, i, k) &#123; var temp = array[i]; array[i] = array[k]; array[k] = temp; &#125; // 数组分区，左小右大 function partition(array, left, right) &#123; var storeIndex = left; var pivot = array[right]; // 直接选最右边的元素为基准元素 for (var i = left; i &lt; right; i++) &#123; if (array[i] &lt; pivot) &#123; swap(array, storeIndex, i); storeIndex++; // 交换位置后，storeIndex 自增 1，代表下一个可能要交换的位置 &#125; &#125; swap(array, right, storeIndex); // 将基准元素放置到最后的正确位置上 return storeIndex; &#125; function sort(array, left, right) &#123; if (left &gt; right) &#123; return; &#125; var storeIndex = partition(array, left, right); sort(array, left, storeIndex - 1); sort(array, storeIndex + 1, right); &#125; sort(array, 0, array.length - 1); return array;&#125; JavaScript 语言实现3 1234567891011121314151617181920212223242526272829303132333435363738function quickSort(arr) &#123; return sort(arr, 0, arr.length - 1); function swap(arr, i, k) &#123; var temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; function sort(arr, start, end) &#123; sort(arr, 0, arr.length - 1); return arr; function swap(arr, i, k) &#123; var temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; function sort(arr, start, end) &#123; if (start &gt;= end) return; var pivot = arr[start], i = start + 1, k = end; while (true) &#123; while (arr[i] &lt; pivot) &#123; i++; &#125; while (arr[k] &gt; pivot) &#123; k--; &#125; if (i &gt;= k) &#123; break; &#125; swap(arr, i, k); &#125; swap(arr, start, k); sort(arr, start, Math.max(0, k - 1)); sort(arr, Math.min(end, k + 1), end); &#125; &#125;&#125; 资料 wiki Quicksort 维基百科 - 快速排序 快速排序（Quicksort）的Javascript实现 Quicksort in JavaScript 经典排序算法 - 快速排序Quick sort 快速排序(QuickSort) ソートアルゴリズムを映像化してみた Stable quicksort in Javascript Friday Algorithms: Quicksort – Difference Between PHP and JavaScript","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go-数据结构[9]-冒泡排序","slug":"go-struture-8-select","date":"2019-03-09T12:26:33.000Z","updated":"2019-03-10T04:30:01.608Z","comments":true,"path":"2019/03/09/go-struture-8-select/","link":"","permalink":"https://dreamerjonson.com/2019/03/09/go-struture-8-select/","excerpt":"","text":"冒泡排序 冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。复杂度o(n2) Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list, compares adjacent pairs and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements “bubble” to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort.[2] Bubble sort can be practical if the input is in mostly sorted order with some out-of-order elements nearly in position. 冒泡排序算法的流程如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。 Google CEO Eric Schmidt asked president Barack Obama once during an interview about the best way to sort one million integers – and Obama, pausing for a moment, then replied: “I think the bubble sort would be the wrong way to go.” 实现过程 以数组 arr = [5, 1, 4, 2, 8] 为例说明，加粗的数字表示每次循环要比较的两个数字： 第一次外循环 ( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变 第二次外循环（除开最后一个元素8，对剩余的序列） ( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道，所以还要进行后续的循环，直到剩余的序列为 1） ( 1 2 4 5 8 ) → ( 1 2 4 5 8 )( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 第四次外循环（最后一次）( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) Go语言实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport \"fmt\"//打印func print(arr []int)&#123; for _,data := range arr&#123; fmt.Printf(\"%d \",data) &#125; fmt.Println()&#125;func main()&#123; arr:= []int&#123;8, 5, 2, 6, 9, 3, 1, 4, 0, 7&#125; print(arr) maopao2(arr) print(arr)&#125;//冒泡排序func maopao(arr []int)&#123; length:= len(arr) //循环的次数，只用循环 length-1次，即最后只用判断两个数就可以了。 for i:=0;i&lt;length-1;i++&#123; //将数冒到最后，冒完后就不管了，因此每一次需要判断的是length - 1 - i长度。 for j:=0;j&lt;length-1-i;j++&#123; //如果前面的数大于后面的数，交换顺序。 if arr[j] &gt; arr[j+1]&#123; temp:= arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125; &#125;&#125;//明白了冒泡的原理，就很容易写出一了倒叙的冒泡func maopao2(arr []int)&#123; length:= len(arr) //和正序一样，倒叙的第一个循环的次数必须是length -1 for i:=length-1;i&gt;0;i--&#123; //第二个循环从最后一个元素开始，一直到只剩下最后一个元素。 //也就是说，最后一次判断为最后两个数之间的判断。 for j:= length -1; j&gt;length -1 - i ;j--&#123; //判断 if arr[j] &gt; arr[j-1]&#123; temp:= arr[j] arr[j] = arr[j-1] arr[j-1] = temp &#125; &#125; &#125;&#125; c语言实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void maopao(int *a,int length);//正序冒泡void maopao2(int *arr, int length);//倒序冒泡void main()&#123; int a[10] = &#123; 1,3,2,4,9,2,6,5,4,8 &#125;; show(a, 10); maopao2(a, 10); show(a, 10); system(\"pause\");&#125;//打印void show(int *a,int length)&#123; for (int i = 0; i &lt; length; i++) &#123; printf(\"%d\\n\", a[i]); &#125; printf(\"---------------------------\\n\");&#125;//冒泡排序，a为数组，length为其长度void maopao(int *a,int length)&#123; //循环的次数，只用循环 length-1次，即最后只用判断两个数就可以了。 for (int i = 0; i &lt; length-1; i++) &#123; //将数冒到最后，冒完后就不管了，因此每一次需要判断的是length - 1 - i长度。 for (int j = 0; j &lt; length - 1 - i;j++) &#123; //如果前面的数大于后面的数，交换顺序。 if (a[j] &gt; a[j + 1]) &#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125;&#125;//明白了冒泡的原理，就很容易写出一了倒叙的冒泡void maopao2(int *arr, int length)&#123; //和正序一样，倒叙的第一个循环的次数必须是length -1 for (int i = length; i &gt; 0; i--) &#123; //第二个循环从最后一个元素开始，一直到只剩下最后一个元素。 //也就是说，最后一次判断为最后两个数之间的判断。 for (int j = length - 1; j &gt; length-i; j--) &#123; //判断 if (arr[j - 1] &gt; arr[j]) &#123; int temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; &#125; &#125; &#125;&#125; js实现 12345678910111213141516function bubbleSort(array) &#123; var length = array.length, i, j, temp; for (i = length - 1; 0 &lt; i; i--) &#123; for (j = 0; j &lt; i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; return array;&#125; 资料 en.wikipedia.org 维基百科，自由的百科全书 Bubble Sort 经典排序算法 - 冒泡排序Bubble sort 冒泡排序","categories":[{"name":"go 数据结构","slug":"go-数据结构","permalink":"https://dreamerjonson.com/categories/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"go 数据结构","slug":"go-数据结构","permalink":"https://dreamerjonson.com/tags/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"go-数据结构[8]-选择排序","slug":"go-structure-6-Selection-Sort","date":"2019-03-09T10:32:04.000Z","updated":"2019-03-10T09:05:15.558Z","comments":true,"path":"2019/03/09/go-structure-6-Selection-Sort/","link":"","permalink":"https://dreamerjonson.com/2019/03/09/go-structure-6-Selection-Sort/","excerpt":"","text":"pre,code { font-family: \"Source Code Pro\", Consolas, Monaco, Menlo, Consolas, monospace !important; } 选择排序 选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的序列进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited. The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right. 实例分析 以数组 arr = [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 为例，先直观看一下每一步的变化，后面再介绍细节 第一次从数组 [8, 5, 2, 6, 9, 3, 1, 4, 0, 7] 中找到最小的数 0，放到数组的最前面（与第一个元素进行交换）： 12345 min ↓8 5 2 6 9 3 1 4 0 7 ↑└───────────────────────────────┘ 交换后： 10 5 2 6 9 3 1 4 8 7 在剩余的序列中 [5, 2, 6, 9, 3, 1, 4, 8, 7] 中找到最小的数 1，与该序列的第一个个元素进行位置交换： 12345 min ↓0 5 2 6 9 3 1 4 8 7 ↑ ↑ └───────────────────┘ 交换后： 10 1 2 6 9 3 5 4 8 7 在剩余的序列中 [2, 6, 9, 3, 5, 4, 8, 7] 中找到最小的数 2，与该序列的第一个个元素进行位置交换（实际上不需要交换）： 12345 min ↓0 1 2 6 9 3 5 4 8 7 ↑ 重复上述过程，直到最后一个元素就完成了排序。 1234567891011121314151617181920212223242526272829303132 min ↓0 1 2 6 9 3 5 4 8 7 ↑ ↑ └───────┘ min ↓0 1 2 3 9 6 5 4 8 7 ↑ ↑ └───────────┘ min ↓0 1 2 3 4 6 5 9 8 7 ↑ ↑ └───┘ min ↓0 1 2 3 4 5 6 9 8 7 ↑ min ↓0 1 2 3 4 5 6 9 8 7 ↑ ↑ └───────┘ min ↓0 1 2 3 4 5 6 7 8 9 ↑ min ↓0 1 2 3 4 5 6 7 8 9 ↑ go语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport \"fmt\"//打印func print(arr []int)&#123; for _,data := range arr&#123; fmt.Printf(\"%d \",data) &#125; fmt.Println() &#125;func main()&#123; arr:= []int&#123;8, 5, 2, 6, 9, 3, 1, 4, 0, 7&#125; print(arr) selectSort(arr) print(arr)&#125; //选择排序func selectSort(arr []int)&#123; length := len(arr) //第一个循环从第一个元素到倒数第二个元素。 for i:= 0;i&lt;length-1;i++&#123; //最小的序号 index:= i //遍历其后面的节点，找到最小的节点的下标。 for j:= i+1;j&lt;length;j++&#123; if arr[index]&gt; arr[j]&#123; //保留下标 index = j &#125; &#125; //index != i，就将最小的数交换到a[i]的位置。 if index != i&#123; temp := arr[i] arr[i] = arr[index] arr[index] = temp &#125; &#125;&#125; c语言实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; void select_sort(int *a,int length) ;void show(int *a,int length);void main()&#123; int a[10] = &#123; 1,3,2,4,9,2,6,5,4,8 &#125;; show(a, 10); select_sort(a, 10); show(a, 10); system(\"pause\");&#125;//打印void show(int *a,int length)&#123; for (int i = 0; i &lt; length; i++) &#123; printf(\"%d\\n\", a[i]); &#125; printf(\"---------------------------\\n\");&#125;//选择排序//选择排序排序，a为数组，length为其长度void select_sort(int *a,int length)&#123; //最小的序号 int min = 0; //第一个循环从第一个元素到倒数第二个元素。 for (int i = 0; i &lt; length - 1; i++) &#123; //保留下标 min = i; //遍历其后面的节点，找到最小的节点的下标。 for (int j = i + 1; j &lt; length; j++) &#123; if (a[j] &gt; a[min]) &#123; min = j; &#125; &#125; //如果min != i，就将最小的数交换到a[i]的位置。 if (min != i) &#123; int temp = a[min]; a[min] = a[i]; a[i] = temp; &#125; &#125;&#125; js实现 1234567891011121314151617181920212223function selectionSort(array) &#123; var length = array.length, i, j, minIndex, minValue, temp; for (i = 0; i &lt; length - 1; i++) &#123; minIndex = i; minValue = array[minIndex]; for (j = i + 1; j &lt; length; j++) &#123; if (array[j] &lt; minValue) &#123; minIndex = j; minValue = array[minIndex]; &#125; &#125; // 交换位置 temp = array[i]; array[i] = minValue; array[minIndex] = temp; &#125; return array&#125; 参考文献 en.wikipedia.org wikibooks 维基百科 Selection sort in JavaScript 直接选择排序(Straight Selection Sort) 经典排序算法 - 选择排序 Selection Sort 选择排序算法","categories":[{"name":"go 数据结构","slug":"go-数据结构","permalink":"https://dreamerjonson.com/categories/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"go 数据结构","slug":"go-数据结构","permalink":"https://dreamerjonson.com/tags/go-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"golang[70]-web编程-未完待续....","slug":"golang-70-web","date":"2019-03-05T02:33:12.000Z","updated":"2019-03-09T10:59:04.473Z","comments":true,"path":"2019/03/05/golang-70-web/","link":"","permalink":"https://dreamerjonson.com/2019/03/05/golang-70-web/","excerpt":"","text":"","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[69]-goland快捷键","slug":"golang-69-shortkey","date":"2019-03-05T02:25:56.000Z","updated":"2019-03-05T02:34:27.513Z","comments":true,"path":"2019/03/05/golang-69-shortkey/","link":"","permalink":"https://dreamerjonson.com/2019/03/05/golang-69-shortkey/","excerpt":"","text":"Mac 键盘符号和修饰键说明 123456789101112131415161718⌘ ——&gt; Command⇧ ——&gt; Shift⌥ ——&gt; Option⌃ ——&gt; Control↩︎ ——&gt; Return&#x2F;Enter⌫ ——&gt; Delete⌦ ——&gt; 向前删除键(Fn + Delete)↑ ——&gt; 上箭头↓ ——&gt; 下箭头← ——&gt; 左箭头→ ——&gt; 右箭头⇞ ——&gt; Page Up(Fn + ↑)⇟ ——&gt; Page Down(Fn + ↓)⇥ ——&gt; 右制表符(Tab键)⇤ ——&gt; 左制表符(Shift + Tab)⎋ ——&gt; Escape(Esc)End ——&gt; Fn + →Home ——&gt; Fn + ← Part 1：Editing（编辑） 12345678910111213141516171819202122232425262728293031323334353637383940快捷键 作用Control + Space 基本的代码补全（补全任何类、方法、变量）Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型）Command + Shift + Enter 自动结束代码，行末自动添加分号Command + P 显示方法的参数信息Control + J 快速查看文档Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）Command + 鼠标放在代码上 显示代码简要信息Command + F1 在错误或警告处显示具体描述信息Command + N, Control + Enter, Control + N 生成代码（getter、setter、hashCode、equals、toString、构造函数等）Control + O 覆盖方法（重写父类方法）Control + I 实现方法（实现接口中的方法）Command + Option + T 包围代码（使用if...else、try...catch、for、synchronized等包围选中的代码）Command + &#x2F; 注释 &#x2F; 取消注释与行注释Command + Option + &#x2F; 注释 &#x2F; 取消注释与块注释Option + 方向键上 连续选中代码块Option + 方向键下 减少当前选中的代码块Control + Shift + Q 显示上下文信息Option + Enter 显示意向动作和快速修复代码Command + Option + L 格式化代码Control + Option + O 优化 importControl + Option + I 自动缩进线Tab &#x2F; Shift + Tab 缩进代码 &#x2F; 反缩进代码Command + X 剪切当前行或选定的块到剪贴板Command + C 复制当前行或选定的块到剪贴板Command + V 从剪贴板粘贴Command + Shift + V 从最近的缓冲区粘贴Command + D 复制当前行或选定的块Command + Delete 删除当前行或选定的块的行Control + Shift + J 智能的将代码拼接成一行Command + Enter 智能的拆分拼接的行Shift + Enter 开始新的一行Command + Shift + U 大小写切换Command + Shift + ] &#x2F; Command + Shift + [ 选择直到代码块结束 &#x2F; 开始Option + Fn + Delete 删除到单词的末尾Option + Delete 删除到单词的开头Command + 加号 &#x2F; Command + 减号 展开 &#x2F; 折叠代码块Command + Shift + 加号 展开所以代码块Command + Shift + 减号 折叠所有代码块Command + W 关闭活动的编辑器选项卡 Part 2：Search / Replace（查询/替换） 12345678910快捷键 作用Double Shift 查询任何东西Command + F 文件内查找Command + G 查找模式下，向下查找Command + Shift + G 查找模式下，向上查找Command + R 文件内替换Command + Shift + F 全局查找（根据路径）Command + Shift + R 全局替换（根据路径）Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在 Keymap 中设置）Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在 Keymap 中设置） Part 3：Usage Search（使用查询） 1234快捷键 作用Option + F7 &#x2F; Command + F7 在文件中查找用法 &#x2F; 在类中查找用法Command + Shift + F7 在文件中突出显示的用法Command + Option + F7 显示用法 Part 4：Compile and Run（编译和运行） 12345678快捷键 作用Command + F9 编译 ProjectCommand + Shift + F9 编译选择的文件、包或模块Control + Option + R 弹出 Run 的可选择菜单Control + Option + D 弹出 Debug 的可选择菜单Control + R 运行Control + D 调试Control + Shift + R, Control + Shift + D 从编辑器运行上下文环境配置 Part 5：Debugging（调试） 1234567891011121314151617181920212223242526272829303132333435363738394041424344快捷键 作用F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法Shift + F8 跳出Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点Option + F8 计算表达式（可以更改变量值使其生效）Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）Command + Shift + F8 查看断点信息Part 6：Navigation（导航）快捷键 作用Command + O 查找类文件Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠&#x2F;Command + Option + O 前往指定的变量 &#x2F; 方法Control + 方向键左 &#x2F; Control + 方向键右 左右切换打开的编辑 tab 页F12 返回到前一个工具窗口Esc 从工具窗口进入代码文件窗口Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口Command + Shift + F4 关闭活动 run&#x2F;messages&#x2F;find&#x2F;... tabCommand + L 在当前文件跳转到某一行的指定处Command + E 显示最近打开的文件记录列表Option + 方向键左 &#x2F; Option + 方向键右 光标跳转到当前单词 &#x2F; 中文句的左 &#x2F; 右侧开头位置Command + Option + 方向键左 &#x2F; Command + Option + 方向键右 退回 &#x2F; 前进到上一个操作的地方Command + Shift + Delete 跳转到最后一个编辑的地方Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的 Finder)Command + B &#x2F; Command + 鼠标点击 进入光标所在的方法&#x2F;变量的接口或是定义处Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口Option + Space, Command + Y 快速打开光标所在方法、类的定义Control + Shift + B 跳转到类型声明处Command + U 前往当前光标所在方法的父类的方法 &#x2F; 接口定义Control + 方向键下 &#x2F; Control + 方向键上 当前光标跳转到当前文件的前一个 &#x2F; 后一个方法名位置Command + ] &#x2F; Command + [ 移动光标到当前所在代码的花括号开始 &#x2F; 结束位置Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）Control + H 显示当前类的层次结构Command + Shift + H 显示方法层次结构Control + Option + H 显示调用层次结构F2 &#x2F; Shift + F2 跳转到下一个 &#x2F; 上一个突出错误或警告的位置F4 &#x2F; Command + 方向键下 编辑 &#x2F; 查看代码源Option + Home 显示到当前文件的导航条F3 选中文件 &#x2F; 文件夹 &#x2F; 代码行，添加 &#x2F; 取消书签Option + F3 选中文件 &#x2F; 文件夹&#x2F;代码行，使用助记符添加 &#x2F; 取消书签Control + 0…Control + 9 定位到对应数值的书签位置Command + F3 显示所有书签 Part 7：Refactoring（重构） 123456789101112快捷键 作用F5 复制文件到指定目录F6 移动文件到指定目录Command + Delete 在文件上为安全删除文件，弹出确认框Shift + F6 重命名文件Command + F6 更改签名Command + Option + N 一致性Command + Option + M 将选中的代码提取为方法Command + Option + V 提取变量Command + Option + F 提取字段Command + Option + C 提取常量Command + Option + P 提取参数 Part 8：VCS / Local History（版本控制 / 本地历史记录） 12345快捷键 作用Command + K 提交代码到版本控制器Command + T 从版本控制器更新代码Option + Shift + C 查看最近的变更记录Control + C 快速弹出版本控制器操作面板 Part 9：Live Templates（动态代码模板） 123快捷键 作用Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住Command + J 插入自定义动态代码模板 Part 10：General（通用） 12345678910111213快捷键 作用Command + 1…Command + 9 打开相应编号的工具窗口Command + S 保存所有Command + Option + Y 同步、刷新Control + Command + F 切换全屏模式Command + Shift + F12 切换最大化编辑器Option + Shift + F 添加到收藏夹Option + Shift + I 检查当前文件与当前的配置文件Control + &#96; 快速切换当前的 scheme（切换主题、代码样式等）Command + , 打开 IDEA 系统设置Command + ; 打开项目结构对话框Shift + Command + A 查找动作（可设置相关选项）Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上 delete，则是关闭对应选中的窗口","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[68]-正则表达式支持","slug":"golang-67-regexp","date":"2019-03-04T15:45:34.000Z","updated":"2019-03-04T15:46:39.898Z","comments":true,"path":"2019/03/04/golang-67-regexp/","link":"","permalink":"https://dreamerjonson.com/2019/03/04/golang-67-regexp/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport \"bytes\"import \"fmt\"import \"regexp\"func main() &#123; // 是否匹配 match, _ := regexp.MatchString(\"p([a-z]+)ch\", \"peach\") fmt.Println(match) // 上面我们直接使用了字符串模式，但是其他的regexp的任务你需要编写一个` `//` regexp `结构优化。 r, _ := regexp.Compile(\"p([a-z]+)ch\") // 此结构体有很多方法，如何上面一样的匹配 fmt.Println(r.MatchString(\"peach\")) // 查找 fmt.Println(r.FindString(\"peach punch\")) // 查找第一个匹配的位置 fmt.Println(r.FindStringIndex(\"peach punch\")) // 全局和括号里面的子集 // for both `p([a-z]+)ch` and `([a-z]+)`. fmt.Println(r.FindStringSubmatch(\"peach punch\"))// 全局和括号里面的子集的序号 fmt.Println(r.FindStringSubmatchIndex(\"peach punch\")) // 发现所有匹配的 fmt.Println(r.FindAllString(\"peach punch pinch\", -1)) // 也适用于子集 fmt.Println(r.FindAllStringSubmatchIndex( \"peach punch pinch\", -1)) // 第2个参数限制匹配的数量 fmt.Println(r.FindAllString(\"peach punch pinch\", 2)) // 字符数组也可以 fmt.Println(r.Match([]byte(\"peach\")))// 当用正则表达式创建常量时你可以使用mustcompile变化编译。 r = regexp.MustCompile(\"p([a-z]+)ch\") fmt.Println(r) // 替换 fmt.Println(r.ReplaceAllString(\"a peach\", \"&lt;fruit&gt;\")) // 自定义替换方式 in := []byte(\"a peach\") out := r.ReplaceAllFunc(in, bytes.ToUpper) fmt.Println(string(out))&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"kali-linux","slug":"kali-linux","date":"2019-03-04T13:52:06.000Z","updated":"2019-03-04T13:55:06.935Z","comments":true,"path":"2019/03/04/kali-linux/","link":"","permalink":"https://dreamerjonson.com/2019/03/04/kali-linux/","excerpt":"","text":"下载：https://www.kali.org/ 下载：https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-image-download/ john 破解MD5 123&gt; locate rockyou.txt&gt; gzip –d rockyou.text.gz&gt; john --worklist&#x3D;rockyou.text.gz --format&#x3D;raw-md5 passw.txt","categories":[{"name":"kali-linux","slug":"kali-linux","permalink":"https://dreamerjonson.com/categories/kali-linux/"}],"tags":[{"name":"kali-linux","slug":"kali-linux","permalink":"https://dreamerjonson.com/tags/kali-linux/"}]},{"title":"golang[7]-数据结构-树的生成与遍历与通道遍历","slug":"golang-7-structure-tree","date":"2019-03-03T03:39:45.000Z","updated":"2019-03-03T04:01:37.921Z","comments":true,"path":"2019/03/03/golang-7-structure-tree/","link":"","permalink":"https://dreamerjonson.com/2019/03/03/golang-7-structure-tree/","excerpt":"","text":"node.go 节点的结构、打印节点、设置节点、遍历节点与通道遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package treeimport \"fmt\"type Node struct &#123; Value int Left, Right *Node&#125;func (node Node) Print() &#123; fmt.Print(node.Value, \" \")&#125;func (node *Node) SetValue(value int) &#123; if node == nil &#123; fmt.Println(\"Setting Value to nil \" + \"node. Ignored.\") return &#125; node.Value = value&#125;func CreateNode(value int) *Node &#123; return &amp;Node&#123;Value: value&#125;&#125;func (node *Node) Traverse() &#123; node.TraverseFunc(func(n *Node) &#123; n.Print() &#125;) fmt.Println()&#125;func (node *Node) TraverseFunc(f func(*Node)) &#123; if node == nil &#123; return &#125; node.Left.TraverseFunc(f) f(node) node.Right.TraverseFunc(f)&#125;func (node *Node) TraverseWithChannel() chan *Node &#123; out := make(chan *Node) go func() &#123; node.TraverseFunc(func(node *Node) &#123; out &lt;- node &#125;) close(out) &#125;() return out&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( \"fmt\" \"github/dreamjonson/tree\")type myTreeNode struct &#123; node *tree.Node&#125;func (myNode *myTreeNode) postOrder() &#123; if myNode == nil || myNode.node == nil &#123; return &#125; left := myTreeNode&#123;myNode.node.Left&#125; right := myTreeNode&#123;myNode.node.Right&#125; left.postOrder() right.postOrder() myNode.node.Print()&#125;func main() &#123; //生成树 var root tree.Node root = tree.Node&#123;Value: 3&#125; root.Left = &amp;tree.Node&#123;&#125; root.Right = &amp;tree.Node&#123;5, nil, nil&#125; root.Right.Left = new(tree.Node) root.Left.Right = tree.CreateNode(2) root.Right.Left.SetValue(4) //遍历树 fmt.Print(\"In-order traversal: \") root.Traverse() //遍历树2 fmt.Print(\"My own post-order traversal: \") myRoot := myTreeNode&#123;&amp;root&#125; myRoot.postOrder() fmt.Println() //统计节点数量 nodeCount := 0 root.TraverseFunc(func(node *tree.Node) &#123; nodeCount++ &#125;) fmt.Println(\"Node count:\", nodeCount) //通道遍历树 c := root.TraverseWithChannel() maxNodeValue := 0 for node := range c &#123; if node.Value &gt; maxNodeValue &#123; maxNodeValue = node.Value &#125; &#125; fmt.Println(\"Max node value:\", maxNodeValue)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[67]-go语言生成文档注释","slug":"golang-67-document","date":"2019-03-02T09:21:53.000Z","updated":"2019-03-02T09:25:44.434Z","comments":true,"path":"2019/03/02/golang-67-document/","link":"","permalink":"https://dreamerjonson.com/2019/03/02/golang-67-document/","excerpt":"","text":"写文档注释 12345678910111213141516171819202122package queue// A FIFO queue.type Queue []int// Pushes the element into the queue.// e.g. q.Push(123)func (q *Queue) Push(v int) &#123; *q = append(*q, v)&#125;// Pops element from head.func (q *Queue) Pop() int &#123; head := (*q)[0] *q = (*q)[1:] return head&#125;// Returns if the queue is empty or not.func (q *Queue) IsEmpty() bool &#123; return len(*q) == 0&#125; 查看文档 1go doc 生成文档 1godoc -http :6060 生成文档注释 queue_test.go 12345678910111213141516171819202122package queueimport \"fmt\"func ExampleQueue_Pop() &#123; q := Queue&#123;1&#125; q.Push(2) q.Push(3) fmt.Println(q.Pop()) fmt.Println(q.Pop()) fmt.Println(q.IsEmpty()) fmt.Println(q.Pop()) fmt.Println(q.IsEmpty()) // Output: // 1 // 2 // false // 3 // true&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[66]-test测试","slug":"golang-66-test","date":"2019-03-01T02:26:31.000Z","updated":"2019-03-05T03:39:00.246Z","comments":true,"path":"2019/03/01/golang-66-test/","link":"","permalink":"https://dreamerjonson.com/2019/03/01/golang-66-test/","excerpt":"","text":"go test 123go test是一个按照一定的约定和组织的测试代码的驱动程序.在包目录内,以_test.go为后缀名的源文件并不是go build构建包的以部分,它们是go test测试的一部分.早*_test.go文件中,有三种类型的函数:测试函数,基准测试函数,例子函数.一个测试函数是以Test为函数名前缀的函数,用于测试程序的一些逻辑行为是否正确; go test会调用这些测试函数并报告测试结果是PASS或FAIL.基准测试函数是以Benchmark为函数名前缀的函数,用于衡量一些函数的性能; go test会多次运行基准函数以计算一个平均的执行时间.例子函数是以Example为函数名前缀的函数,提供一个由机器检测正确性的例子文档go test命令会遍历所有的*_test.go文件中上述函数,然后生成一个临时的main包调用相应的测试函数,然后构建并运行,报告测试结果,最后清理临时文件. 测试函数 每个测试函数必须导入testing 包. 测试函数有如下的签名: 123func TestName(t *testing.T) &#123; &#x2F;&#x2F; ...&#125; 测试函数的名字必须以Test开头, 可选的后缀名必须以大写字母开头: 123func TestSin(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;func TestCos(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125;func TestLog(t *testing.T) &#123; &#x2F;* ... *&#x2F; &#125; 其中t 参数用于报告测试失败和附件的日志信息. 让我们顶一个一个实例包gopl.io/ch11/word1, 只有一个函数IsPalindrome 用于检查一个字符串是否从前向后和从后向前读都一样. (这个实现对于一个字符串是否是回文字符串前后重复测试了两次; 我们稍后会再讨论这个问题.) 12345678910111213&#x2F;&#x2F; Package word provides utilities for word games.package word&#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.&#x2F;&#x2F; (Our first attempt.)func IsPalindrome(s string) bool &#123; for i :&#x3D; range s &#123; if s[i] !&#x3D; s[len(s)-1-i] &#123; return false &#125; &#125; return true&#125; 在相同的目录下, word_test.go 文件包含了TestPalindrome 和TestNonPalindrome 两个测试函数. 每一个都是测试IsPalindrome 是否给出正确的结果, 并使用t.Error 报告失败: 123456789101112131415161718package wordimport &quot;testing&quot;func TestPalindrome(t *testing.T) &#123; if !IsPalindrome(&quot;detartrated&quot;) &#123; t.Error(&#96;IsPalindrome(&quot;detartrated&quot;) &#x3D; false&#96;) &#125; if !IsPalindrome(&quot;kayak&quot;) &#123; t.Error(&#96;IsPalindrome(&quot;kayak&quot;) &#x3D; false&#96;) &#125;&#125;func TestNonPalindrome(t *testing.T) &#123; if IsPalindrome(&quot;palindrome&quot;) &#123; t.Error(&#96;IsPalindrome(&quot;palindrome&quot;) &#x3D; true&#96;) &#125;&#125; go test(或go build)命令如果没有参数指定包那么将默认采用当前目录对应的包.我们可以用下面的命令构建和运行测试. $ cd GOPATH/src/gopl.io/ch11/word1GOPATH/src/gopl.io/ch11/word1 GOPATH/src/gopl.io/ch11/word1 go test ok gopl.io/ch11/word1 0.008s 还比较满意, 我们运行了这个程序, 不过没有提前退出是因为还没有遇到BUG报告. 一个法国名为Noelle Eve Elleon 的用户抱怨IsPalindrome 函数不能识别’‘été.’’. 另外一个来自美国中部用户的抱怨是不能识别’‘A man, a plan, a canal: Panama.’’. 执行特殊和小的BUG报告为我们提供了新的更自然的测试用例. 123456789101112func TestFrenchPalindrome(t *testing.T) &#123; if !IsPalindrome(&quot;été&quot;) &#123; t.Error(&#96;IsPalindrome(&quot;été&quot;) &#x3D; false&#96;) &#125;&#125;func TestCanalPalindrome(t *testing.T) &#123; input :&#x3D; &quot;A man, a plan, a canal: Panama&quot; if !IsPalindrome(input) &#123; t.Errorf(&#96;IsPalindrome(%q) &#x3D; false&#96;, input) &#125;&#125; 为了避免两次输入较长的字符串, 我们使用了提供了有类似Printf 格式化功能的Errorf 函数来汇报错误结果. 当添加了这两个测试用例之后, go test返回了测试失败的信息. 1234567$ go test--- FAIL: TestFrenchPalindrome (0.00s) word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false--- FAIL: TestCanalPalindrome (0.00s) word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; falseFAILFAIL gopl.io&#x2F;ch11&#x2F;word1 0.014s 先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯. 只有这样, 我们才能定位我们要眞正解决的问题. 先写测试用例的另好处是, 运行测试通常会比手工描述报告的处理更快, 这让我们可以进行快速地迭代. 如果测试集有很多运行缓慢的测试, 我们可以通过只选择运行某些特定的测试来加快测试速度. 参数-v用于打印每个测试函数的名字和运行时间: 1234567891011121314$ go test -v&#x3D;&#x3D;&#x3D; RUN TestPalindrome--- PASS: TestPalindrome (0.00s)&#x3D;&#x3D;&#x3D; RUN TestNonPalindrome--- PASS: TestNonPalindrome (0.00s)&#x3D;&#x3D;&#x3D; RUN TestFrenchPalindrome--- FAIL: TestFrenchPalindrome (0.00s) word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false&#x3D;&#x3D;&#x3D; RUN TestCanalPalindrome--- FAIL: TestCanalPalindrome (0.00s) word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; falseFAILexit status 1FAIL gopl.io&#x2F;ch11&#x2F;word1 0.017s 参数-run是一个正则表达式,只有测试函数名被它正确匹配的测试函数才会被go test运行: 12345678910$ go test -v -run&#x3D;&quot;French|Canal&quot;&#x3D;&#x3D;&#x3D; RUN TestFrenchPalindrome--- FAIL: TestFrenchPalindrome (0.00s) word_test.go:28: IsPalindrome(&quot;été&quot;) &#x3D; false&#x3D;&#x3D;&#x3D; RUN TestCanalPalindrome--- FAIL: TestCanalPalindrome (0.00s) word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) &#x3D; falseFAILexit status 1FAIL gopl.io&#x2F;ch11&#x2F;word1 0.014s 当然,一旦我们已经修复了失败的测试用例,在我们提交代码更新之前,我们应该以不带参数的go test命令运行全部的测试用例,以确保更新没有引入新的问题. 我们现在的任务就是修复这些错误. 简要分析后发现第一个BUG的原因是我们采用了byte 而不是rune 序列, 所以像&quot;été&quot; 中的é 等非ASCII 字符不能正确处理. 第二个BUG是因为没有忽略空格和字母的大小写导致的. 针对上述两个BUG, 我们仔细重写了函数: 12345678910111213141516171819202122gopl.io&#x2F;ch11&#x2F;word2&#x2F;&#x2F; Package word provides utilities for word games.package wordimport &quot;unicode&quot;&#x2F;&#x2F; IsPalindrome reports whether s reads the same forward and backward.&#x2F;&#x2F; Letter case is ignored, as are non-letters.func IsPalindrome(s string) bool &#123; var letters []rune for _, r :&#x3D; range s &#123; if unicode.IsLetter(r) &#123; letters &#x3D; append(letters, unicode.ToLower(r)) &#125; &#125; for i :&#x3D; range letters &#123; if letters[i] !&#x3D; letters[len(letters)-1-i] &#123; return false &#125; &#125; return true&#125; 同时我们也将之前的所有测试数据合并到了一个测试中的表格中. 12345678910111213141516171819202122232425func TestIsPalindrome(t *testing.T) &#123; var tests &#x3D; []struct &#123; input string want bool &#125;&#123; &#123;&quot;&quot;, true&#125;, &#123;&quot;a&quot;, true&#125;, &#123;&quot;aa&quot;, true&#125;, &#123;&quot;ab&quot;, false&#125;, &#123;&quot;kayak&quot;, true&#125;, &#123;&quot;detartrated&quot;, true&#125;, &#123;&quot;A man, a plan, a canal: Panama&quot;, true&#125;, &#123;&quot;Evil I did dwell; lewd did I live.&quot;, true&#125;, &#123;&quot;Able was I ere I saw Elba&quot;, true&#125;, &#123;&quot;été&quot;, true&#125;, &#123;&quot;Et se resservir, ivresse reste.&quot;, true&#125;, &#123;&quot;palindrome&quot;, false&#125;, &#x2F;&#x2F; non-palindrome &#123;&quot;desserts&quot;, false&#125;, &#x2F;&#x2F; semi-palindrome &#125; for _, test :&#x3D; range tests &#123; if got :&#x3D; IsPalindrome(test.input); got !&#x3D; test.want &#123; t.Errorf(&quot;IsPalindrome(%q) &#x3D; %v&quot;, test.input, got) &#125; &#125;&#125; 我们的新测试阿都通过了: $ go test gopl.io/ch11/word2 ok gopl.io/ch11/word2 0.015s 这种表格驱动的测试在Go中很常见的. 我们很容易想表格添加新的测试数据, 并且后面的测试逻辑也没有冗余, 这样我们可以更好地完善错误信息. 失败的测试的输出并不包括调用t.Errorf 时刻的堆栈调用信息. 不像其他语言或测试框架的assert 断言, t.Errorf 调用也没有引起panic 或停止测试的执行. 卽使表格中前面的数据导致了测试的失败, 表格后面的测试数据依然会运行测试, 因此在一个测试中我们可能了解多个失败的信息. 如果我们眞的需要停止测试, 或许是因为初始化失败或可能是早先的错误导致了后续错误等原因, 我们可以使用t.Fatal 或t.Fatalf 停止测试. 它们必须在和测试函数同一个goroutine 内调用. 测试失败的信息一般的形式是&quot;f(x) = y, want z&quot;, f(x) 解释了失败的操作和对应的输出, y 是实际的运行结果, z 是期望的正确的结果. 就像前面检查回文字符串的例子, 实际的函数用于f(x) 部分. 如果显示x 是表格驱动型测试中比较重要的部分, 因为同一个断言可能对应不同的表格项执行多次. 要避免无用和冗余的信息. 在测试类似IsPalindrome 返回布尔类型的函数时, 可以忽略并没有额外信息的z 部分. 如果x, y 或z 是y 的长度, 输出一个相关部分的简明总结卽可. 测试的作者应该要努力帮助程序员诊断失败的测试. basic.go 12345func calcTriangle(a, b int) int &#123; var c int c &#x3D; int(math.Sqrt(float64(a*a + b*b))) return c&#125; triangle_test.go 123456789101112131415161718192021package mainimport \"testing\"func TestTriangle(t *testing.T) &#123; tests := []struct&#123; a, b, c int &#125;&#123; &#123;3, 4, 5&#125;, &#123;5, 12, 13&#125;, &#123;8, 15, 17&#125;, &#123;12, 35, 37&#125;, &#123;30000, 40000, 50000&#125;, &#125; for _, tt := range tests &#123; if actual := calcTriangle(tt.a, tt.b); actual != tt.c &#123; t.Errorf(\"calcTriangle(%d, %d); \"+ \"got %d; expected %d\", tt.a, tt.b, actual, tt.c) &#125; &#125;&#125; noreactping_test.go 12345678910111213141516171819202122232425262728293031323334package mainimport \"testing\"func TestSubstr(t *testing.T) &#123; tests := []struct &#123; s string ans int &#125;&#123; // Normal cases &#123;\"abcabcbb\", 3&#125;, &#123;\"pwwkew\", 3&#125;, // Edge cases &#123;\"\", 0&#125;, &#123;\"b\", 1&#125;, &#123;\"bbbbbbbbb\", 1&#125;, &#123;\"abcabcabcd\", 4&#125;, // Chinese support &#123;\"这里是慕课网\", 6&#125;, &#123;\"一二三二一\", 3&#125;, &#123;\"黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花\", 8&#125;, &#125; for _, tt := range tests &#123; actual := lengthOfNonRepeatingSubStr(tt.s) if actual != tt.ans &#123; t.Errorf(\"got %d for input %s; \"+ \"expected %d\", actual, tt.s, tt.ans) &#125; &#125;&#125; 随机测试 表格驱动的测试便于构造基于精心挑选的测试数据的测试用例. 另一种测试思路是随机测试, 也就是通过构造更广泛的随机输入来测试探索函数的行为. 那么对于一个随机的输入, 我们如何能知道希望的输出结果呢? 这里有两种策略. 第一个是编写另一个函数, 使用简单和清晰的算法, 虽然效率较低但是行为和要测试的函数一致, 然后针对相同的随机输入检查两者的输出结果. 第二种是生成的随机输入的数据遵循特定的模式, 这样我们就可以知道期望的输出的模式. 下面的例子使用的是第二种方法: randomPalindrome 函数用于随机生成回文字符串. 1234567891011121314151617181920212223242526272829import \"math/rand\"// randomPalindrome returns a palindrome whose length and contents// are derived from the pseudo-random number generator rng.func randomPalindrome(rng *rand.Rand) string &#123; n := rng.Intn(25) // random length up to 24 runes := make([]rune, n) for i := 0; i &lt; (n+1)/2; i++ &#123; r := rune(rng.Intn(0x1000)) // random rune up to '\\u0999' runes[i] = r runes[n-1-i] = r &#125; return string(runes)&#125;func TestRandomPalindromes(t *testing.T) &#123; // Initialize a pseudo-random number generator. seed := time.Now().UTC().UnixNano() t.Logf(\"Random seed: %d\", seed) rng := rand.New(rand.NewSource(seed)) for i := 0; i &lt; 1000; i++ &#123; p := randomPalindrome(rng) if !IsPalindrome(p) &#123; t.Errorf(\"IsPalindrome(%q) = false\", p) &#125; &#125;&#125; 虽然随机测试有不确定因素, 但是它也是至关重要的, 我们可以从失败测试的日志获取足够的信息. 在我们的例子中, 输入IsPalindrome 的p 参数将告诉我们眞实的数据, 但是对于函数将接受更复杂的输入, 不需要保存所有的输入, 只要日志中简单地记录随机数种子卽可(像上面的方式). 有了这些随机数初始化种子, 我们可以很容易修改测试代码以重现失败的随机测试. 通过使用当前时间作为随机种子, 在整个过程中的每次运行测试命令时都将探索新的随机数据. 如果你使用的是定期运行的自动化测试集成系统, 随机测试将特别有价值. 测试代码覆盖率 12go test -coverprofile&#x3D;c.outgo tool cover -html&#x3D;c.out 性能测试 同一个函数执行N多次。 123456789101112131415161718192021222324252627282930313233343536func BenchmarkSubstr(b *testing.B) &#123; s :&#x3D; &quot;黑化肥挥发发灰会花飞灰化肥挥发发黑会飞花&quot; &#x2F;&#x2F;for i :&#x3D; 0; i &lt; 13; i++ &#123; &#x2F;&#x2F; s &#x3D; s + s &#x2F;&#x2F;&#125; &#x2F;&#x2F;b.Logf(&quot;len(s) &#x3D; %d&quot;, len(s)) ans :&#x3D; 8 &#x2F;&#x2F;b.ResetTimer() for i :&#x3D; 0; i &lt; b.N; i++ &#123; actual :&#x3D; lengthOfNonRepeatingSubStr(s) if actual !&#x3D; ans &#123; b.Errorf(&quot;got %d for input %s; &quot;+ &quot;expected %d&quot;, actual, s, ans) &#125; &#125;&#125;func lengthOfNonRepeatingSubStr(s string) int &#123; lastOccurred :&#x3D; make(map[rune]int) start :&#x3D; 0 maxLength :&#x3D; 0 for i, ch :&#x3D; range []rune(s) &#123; if lastI, ok :&#x3D; lastOccurred[ch]; ok &amp;&amp; lastI &gt;&#x3D; start &#123; start &#x3D; lastI + 1 &#125; if i-start+1 &gt; maxLength &#123; maxLength &#x3D; i - start + 1 &#125; lastOccurred[ch] &#x3D; i &#125; return maxLength&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"docker[4]-front","slug":"docker-front","date":"2019-02-26T09:46:42.000Z","updated":"2019-05-19T09:27:24.070Z","comments":true,"path":"2019/02/26/docker-front/","link":"","permalink":"https://dreamerjonson.com/2019/02/26/docker-front/","excerpt":"","text":"查询 1234567891011121314151617181920docker inspect -f &quot;&#123;&#123; .NetworkSettings &#125;&#125;&quot; f20docker build -t friendlyhello . # Create image using this directory&#39;s Dockerfiledocker run -p 4000:80 friendlyhello # Run &quot;friendlyhello&quot; mapping port 4000 to 80docker run -d -p 4000:80 friendlyhello # Same thing, but in detached modedocker container ls # List all running containersdocker container ls -a # List all containers, even those not runningdocker container stop &lt;hash&gt; # Gracefully stop the specified containerdocker container kill &lt;hash&gt; # Force shutdown of the specified containerdocker container rm &lt;hash&gt; # Remove specified container from this machinedocker container rm $(docker container ls -a -q) # Remove all containersdocker image ls -a # List all images on this machinedocker image rm &lt;image id&gt; # Remove specified image from this machinedocker image rm $(docker image ls -a -q) # Remove all images from this machinedocker login # Log in this CLI session using your Docker credentialsdocker tag &lt;image&gt; username&#x2F;repository:tag # Tag &lt;image&gt; for upload to registrydocker push username&#x2F;repository:tag # Upload tagged image to registrydocker run username&#x2F;repository:tag # Run image from a registry docker stop &#39;docker ps -q&#39; #stop all the running containers 创建react应用并用vscode打开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ create-react-app frontendCreating a new React app in &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;frontend.Installing packages. This might take a couple of minutes.Installing react, react-dom, and react-scripts...&gt; fsevents@1.2.7 install &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;frontend&#x2F;node_modules&#x2F;chokidar&#x2F;node_modules&#x2F;fsevents&gt; node install[fsevents] Success: &quot;&#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;frontend&#x2F;node_modules&#x2F;chokidar&#x2F;node_modules&#x2F;fsevents&#x2F;lib&#x2F;binding&#x2F;Release&#x2F;node-v64-darwin-x64&#x2F;fse.node&quot; is installed via remote&gt; fsevents@1.2.4 install &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;frontend&#x2F;node_modules&#x2F;fsevents&gt; node install[fsevents] Success: &quot;&#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;frontend&#x2F;node_modules&#x2F;fsevents&#x2F;lib&#x2F;binding&#x2F;Release&#x2F;node-v64-darwin-x64&#x2F;fse.node&quot; already installedPass --update-binary to reinstall or --build-from-source to recompile+ react@16.8.3+ react-scripts@2.1.5+ react-dom@16.8.3added 1948 packages from 733 contributors and audited 36230 packages in 147.639sfound 63 low severity vulnerabilities run &#96;npm audit fix&#96; to fix them, or &#96;npm audit&#96; for detailsInitialized a git repository.Success! Created frontend at &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;frontendInside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!We suggest that you begin by typing: cd frontend npm startHappy hacking!jacksondeMacBook-Pro:Downloads jackson$ code frontend 新建Dockerfile.dev 123456789FROM node:alpineWORKDIR &#39;&#x2F;app&#39;COPY package.json .RUN npm installCOPY . .CMD [&quot;npm&quot;,&quot;run&quot;,&quot;start&quot;] 删除node_moudles 构建 1234567891011121314151617181920$ docker build -f Dockerfile.dev .Sending build context to Docker daemon 914.9kBStep 1&#x2F;6 : FROM node:alpine ---&gt; 4e50ad7c0e0bStep 2&#x2F;6 : WORKDIR &#39;&#x2F;app&#39; ---&gt; Using cache ---&gt; e99f36e2e99dStep 3&#x2F;6 : COPY package.json . ---&gt; Using cache ---&gt; c5c9213cbf46Step 4&#x2F;6 : RUN npm install ---&gt; Using cache ---&gt; a770342ca69aStep 5&#x2F;6 : COPY . . ---&gt; 7c0e4f289ad5Step 6&#x2F;6 : CMD [&quot;npm&quot;,&quot;run&quot;,&quot;start&quot;] ---&gt; Running in c9fd7f9cfbbeRemoving intermediate container c9fd7f9cfbbe ---&gt; 80bf791492c9Successfully built 80bf791492c9 运行 12345678910111213141516$ docker run -p 3000:3000 80bf791492c9&gt; frontend@0.1.0 start &#x2F;app&gt; react-scripts startStarting the development server...Compiled successfully!You can now view frontend in the browser. Local: http:&#x2F;&#x2F;localhost:3000&#x2F; On Your Network: http:&#x2F;&#x2F;172.17.0.2:3000&#x2F;Note that the development build is not optimized.To create a production build, use npm run build. 访问 打开浏览器访问localhost:3000即可访问react首页 123456789If you are running on Windows, please read this: Create-React-App has some issues detecting when files get changed on Windows based machines. To fix this, please do the following:In the root project directory, create a file called .envAdd the following text to the file and save it: CHOKIDAR_USEPOLLING&#x3D;trueThat&#39;s all!For more on why this is required, you can check out: https:&#x2F;&#x2F;facebook.github.io&#x2F;create-react-app&#x2F;docs&#x2F;troubleshooting#npm-start-doesn-t-detect-changes 如果要修改react首页的App.js，我们不希望从新生成image。 其中(pwd)代表当前路径 (pwd):/app代表当前路径映射到container中的/app -v /app/node_modules 代表使用container中的node_moudles 12345678910111213141516$ docker run -p 3000:3000 -v &#x2F;app&#x2F;node_modules -v $(pwd):&#x2F;app 80bf791492c9&gt; frontend@0.1.0 start &#x2F;app&gt; react-scripts startStarting the development server...Compiled successfully!You can now view frontend in the browser. Local: http:&#x2F;&#x2F;localhost:3000&#x2F; On Your Network: http:&#x2F;&#x2F;172.17.0.2:3000&#x2F;Note that the development build is not optimized.To create a production build, use npm run build. 测试第一种方式 123456789测试：docker build -f Dockerfile.dev .docker run -it d0ec57f38348 npm run test动态测试的一种方式：docker-compose up新开一个窗口，与已经在docker中的container交互：docker exec -it d0ec57f38348 npm run test 测试第二个方式 创建一个服务器，单独用于测试 修改docker-compose.yml： 12345678910111213141516171819version: &#39;3&#39;services: web: build: context: . dockerfile: Dockerfile.dev ports: - &quot;3000:3000&quot; volumes: - &#x2F;app&#x2F;node_modules - .:&#x2F;app tests: build: context: . dockerfile: Dockerfile.dev volumes: - &#x2F;app&#x2F;node_modules - .:&#x2F;app command: [&quot;npm&quot;,&quot;run&quot;,&quot;test&quot;] 生产环境 生产环境运行nginx服务器，将build文件夹下的所有文件都复制到nginx中 Dockerfile 12345678910FROM node:alpine as builderWORKDIR &#39;&#x2F;app&#39;COPY package*.json .&#x2F;RUN npm installCOPY . .RUN npm run buildFROM nginx EXPOSE 80COPY --from&#x3D;builder &#x2F;app&#x2F;build &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 运行nginx go build . go run -p 8080:80 7912f8a3f73e 部署到github 123456git initgit add README.mdgit add .git commit -m &quot;first commit&quot;git remote add origin https:&#x2F;&#x2F;github.com&#x2F;dreamerjackson&#x2F;docker-react-aws.gitgit push -u origin master .travis.yml Travis CI 123456789sudo: requiredservices:- dockerbefore_install:- docker build -t stephengrider&#x2F;docker-react -f Dockerfile.dev .script:- docker run stephengrider&#x2F;docker-react npm run test -- --coverage 12345678910111213141516171819202122sudo: requiredservices: - dockerbefore_install: - docker build -t stephengrider&#x2F;docker-react -f Dockerfile.dev .script: - docker run stephengrider&#x2F;docker-react npm run test -- --coveragedeploy: provider: elasticbeanstalk region: &quot;us-east-2&quot; app: &quot;docker-react-aws&quot; env: &quot;DockerReactAws-env&quot; bucket_name: &quot;elasticbeanstalk-us-east-2-943387109564&quot; bucket_path: &quot;docker-react-aws&quot; on: branch: master access_key_id: $AWS_ACCESS_KEY secret_access_key: secure: &quot;$AWS_SECRET_KEY&quot;","categories":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/tags/docker/"}]},{"title":"golang[65]-package包","slug":"golang-65-package","date":"2019-02-26T03:01:31.000Z","updated":"2019-03-05T03:39:05.763Z","comments":true,"path":"2019/02/26/golang-65-package/","link":"","permalink":"https://dreamerjonson.com/2019/02/26/golang-65-package/","excerpt":"","text":"现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小的一部分和做很少的设计，因为绝大部分代码都是由他人编写的，它们通过类似包或模块的方式被重用。 Go语言有超过100个的标准包（译注：可以用go list std | wc -l命令查看标准包的具体数目），标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语音开源包，它们可以通过http://godoc.org检索。在本章，我们将演示如果使用已有的包和创建新的包。 包简介 任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。 每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以避免在我们使用它们的时候减少和其它部分名字的冲突。 每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。 当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。卽使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。 每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。 123456789import ( &quot;fmt&quot; &quot;math&#x2F;rand&quot; &quot;encoding&#x2F;json&quot; &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&quot; &quot;github.com&#x2F;go-sql-driver&#x2F;mysql&quot;) 就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google公司内部的Go语言码农，他们就使用内部的多语言构建系统（译注：Google公司使用的是类似Bazel的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境） ，用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更紧密适配他们内部环境。 如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。 包声明 在每个Go语音源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。 例如，math/rand包的每个源文件的开头都包含package rand包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员。 12345678910package mainimport ( &quot;fmt&quot; &quot;math&#x2F;rand&quot;)func main() &#123; fmt.Println(rand.Int())&#125; 通常来说，默认的包名就是包导入路径名的最后一段，因此卽使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。稍后我们将看到如何同时导入两个有相同包名的包。 关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。 第二个例外，包所在的目录中可能有一些文件名是以test.go为后缀的Go源文件（译注：前面必须有其它的字符，因为以前缀的源文件是被忽略的） ，并且这些源文件声明的包名也是以_test为后缀名的。这种目录可以包含两种包：一种普通包，加一种则是测试的外部扩展包。所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖 第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如&quot;gopkg.in/yaml.v2&quot;。这种情况下包的名字并不包含版本号后缀，而是yaml。 导入声明 可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。下面两个导入形式是等价的，但是第二种形式更为常见。 import “fmt” import “os” import ( “fmt” “os” ) 导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt和goimports工具都可以将不同分组导入的包独立排序。） import ( “fmt” “html/template” “os” &quot;golang.org/x/net/html&quot; &quot;golang.org/x/net/ipv4&quot; ) 如果我们想同时导入两个有着名字相同的包，例如math/rand包和crypto/rand包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。 import ( “crypto/rand” mrand “math/rand” // alternative name mrand avoids conflict ) 导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。 导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将&quot;path&quot;标准包重命名为pathpkg。 每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。 如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线_来重命名导入的包。像往常一样，下划线_为空白标识符，并不能被访问。 import _ “image/png” // register PNG decoder 这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。 包和命名 在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。 当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。 它们的名字都简洁明了。例如，不要将一个类似imageutil或ioutilis的通用包命名为util，虽然它看起来很短小。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，例如前面看到的path包。 包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go/types是为了避免和type关键字冲突。 要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了temp包名，虽然并没有持续多久。但这是一个糟糕的尝试，因为temp几乎是临时变量的同义词。然后我们有一段时间使用了temperature作为包名，虽然名字并没有表达包的眞实用途。最后我们改成了和strconv标准包类似的tempconv包名，这个名字比之前的就好多了。 现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如fmt.Println，同时包含了包名和成员名信息。因此，我们一般并不需要关注Println的具体内容，因为fmt包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子： bytes.Equal flag.Int http.Get json.Marshal 我们可以看到一些常用的命名模式。strings包提供了和字符串相关的诸多操作： 123456789package stringsfunc Index(needle, haystack string) inttype Replacer struct&#123; &#x2F;* ... *&#x2F; &#125;func NewReplacer(oldnew ...string) *Replacertype Reader struct&#123; &#x2F;* ... *&#x2F; &#125;func NewReader(s string) *Reader 字符串string本身并没有出现在每个成员名字中。因为用户会这样引用这些成员strings.Index、strings.Replacer等。 其它一些包，可能只描述了单一的数据类型，例如html/template和math/rand等，只暴露一个主要的数据结构和与它相关的方法，还有一个以New命名的函数用于创建实例。 1234package rand &#x2F;&#x2F; &quot;math&#x2F;rand&quot;type Rand struct&#123; &#x2F;* ... *&#x2F; &#125;func New(source Source) *Rand 这可能导致一些名字重复，例如template.Template或rand.Rand，这就是为什么这些种类的包名往往特别短的原因之一。 在另一个极端，还有像net/http包那样含有非常多的名字和种类不多的数据类型，因为它们都是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。 go工具 本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安装Go语言编写的程序。 Go语言的工具箱集合了一系列的功能的命令集。它可以看作是一个包管理器（类似于Linux中的apt和rpm工具），用于包的查询、计算的包依赖关系、从远程版本控制系统和下载它们等任务。它也是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和连接器构建程序，虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的驱动程序，我们将在第11章讨论测试话题。 Go语言工具箱的命令有着类似“瑞士军刀”的风格，带着一打子的子命令，有一些我们经常用到，例如get、run、build和fmt等。你可以运行go或go help命令查看内置的帮助文档，为了查询方便，我们列出了最常用的命令： 12345678910111213141516$ go... build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fmt run gofmt on package sources get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages version print Go version vet run go tool vet on packagesUse &quot;go help [command]&quot; for more information about a command. 为了达到零配置的设计目标，Go语言的工具箱很多地方都依赖各种约定。例如，根据给定的源文件的名称，Go语言的工具可以找到源文件对应的包，因为每个目录只包含了单一的包，并且到的导入路径和工作区的目录结构是对应的。给定一个包的导入路径，Go语言的工具可以找到对应的目录中没个实体对应的源文件。它还可以根据导入路径找到存储代码仓库的远程服务器的URL。 工作区结构 对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录卽可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了。例如，我们在编写本书时将GOPATH设置为HOME/gobook： export GOPATH=HOME/gobookHOME/gobook HOME/gobook go get gopl.io/… 当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这样的： 12345678910111213141516171819202122GOPATH&#x2F; src&#x2F; gopl.io&#x2F; .git&#x2F; ch1&#x2F; helloworld&#x2F; main.go dup&#x2F; main.go ... golang.org&#x2F;x&#x2F;net&#x2F; .git&#x2F; html&#x2F; parse.go node.go ... bin&#x2F; helloworld dup pkg&#x2F; darwin_amd64&#x2F; ... GOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在与GOPATH/src的相对路径为包导入路径的子目录中，例如gopl.io/ch1/helloworld相对应的路径目录。我们看到，一个GOPATH工作区的src目录中可能有多个独立的版本控制系统，例如gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。 第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。 其中go env命令用于查看Go语音工具涉及的所有环境变量的值，包括未设置环境变量的默认值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变量是唯一必需要设置的，但是其它环境变量也会偶尔用到。 123456$ go envGOPATH&#x3D;&quot;&#x2F;home&#x2F;gopher&#x2F;gobook&quot;GOROOT&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;go&quot;GOARCH&#x3D;&quot;amd64&quot;GOOS&#x3D;&quot;darwin&quot;... 下载包 使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。 使用命令go get可以下载一个单一的包或者用…下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org/x/net/html自动出现在本地工作区目录的原因。 一旦go get命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的gopl.io/ch2/popcount包代码进行编码风格检查。它友好地报告了忘记了包的文档： 1234$ go get github.com&#x2F;golang&#x2F;lint&#x2F;golint$ $GOPATH&#x2F;bin&#x2F;golint gopl.io&#x2F;ch2&#x2F;popcountsrc&#x2F;gopl.io&#x2F;ch2&#x2F;popcount&#x2F;main.go:1:1: package comment should be of the form &quot;Package popcount ...&quot; go get命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如Git或Mercurial。运行go help importpath获取相关的信息。 go get命令获取的代码是眞实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org/x/net包目录对应一个Git仓库： 1234$ cd $GOPATH&#x2F;src&#x2F;golang.org&#x2F;x&#x2F;net$ git remote -vorigin https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (fetch)origin https:&#x2F;&#x2F;go.googlesource.com&#x2F;net (push) 需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，眞实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是眞实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面https://golang.org/x/net/html包含了如下的元数据，它告诉Go语言的工具当前包眞实的Git仓库托管地址： 1234$ go build gopl.io&#x2F;ch1&#x2F;fetch$ .&#x2F;fetch https:&#x2F;&#x2F;golang.org&#x2F;x&#x2F;net&#x2F;html | grep go-import&lt;meta name&#x3D;&quot;go-import&quot; content&#x3D;&quot;golang.org&#x2F;x&#x2F;net git https:&#x2F;&#x2F;go.googlesource.com&#x2F;net&quot;&gt; 如果指定-u命令行标志参数，go get命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码那么将不会被自动更新。 go get -u命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较很方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org/x/net/html导入路径可能会变为gopl.io/vendor/golang.org/x/net/html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以通过go help gopath命令查看Vendor的帮助文档。 构建包 go build命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包的可以正确编译的。如果包的名字是main，go build将调用连接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。 因为每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供Go文档服务的golang.org/x/tools/cmd/godoc命令就是放在cmd子目录（§10.7.4）。 每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径知指定，相对路径必须以.或…开头。如果没有指定参数，那么默认指定为当前目录对应的包。下面的命令用于构建同一个包,虽然它们的写法各不相同: $ cd GOPATH/src/gopl.io/ch1/helloworldGOPATH/src/gopl.io/ch1/helloworld GOPATH/src/gopl.io/ch1/helloworld go build 或者： $ cd anywhere $ go build gopl.io/ch1/helloworld 或者： $ cd GOPATHGOPATH GOPATH go build ./src/gopl.io/ch1/helloworld 但不能这样： $ cd GOPATHGOPATH GOPATH go build src/gopl.io/ch1/helloworld Error: cannot find package “src/gopl.io/ch1/helloworld”. 也可以指定包的源文件列表，这一般这只用于构建一些小程序或做一些临时性的实验。如果是main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。 1234567891011121314$ cat quoteargs.gopackage mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; fmt.Printf(&quot;%q\\n&quot;, os.Args[1:])&#125;$ go build quoteargs.go$ .&#x2F;quoteargs one &quot;two three&quot; four\\ five[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;] 特别是对于这类一次性运行的程序，我们希望尽快的构建并运行它。go run命令实际上是结合了构建和运行的两个步骤： 12$ go run quoteargs.go one &quot;two three&quot; four\\ five[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;] 第一行的参数列表中，第一个不是以.go结尾的将作为可执行程序的参数运行。 默认情况下，go build命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。依赖分析和编译过程虽然都是很快的，但是随着项目增加到几十个包和成千上万行代码，依赖关系分析和编译时间的消耗将变的可观，有时候可能需要几秒种，卽使这些依赖项没有改变。 go install命令和go build命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到GOPATH/pkg目录下，目录路径和src目录路径对应，可执行程序被保存到GOPATH/bin目录。（很多用户会将GOPATH/bin添加到可执行程序的搜索列表中。）还有，go install命令和go build命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包，go build -i命令将安装每个目标所依赖的包。 因为编译对应不同的操作系统平台和CPU架构，go install命令会将编译结果安装到GOOS和GOARCH对应的目录。例如，在Mac系统，golang.org/x/net/html包将被安装到GOPATH/pkg/darwin_amd64目录下的golang.org/x/net/html.a文件。 针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH，然后运行构建命令卽可。下面交叉编译的程序将输出它在编译时操作系统和CPU类型： 1234567891011func main() &#123; fmt.Println(runtime.GOOS, runtime.GOARCH)&#125;下面以64位和32位环境分别执行程序：$ go build gopl.io&#x2F;ch10&#x2F;cross$ .&#x2F;crossdarwin amd64$ GOARCH&#x3D;386 go build gopl.io&#x2F;ch10&#x2F;cross$ .&#x2F;crossdarwin 386 有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或提供为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释注释可以提供更多的构建过程控制。例如，文件中可能包含下面的注释： // +build linux darwin 在包声明和包注释的前面，该构建注释参数告诉go build只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件： // +build ignore 更多细节，可以参考go/build包的构建约束部分的文档。 $ go doc go/build 包文档 Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。 Go语言中包文档注释一般是完整的句子，第一行是包的摘要说明，注释后仅跟着包声明语句。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是fmt.Fprintf的文档注释。 // Fprintf formats according to a format specifier and writes to w. // It returns the number of bytes written and any write error encountered. func Fprintf(w io.Writer, format string, a …interface{}) (int, error) Fprintf函数格式化的细节在fmt包文档中描述。如果注释后仅跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。 好的文档并不需要面面俱到，文档本身应该是简洁但可不忽略的。事实上，Go语言的风格更喜欢简洁的文档，并且文档也是需要像代码一样维护的。对于一组声明语句，可以用一个精炼的句子描述，如果是显而易见的功能则并不需要注释。 在本书中，只要空间允许，我们之前很多包声明都包含了注释文档，但你可以从标准库中发现很多更好的例子。有两个工具可以帮到你。 首先是go doc命令，该命令打印包的声明和每个成员的文档注释，下面是整个包的文档： 12345678910111213$ go doc timepackage time &#x2F;&#x2F; import &quot;time&quot;Package time provides functionality for measuring and displaying time.const Nanosecond Duration &#x3D; 1 ...func After(d Duration) &lt;-chan Timefunc Sleep(d Duration)func Since(t Time) Durationfunc Now() Timetype Duration int64type Time struct &#123; ... &#125;...many more... 或者是某个具体包成员的注释文档： 12345$ go doc time.Sincefunc Since(t Time) Duration Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). 或者是某个具体包的一个方法的注释文档： 1234$ go doc time.Duration.Secondsfunc (d Duration) Seconds() float64 Seconds returns the duration as a floating-point number of seconds. 该命令并不需要输入完整的包导入路径或正确的大小写。下面的命令将打印encoding/json包的(*json.Decoder).Decode方法的文档： 123456789$ go doc json.decodefunc (dec *Decoder) Decode(v interface&#123;&#125;) error Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.第二个工具，名字也叫godoc，它提供可以相互交叉引用的HTML页面，但是包含和go doc命令相同以及更多的信息。10.1节演示了time包的文档，11.6节将看到godoc演示可以交互的示例程序。godoc的在线服务https:&#x2F;&#x2F;godoc.org，包含了成千上万的开源包的检索工具。你也可以在自己的工作区目录运行godoc服务。运行下面的命令，然后在浏览器查看http:&#x2F;&#x2F;localhost:8000&#x2F;pkg页面：$ godoc -http :8000其中-analysis&#x3D;type和-analysis&#x3D;pointer命令行标志参数用于打开文档和代码中关于静态分析的结果。 内部包 在Go语音程序中，包的封装机制是一个重要的特性。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。 有时候，一个中间的状态可能也是有用的，对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。 为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。 net/http net/http/internal/chunked net/http/httputil net/url 查询包 go list命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径： 12$ go list github.com&#x2F;go-sql-driver&#x2F;mysqlgithub.com&#x2F;go-sql-driver&#x2F;mysql go list命令的参数还可以用&quot;…&quot;表示匹配任意的包的导入路径。我们可以用它来列表工作区中的所有包： 12345678$ go list ...archive&#x2F;tararchive&#x2F;zipbufiobytescmd&#x2F;addr2linecmd&#x2F;api...many more... 或者是特定子目录下的所有包： 12345678$ go list gopl.io&#x2F;ch3&#x2F;...gopl.io&#x2F;ch3&#x2F;basename1gopl.io&#x2F;ch3&#x2F;basename2gopl.io&#x2F;ch3&#x2F;commagopl.io&#x2F;ch3&#x2F;mandelbrotgopl.io&#x2F;ch3&#x2F;netflaggopl.io&#x2F;ch3&#x2F;printintsgopl.io&#x2F;ch3&#x2F;surface 或者是和某个主题相关的所有包: 123$ go list ...xml...encoding&#x2F;xmlgopl.io&#x2F;ch7&#x2F;xmlselect go list命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中-json命令行参数表示用JSON格式打印每个包的元信息。 12345678910111213141516171819202122232425$ go list -json hash&#123; &quot;Dir&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&#x2F;src&#x2F;hash&quot;, &quot;ImportPath&quot;: &quot;hash&quot;, &quot;Name&quot;: &quot;hash&quot;, &quot;Doc&quot;: &quot;Package hash provides interfaces for hash functions.&quot;, &quot;Target&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&#x2F;pkg&#x2F;darwin_amd64&#x2F;hash.a&quot;, &quot;Goroot&quot;: true, &quot;Standard&quot;: true, &quot;Root&quot;: &quot;&#x2F;home&#x2F;gopher&#x2F;go&quot;, &quot;GoFiles&quot;: [ &quot;hash.go&quot; ], &quot;Imports&quot;: [ &quot;io&quot; ], &quot;Deps&quot;: [ &quot;errors&quot;, &quot;io&quot;, &quot;runtime&quot;, &quot;sync&quot;, &quot;sync&#x2F;atomic&quot;, &quot;unsafe&quot; ]&#125; 命令行参数-f则允许用户使用text/template包（§4.6）的模板语言定义输出文本的格式。下面的命令将打印strconv包的依赖的包，然后用join模板函数将结果链接为一行，连接时每个结果之间用一个空格分隔： 12$ go list -f &#39;&#123;&#123;join .Deps &quot; &quot;&#125;&#125;&#39; strconverrors math runtime unicode&#x2F;utf8 unsafe 译注：上面的命令在Windows的命令行运行会遇到template: main:1: unclosed action的错误。产生这个错误的原因是因为命令行对命令中的&quot; &quot;参数进行了转义处理。可以按照下面的方法解决转义字符串的问题： 1$ go list -f &quot;&#123;&#123;join .Deps \\&quot; \\&quot;&#125;&#125;&quot; strconv 下面的命令打印compress子目录下所有包的依赖包列表： 123456$ go list -f &#39;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#39; compress&#x2F;...compress&#x2F;bzip2 -&gt; bufio io sortcompress&#x2F;flate -&gt; bufio fmt io math sort strconvcompress&#x2F;gzip -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;crc32 io timecompress&#x2F;lzw -&gt; bufio errors fmt iocompress&#x2F;zlib -&gt; bufio compress&#x2F;flate errors fmt hash hash&#x2F;adler32 io 译注：Windows下有同样有问题，要避免转义字符串的干扰： 1$ go list -f &quot;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports \\&quot; \\&quot;&#125;&#125;&quot; compress&#x2F;... go list命令对于一次性的交互式查询或自动化构建或测试脚本都很有帮助。我们将在11.2.4节中再次使用它。每个子命令的更多信息，包括可设置的字段和意义，可以用go help list命令查看。 在本章，我们解释了Go语言工具中除了测试命令之外的所有重要的子命令。在下一章，我们将看到如何用go test命令去运行Go语言程序中的测试代码。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"docker[3]-真实web应用","slug":"docker-webserver","date":"2019-02-25T12:57:42.000Z","updated":"2019-03-14T14:13:15.152Z","comments":true,"path":"2019/02/25/docker-webserver/","link":"","permalink":"https://dreamerjonson.com/2019/02/25/docker-webserver/","excerpt":"","text":"index.js: 1234567891011121314151617181920const express = require('express');const redis = require('redis');const app = express();const client = redis.createClient(&#123; host:'redis-server', // 配合docker-compose使用。//自动连接docker中的后台主机名为redis-server的服务器，默认端口为6379 port:6379&#125;);client.set('visits', 0);app.get('/', (req, res) =&gt; &#123; client.get('visits', (err, visits) =&gt; &#123; res.send('Number of visits is ' + visits); client.set('visits', parseInt(visits) + 1); &#125;);&#125;);app.listen(8081, () =&gt; &#123; console.log('Listening on port 8081');&#125;); package.json 123456789&#123; \"dependencies\": &#123; \"express\": \"*\", \"redis\": \"2.8.0\" &#125;, \"scripts\": &#123; \"start\": \"node index.js\" &#125;&#125; Dockerfile 123456789FROM node:alpineWORKDIR &#39;&#x2F;app&#39;COPY package.json .RUN npm installCOPY . .CMD [&quot;npm&quot;,&quot;start&quot;] 1234567891011121314151617181920212223242526272829$ docker build -t zhuimengshaonian04&#x2F;webtest:latest .Sending build context to Docker daemon 4.096kBStep 1&#x2F;6 : FROM node:alpine ---&gt; 4e50ad7c0e0bStep 2&#x2F;6 : WORKDIR &#39;&#x2F;app&#39; ---&gt; Using cache ---&gt; e99f36e2e99dStep 3&#x2F;6 : COPY package.json . ---&gt; 2b85c0cb1430Step 4&#x2F;6 : RUN npm install ---&gt; Running in a4e0904bb389npm notice created a lockfile as package-lock.json. You should commit this file.npm WARN app No descriptionnpm WARN app No repository field.npm WARN app No license field.added 52 packages from 40 contributors and audited 125 packages in 11.86sfound 0 vulnerabilitiesRemoving intermediate container a4e0904bb389 ---&gt; c479e4e9544dStep 5&#x2F;6 : COPY . . ---&gt; e270a6054ebdStep 6&#x2F;6 : CMD [&quot;npm&quot;,&quot;start&quot;] ---&gt; Running in 46558e1f9bbfRemoving intermediate container 46558e1f9bbf ---&gt; 862676d2443eSuccessfully built 862676d2443eSuccessfully tagged zhuimengshaonian04&#x2F;webtest:latest docker-compose.yml 独立的客户端。docker-compose可以避免繁琐的docker命令，并且让多个container相互通信 12345678version : '3'services: redis-server: #服务器名字 image: 'redis' node-app: #服务器名字 build: . # 使用Dockerfile中的 ports: - \"4001:8081\" #真实端口4001转移到docker端口8081 开启docker-compose 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950$ docker-compose upCreating network &quot;visits2_default&quot; with the default driverBuilding node-appStep 1&#x2F;6 : FROM node:alpine ---&gt; 4e50ad7c0e0bStep 2&#x2F;6 : WORKDIR &#39;&#x2F;app&#39; ---&gt; Using cache ---&gt; e99f36e2e99dStep 3&#x2F;6 : COPY package.json . ---&gt; f58dd6549a9cStep 4&#x2F;6 : RUN npm install ---&gt; Running in d24b1cc9a3c1npm notice created a lockfile as package-lock.json. You should commit this file.npm WARN app No descriptionnpm WARN app No repository field.npm WARN app No license field.added 52 packages from 40 contributors and audited 125 packages in 7.725sfound 0 vulnerabilitiesRemoving intermediate container d24b1cc9a3c1 ---&gt; 43ff230ce2d5Step 5&#x2F;6 : COPY . . ---&gt; bd09786967c4Step 6&#x2F;6 : CMD [&quot;npm&quot;,&quot;start&quot;] ---&gt; Running in d244a10ca082Removing intermediate container d244a10ca082 ---&gt; 7f254839bf80Successfully built 7f254839bf80Successfully tagged visits2_node-app:latestWARNING: Image for service node-app was built because it did not already exist. To rebuild this image you must use &#96;docker-compose build&#96; or &#96;docker-compose up --build&#96;.Creating visits2_node-app_1 ... doneCreating visits2_redis-server_1 ... doneAttaching to visits2_redis-server_1, visits2_node-app_1redis-server_1 | 1:C 26 Feb 01:43:22.949 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis-server_1 | 1:C 26 Feb 01:43:22.955 # Redis version&#x3D;4.0.11, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;1, just startedredis-server_1 | 1:C 26 Feb 01:43:22.955 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server &#x2F;path&#x2F;to&#x2F;redis.confredis-server_1 | 1:M 26 Feb 01:43:22.957 * Running mode&#x3D;standalone, port&#x3D;6379.redis-server_1 | 1:M 26 Feb 01:43:22.957 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.redis-server_1 | 1:M 26 Feb 01:43:22.957 # Server initializedredis-server_1 | 1:M 26 Feb 01:43:22.957 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled&#39; as root, and add it to your &#x2F;etc&#x2F;rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.redis-server_1 | 1:M 26 Feb 01:43:22.957 * Ready to accept connectionsnode-app_1 |node-app_1 | &gt; @ start &#x2F;appnode-app_1 | &gt; node index.jsnode-app_1 |node-app_1 | Listening on port 8081 浏览器中访问 浏览器中访问网址：localhost:4001 利用docker-compose同时管理-释放多个container 开启之前的多个container docker-compose up -d 关闭： docker-compose down 当修改了文件后，更新重构： docker-compose up --build 查看状态：注意必须要在拥有docker-compose.yml的目录下。 docker-compose ps docker-compose 重启规则 “no” 永不重启 always 总是会重启 on-failure 出错代码才会重启 unless-stopped 一直会重启，除非开发者强制关闭，例如执行docker stop","categories":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/tags/docker/"}]},{"title":"golang[64]-同步和锁","slug":"golang-63-concurrentandlock","date":"2019-02-25T09:16:24.000Z","updated":"2019-02-25T15:00:17.365Z","comments":true,"path":"2019/02/25/golang-63-concurrentandlock/","link":"","permalink":"https://dreamerjonson.com/2019/02/25/golang-63-concurrentandlock/","excerpt":"","text":"Race Conditions 在某些情况下，如果并发的情况操作同一个变量可以会出现问题。 123456789101112131415161718192021222324252627282930313233// Package bank implements a bank with only one account.package bankvar balance intfunc Deposit(amount int) &#123; balance = balance + amount &#125;func Balance() int &#123; return balance &#125;考虑下面的情况：// Alice:go func() &#123;bank.Deposit(200) // A1fmt.Println(\"=\", bank.Balance()) // A2&#125;()// Bob:go bank.Deposit(100) // B//会发生非常严重单位问题，不同的顺序可能会导致不同的结果：// Alice first Bob first Alice/Bob/Alice// 0 0 0// A1 200 B 100 A1 200// A2 \"= 200\" A1 300 B 300// B 300 A2 \"= 300\" A2 \"= 300\"如果说第3中还能够保证金额的话，第4种可能性连金额都有问题// Data race// 0// A1r 0 ... = balance + amount// B 100// A1w 200 balance = ...// A2 \"= 200\" 定义 A data race occurs whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. It follows from this definition that there are three ways to avoid a data race. 解决办法 1、不写数据，只读取数据 2、通过通道来通信，修改只限制在唯一的协程中。或者通过管道的方式，将数据限制在唯一的管道中。 3、互斥锁 互斥锁 第一种方式是通过1个buffle的管道，来达到互斥的目的。 1234567891011121314151617181920package bank//!+var ( sema = make(chan struct&#123;&#125;, 1) // a binary semaphore guarding balance balance int)func Deposit(amount int) &#123; sema &lt;- struct&#123;&#125;&#123;&#125; // acquire token balance = balance + amount &lt;-sema // release token&#125;func Balance() int &#123; sema &lt;- struct&#123;&#125;&#123;&#125; // acquire token b := balance &lt;-sema // release token return b&#125; 第二种方式是使用互斥锁：sync.Mutex 1234567891011121314151617181920212223package bank//!+import \"sync\"var ( mu sync.Mutex // guards balance balance int)func Deposit(amount int) &#123; mu.Lock() balance = balance + amount mu.Unlock()&#125;func Balance() int &#123; mu.Lock() b := balance mu.Unlock() return b&#125; 最好是使用defer，延迟释放 12345func Balance() int &#123;mu.Lock()defer mu.Unlock()return balance&#125; 只读锁 只能读，相对于互斥锁，速度更快。 1234567var mu sync.RWMutexvar balance intfunc Balance() int &#123;mu.RLock() &#x2F;&#x2F; readers lockdefer mu.RUnlock()return balance&#125; 内存同步 你可能比较纠结为什么Balance方法需要用到互斥条件，无论是基于channel还是基于互斥量。毕竟和存款不一样，它只由一个简单的操作组成，所以不会碰到其它goroutine在其执行&quot;中&quot;执行其它的逻辑的风险。这里使用mutex有两方面考虑。第一Balance不会在其它操作比如Withdraw“中间”执行。第二(更重要)的是&quot;同步&quot;不仅仅是一堆goroutine执行顺序的问题；同样也会涉及到内存的问题。 在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存(local cache)。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。 考虑一下下面代码片段的可能输出： var x, y int go func() { x = 1 // A1 fmt.Print(“y:”, y, &quot; &quot;) // A2 }() go func() { y = 1 // B1 fmt.Print(“x:”, x, &quot; &quot;) // B2 }() 因为两个goroutine是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况： y:0 x:1 x:0 y:1 x:1 y:1 y:1 x:1 第四行可以被解释为执行顺序A1,B1,A2,B2或者B1,A1,A2,B2的执行结果。然而实际的运行时还是有些情况让我们有点惊讶： x:0 y:0 y:0 x:0 但是根据所使用的编译器，CPU，或者其它很多影响因子，这两种情况也是有可能发生的。那么这两种情况要怎么解释呢？ 在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的；也就是说goroutine是顺序连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。 尽管去理解并发的一种尝试是去将其运行理解为不同goroutine语句的交错执行，但看看上面的例子，这已经不是现代的编译器和cpu的工作方式了。因为赋值和打印指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。如果两个goroutine在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其它goroutine的Print，在主存同步之前就是不可见的了。 所有并发的问题都可以用一致的、简单的旣定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。 竞争条件检测 12345卽使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器(the race detector)。只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test ，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用。(完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的。译注：https:&#x2F;&#x2F;golang.org&#x2F;ref&#x2F;mem )竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，卽数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。9.7节中会有一个竞争检查器的实战样例。竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你到包。由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，卽时是这样，这些代价对于很多生产环境的工作来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。(译注：多少服务端C和C艹程序员为此尽折腰)","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[6]-数据结构-斐波拉契数列","slug":"golang-6-structure-fib","date":"2019-02-24T05:37:21.000Z","updated":"2019-02-28T13:11:46.378Z","comments":true,"path":"2019/02/24/golang-6-structure-fib/","link":"","permalink":"https://dreamerjonson.com/2019/02/24/golang-6-structure-fib/","excerpt":"","text":"方法1 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"time\")//!+func main() &#123; go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow fmt.Printf(\"\\rFibonacci(%d) = %d\\n\", n, fibN)&#125;func spinner(delay time.Duration) &#123; for &#123; for _, r := range `-\\|/` &#123; fmt.Printf(\"\\r%c\", r) time.Sleep(delay) &#125; &#125;&#125;func fib(x int) int &#123; if x &lt; 2 &#123; return x &#125; return fib(x-1) + fib(x-2)&#125; 方法2 12345678// 1, 1, 2, 3, 5, 8, 13, ...func Fibonacci() func() int &#123; a, b := 0, 1 return func() int &#123; a, b = b, a+b return a &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[63]-concurrent并发荟萃","slug":"golang-63-concurrent","date":"2019-02-24T05:23:18.000Z","updated":"2019-03-31T07:52:28.054Z","comments":true,"path":"2019/02/24/golang-63-concurrent/","link":"","permalink":"https://dreamerjonson.com/2019/02/24/golang-63-concurrent/","excerpt":"","text":"goroutine 并发程序指的是同时做好几件事情的程序，随着硬件的发展，并发程序显得越来越重要。Web服务器会一次处理成千上万的请求。平板电脑和手机app在渲染用户动畵的同时，还会后台执行各种计算任务和网络请求。卽使是传统的批处理问题–读取数据，计算，写输出–现在也会用并发来隐藏掉I/O的操作延迟充分利用现代计算机设备的多核，尽管计算机的性能每年都在增长，但并不是线性。 Go语言中的并发程序可以用两种手段来实现。这一章会讲解goroutine和channel，其支持“顺序进程通信”(communicating sequential processes)或被简称为CSP。CSP是一个现代的并发编程模型，在这种编程模型中值会在不同的运行实例(goroutine)中传递，尽管大多数情况下被限制在单一实例中。第9章会覆盖到更为传统的并发模型：多线程共享内存，如果你在其它的主流语言中写过并发程序的话可能会更熟悉一些。第9章同时会讲一些本章不会深入的并发程序带来的重要风险和陷阱。 尽管Go对并发的支持是众多强力特性之一，但大多数情况下跟踪并发程序还是很困难，并且在线性程序中我们的直觉往往还会让我们误入歧途。如果这是你第一次接触并发，那么我推荐你稍微多花一些时间来思考这两个章节中的样例。 在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里有一个程序有两个函数，一个函数做一些计算，另一个输出一些结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用来一个，但如果是在有两个甚至更多个goroutine的程序中，对两个函数的调用就可以在同一时间。我们马上就会看到这样的一个程序。 如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。 当一个程序启动时，其主函数卽在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。 f() // call f(); wait for it to return go f() // create a new goroutine that calls f(); don’t wait 在下面的例子中，main goroutine会计算第45个菲波那契数。由于计算函数使用了效率非常低的递归，所以会运行相当可观的一段时间，在这期间我们想要让用户看到一个可见的标识来表明程序依然在正常运行，所以显示一个动畵的小图标： 12345678910111213141516171819202122func main() &#123; go spinner(100 * time.Millisecond) const n = 45 fibN := fib(n) // slow fmt.Printf(\"\\rFibonacci(%d) = %d\\n\", n, fibN)&#125;func spinner(delay time.Duration) &#123; for &#123; for _, r := range `-\\|/` &#123; fmt.Printf(\"\\r%c\", r) time.Sleep(delay) &#125; &#125;&#125;func fib(x int) int &#123; if x &lt; 2 &#123; return x &#125; return fib(x-1) + fib(x-2)&#125; 动畵显示了几秒之后，fib(45)的调用成功地返回，并且打印结果： Fibonacci(45) = 1134903170 然后主函数返回。当主函数返回时，所有的goroutine都会直接打断，程序退出。除了从主函数退出或者直接退出程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是我们之后可以看到，可以通过goroutine之间的通信来让一个goroutine请求请求其它的goroutine，并让其自己结束执行。 注意这里的两个独立的单元是如何进行组合的，spinning和菲波那契的计算。每一个都是写在独立的函数中，但是每一个函数都会并发地执行。 协程 开启1000个协程，等待1秒后主协程退出 123456789101112131415161718package mainimport ( \"fmt\" \"time\")func main() &#123; for i := 0; i &lt; 1000; i++ &#123; go func(i int) &#123; for &#123; fmt.Printf(\"Hello from \"+ \"goroutine %d\\n\", i) &#125; &#125;(i) &#125; time.Sleep(time.Millisecond)&#125; 检查协程中的竞争 12345678910111213141516171819package mainimport ( \"time\" \"fmt\")func main() &#123; var a [10]int for i := 0; i &lt; 10; i++ &#123; go func(i int) &#123; for &#123; a[i]++ &#125; &#125;(i) &#125; time.Sleep(time.Second) fmt.Println(a)&#125; 输出检查各个协程的工作： [268823720 278385441 259742710 274100267 206918978 216150917 212971051 204840248 201749853 209193197] 1go run -race goroutine.go 输出为： 123456789&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;WARNING: DATA RACERead at 0x00c00001a0a0 by main goroutine: main.main() &#x2F;Users&#x2F;jackson&#x2F;Documents&#x2F;u2pppw&#x2F;goroutine&#x2F;goroutine.go:18 +0xfbPrevious write at 0x00c00001a0a0 by goroutine 6: main.main.func1() &#x2F;Users&#x2F;jackson&#x2F;Documents&#x2F;u2pppw&#x2F;goroutine&#x2F;goroutine.go:13 +0x64 一个陷阱 错误代码 12345678910111213141516171819package mainimport ( \"time\" \"fmt\")func main() &#123; var a [10]int for i := 0; i &lt; 10; i++ &#123; go func() &#123; for &#123; a[i]++ &#125; &#125;() &#125; time.Sleep(time.Second) fmt.Println(a)&#125; 上面的代码错误的原因是：panic: runtime error: index out of range 原因是现在的i的结果为10，超过了数组的限制。 Channels 如果说goroutine是Go语音程序的并发体的话，那么channels它们之间的通信机制。一个channels是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。 使用内置的make函数，我们可以创建一个channel： ch := make(chan int) // ch has type ‘chan int’ 和map类似，channel也一个对应make创建的底层数据结构的引用。当我吗复制一个channel或用于函数参数传递时，我吗只是拷贝了一个channel引用，因此调用者何被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。 两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相通的对象，那么比较的结果为眞。一个channel也可以和nil进行比较。 一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都是用&lt;-运算符。在发送语句中，&lt;-运算符分割channel和要发送的值。在接收语句中，&lt;-运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。 ch &lt;- x // a send statement x = &lt;-ch // a receive expression in an assignment statement &lt;-ch // a receive statement; result is discarded Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel之行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话讲产生一个零值的数据。 使用内置的close函数就可以关闭一个channel： close(ch) 以最简单方式调用make函数创建的时一个无缓存的channel，但是我们也可以指定第二个整形参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。 ch = make(chan int) // unbuffered channel ch = make(chan int, 0) // unbuffered channel ch = make(chan int, 3) // buffered channel with capacity 3 我们将先讨论无缓存的channel，然后在8.4.4节讨论带缓存的channel。 最简单的协程与通道案例 1234567891011121314package mainfunc main() &#123; // create new channel of type int ch := make(chan int) // start new anonymous goroutine go func() &#123; // send 42 to channel ch &lt;- 42 &#125;() // read from channel &lt;-ch&#125; 不带缓存的Channels 一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。 基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在唤醒发送者goroutine之前（译注：happens before，这是Go语言并发内存模型的一个关键术语！）。 在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。 当我们说x事件旣不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。 在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine： 123456789101112131415func main() &#123; conn, err := net.Dial(\"tcp\", \"localhost:8000\") if err != nil &#123; log.Fatal(err) &#125; done := make(chan struct&#123;&#125;) go func() &#123; io.Copy(os.Stdout, conn) // NOTE: ignoring errors log.Println(\"done\") done &lt;- struct&#123;&#125;&#123;&#125; // signal the main goroutine &#125;() mustCopy(conn, os.Stdin) conn.Close() &lt;-done // wait for background goroutine to finish&#125; 当用户关闭了标准输入，主goroutine中的mustCopy函数调用将返回，然后调用conn.Close()关闭读和写方向的网络连接。关闭网络链接中的写方向的链接将导致server程序收到一个文件（end-of-ﬁle）结束的信号。关闭网络链接中读方向的链接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”（“从关闭的链接读”）类似的错误，因此我们临时移除了错误日志语句；在练习8.3将会提供一个更好的解决方案。（需要注意的是go语句调用了一个函数字面量，这Go语言中启动goroutine常用的形式。） 在后台goroutine返回之前，它先打印一个日志信息，然后向done对应的channel发送一个值。主goroutine在退出前先等待从done对应的channel接收一个值。因此，总是可以在程序退出前正确输出“done”消息。 基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为消息事件。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用struct{}空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，done &lt;- 1语句也比done &lt;- struct{}{}更短。 通道作为一等公民 作为参数和返回值 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\" \"time\")func worker(id int, c chan int) &#123; for n := range c &#123; fmt.Printf(\"Worker %d received %c\\n\", id, n) &#125;&#125;func createWorker(id int) chan&lt;- int &#123; c := make(chan int) go worker(id, c) return c&#125;func chanDemo() &#123; var channels [10]chan&lt;- int for i := 0; i &lt; 10; i++ &#123; channels[i] = createWorker(i) &#125; for i := 0; i &lt; 10; i++ &#123; channels[i] &lt;- 'a' + i &#125; for i := 0; i &lt; 10; i++ &#123; channels[i] &lt;- 'A' + i &#125; time.Sleep(time.Millisecond)&#125;func main()&#123; chanDemo()&#125; 构建一个简单的计时器 In fact, you can build a simple timer with this approach - create a channel, start goroutine which writes to this channel after given duration and returns this channel to the caller of your func. The caller then blocks on reading from the channel for the exact amount of time 12345678910111213141516171819package mainimport \"time\"func timer(d time.Duration) &lt;-chan int &#123; c := make(chan int) go func() &#123; time.Sleep(d) c &lt;- 1 &#125;() return c&#125;func main() &#123; for i := 0; i &lt; 24; i++ &#123; c := timer(1 * time.Second) &lt;-c &#125;&#125; Ping-pong 模式 This nice concurrency example was found in a great talk by googler Sameer Ajmani “Advanced Go Concurrency Patterns”. Of course, this pattern isn’t very advanced, but for those who only get themselves familiar with Go concurrency it may look quite fresh and interesting. Here we have a channel as a table of the ping-pong game. The ball is an integer variable, and two goroutines-players that ‘hit’ the ball, increasing its value (hits counter). 1234567891011121314151617181920212223package mainimport \"time\"func main() &#123; var Ball int table := make(chan int) go player(table) go player(table) table &lt;- Ball time.Sleep(1 * time.Second) &lt;-table&#125;func player(table chan int) &#123; for &#123; ball := &lt;-table ball++ time.Sleep(100 * time.Millisecond) table &lt;- ball &#125;&#125; Fan-In模式 扇入 多个入，抢夺一个通道出 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"time\")func producer(ch chan int, d time.Duration) &#123; var i int for &#123; ch &lt;- i i++ time.Sleep(d) &#125;&#125;func reader(out chan int) &#123; for x := range out &#123; fmt.Println(x) &#125;&#125;func main() &#123; ch := make(chan int) out := make(chan int) go producer(ch, 100*time.Millisecond) go producer(ch, 250*time.Millisecond) go reader(out) for i := range ch &#123; out &lt;- i &#125;&#125; fan-out模式 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"fmt\" \"sync\" \"time\")func worker(tasksCh &lt;-chan int, wg *sync.WaitGroup) &#123; defer wg.Done() for &#123; task, ok := &lt;-tasksCh if !ok &#123; return &#125; d := time.Duration(task) * time.Millisecond time.Sleep(d) fmt.Println(\"processing task\", task) &#125;&#125;func pool(wg *sync.WaitGroup, workers, tasks int) &#123; tasksCh := make(chan int) for i := 0; i &lt; workers; i++ &#123; go worker(tasksCh, wg) &#125; for i := 0; i &lt; tasks; i++ &#123; tasksCh &lt;- i &#125; close(tasksCh)&#125;func main() &#123; var wg sync.WaitGroup wg.Add(36) go pool(&amp;wg, 36, 50) wg.Wait()&#125; worker or fan-out模型 多个goroutines抢夺一个通道进行处理 The opposite pattern to fan-in is a fan-out or workers pattern. Multiple goroutines can read from a single channel, distributing an amount of work between CPU cores, hence the workers name. In Go, this pattern is easy to implement - just start a number of goroutines with channel as parameter, and just send values to that channel - distributing and multiplexing will be done by Go runtime, automagically 😃 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\" \"sync\" \"time\")func worker(tasksCh &lt;-chan int, wg *sync.WaitGroup) &#123; defer wg.Done() for &#123; task, ok := &lt;-tasksCh if !ok &#123; return &#125; d := time.Duration(task) * time.Millisecond time.Sleep(d) fmt.Println(\"processing task\", task) &#125;&#125;func pool(wg *sync.WaitGroup, workers, tasks int) &#123; tasksCh := make(chan int) for i := 0; i &lt; workers; i++ &#123; go worker(tasksCh, wg) &#125; for i := 0; i &lt; tasks; i++ &#123; tasksCh &lt;- i &#125; close(tasksCh)&#125;func main() &#123; var wg sync.WaitGroup wg.Add(36) go pool(&amp;wg, 36, 50) wg.Wait()&#125; 更复杂的fan-out模型 worker下面还有子worker 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( \"fmt\" \"sync\" \"time\")const ( WORKERS = 5 SUBWORKERS = 3 TASKS = 20 SUBTASKS = 10)func subworker(subtasks chan int) &#123; for &#123; task, ok := &lt;-subtasks if !ok &#123; return &#125; time.Sleep(time.Duration(task) * time.Millisecond) fmt.Println(task) &#125;&#125;func worker(tasks &lt;-chan int, wg *sync.WaitGroup) &#123; defer wg.Done() for &#123; task, ok := &lt;-tasks if !ok &#123; return &#125; subtasks := make(chan int) for i := 0; i &lt; SUBWORKERS; i++ &#123; go subworker(subtasks) &#125; for i := 0; i &lt; SUBTASKS; i++ &#123; task1 := task * i subtasks &lt;- task1 &#125; close(subtasks) &#125;&#125;func main() &#123; var wg sync.WaitGroup wg.Add(WORKERS) tasks := make(chan int) for i := 0; i &lt; WORKERS; i++ &#123; go worker(tasks, &amp;wg) &#125; for i := 0; i &lt; TASKS; i++ &#123; tasks &lt;- i &#125; close(tasks) wg.Wait()&#125; server Next common pattern is similar to fan-out, but with goroutines spawned for the short period of time, just to accomplish some task. It’s typically used for implementing servers - create a listener, run accept() in a loop and start goroutine for each accepted connection. It’s very expressive and allows to implement server handlers as simple as possible. Take a look at this simple example: 123456789101112131415161718192021222324package mainimport \"net\"func handler(c net.Conn) &#123; c.Write([]byte(\"ok\")) c.Close()&#125;func main() &#123; l, err := net.Listen(\"tcp\", \":5000\") if err != nil &#123; panic(err) &#125; for &#123; c, err := l.Accept() if err != nil &#123; continue &#125; go handler(c) &#125;&#125; It’s not very interesting - it seems there is nothing happens in terms of concurrency. Of course, under the hood there is a ton of complexity, which is deliberately hidden from us. “Simplicity is complicated”. But let’s go back to concurrency and add some interaction to our server. Let’s say, each handler wants to write asynchronously to the logger. Logger itself, in our example, is a separate goroutine which does the job. 改进server，写入log 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\" \"net\" \"time\")func handler(c net.Conn, ch chan string) &#123; ch &lt;- c.RemoteAddr().String() c.Write([]byte(\"ok\")) c.Close()&#125;func logger(ch chan string) &#123; for &#123; fmt.Println(&lt;-ch) &#125;&#125;func server(l net.Listener, ch chan string) &#123; for &#123; c, err := l.Accept() if err != nil &#123; continue &#125; go handler(c, ch) &#125;&#125;func main() &#123; l, err := net.Listen(\"tcp\", \":5000\") if err != nil &#123; panic(err) &#125; ch := make(chan string) go logger(ch) go server(l, ch) time.Sleep(10 * time.Second)&#125; Server + Worker Server with worker example is a bit advanced version of the logger. It not only does some work but sends the result of its work back to the pool using results channel. Not a big deal, but it extends our logger example to something more practical. Let’s see the code and animation: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( \"net\" \"time\")func handler(c net.Conn, ch chan string) &#123; addr := c.RemoteAddr().String() ch &lt;- addr time.Sleep(100 * time.Millisecond) c.Write([]byte(\"ok\")) c.Close()&#125;func logger(wch chan int, results chan int) &#123; for &#123; data := &lt;-wch data++ results &lt;- data &#125;&#125;func parse(results chan int) &#123; for &#123; &lt;-results &#125;&#125;func pool(ch chan string, n int) &#123; wch := make(chan int) results := make(chan int) for i := 0; i &lt; n; i++ &#123; go logger(wch, results) &#125; go parse(results) for &#123; addr := &lt;-ch l := len(addr) wch &lt;- l &#125;&#125;func server(l net.Listener, ch chan string) &#123; for &#123; c, err := l.Accept() if err != nil &#123; continue &#125; go handler(c, ch) &#125;&#125;func main() &#123; l, err := net.Listen(\"tcp\", \":5000\") if err != nil &#123; panic(err) &#125; ch := make(chan string) go pool(ch, 4) go server(l, ch) time.Sleep(10 * time.Second)&#125; 串联的Channels（Pipeline） Channels也可以用于将多个goroutine链接在一起，一个Channels的输出作为下一个Channels的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来 第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；第二个goroutine是一个求平方的程序，对收到的每个整数求平方，然后将平方后的结果通过第二个channel发送给第三个goroutine；第三个goroutine是一个打印程序，打印收到的每个整数。为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此​​简单的运算构建三个goroutine。 123456789101112131415161718192021222324func main() &#123; naturals :&#x3D; make(chan int) squares :&#x3D; make(chan int) &#x2F;&#x2F; Counter go func() &#123; for x :&#x3D; 0; ; x++ &#123; naturals &lt;- x &#125; &#125;() &#x2F;&#x2F; Squarer go func() &#123; for &#123; x :&#x3D; &lt;-naturals squares &lt;- x * x &#125; &#125;() &#x2F;&#x2F; Printer (in main goroutine) for &#123; fmt.Println(&lt;-squares) &#125;&#125; 如您所料，上面的程序将生成0、1、4、9、……形式的无穷数列。像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？ 如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现： close(naturals) 当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立卽返回一个零值。关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。 没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。使用这个特性，我们可以修改squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel. 12345678910go func() &#123; for &#123; x, ok :&#x3D; &lt;-naturals if !ok &#123; break &#x2F;&#x2F; channel was closed and drained &#125; squares &lt;- x * x &#125; close(squares)&#125;() 因为上面的语法是笨拙的，而且这种处理模式很常见，因此Go语言的range循环可直接在channels上面迭代。使用range循环是上面处理模式的简洁语法，它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环 在下面的改进中，我们的计数器goroutine只生成100个含数字的序列，然后关闭naturals对应的channel，这将导致计算平方数的squarer对应的goroutine可以正常终止循环并关闭squares对应的channel。（在一个更复杂的程序中，可以通过defer语句关闭对应的channel。最后，主goroutine也可以正常终止循环并退出程序。 12345678910111213141516171819202122232425func main() &#123; naturals :&#x3D; make(chan int) squares :&#x3D; make(chan int) &#x2F;&#x2F; Counter go func() &#123; for x :&#x3D; 0; x &lt; 100; x++ &#123; naturals &lt;- x &#125; close(naturals) &#125;() &#x2F;&#x2F; Squarer go func() &#123; for x :&#x3D; range naturals &#123; squares &lt;- x * x &#125; close(squares) &#125;() &#x2F;&#x2F; Printer (in main goroutine) for x :&#x3D; range squares &#123; fmt.Println(x) &#125;&#125; 其实你并不需要关闭每一个channel。只要当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。（不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的使用调用对应的Close方法来关闭文件。） 视图重复关闭一个channel将导致panic异常，视图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制，我们将在8.9节讨论。 并发求素数 1234567891011121314151617181920212223242526272829303132333435// A concurrent prime sievepackage mainimport \"fmt\"// Send the sequence 2, 3, 4, ... to channel 'ch'.func Generate(ch chan&lt;- int) &#123; for i := 2; ; i++ &#123; ch &lt;- i // Send 'i' to channel 'ch'. &#125;&#125;// Copy the values from channel 'in' to channel 'out',// removing those divisible by 'prime'.func Filter(in &lt;-chan int, out chan&lt;- int, prime int) &#123; for &#123; i := &lt;-in // Receive value from 'in'. if i%prime != 0 &#123; out &lt;- i // Send 'i' to 'out'. &#125; &#125;&#125;// The prime sieve: Daisy-chain Filter processes.func main() &#123; ch := make(chan int) // Create a new channel. go Generate(ch) // Launch Generate goroutine. for i := 0; i &lt; 10; i++ &#123; prime := &lt;-ch fmt.Println(prime) ch1 := make(chan int) go Filter(ch, ch1, prime) ch = ch1 &#125;&#125; 单方向的Channel 随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个channels连链接它们，它们都是main函数的局部变量。将三个goroutine拆分为以下三个函数是自然的想法： func counter(out chan int) func squarer(out, in chan int) func printer(in chan int) 其中squarer计算平方的函数在两个串联Channels的中间，因此拥有两个channels类型的参数，一个用于输入一个用于输出。每个channels都用有相同的类型，但是它们的使用方式想反：一个只用于接收，另一个只用于发送。参数的名字in和out已经明确表示了这个意图，但是并无法保证squarer函数向一个in参数对应的channels发送数据或者从一个out参数对应的channels接收数据。 这种场景是典型的。当一个channel作为一个函数参数是，它一般总是被专门用于只发送或者只接收。 为了表明这种意图并防止被滥用，Go语言的类型系统提供了单方向的channel类型，分别用于只发送或只接收的channel。类型chan&lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型&lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头&lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。 因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。 这是改进的版本，这一次参数使用了单方向channel类型： gopl.io/ch8/pipeline3 func counter(out chan&lt;- int) { for x := 0; x &lt; 100; x++ { out &lt;- x } close(out) } func squarer(out chan&lt;- int, in &lt;-chan int) { for v := range in { out &lt;- v * v } close(out) } func printer(in &lt;-chan int) { for v := range in { fmt.Println(v) } } func main() { naturals := make(chan int) squares := make(chan int) go counter(naturals) go squarer(squares, naturals) printer(squares) } 调用counter(naturals)将导致将chan int类型的naturals隐式地转换为chan&lt;- int类型只发送型的channel。调用printer(squares)也会导致相似的隐式转换，这一次是转换为&lt;-chan int类型只接收型的channel。任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。这里并没有反向转换的语法：也就是不能一个将类似chan&lt;- int类型的单向型的channel转换为chan int类型的双向型的channel。 带缓存的Channels 带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。图8.2是ch变量对应的channel的图形表示形式。 ch = make(chan string, 3) 向缓存Channel的发送操作就是向内部缓存队列的尾部插入原因，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。 我们可以在无阻塞的情况下连续向新创建的channel发送三个值： ch &lt;- “A” ch &lt;- “B” ch &lt;- “C” 此刻，channel的内部缓存队列将是满的，如果有第四个发送操作将发生阻塞。 如果我们接收一个值， fmt.Println(&lt;-ch) // “A” 那么channel的缓存队列将不是满的也不是空的（图8.4），因此对该channel执行的发送或接收操作都不会发送阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。 在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取： fmt.Println(cap(ch)) // “3” 同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。 fmt.Println(len(ch)) // “2” 在继续执行两次接收操作后channel内部的缓存队列将又成为空的，如果有第四个接收操作将发生阻塞： fmt.Println(&lt;-ch) // “B” fmt.Println(&lt;-ch) // “C” 在这个例子中，发送和接收操作都发生在同一个goroutine中，但是在眞是的程序中它们一般由不同的goroutine执行。Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，一个发送操作——或许是整个程序——可能会永远阻塞。如果你只是需要一个简单的队列，使用slice就可以了。 下面的例子展示了一个使用了带缓存channel的应用。它并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。（顺便说一下，多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。） 123456789func mirroredQuery() string &#123; responses :&#x3D; make(chan string, 3) go func() &#123; responses &lt;- request(&quot;asia.gopl.io&quot;) &#125;() go func() &#123; responses &lt;- request(&quot;europe.gopl.io&quot;) &#125;() go func() &#123; responses &lt;- request(&quot;americas.gopl.io&quot;) &#125;() return &lt;-responses &#x2F;&#x2F; return the quickest response&#125;func request(hostname string) (response string) &#123; &#x2F;* ... *&#x2F; &#125; 如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。 关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，卽使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓冲将导致程序死锁。 Channel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师在生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。 如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕在制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后在加快赶上进度而不影响其其他人。 另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。 生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第阶段厨师的需求。要解决这个问题，我们可以雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作。这类似于基于相同的channels创建另一个独立的goroutine。 123456789func bufferedChannel() &#123; c :&#x3D; make(chan int, 3) go worker(0, c) c &lt;- &#39;a&#39; c &lt;- &#39;b&#39; c &lt;- &#39;c&#39; c &lt;- &#39;d&#39; time.Sleep(time.Millisecond)&#125; 单爬虫 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package mainimport ( \"fmt\" \"os\" \"net/http\" \"golang.org/x/net/html\" \"log\")func breadthFirst(f func(item string) []string, worklist []string) &#123; seen := make(map[string]bool) for len(worklist) &gt; 0 &#123; items := worklist worklist = nil for _, item := range items &#123; if !seen[item] &#123; seen[item] = true worklist = append(worklist, f(item)...) &#125; &#125; &#125;&#125;//!-breadthFirst//!+crawlfunc crawl(url string) []string &#123; fmt.Println(url) list, err := Extract(url) if err != nil &#123; log.Print(err) &#125; return list&#125;//!-crawl//!+mainfunc main() &#123; // Crawl the web breadth-first, // starting from the command-line arguments. breadthFirst(crawl, os.Args[1:])&#125;//!-mainfunc Extract(url string) ([]string, error) &#123; resp, err := http.Get(url) if err != nil &#123; return nil, err &#125; if resp.StatusCode != http.StatusOK &#123; resp.Body.Close() return nil, fmt.Errorf(\"getting %s: %s\", url, resp.Status) &#125; doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil &#123; return nil, fmt.Errorf(\"parsing %s as HTML: %v\", url, err) &#125; var links []string visitNode := func(n *html.Node) &#123; if n.Type == html.ElementNode &amp;&amp; n.Data == \"a\" &#123; for _, a := range n.Attr &#123; if a.Key != \"href\" &#123; continue &#125; link, err := resp.Request.URL.Parse(a.Val) if err != nil &#123; continue // ignore bad URLs &#125; links = append(links, link.String()) &#125; &#125; &#125; forEachNode(doc, visitNode, nil) return links, nil&#125;//!-Extract// Copied from gopl.io/ch5/outline2.func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123; if pre != nil &#123; pre(n) &#125; for c := n.FirstChild; c != nil; c = c.NextSibling &#123; forEachNode(c, pre, post) &#125; if post != nil &#123; post(n) &#125;&#125; 并发爬虫的错误案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( \"fmt\" \"log\" \"os\" \"gopl.io/ch5/links\")//!+crawlfunc crawl(url string) []string &#123; fmt.Println(url) list, err := links.Extract(url) if err != nil &#123; log.Print(err) &#125; return list&#125;//!-crawl//!+mainfunc main() &#123; worklist := make(chan []string) // Start with the command-line arguments. go func() &#123; worklist &lt;- os.Args[1:] &#125;() // Crawl the web concurrently. seen := make(map[string]bool) for list := range worklist &#123; for _, link := range list &#123; if !seen[link] &#123; seen[link] = true go func(link string) &#123; worklist &lt;- crawl(link) &#125;(link) &#125; &#125; &#125;&#125;//!-main/*//!+output$ go build gopl.io/ch8/crawl1$ ./crawl1 http://gopl.io/http://gopl.io/https://golang.org/help/https://golang.org/doc/https://golang.org/blog/...2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files...//!-output*/ 最初的错误信息是一个让人莫名的DNS查找失败，卽使这个域名是完全可靠的。而随后的错误信息揭示了原因：这个程序一次性创建了太多网络连接，超过了每一个进程的打开文件数限制，旣而导致了在调用net.Dial像DNS查找失败这样的问题。 这个程序实在是太他妈并行了。无穷无尽地并行化并不是什么好事情，因为不管怎么说，你的系统总是会有一个些限制因素，比如CPU核心数会限制你的计算负载，比如你的硬盘转轴和磁头数限制了你的本地磁盘IO操作频率，比如你的网络带宽限制了你的下载速度上限，或者是你的一个web服务的服务容量上限等等。为了解决这个问题，我们可以限制并发程序所使用的资源来使之适应自己的运行环境。对于我们的例子来说，最简单的方法就是限制对links.Extract在同一时间最多不会有超过n次调用，这里的n是fd的limit-20，一般情况下。 我们可以用一个有容量限制的buffered channel来控制并发，这类似于操作系统里的计数信号量概念。从概念上讲，channel里的n个空槽代表n个可以处理内容的token(通行证)，从channel里接收一个值会释放其中的一个token，并且生成一个新的空槽位。这样保证了在没有接收介入时最多有n个发送操作。(这里可能我们拿channel里填充的槽来做token更直观一些，不过还是这样吧~)。由于channel里的元素类型并不重要，我们用一个零值的struct{}来作为其元素。 让我们重写crawl函数，将对links.Extract的调用操作用获取、释放token的操作包裹起来，来确保同一时间对其只有20个调用。信号量数量和其能操作的IO资源数量应保持接近。 第二个问题是这个程序永远都不会终止，卽使它已经爬到了所有初始链接衍生出的链接。为了使这个程序能够终止，我们需要在worklist为空或者没有crawl的goroutine在运行时退出主循环。这个版本中，计算器n对worklist的发送操作数量进行了限制。每一次我们发现有元素需要被发送到worklist时，我们都会对n进行操作，在向worklist中发送初始的命令行参数之前，我们也进行过一次操作。这里的操作++是在每启动一个crawler的goroutine之前。主循环会在n减为0时终止，这时候说明没活可干了。 现在这个并发爬虫会比5.6节中的深度优先搜索版快上20倍，而且不会出什么错，并且在其完成任务时也会正确地终止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"fmt\" \"log\" \"os\" \"gopl.io/ch5/links\")//!+sema// tokens is a counting semaphore used to// enforce a limit of 20 concurrent requests.var tokens = make(chan struct&#123;&#125;, 20)func crawl(url string) []string &#123; fmt.Println(url) tokens &lt;- struct&#123;&#125;&#123;&#125; // acquire a token list, err := links.Extract(url) &lt;-tokens // release the token if err != nil &#123; log.Print(err) &#125; return list&#125;//!-sema//!+func main() &#123; worklist := make(chan []string) var n int // number of pending sends to worklist // Start with the command-line arguments. n++ go func() &#123; worklist &lt;- os.Args[1:] &#125;() // Crawl the web concurrently. seen := make(map[string]bool) for ; n &gt; 0; n-- &#123; list := &lt;-worklist for _, link := range list &#123; if !seen[link] &#123; seen[link] = true n++ go func(link string) &#123; worklist &lt;- crawl(link) &#125;(link) &#125; &#125; &#125;&#125; 下面的程序是避免过度并发的另一种思路。这个版本使用了原来的crawl函数，但没有使用计数信号量，取而代之用了20个长活的crawler goroutine，这样来保证最多20个HTTP请求在并发。 123456789101112131415161718192021222324252627282930func main() &#123; worklist := make(chan []string) // lists of URLs, may have duplicates unseenLinks := make(chan string) // de-duplicated URLs // Add command-line arguments to worklist. go func() &#123; worklist &lt;- os.Args[1:] &#125;() // Create 20 crawler goroutines to fetch each unseen link. for i := 0; i &lt; 20; i++ &#123; go func() &#123; for link := range unseenLinks &#123; foundLinks := crawl(link) go func() &#123; worklist &lt;- foundLinks &#125;() &#125; &#125;() &#125; // The main goroutine de-duplicates worklist items // and sends the unseen ones to the crawlers. seen := make(map[string]bool) for list := range worklist &#123; for _, link := range list &#123; if !seen[link] &#123; seen[link] = true unseenLinks &lt;- link &#125; &#125; &#125;&#125; 所有的爬虫goroutine现在都是被同一个channel-unseenLinks喂饱的了。主goroutine负责拆分它从worklist里拿到的元素，然后把没有抓过的经由unseenLinks channel发送给一个爬虫的goroutine。 seen这个map被限定在main goroutine中；也就是说这个map只能在main goroutine中进行访问。类似于其它的信息隐藏方式，这样的约束可以让我们从一定程度上保证程序的正确性。例如，内部变量不能够在函数外部被访问到；变量在没有被转义的情况下是无法在函数外部访问的；一个对象的封装字段无法被该对象的方法以外的方法访问到。在所有的情况下，信息隐藏都可以帮助我们约束我们的程序，使其不发生意料之外的情况。 crawl函数爬到的链接在一个专有的goroutine中被发送到worklist中来避免死锁。为了节省空间，这个例子的终止问题我们先不进行详细阐述了。 基于select的多路复用 下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。 123456789func main() &#123; fmt.Println(&quot;Commencing countdown.&quot;) tick :&#x3D; time.Tick(1 * time.Second) for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123; fmt.Println(countdown) j&lt;-tick &#125; launch()&#125; 现在我们让这个程序支持在倒计时中，用户按下return键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中调入一个单独的byte并且，如果成功了，会向名为abort的channel发送一个值。 12345abort :&#x3D; make(chan struct&#123;&#125;)go func() &#123; os.Stdin.Read(make([]byte, 1)) &#x2F;&#x2F; read a single byte abort &lt;- struct&#123;&#125;&#123;&#125;&#125;() 现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了：ticker channel当一切正常时(就像NASA jorgon的&quot;nominal&quot;，译注：这梗估计我们是不懂了)或者异常时返回的abort事件。我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用(multiplex)这些操作了，为了能够多路复用，我们使用了select语句。 select { case &lt;-ch1: // … case x := &lt;-ch2: // …use x… case ch3 &lt;- y: // … default: // … } 上面是select语句的一般形式。和switch语句稍微有点相似，也会有几个case和最后的default选择支。每一个case代表一个通信操作(在某个channel上进行发送或者接收)并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身(译注：不把接收到的值赋值给变量什么的)，就像上面的第一个case，或者包含在一个简短的变量声明中，像第二个case里一样；第二种形式让你能够引用接收到的值。 select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。 让我们回到我们的火箭发射程序。time.After函数会立卽返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句会会一直等待到两个事件中的一个到达，无论是abort事件或者一个10秒经过的事件。如果10秒经过了还没有abort事件进入，那么火箭就会发射。 12345678910111213func main() &#123; &#x2F;&#x2F; ...create abort channel... fmt.Println(&quot;Commencing countdown. Press return to abort.&quot;) select &#123; case &lt;-time.After(10 * time.Second): &#x2F;&#x2F; Do nothing. case &lt;-abort: fmt.Println(&quot;Launch aborted!&quot;) return &#125; launch()&#125; 下面这个例子更微秒。ch这个channel的buffer大小是1，所以会交替的为空或为满，所以只有一个case可以进行下去，无论i是奇数或者偶数，它都会打印0 2 4 6 8。 12345678ch :&#x3D; make(chan int, 1)for i :&#x3D; 0; i &lt; 10; i++ &#123; select &#123; case x :&#x3D; &lt;-ch: fmt.Println(x) &#x2F;&#x2F; &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot; case ch &lt;- i: &#125;&#125; 如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。增加前一个例子的buffer大小会使其输出变得不确定，因为当buffer旣不为满也不为空时，select语句的执行情况就像是抛硬币的行为一样是随机的。 下面让我们的发射程序打印倒计时。这里的select语句会使每次循环迭代等待一秒来执行退出操作。 1234567891011121314151617func main() &#123; &#x2F;&#x2F; ...create abort channel... fmt.Println(&quot;Commencing countdown. Press return to abort.&quot;) tick :&#x3D; time.Tick(1 * time.Second) for countdown :&#x3D; 10; countdown &gt; 0; countdown-- &#123; fmt.Println(countdown) select &#123; case &lt;-tick: &#x2F;&#x2F; Do nothing. case &lt;-abort: fmt.Println(&quot;Launch aborted!&quot;) return &#125; &#125; launch()&#125; time.Tick函数表现得好像它创建了一个在循环中调用time.Sleep的goroutine，每次被唤醒时发送一个事件。当countdown函数返回时，它会停止从tick中接收事件，但是ticker这个goroutine还依然存活，继续徒劳地尝试从channel中发送值，然而这时候已经没有其它的goroutine会从该channel中接收值了–这被称为goroutine泄露(§8.4.4)。 Tick函数挺方便，但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适。否则的话，我们应该使用下面的这种模式： ticker := time.NewTicker(1 * time.Second) &lt;-ticker.C // receive from the ticker’s channel ticker.Stop() // cause the ticker’s goroutine to terminate 有时候我们希望能够从channel中发送或者接收值，并避免因为发送或者接收导致的阻塞，尤其是当channel没有准备好写或者读时。select语句就可以实现这样的功能。select会有一个default来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑。 下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。 1234567select &#123;case &lt;-abort: fmt.Printf(&quot;Launch aborted!\\n&quot;) returndefault: &#x2F;&#x2F; do nothing&#125; channel的零值是nil。也许会让你觉得比较奇怪，nil的channel有时候也是有一些用处的。因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。 这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。我们会在下一节中看到一个例子。 select一个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"fmt\" \"math/rand\" \"time\")func generator() chan int &#123; out := make(chan int) go func() &#123; i := 0 for &#123; time.Sleep( time.Duration(rand.Intn(1500)) * time.Millisecond) out &lt;- i i++ &#125; &#125;() return out&#125;func worker(id int, c chan int) &#123; for n := range c &#123; time.Sleep(time.Second) fmt.Printf(\"Worker %d received %d\\n\", id, n) &#125;&#125;func createWorker(id int) chan&lt;- int &#123; c := make(chan int) go worker(id, c) return c&#125;func main() &#123; var c1, c2 = generator(), generator() var worker = createWorker(0) var values []int tm := time.After(10 * time.Second) //10秒后往通道发送消息 tick := time.Tick(time.Second) //每隔一秒钟发送一次 for &#123; var activeWorker chan&lt;- int var activeValue int if len(values) &gt; 0 &#123; activeWorker = worker activeValue = values[0] &#125; select &#123; case n := &lt;-c1: values = append(values, n) case n := &lt;-c2: values = append(values, n) case activeWorker &lt;- activeValue: values = values[1:] case &lt;-time.After(800 * time.Millisecond): fmt.Println(\"timeout\") case &lt;-tick: fmt.Println( \"queue len =\", len(values)) case &lt;-tm: fmt.Println(\"bye\") return &#125; &#125;&#125; select的第二个例子： 时间+先到先得，但是只能一次 123456789101112131415func ToChansTimedTimerSelect(d time.Duration, message Type, a, b chan Type) (written int) &#123; t :&#x3D; time.NewTimer(d) for i :&#x3D; 0; i &lt; 2; i++ &#123; select &#123; case a &lt;- message: a &#x3D; nil case b &lt;- message: b &#x3D; nil case &lt;-t.C: return i &#125; &#125; t.Stop() return 2&#125; time.timer定时器 死锁 12345678910111213141516171819202122232425262728293031package mainimport \"time\"func toChanTimed(t *time.Timer, ch chan int) &#123; t.Reset(1 * time.Second) defer func() &#123; if !t.Stop() &#123; &lt;-t.C &#125; &#125;() select &#123; case ch &lt;- 42: case &lt;-t.C: return &#125;&#125;func main()&#123; t := time.NewTimer(time.Second) var ch chan int = make(chan int) toChanTimed(t,ch)&#125; 正确： t.reset 与t.stop()不能并发 12345678910111213141516171819202122232425262728package mainimport \"time\"func toChanTimed(t *time.Timer, ch chan int) &#123; t.Reset(1 * time.Second) select &#123; case ch &lt;- 42: case &lt;-t.C: return &#125; if !t.Stop() &#123; &lt;-t.C &#125;&#125;func main()&#123; t := time.NewTimer(time.Second) var ch chan int = make(chan int) toChanTimed(t,ch)&#125; 并发的文件遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"flag\" \"fmt\" \"io/ioutil\" \"os\" \"path/filepath\")func main() &#123; // Determine the initial directories. flag.Parse() roots := flag.Args() if len(roots) == 0 &#123; roots = []string&#123;\".\"&#125; &#125; // Traverse the file tree. fileSizes := make(chan int64) go func() &#123; for _, root := range roots &#123; walkDir(root, fileSizes) &#125; close(fileSizes) &#125;() // Print the results. var nfiles, nbytes int64 for size := range fileSizes &#123; nfiles++ nbytes += size &#125; printDiskUsage(nfiles, nbytes)&#125;func printDiskUsage(nfiles, nbytes int64) &#123; fmt.Printf(\"%d files %.1f GB\\n\", nfiles, float64(nbytes)/1e9)&#125;//!-main//!+walkDir// walkDir recursively walks the file tree rooted at dir// and sends the size of each found file on fileSizes.func walkDir(dir string, fileSizes chan&lt;- int64) &#123; for _, entry := range dirents(dir) &#123; if entry.IsDir() &#123; subdir := filepath.Join(dir, entry.Name()) walkDir(subdir, fileSizes) &#125; else &#123; fileSizes &lt;- entry.Size() &#125; &#125;&#125;// dirents returns the entries of directory dir.func dirents(dir string) []os.FileInfo &#123; entries, err := ioutil.ReadDir(dir) if err != nil &#123; fmt.Fprintf(os.Stderr, \"du1: %v\\n\", err) return nil &#125; return entries&#125;//!-walkDir// The du1 variant uses two goroutines and// prints the total after every file is found. 并发的文件遍历2 借助select能够打印出过程有点意思。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package main// The du2 variant uses select and a time.Ticker// to print the totals periodically if -v is set.import ( \"flag\" \"fmt\" \"io/ioutil\" \"os\" \"path/filepath\" \"time\")//!+var verbose = flag.Bool(\"v\", false, \"show verbose progress messages\")func main() &#123; // ...start background goroutine... //!- // Determine the initial directories. flag.Parse() roots := flag.Args() if len(roots) == 0 &#123; roots = []string&#123;\".\"&#125; &#125; // Traverse the file tree. fileSizes := make(chan int64) go func() &#123; for _, root := range roots &#123; walkDir(root, fileSizes) &#125; close(fileSizes) &#125;() //!+ // Print the results periodically. var tick &lt;-chan time.Time if *verbose &#123; tick = time.Tick(500 * time.Millisecond) &#125; var nfiles, nbytes int64loop: for &#123; select &#123; case size, ok := &lt;-fileSizes: if !ok &#123; break loop // fileSizes was closed &#125; nfiles++ nbytes += size case &lt;-tick: printDiskUsage(nfiles, nbytes) &#125; &#125; printDiskUsage(nfiles, nbytes) // final totals&#125;//!-func printDiskUsage(nfiles, nbytes int64) &#123; fmt.Printf(\"%d files %.1f GB\\n\", nfiles, float64(nbytes)/1e9)&#125;// walkDir recursively walks the file tree rooted at dir// and sends the size of each found file on fileSizes.func walkDir(dir string, fileSizes chan&lt;- int64) &#123; for _, entry := range dirents(dir) &#123; if entry.IsDir() &#123; subdir := filepath.Join(dir, entry.Name()) walkDir(subdir, fileSizes) &#125; else &#123; fileSizes &lt;- entry.Size() &#125; &#125;&#125;// dirents returns the entries of directory dir.func dirents(dir string) []os.FileInfo &#123; entries, err := ioutil.ReadDir(dir) if err != nil &#123; fmt.Fprintf(os.Stderr, \"du: %v\\n\", err) return nil &#125; return entries&#125; 并发的文件遍历3 改进在：1、main函数中，每一个目录都加了goroutines。 2、信号量 3、sync.WaitGroup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package main// The du3 variant traverses all directories in parallel.// It uses a concurrency-limiting counting semaphore// to avoid opening too many files at once.import ( \"flag\" \"fmt\" \"io/ioutil\" \"os\" \"path/filepath\" \"sync\" \"time\")var vFlag = flag.Bool(\"v\", false, \"show verbose progress messages\")//!+func main() &#123; // ...determine roots... //!- flag.Parse() // Determine the initial directories. roots := flag.Args() if len(roots) == 0 &#123; roots = []string&#123;\".\"&#125; &#125; //!+ // Traverse each root of the file tree in parallel. fileSizes := make(chan int64) var n sync.WaitGroup for _, root := range roots &#123; n.Add(1) //sync.WaitGroup 等待协程 go walkDir(root, &amp;n, fileSizes) //协程 &#125; go func() &#123; n.Wait() close(fileSizes) &#125;() //!- // Print the results periodically. var tick &lt;-chan time.Time if *vFlag &#123; tick = time.Tick(500 * time.Millisecond) &#125; var nfiles, nbytes int64loop: for &#123; select &#123; case size, ok := &lt;-fileSizes: if !ok &#123; break loop // fileSizes was closed &#125; nfiles++ nbytes += size case &lt;-tick: printDiskUsage(nfiles, nbytes) &#125; &#125; printDiskUsage(nfiles, nbytes) // final totals //!+ // ...select loop...&#125;//!-func printDiskUsage(nfiles, nbytes int64) &#123; fmt.Printf(\"%d files %.1f GB\\n\", nfiles, float64(nbytes)/1e9)&#125;// walkDir recursively walks the file tree rooted at dir// and sends the size of each found file on fileSizes.//!+walkDirfunc walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123; defer n.Done() for _, entry := range dirents(dir) &#123; if entry.IsDir() &#123; n.Add(1) subdir := filepath.Join(dir, entry.Name()) go walkDir(subdir, n, fileSizes) &#125; else &#123; fileSizes &lt;- entry.Size() &#125; &#125;&#125;//!-walkDir//信号量//!+sema// sema is a counting semaphore for limiting concurrency in dirents.var sema = make(chan struct&#123;&#125;, 20)// dirents returns the entries of directory dir.func dirents(dir string) []os.FileInfo &#123; sema &lt;- struct&#123;&#125;&#123;&#125; // acquire token defer func() &#123; &lt;-sema &#125;() // release token // ... //!-sema entries, err := ioutil.ReadDir(dir) if err != nil &#123; fmt.Fprintf(os.Stderr, \"du: %v\\n\", err) return nil &#125; return entries&#125; 并发的退出 有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。 Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫abort的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢？ 一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还多，这样导致我们的发送直接被阻塞。另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。 回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立卽被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。 只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出的channel，这个channel不会向其中发送任何值，但其所在的闭包内要写明程序需要退出。我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。 12345678910var done &#x3D; make(chan struct&#123;&#125;)func cancelled() bool &#123; select &#123; case &lt;-done: return true default: return false &#125;&#125; 下面我们创建一个从标准输入流中读取内容的goroutine，这是一个比较典型的连接到终端的程序。每当有输入被读到(比如用户按了回车键)，这个goroutine就会把取消消息通过关闭done的channel广播出去。 // Cancel traversal when input is detected. go func() { os.Stdin.Read(make([]byte, 1)) // read a single byte close(done) }() 现在我们需要使我们的goroutine来对取消进行响应。在main goroutine中，我们添加了select的第三个case语句，尝试从done channel中接收内容。如果这个case被满足的话，在select到的时候卽会返回，但在结束之前我们需要把fileSizes channel中的内容“排”空，在channel被关闭之前，舍弃掉所有值。这样可以保证对walkDir的调用不要被向fileSizes发送信息阻塞住，可以正确地完成。 123456789101112for &#123; select &#123; case &lt;-done: // Drain fileSizes to allow existing goroutines to finish. for range fileSizes &#123; // Do nothing. &#125; return case size, ok := &lt;-fileSizes: // ... &#125;&#125; walkDir这个goroutine一启动就会轮询取消状态，如果取消状态被设置的话会直接返回，并且不做额外的事情。这样我们将所有在取消事件之后创建的goroutine改变为无操作。 123456789func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&lt;- int64) &#123; defer n.Done() if cancelled() &#123; return &#125; for _, entry := range dirents(dir) &#123; // ... &#125;&#125; 在walkDir函数的循环中我们对取消状态进行轮询可以带来明显的益处，可以避免在取消事件发生时还去创建goroutine。取消本身是有一些代价的；想要快速的响应需要对程序逻辑进行侵入式的修改。确保在取消发生之后不要有代价太大的操作可能会需要修改你代码里的很多地方，但是在一些重要的地方去检查取消事件也确实能带来很大的好处。 对这个程序的一个简单的性能分析可以揭示瓶颈在dirents函数中获取一个信号量。下面的select可以让这种操作可以被取消，并且可以将取消时的延迟从几百毫秒降低到几十毫秒。 123456789func dirents(dir string) []os.FileInfo &#123; select &#123; case sema &lt;- struct&#123;&#125;&#123;&#125;: // acquire token case &lt;-done: return nil // cancelled &#125; defer func() &#123; &lt;-sema &#125;() // release token // ...read directory...&#125; 现在当取消发生时，所有后台的goroutine都会迅速停止并且主函数会返回。当然，当主函数返回时，一个程序会退出，而我们又无法在主函数退出的时候确认其已经释放了所有的资源(译注：因为程序都退出了，你的代码都没法执行了) 。这里有一个方便的窍门我们可以一用：取代掉直接从主函数返回，我们调用一个panic，然后runtime会把每一个goroutine的栈dump下来。如果main goroutine是唯一一个剩下的goroutine的话，他会清理掉自己的一切资源。但是如果还有其它的goroutine没有退出，他们可能没办法被正确地取消掉，也有可能被取消但是取消操作会很花时间；所以这里的一个调研还是很有必要的。我们用panic来获取到足够的信息来验证我们上面的判断，看看最终到底是什么样的情况。 通道的关闭 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"time\")func worker(id int, c chan int) &#123; for n := range c &#123; fmt.Printf(\"Worker %d received %c\\n\", id, n) &#125;&#125;func channelClose() &#123; c := make(chan int) go worker(0, c) c &lt;- 'a' c &lt;- 'b' c &lt;- 'c' c &lt;- 'd' close(c) time.Sleep(time.Millisecond)&#125;func main() &#123; channelClose()&#125; 通道的经典死锁现象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( \"fmt\")func doWork(id int, c chan int,done chan bool) &#123; for n := range c &#123; fmt.Printf(\"Worker %d received %c\\n\", id, n) //done 代表任务做完，需要人来接收。因为done一直等不到人来接收，就会卡住，卡住就不会接收C done &lt;- true &#125;&#125;type worker struct &#123; in chan int done chan bool&#125;func createWorker( id int) worker &#123; w := worker&#123; in: make(chan int), done:make(chan bool), &#125; go doWork(id, w.in,w.done) return w&#125;func chanDemo() &#123; var workers [10]worker for i := 0; i &lt; 10; i++ &#123; workers[i] = createWorker(i) &#125; //第一遍循环顺利进行 for i, worker := range workers &#123; worker.in &lt;- 'a' + i &#125; //第二遍循环会陷入死锁，原因见上。 for i, worker := range workers &#123; worker.in &lt;- 'A' + i &#125; for _,worker := range workers&#123; &lt;-worker.done &lt;-worker.done &#125;&#125;func main() &#123; chanDemo()&#125; 死锁的解决方法1: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\")func doWork(id int, c chan int,done chan bool) &#123; for n := range c &#123; fmt.Printf(\"Worker %d received %c\\n\", id, n) done &lt;- true &#125;&#125;type worker struct &#123; in chan int done chan bool&#125;func createWorker( id int) worker &#123; w := worker&#123; in: make(chan int), done:make(chan bool), &#125; go doWork(id, w.in,w.done) return w&#125;func chanDemo() &#123; var workers [10]worker for i := 0; i &lt; 10; i++ &#123; workers[i] = createWorker(i) &#125; for i, worker := range workers &#123; worker.in &lt;- 'a' + i &#125; for _,worker := range workers&#123; &lt;-worker.done &#125; for i, worker := range workers &#123; worker.in &lt;- 'A' + i &#125; for _,worker := range workers&#123; &lt;-worker.done &#125;&#125;func main() &#123; chanDemo()&#125; 死锁的解决方法2: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"fmt\")func doWork(id int, c chan int,done chan bool) &#123; for n := range c &#123; fmt.Printf(\"Worker %d received %c\\n\", id, n) go func() &#123; done &lt;- true&#125;() &#125;&#125;type worker struct &#123; in chan int done chan bool&#125;func createWorker( id int) worker &#123; w := worker&#123; in: make(chan int), done:make(chan bool), &#125; go doWork(id, w.in,w.done) return w&#125;func chanDemo() &#123; var workers [10]worker for i := 0; i &lt; 10; i++ &#123; workers[i] = createWorker(i) &#125; for i, worker := range workers &#123; worker.in &lt;- 'a' + i &#125; for i, worker := range workers &#123; worker.in &lt;- 'A' + i &#125; for _,worker := range workers&#123; &lt;-worker.done &lt;-worker.done &#125;&#125;func main() &#123; chanDemo()&#125; sync.WaitGroup 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\" \"sync\")func doWork(id int, w worker) &#123; for n := range w.in &#123; fmt.Printf(\"Worker %d received %c\\n\", id, n) w.done() &#125;&#125;type worker struct &#123; in chan int done func()&#125;func createWorker( id int, wg *sync.WaitGroup) worker &#123; w := worker&#123; in: make(chan int), done: func() &#123; wg.Done() &#125;, &#125; go doWork(id, w) return w&#125;func chanDemo() &#123; var wg sync.WaitGroup var workers [10]worker for i := 0; i &lt; 10; i++ &#123; workers[i] = createWorker(i, &amp;wg) &#125; wg.Add(20) for i, worker := range workers &#123; worker.in &lt;- 'a' + i &#125; for i, worker := range workers &#123; worker.in &lt;- 'A' + i &#125; wg.Wait()&#125;func main() &#123; chanDemo()&#125; 动态栈 每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。而对于go程序来说，同时创建成百上千个gorutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。 相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。 练习9.4: 创建一个流水线程序，支持用channel连接任意数量的goroutine，在跑爆内存之前，可以创建多少流水线阶段？一个变量通过整个流水线需要用多久？(这个练习题翻译不是很确定。。) Goroutine调度 OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并保存内存中它的寄存器内容，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。 Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工(调度)m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine(译注：按程序独立)。 和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器而是被Go语言&quot;建筑&quot;本身进行调度的。例如当一个goroutine调用了time.Sleep或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一个goroutine。因为因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。 GOMAXPROCS Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行G​​o的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。(GOMAXPROCS是前面说的m:n调度中的n)。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计数在内。 你可以用GOMAXPROCS的环境变量吕显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它。我们在下面的小程序中会看到GOMAXPROCS的效果，这个程序会无限打印0和1。 for { go fmt.Print(0) fmt.Print(1) } $ GOMAXPROCS=1 go run hacker-cliché.go 111111111111111111110000000000000000000011111… $ GOMAXPROCS=2 go run hacker-cliché.go 010101010101010101011001100101011010010100110… 在第一次执行时，最多同时只能有一个goroutine被执行。初始情况下只有main goroutine被执行，所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。在第二次执行时，我们使用了两个操作系统线程，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。我们必须强调的是goroutine的调度是受很多因子影响的，而runtime也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。 Goroutine没有ID号 在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份(id)，并且这个身份信息可以以一个普通值的形式被被很容易地获取到，典型的可以是一个integer或者指针值。这种情况下我们做一个抽象化的thread-local storage(线程本地存储，多线程编程中不希望其它线程访问的内容)就很容易，只需要以线程的id作为key的一个map就可以解决问题，每一个线程以其id就能从中获取到值，且和其它线程互不冲突。 goroutine没有可以被程序员获取到的身份(id)的概念。这一点是设计上故意而为之，由于thread-local storage总是会被滥用。比如说，一个web server是用一种支持tls的语言实现的，而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层(这个存储层有可能是tls)查找的。这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能不是由其自己内部的变量所决定，而是由其所运行在的线程所决定。因此，如果线程本身的身份会改变–比如一些worker线程之类的–那么函数的行为就会变得神秘莫测。 Go鼓励更为简单的模式，这种模式下参数对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[60]-defer-function","slug":"golang-62-defer-function","date":"2019-02-17T08:09:49.000Z","updated":"2019-02-28T13:09:51.184Z","comments":true,"path":"2019/02/17/golang-62-defer-function/","link":"","permalink":"https://dreamerjonson.com/2019/02/17/golang-62-defer-function/","excerpt":"","text":"为什么使用defer 查看下面的这个程序，重复的写入了多个 resp.Body.Close()。如果程序的错误检查足够多，我们就需要在每一次处理资源关闭，这是非常麻烦的，defer就可以为我们解决这个问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package main/*//!+output$ go build gopl.io/ch5/title1$ ./title1 http://gopl.ioThe Go Programming Language$ ./title1 https://golang.org/doc/effective_go.htmlEffective Go - The Go Programming Language$ ./title1 https://golang.org/doc/gopher/frontpage.pngtitle: https://golang.org/doc/gopher/frontpage.png has type image/png, not text/html//!-output*/import ( \"fmt\" \"net/http\" \"os\" \"strings\" \"golang.org/x/net/html\")// Copied from gopl.io/ch5/outline2.func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123; if pre != nil &#123; pre(n) &#125; for c := n.FirstChild; c != nil; c = c.NextSibling &#123; forEachNode(c, pre, post) &#125; if post != nil &#123; post(n) &#125;&#125;//!+func title(url string) error &#123; resp, err := http.Get(url) if err != nil &#123; return err &#125; // Check Content-Type is HTML (e.g., \"text/html; charset=utf-8\"). ct := resp.Header.Get(\"Content-Type\") if ct != \"text/html\" &amp;&amp; !strings.HasPrefix(ct, \"text/html;\") &#123; resp.Body.Close() return fmt.Errorf(\"%s has type %s, not text/html\", url, ct) &#125; doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil &#123; return fmt.Errorf(\"parsing %s as HTML: %v\", url, err) &#125; visitNode := func(n *html.Node) &#123; if n.Type == html.ElementNode &amp;&amp; n.Data == \"title\" &amp;&amp; n.FirstChild != nil &#123; fmt.Println(n.FirstChild.Data) &#125; &#125; forEachNode(doc, visitNode, nil) return nil&#125;//!-func main() &#123; for _, arg := range os.Args[1:] &#123; if err := title(arg); err != nil &#123; fmt.Fprintf(os.Stderr, \"title: %v\\n\", err) &#125; &#125;&#125; defer特性 当出现defer时，函数和参数表达式将会被执行。但是函数真正的调用将会被延迟，直到包含defer的函数完成。可能会有多个defer，但是他们的执行顺序是相反的。 上面的例子可以修改为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( \"fmt\" \"net/http\" \"os\" \"strings\" \"golang.org/x/net/html\")// Copied from gopl.io/ch5/outline2.func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123; if pre != nil &#123; pre(n) &#125; for c := n.FirstChild; c != nil; c = c.NextSibling &#123; forEachNode(c, pre, post) &#125; if post != nil &#123; post(n) &#125;&#125;//!+func title(url string) error &#123; resp, err := http.Get(url) if err != nil &#123; return err &#125; defer resp.Body.Close() ct := resp.Header.Get(\"Content-Type\") if ct != \"text/html\" &amp;&amp; !strings.HasPrefix(ct, \"text/html;\") &#123; return fmt.Errorf(\"%s has type %s, not text/html\", url, ct) &#125; doc, err := html.Parse(resp.Body) if err != nil &#123; return fmt.Errorf(\"parsing %s as HTML: %v\", url, err) &#125; // ...print doc's title element... //!- visitNode := func(n *html.Node) &#123; if n.Type == html.ElementNode &amp;&amp; n.Data == \"title\" &amp;&amp; n.FirstChild != nil &#123; fmt.Println(n.FirstChild.Data) &#125; &#125; forEachNode(doc, visitNode, nil) //!+ return nil&#125;//!-func main() &#123; for _, arg := range os.Args[1:] &#123; if err := title(arg); err != nil &#123; fmt.Fprintf(os.Stderr, \"title: %v\\n\", err) &#125; &#125;&#125; defer常常使用在资源的打开或关闭中。 123456789package ioutilfunc ReadFile(filename string) ([]byte, error) &#123; f, err :&#x3D; os.Open(filename) if err !&#x3D; nil &#123; return nil, err &#125; defer f.Close() return ReadAll(f)&#125; 12345678 var mu sync.Mutex var m &#x3D; make(map[string]int)func lookup(key string) int &#123; mu.Lock() defer mu.Unlock() return m[key]&#125; onenty 与 onexit行为 1234567891011121314151617181920212223242526272829303132333435// The trace program uses defer to add entry/exit diagnostics to a function.package mainimport ( \"log\" \"time\")//!+mainfunc bigSlowOperation() &#123; defer trace(\"bigSlowOperation\")() // don't forget the extra parentheses // ...lots of work... time.Sleep(10 * time.Second) // simulate slow operation by sleeping&#125;func trace(msg string) func() &#123; start := time.Now() log.Printf(\"enter %s\", msg) return func() &#123; log.Printf(\"exit %s (%s)\", msg, time.Since(start)) &#125;&#125;//!-mainfunc main() &#123; bigSlowOperation()&#125;/*!+output$ go build gopl.io/ch5/trace$ ./trace2015/11/18 09:53:26 enter bigSlowOperation2015/11/18 09:53:36 exit bigSlowOperation (10.000589217s)!-output*/ defer 等到修改了结果变量之后被调用 1234567func double(x int) (result int) &#123; defer func() &#123; fmt.Printf(\"double(%d) = %d\\n\", x, result) &#125;() return x + x&#125;_=double(4)// Output:// \"double(4) = 8\" 可以修改结果变量闭包的特性 12345func triple(x int) (result int) &#123;defer func() &#123; result += x &#125;()return double(x)&#125;fmt.Println(triple(4)) // \"12\" 小心循环里的defer 由于defer会在函数结束时执行，所以循环里的defer是非常危险的，下面的程序可能会因为用完了文件描述符而崩溃。 12345678for _, filename := range filenames &#123; f, err := os.Open(filename) if err != nil &#123; return err &#125; defer f.Close() // NOTE: risky; could run out of file descriptors// ...process f...&#125; 上面的程序可以修改为,包裹在一个函数中： 12345678910111213for _, filename := range filenames &#123; if err := doFile(filename); err != nil &#123; return err &#125;&#125;func doFile(filename string) error &#123; f, err := os.Open(filename) if err != nil &#123; return err &#125; defer f.Close() // ...process f...&#125; 错误与defer 12345678910111213141516func main() &#123; f(3)&#125;func f(x int) &#123; fmt.Printf(\"f(%d)\\n\", x+0/x) // panics if x == 0 defer fmt.Printf(\"defer %d\\n\", x) f(x - 1)&#125;When run, the program prints the following to the standard output:f(3)f(2)f(1)defer 1defer 2defer 3 defer 案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 1, 1, 2, 3, 5, 8, 13, ...func Fibonacci() func() int &#123; a, b := 0, 1 return func() int &#123; a, b = b, a+b return a &#125;&#125;func tryDefer() &#123; for i := 0; i &lt; 100; i++ &#123; defer fmt.Println(i) if i == 30 &#123; // Uncomment panic to see // how it works with defer // panic(\"printed too many\") &#125; &#125;&#125;func writeFile(filename string) &#123; file, err := os.OpenFile(filename, os.O_EXCL|os.O_CREATE|os.O_WRONLY, 0666) if err != nil &#123; if pathError, ok := err.(*os.PathError); !ok &#123; panic(err) &#125; else &#123; fmt.Printf(\"%s, %s, %s\\n\", pathError.Op, pathError.Path, pathError.Err) &#125; return &#125; defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() f := Fibonacci() for i := 0; i &lt; 20; i++ &#123; fmt.Fprintln(writer, f()) &#125;&#125;func main() &#123; tryDefer() writeFile(\"fib.txt\")&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[5]-数据结构-广度优先搜索—爬虫案例","slug":"golang-5-structure-Breadth-first-search","date":"2019-02-16T04:39:04.000Z","updated":"2019-02-24T13:55:06.295Z","comments":true,"path":"2019/02/16/golang-5-structure-Breadth-first-search/","link":"","permalink":"https://dreamerjonson.com/2019/02/16/golang-5-structure-Breadth-first-search/","excerpt":"","text":"单爬虫 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package mainimport ( \"fmt\" \"os\" \"net/http\" \"golang.org/x/net/html\" \"log\")func breadthFirst(f func(item string) []string, worklist []string) &#123; seen := make(map[string]bool) for len(worklist) &gt; 0 &#123; items := worklist worklist = nil for _, item := range items &#123; if !seen[item] &#123; seen[item] = true worklist = append(worklist, f(item)...) &#125; &#125; &#125;&#125;//!-breadthFirst//!+crawlfunc crawl(url string) []string &#123; fmt.Println(url) list, err := Extract(url) if err != nil &#123; log.Print(err) &#125; return list&#125;//!-crawl//!+mainfunc main() &#123; // Crawl the web breadth-first, // starting from the command-line arguments. breadthFirst(crawl, os.Args[1:])&#125;//!-mainfunc Extract(url string) ([]string, error) &#123; resp, err := http.Get(url) if err != nil &#123; return nil, err &#125; if resp.StatusCode != http.StatusOK &#123; resp.Body.Close() return nil, fmt.Errorf(\"getting %s: %s\", url, resp.Status) &#125; doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil &#123; return nil, fmt.Errorf(\"parsing %s as HTML: %v\", url, err) &#125; var links []string visitNode := func(n *html.Node) &#123; if n.Type == html.ElementNode &amp;&amp; n.Data == \"a\" &#123; for _, a := range n.Attr &#123; if a.Key != \"href\" &#123; continue &#125; link, err := resp.Request.URL.Parse(a.Val) if err != nil &#123; continue // ignore bad URLs &#125; links = append(links, link.String()) &#125; &#125; &#125; forEachNode(doc, visitNode, nil) return links, nil&#125;//!-Extract// Copied from gopl.io/ch5/outline2.func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123; if pre != nil &#123; pre(n) &#125; for c := n.FirstChild; c != nil; c = c.NextSibling &#123; forEachNode(c, pre, post) &#125; if post != nil &#123; post(n) &#125;&#125; 并发爬虫的错误案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( \"fmt\" \"log\" \"os\" \"gopl.io/ch5/links\")//!+crawlfunc crawl(url string) []string &#123; fmt.Println(url) list, err := links.Extract(url) if err != nil &#123; log.Print(err) &#125; return list&#125;//!-crawl//!+mainfunc main() &#123; worklist := make(chan []string) // Start with the command-line arguments. go func() &#123; worklist &lt;- os.Args[1:] &#125;() // Crawl the web concurrently. seen := make(map[string]bool) for list := range worklist &#123; for _, link := range list &#123; if !seen[link] &#123; seen[link] = true go func(link string) &#123; worklist &lt;- crawl(link) &#125;(link) &#125; &#125; &#125;&#125;//!-main/*//!+output$ go build gopl.io/ch8/crawl1$ ./crawl1 http://gopl.io/http://gopl.io/https://golang.org/help/https://golang.org/doc/https://golang.org/blog/...2015/07/15 18:22:12 Get ...: dial tcp: lookup blog.golang.org: no such host2015/07/15 18:22:12 Get ...: dial tcp 23.21.222.120:443: socket: too many open files...//!-output*/ 最初的错误信息是一个让人莫名的DNS查找失败，卽使这个域名是完全可靠的。而随后的错误信息揭示了原因：这个程序一次性创建了太多网络连接，超过了每一个进程的打开文件数限制，旣而导致了在调用net.Dial像DNS查找失败这样的问题。 这个程序实在是太他妈并行了。无穷无尽地并行化并不是什么好事情，因为不管怎么说，你的系统总是会有一个些限制因素，比如CPU核心数会限制你的计算负载，比如你的硬盘转轴和磁头数限制了你的本地磁盘IO操作频率，比如你的网络带宽限制了你的下载速度上限，或者是你的一个web服务的服务容量上限等等。为了解决这个问题，我们可以限制并发程序所使用的资源来使之适应自己的运行环境。对于我们的例子来说，最简单的方法就是限制对links.Extract在同一时间最多不会有超过n次调用，这里的n是fd的limit-20，一般情况下。 我们可以用一个有容量限制的buffered channel来控制并发，这类似于操作系统里的计数信号量概念。从概念上讲，channel里的n个空槽代表n个可以处理内容的token(通行证)，从channel里接收一个值会释放其中的一个token，并且生成一个新的空槽位。这样保证了在没有接收介入时最多有n个发送操作。(这里可能我们拿channel里填充的槽来做token更直观一些，不过还是这样吧~)。由于channel里的元素类型并不重要，我们用一个零值的struct{}来作为其元素。 让我们重写crawl函数，将对links.Extract的调用操作用获取、释放token的操作包裹起来，来确保同一时间对其只有20个调用。信号量数量和其能操作的IO资源数量应保持接近。 第二个问题是这个程序永远都不会终止，卽使它已经爬到了所有初始链接衍生出的链接。为了使这个程序能够终止，我们需要在worklist为空或者没有crawl的goroutine在运行时退出主循环。这个版本中，计算器n对worklist的发送操作数量进行了限制。每一次我们发现有元素需要被发送到worklist时，我们都会对n进行操作，在向worklist中发送初始的命令行参数之前，我们也进行过一次操作。这里的操作++是在每启动一个crawler的goroutine之前。主循环会在n减为0时终止，这时候说明没活可干了。 现在这个并发爬虫会比5.6节中的深度优先搜索版快上20倍，而且不会出什么错，并且在其完成任务时也会正确地终止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"fmt\" \"log\" \"os\" \"gopl.io/ch5/links\")//!+sema// tokens is a counting semaphore used to// enforce a limit of 20 concurrent requests.var tokens = make(chan struct&#123;&#125;, 20)func crawl(url string) []string &#123; fmt.Println(url) tokens &lt;- struct&#123;&#125;&#123;&#125; // acquire a token list, err := links.Extract(url) &lt;-tokens // release the token if err != nil &#123; log.Print(err) &#125; return list&#125;//!-sema//!+func main() &#123; worklist := make(chan []string) var n int // number of pending sends to worklist // Start with the command-line arguments. n++ go func() &#123; worklist &lt;- os.Args[1:] &#125;() // Crawl the web concurrently. seen := make(map[string]bool) for ; n &gt; 0; n-- &#123; list := &lt;-worklist for _, link := range list &#123; if !seen[link] &#123; seen[link] = true n++ go func(link string) &#123; worklist &lt;- crawl(link) &#125;(link) &#125; &#125; &#125;&#125; 下面的程序是避免过度并发的另一种思路。这个版本使用了原来的crawl函数，但没有使用计数信号量，取而代之用了20个长活的crawler goroutine，这样来保证最多20个HTTP请求在并发。 123456789101112131415161718192021222324252627282930func main() &#123; worklist := make(chan []string) // lists of URLs, may have duplicates unseenLinks := make(chan string) // de-duplicated URLs // Add command-line arguments to worklist. go func() &#123; worklist &lt;- os.Args[1:] &#125;() // Create 20 crawler goroutines to fetch each unseen link. for i := 0; i &lt; 20; i++ &#123; go func() &#123; for link := range unseenLinks &#123; foundLinks := crawl(link) go func() &#123; worklist &lt;- foundLinks &#125;() &#125; &#125;() &#125; // The main goroutine de-duplicates worklist items // and sends the unseen ones to the crawlers. seen := make(map[string]bool) for list := range worklist &#123; for _, link := range list &#123; if !seen[link] &#123; seen[link] = true unseenLinks &lt;- link &#125; &#125; &#125;&#125; 所有的爬虫goroutine现在都是被同一个channel-unseenLinks喂饱的了。主goroutine负责拆分它从worklist里拿到的元素，然后把没有抓过的经由unseenLinks channel发送给一个爬虫的goroutine。 seen这个map被限定在main goroutine中；也就是说这个map只能在main goroutine中进行访问。类似于其它的信息隐藏方式，这样的约束可以让我们从一定程度上保证程序的正确性。例如，内部变量不能够在函数外部被访问到；变量在没有被转义的情况下是无法在函数外部访问的；一个对象的封装字段无法被该对象的方法以外的方法访问到。在所有的情况下，信息隐藏都可以帮助我们约束我们的程序，使其不发生意料之外的情况。 crawl函数爬到的链接在一个专有的goroutine中被发送到worklist中来避免死锁。为了节省空间，这个例子的终止问题我们先不进行详细阐述了。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[4]-数据结构-拓扑排序-深度优先搜索","slug":"golang-4-structure-topsort","date":"2019-02-16T04:26:00.000Z","updated":"2019-02-16T04:38:00.875Z","comments":true,"path":"2019/02/16/golang-4-structure-topsort/","link":"","permalink":"https://dreamerjonson.com/2019/02/16/golang-4-structure-topsort/","excerpt":"","text":"拓扑排序 排序前序课程、深度优先搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// The toposort program prints the nodes of a DAG in topological order.package mainimport ( \"fmt\" \"sort\")//!+table// prereqs maps computer science courses to their prerequisites.var prereqs = map[string][]string&#123; \"algorithms\": &#123;\"data structures\"&#125;, \"calculus\": &#123;\"linear algebra\"&#125;, \"compilers\": &#123; \"data structures\", \"formal languages\", \"computer organization\", &#125;, \"data structures\": &#123;\"discrete math\"&#125;, \"databases\": &#123;\"data structures\"&#125;, \"discrete math\": &#123;\"intro to programming\"&#125;, \"formal languages\": &#123;\"discrete math\"&#125;, \"networks\": &#123;\"operating systems\"&#125;, \"operating systems\": &#123;\"data structures\", \"computer organization\"&#125;, \"programming languages\": &#123;\"data structures\", \"computer organization\"&#125;,&#125;//!-table//!+mainfunc main() &#123; for i, course := range topoSort(prereqs) &#123; fmt.Printf(\"%d:\\t%s\\n\", i+1, course) &#125;&#125;func topoSort(m map[string][]string) []string &#123; var order []string seen := make(map[string]bool) var visitAll func(items []string) visitAll = func(items []string) &#123; for _, item := range items &#123; if !seen[item] &#123; seen[item] = true visitAll(m[item]) order = append(order, item) &#125; &#125; &#125; var keys []string for key := range m &#123; keys = append(keys, key) &#125; sort.Strings(keys) visitAll(keys) return order&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[61]-parsehtml","slug":"golang-61-parsehtml","date":"2019-02-16T03:36:07.000Z","updated":"2019-02-16T04:03:21.070Z","comments":true,"path":"2019/02/16/golang-61-parsehtml/","link":"","permalink":"https://dreamerjonson.com/2019/02/16/golang-61-parsehtml/","excerpt":"","text":"将网页解析为类似js中的DOM对象 案例 获取页面中的url 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\" \"net/http\" \"os\" \"golang.org/x/net/html\")// visit appends to links each link found in n, and returns the result.func visit(links []string, n *html.Node) []string &#123; if n.Type == html.ElementNode &amp;&amp; n.Data == \"a\" &#123; for _, a := range n.Attr &#123; if a.Key == \"href\" &#123; links = append(links, a.Val) &#125; &#125; &#125; for c := n.FirstChild; c != nil; c = c.NextSibling &#123; links = visit(links, c) &#125; return links&#125;//!+func main() &#123; for _, url := range os.Args[1:] &#123; links, err := findLinks(url) if err != nil &#123; fmt.Fprintf(os.Stderr, \"findlinks2: %v\\n\", err) continue &#125; for _, link := range links &#123; fmt.Println(link) &#125; &#125;&#125;// findLinks performs an HTTP GET request for url, parses the// response as HTML, and extracts and returns the links.func findLinks(url string) ([]string, error) &#123; resp, err := http.Get(url) if err != nil &#123; return nil, err &#125; if resp.StatusCode != http.StatusOK &#123; resp.Body.Close() return nil, fmt.Errorf(\"getting %s: %s\", url, resp.Status) &#125; doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil &#123; return nil, fmt.Errorf(\"parsing %s as HTML: %v\", url, err) &#125; return visit(nil, doc), nil&#125; 递归打印文件结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package mainimport ( \"fmt\" \"net/http\" \"os\" \"golang.org/x/net/html\")func main() &#123; for _, url := range os.Args[1:] &#123; outline(url) &#125;&#125;func outline(url string) error &#123; resp, err := http.Get(url) if err != nil &#123; return err &#125; defer resp.Body.Close() doc, err := html.Parse(resp.Body) if err != nil &#123; return err &#125; //!+call forEachNode(doc, startElement, endElement) //!-call return nil&#125;//!+forEachNode// forEachNode calls the functions pre(x) and post(x) for each node// x in the tree rooted at n. Both functions are optional.// pre is called before the children are visited (preorder) and// post is called after (postorder).func forEachNode(n *html.Node, pre, post func(n *html.Node)) &#123; if pre != nil &#123; pre(n) &#125; for c := n.FirstChild; c != nil; c = c.NextSibling &#123; forEachNode(c, pre, post) &#125; if post != nil &#123; post(n) &#125;&#125;//!-forEachNode//!+startendvar depth intfunc startElement(n *html.Node) &#123; if n.Type == html.ElementNode &#123; fmt.Printf(\"%*s&lt;%s&gt;\\n\", depth*2, \"\", n.Data) depth++ &#125;&#125;func endElement(n *html.Node) &#123; if n.Type == html.ElementNode &#123; depth-- fmt.Printf(\"%*s&lt;/%s&gt;\\n\", depth*2, \"\", n.Data) &#125;&#125;//!-startend","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"docker[3]-dockerrun","slug":"docker-3-dockerrun","date":"2019-02-12T14:57:32.000Z","updated":"2019-03-01T12:21:30.400Z","comments":true,"path":"2019/02/12/docker-3-dockerrun/","link":"","permalink":"https://dreamerjonson.com/2019/02/12/docker-3-dockerrun/","excerpt":"","text":"Docker hub:https://hub.docker.com/ 第一个docker命令 1&gt; docker run hello-world 输出： 1234567891011121314151617181920Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https:&#x2F;&#x2F;hub.docker.com&#x2F;For more examples and ideas, visit: https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F; 将文件快照加载到container中，执行指定命令，如 &gt; run hello-wold 重写指定命令 123456789101112131415$ docker run busybox echo hi herehi here$ docker run busybox lsbindevetchomeprocrootsystmpusrvar可以看出打印出的文件目录是运行的linux虚拟机的文件目录 查看运行中的container 1234&gt; docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES07615c2e850e busybox &quot;ping baidu.com&quot; 19 seconds ago Up 18 seconds confident_feynman 查看所有的container，包含以前运行过的。 1234567891011&gt; docker ps --allCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES07615c2e850e busybox &quot;ping baidu.com&quot; About a minute ago Up About a minute confident_feynmana043e6324f01 busybox &quot;ls&quot; 14 hours ago Exited (0) 14 hours ago quirky_hawkinga49540a381c4 busybox &quot;echo hi here&quot; 14 hours ago Exited (0) 14 hours ago silly_wozniak5e8d8cab229d hello-world &quot;&#x2F;hello&quot; 14 hours ago Exited (0) 14 hours ago confident_poitras32e394eb48be elasticsearch:6.5.0 &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;dock…&quot; 2 weeks ago Exited (255) 40 hours ago 0.0.0.0:9200-&gt;9200&#x2F;tcp, 9300&#x2F;tcp sharp_sanderson26e7cfd18013 elasticsearch:6.5.0 &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;dock…&quot; 2 weeks ago Exited (137) 2 weeks ago upbeat_hawking3aef31dc5086 elasticsearch:6.5.0 &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;dock…&quot; 2 weeks ago Exited (137) 2 weeks ago trusting_bhabha813f5b2d17c5 hello-world &quot;&#x2F;hello&quot; 2 weeks ago Exited (0) 2 weeks ago docker run docker run 命令本身运行了两条指令： docker create 以及dokcer start: 1234567891011121314151617181920212223242526$ docker create hello-world1a7fc1e876787a20d190187ba0ba6e83eda5f76b0401e9d511d2982f9d8533a6&#x2F;&#x2F;-a的作用是将输出打印到终端中。$ docker start -a 1a7fc1e876787a20d190187ba0ba6e83eda5f76b0401e9d511d2982f9d8533a6Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https:&#x2F;&#x2F;hub.docker.com&#x2F;For more examples and ideas, visit: https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F; 删除废弃container 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152$ docker system pruneWARNING! This will remove: - all stopped containers - all networks not used by at least one container - all dangling images - all dangling build cacheAre you sure you want to continue? [y&#x2F;N] yDeleted Containers:1a7fc1e876787a20d190187ba0ba6e83eda5f76b0401e9d511d2982f9d8533a6a043e6324f01a418a8c115b4b1cdddab0a10afff9bc9c5ee06a720219a4f1b1ca49540a381c4d7da4dfd1efb598a27c2db3574115b82b1b6d33c4f8390b5241e5e8d8cab229df7f2adcef62f344581fd7e9094fd93e26618d0999545cdc6d66e32e394eb48be7d5cd7b530a78559ab686f7cf9af88c2c7ae1fdc68e551ca5b3626e7cfd18013369a5bc8fed0b5612ad2703929f18c01cb50809274dde055ae663aef31dc5086b99029e3ecabc2f6ba0cb096000cf9e535d685d08e78de9db692813f5b2d17c5368e5c1804450da9aa054fe7072d89c64db0a77f347dd6b848ed0d47fb9e443b4e4630722e41ddcec47fe9d8c8f5488f26f68963ad110acc0601b0a0dac8a3ed04083591e959d339db4ba8a74cb311f793cbaa98e931e68bd333bd1c71df5bc48a49308bba863adf66d7c7400fe93936718afbac9c10255f2804585f744217f723b9c355720abed52bcf87d5bc9c6159c265b88b9659227411067a3fef3b2896bc383f28cb5f1374763b94c7503827fc5705b35442e842035ce5ad43464f85fcb2378435bdebbd2cd5c3232af2439bb934f9b0ccc1751d27e29704a5b4a90ba958d8d3b38d369adb81facd04914535fb77da220792cf011a49639102238917d07e0e44a6f052fc6919f3b7b71f55f170918d9c3d5646491277f039e50fa4f86b5a260dd472cbfae7a875410093a95bb349e5551156f88b71eb3d49e7c150cac80467f1eb66ceb2ea53fc06e855f3d7f93f1f41b781b956c071ba5f5d3dd19fba4734a9b3508f4b0fe9bce5fc3c993c08a29fe2f98e01c622f651fd9d9e75471a281b1388e9376492b0017055a613b833d40598a95b83d5c4c599f8564237f6ffc9b95f06bab040aedd465f915f8cc58abdf63fcf8346476cc3caf48f5791f55949dcbd3c4c010d3336877c9887f0a5a2a0973d1d06ede75f8bfe3aee61c2515fbcb95e8bbc631450037ed7c31df12084cb18fe6a7fcc44d9ba2f460336feb3c41a8449edf6938813055f4f1a54bca5ac0d4792ebf56c5b150e430175f73a66980a7976484b6165914dc2c92b3038de212ed3c8ada518b37473155bb9c44ff6e00236e1efff308c15ab2c325dca83dadcfa5436929fe53bca3c9bDeleted Networks:composer_defaultfrontend_defaultDeleted Images:deleted: sha256:976d4268d7fdf90cc93ec61f85f078927d36bdc67db90b499b89ccf1a055ef0adeleted: sha256:8a8ed4af849b7d02679d9b9e4fab2fc9127c767bb06663941cbd670a290e0164deleted: sha256:016d15cc49ebebae72ead1a301ff58d286452b4c41b6e55bf773c178dbca8e80deleted: sha256:d0ec57f38348b804f222f15580a90ccbd74b62edb7603c31ca93426b17273177deleted: sha256:d38bf24881b8a552e4860a522b855da7477c21d1afda8da134f58ae2385b5cb1deleted: sha256:a072b7745bf6bcaed809584e6c435a0b73c0bf7bcdc079cee7b1a0e3646bf99bdeleted: sha256:9dd54c53fb6a246adcb826eb42321be2f1bf37d61eb96180da2ba05b68d218d6deleted: sha256:1dfabb24d4d4a7f7b3ba2af8d5f58e4f16805c0e67e1337a6240d13402487b22deleted: sha256:a241c1a1c4a34e202c30a39f4bcba36ea2572b7707ce393d8d495c60f940218ddeleted: sha256:1611321909424f073c866daf57fe4d6fc3e5f49e34aeb2b2e0c37bc0c9f31333Total reclaimed space: 462.9MB 停止container docker stop 让程序自动停止，10秒钟后不停止即会调用docker kill docker kill 立即停止 12&gt; docker stop &lt;id&gt;&gt; docker kill &lt;id&gt; 打印日志 12345678$ docker create busybox echo hi there5795ad1cd0e25ff9601eef2fdb45a28ba7fc3f765a73b6b5513a7fcdd1a9b767$ docker start 5795ad1cd0e25ff9601eef2fdb45a28ba7fc3f765a73b6b5513a7fcdd1a9b7675795ad1cd0e25ff9601eef2fdb45a28ba7fc3f765a73b6b5513a7fcdd1a9b767$ docker logs 5795ad1cd0e25ff9601eef2fdb45a28ba7fc3f765a73b6b5513a7fcdd1a9b767hi there 执行命令在container中 it代表能够与键盘交互、i代表输入输出。 t代表好的格式化展示。 exec命令将redis-cli加入到container中 123456$ docker run redis$ docker exec -it 5f6f2e746bf4 redis-cli127.0.0.1:6379&gt; set myvalue 5OK127.0.0.1:6379&gt; get myvalue&quot;5&quot; sh在container中执行任意指令 1234567$ docker exec -it 5f6f2e746bf4 sh# ls# cd &#x2F;# lsbin boot data dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var# redis-cli127.0.0.1:6379&gt; 构建自己的docker image 新建 Dockerfile文件 123456#使用存在的docker image作为基本,类似于一个初始的操作系统。FROM alpine#下载redis到container的文件fs系统中RUN apk add --update redis#告诉 image如何做 开启作为container的时候CMD [\"redis-server\"] 123456789101112131415161718$ docker build .Sending build context to Docker daemon 2.048kBStep 1&#x2F;3 : FROM alpine ---&gt; 11cd0b38bc3cStep 2&#x2F;3 : RUN apk add --update redis---&gt; Running in d92500442b84fetch http:&#x2F;&#x2F;dl-cdn.alpinelinux.org&#x2F;alpine&#x2F;v3.8&#x2F;main&#x2F;x86_64&#x2F;APKINDEX.tar.gzfetch http:&#x2F;&#x2F;dl-cdn.alpinelinux.org&#x2F;alpine&#x2F;v3.8&#x2F;community&#x2F;x86_64&#x2F;APKINDEX.tar.gz(1&#x2F;1) Installing redis (4.0.11-r0)Executing redis-4.0.11-r0.pre-installExecuting redis-4.0.11-r0.post-installStep 3&#x2F;3 : CMD [&quot;redis-server&quot;] ---&gt; Running in 0f7a29a04b04Removing intermediate container 0f7a29a04b04 ---&gt; 5a14153acdc5Successfully built 5a14153acdc5$ docker run 5a14153acdc5 当构建好，最后就会有一个image id，可以通过docker run 5a14153acdc5运行。 docker build cache docker build 时，拥有缓存机制。例如，如果在之前的基础上增加下面的命令： 命令行显示出： 12345678910Sending build context to Docker daemon 2.048kBStep 1&#x2F;3 : FROM alpine ---&gt; 11cd0b38bc3cStep 2&#x2F;3 : RUN apk add --update redis ---&gt; Using cache ---&gt; 50e12ffd3c2eStep 3&#x2F;3 : CMD [&quot;redis-server&quot;] ---&gt; Using cache ---&gt; 44385ec8305bSuccessfully built 44385ec8305b 这是由于最后一次执行docker build时 前两条命令时完全一样的，就会使用到缓存机制。 12345678910111213141516171819下面的两个dockerfile文件在缓存机制上也是不一样的。FROM alpineRUN apk add --update redisRUN apk add --update gccCMD [&quot;redis-server&quot;]与FROM alpineRUN apk add --update gccRUN apk add --update redisCMD [&quot;redis-server&quot;] 自己的image打包 123456789101112131415$ docker build -t zhuimengshaonian&#x2F;redis-test:latest .Sending build context to Docker daemon 2.048kBStep 1&#x2F;4 : FROM alpine ---&gt; 11cd0b38bc3cStep 2&#x2F;4 : RUN apk add --update redis ---&gt; Using cache ---&gt; 50e12ffd3c2eStep 3&#x2F;4 : RUN apk add --update gcc ---&gt; Using cache ---&gt; 8abfafcb6590Step 4&#x2F;4 : CMD [&quot;redis-server&quot;] ---&gt; Using cache ---&gt; 44385ec8305bSuccessfully built 44385ec8305bSuccessfully tagged zhuimengshaonian&#x2F;redis-test:latest ##运行 1docker run zhuimengshaonian&#x2F;redis-test 简单的docker web应用程序 package.json: 12345678&#123; \"dependencies\": &#123; \"express\": \"*\" &#125;, \"scripts\": &#123; \"start\": \"node index.js\" &#125; &#125; index.js: 1234567891011const express = require('express');const app = express();app.get('/', (req, res) =&gt; &#123; res.send('How are you doing');&#125;);app.listen(8080, () =&gt; &#123; console.log('Listening on port 8080');&#125;); Dockerfile: 12345678910111213# Specify a base image 预置docker包node中的imageFROM node:alpine# 当前工作路径 目的是将应用程序文件与其他文件分离分离WORKDIR /usr/app# Install some depenendencies# 添加当前目录中的文件到container中，并执行npm install命令COPY ./package.json ./RUN npm installCOPY ./ ./# Default command 开启container时候的start命令CMD [\"npm\", \"start\"] 打包 123456789101112131415161718192021222324252627282930$ docker build -t zhuimengshaonian&#x2F;webtest:latest .Sending build context to Docker daemon 4.096kBStep 1&#x2F;6 : FROM node:alpine ---&gt; 4e50ad7c0e0bStep 2&#x2F;6 : WORKDIR &#x2F;usr&#x2F;app ---&gt; Running in 2cdc013a3181Removing intermediate container 2cdc013a3181 ---&gt; 2d21ad008a15Step 3&#x2F;6 : COPY .&#x2F;package.json .&#x2F; ---&gt; 3f2b0cf62e30Step 4&#x2F;6 : RUN npm install ---&gt; Running in e9d76dc22840npm notice created a lockfile as package-lock.json. You should commit this file.npm WARN app No descriptionnpm WARN app No repository field.npm WARN app No license field.added 48 packages from 36 contributors and audited 121 packages in 6.418sfound 0 vulnerabilitiesRemoving intermediate container e9d76dc22840 ---&gt; ff47e69c4824Step 5&#x2F;6 : COPY .&#x2F; .&#x2F; ---&gt; 14e12e344e93Step 6&#x2F;6 : CMD [&quot;npm&quot;, &quot;start&quot;] ---&gt; Running in 31b6e275bb7cRemoving intermediate container 31b6e275bb7c ---&gt; e4c1d9cc8d2eSuccessfully built e4c1d9cc8d2eSuccessfully tagged zhuimengshaonian&#x2F;webtest:latest 执行 端口转发,实际的8080端口映射docker中的8080端口。 123456$ docker run -p 8080:8080 zhuimengshaonian&#x2F;webtest&gt; @ start &#x2F;usr&#x2F;app&gt; node index.jsListening on port 8080","categories":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/tags/docker/"}]},{"title":"go语言[3]-数据结构-递归树构建17亿数据的内存模型","slug":"golang-3-structure-Recursive-tree","date":"2019-02-12T10:09:02.000Z","updated":"2019-02-12T10:31:56.978Z","comments":true,"path":"2019/02/12/golang-3-structure-Recursive-tree/","link":"","permalink":"https://dreamerjonson.com/2019/02/12/golang-3-structure-Recursive-tree/","excerpt":"","text":"递归树 用递归的方式实现了一颗树状的结构，该模型可以处理上亿qq数据。 内存中查询10次既可以找到结果，速度非常快。虽然将数据全部放置在了内存中，但是内存的消耗应该是降低到了最低的。 相较于C语言，这段代码明显就要难看了很多。因为Go语言是类型安全的语言，安全的的背后就是效率的损失。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/*Copyright © 2018 jonson功能：在上亿乱序的qq账号密码数据文件中构建递归树，能够在不到1秒的时间内查询出指定账号的密码。代码基于泄漏的qq老密，加群获取文件*/package mainimport ( \"bufio\" \"fmt\" \"log\" \"os\" \"strings\" \"unsafe\")var g_pp = make([]*[]*byte,10)func main() &#123; search()&#125;//初始化构建内存模型func init()&#123; fmt.Println(\"初始化开始\") file, err := os.Open(\"1E~001.txt\") if err != nil &#123; log.Fatal(err) &#125; defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() &#123; str:= scanner.Text() if len(str) &lt;50&#123;//数据已经整理过，最多50位。 qq:= getQQ(str) //fmt.Println(qq) if len(qq)==10 &amp;&amp; isAllNum(qq)&#123; //递归树，将模型构建完毕。 assign(&amp;g_pp,11,qq,str) &#125; &#125; &#125; if err := scanner.Err(); err != nil &#123; log.Fatal(err) &#125; fmt.Println(\"初始化结束\")&#125;/*最重要的递归函数，pp指针。deep为深度，str为字符串，password为密码*/func assign(pp *[]*[]*byte, deep int, str string,password string) &#123; //最后一级指针时，开辟内存，存储密码。 if deep == 1 &#123; buf:= make([]*byte,10) (*pp)[getnum(str[10-deep])] = &amp;buf p:= (*string)(unsafe.Pointer((*pp)[getnum(str[10-deep])])) *p = password return &#125; //刚开始传递11级指针的地址，deep=11递归下去，可以省略，改为传递11级指针，deep=10。 if deep == 11 &#123; assign((*[]*[]*byte)(unsafe.Pointer(pp)), deep - 1, str,password); return &#125; //判断该指针是否为空。如1131052403，当deep=10时，取出第一个数字1.判断pp[1]是否为Nil，为Nil就说明从来没有出现过第10位为1的qq号。 //这时就会为pp[1]开辟10个指针大小的内存，初始化为空。 //如果已经存在就继续递归。 if (*pp)[getnum(str[10-deep])]!=nil&#123; assign((*[]*[]*byte)(unsafe.Pointer((*pp)[getnum(str[10-deep])])), deep - 1, str,password); &#125;else &#123; buf:= make([]*byte,10) (*pp)[getnum(str[10-deep])] = &amp;buf assign((*[]*[]*byte)(unsafe.Pointer((*pp)[getnum(str[10-deep])])), deep - 1, str,password); &#125;&#125;//字符转换为数字func getnum(u uint8) uint8&#123; return u - '0'&#125;//qq补齐位数，判断是否为数字，字符转换为数字，数字不足补充0的算法//获取QQ号 1131052403----qwerty//截取数字10位，不足的补0，//对于这个函数的改进，让我可以在查找qq函数时也可以用func getQQ(s string) string&#123; raw:= strings.Split(s,\"----\")[0] length := len(raw) if length &lt; 10 &#123; raw = strings.Repeat(\"0\",10-length) + raw &#125; return raw&#125;//判断qq全部为数字func isAllNum(qq string ) bool&#123; for _,ch := range qq&#123; if ch &lt; '0' || ch &gt; '9'&#123; return false &#125; &#125; return true&#125;/*根据初始化递归树的原理，我们可以明白判断是否存在的意义。如果在某一位出现了一个数字，其所在的指针为NULL，就说明在该位从来没有出现过这个数字。相反，如果存在该数字，就首先说明其每一位的指针都不为空。*/var flag = truevar findresult string = \"\"func isExit(pp *[]*[]*byte, deep int, str string) &#123; if deep == 1 &#123; if (*pp)[getnum(str[10-deep])]!=nil&#123; findresult = *(*string)(unsafe.Pointer((*pp)[getnum(str[10-deep])])) &#125; return &#125; if deep == 11 &#123; isExit((*[]*[]*byte)(unsafe.Pointer(pp)), deep - 1, str); return &#125; if flag &amp;&amp; (*pp)[getnum(str[10-deep])]!=nil&#123; isExit((*[]*[]*byte)(unsafe.Pointer((*pp)[getnum(str[10-deep])])), deep - 1, str); &#125;else &#123; flag = false return &#125;&#125;//查找qq号func search()&#123; input := bufio.NewScanner(os.Stdin) for input.Scan()&#123; flag = true findresult=\"\" qq:= input.Text() qq= getQQ(qq) fmt.Println(\"搜索qq号：\",qq) isExit(&amp;g_pp,11,qq) if isAllNum(qq) &amp;&amp; findresult!=\"\"&#123; fmt.Printf(\"结果为：%s\\n\",findresult) &#125; &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"},{"name":"数据结构","slug":"go/数据结构","permalink":"https://dreamerjonson.com/categories/go/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"},{"name":"数据结构","slug":"数据结构","permalink":"https://dreamerjonson.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"golang[2]-structure-prime","slug":"golang-2-structure-prime","date":"2019-02-11T08:38:44.000Z","updated":"2019-02-11T08:41:42.094Z","comments":true,"path":"2019/02/11/golang-2-structure-prime/","link":"","permalink":"https://dreamerjonson.com/2019/02/11/golang-2-structure-prime/","excerpt":"","text":"并发版go语言求素数 并发版go语言求素数，代码非常优美 1234567891011121314151617181920212223242526272829303132333435// A concurrent prime sievepackage mainimport \"fmt\"// Send the sequence 2, 3, 4, ... to channel 'ch'.func Generate(ch chan&lt;- int) &#123; for i := 2; ; i++ &#123; ch &lt;- i // Send 'i' to channel 'ch'. &#125;&#125;// Copy the values from channel 'in' to channel 'out',// removing those divisible by 'prime'.func Filter(in &lt;-chan int, out chan&lt;- int, prime int) &#123; for &#123; i := &lt;-in // Receive value from 'in'. if i%prime != 0 &#123; out &lt;- i // Send 'i' to 'out'. &#125; &#125;&#125;// The prime sieve: Daisy-chain Filter processes.func main() &#123; ch := make(chan int) // Create a new channel. go Generate(ch) // Launch Generate goroutine. for i := 0; i &lt; 10; i++ &#123; prime := &lt;-ch fmt.Println(prime) ch1 := make(chan int) go Filter(ch, ch1, prime) ch = ch1 &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[60]-viper","slug":"golang-60-viper","date":"2019-02-11T05:24:23.000Z","updated":"2019-02-11T06:06:58.198Z","comments":true,"path":"2019/02/11/golang-60-viper/","link":"","permalink":"https://dreamerjonson.com/2019/02/11/golang-60-viper/","excerpt":"","text":"简单的说，viper就是go语言中高效解决配置信息的:https://github.com/spf13/viper What is Viper? Viper is a complete configuration solution for Go applications including 12-Factor apps. It is designed to work within an application, and can handle all types of configuration needs and formats. It supports: setting defaults reading from JSON, TOML, YAML, HCL, and Java properties config files live watching and re-reading of config files (optional) reading from environment variables reading from remote config systems (etcd or Consul), and watching changes reading from command line flags reading from buffer setting explicit values Viper can be thought of as a registry for all of your applications configuration needs. Why Viper? When building a modern application, you don’t want to worry about configuration file formats; you want to focus on building awesome software. Viper is here to help with that. Viper does the following for you: Find, load, and unmarshal a configuration file in JSON, TOML, YAML, HCL, or Java properties formats. Provide a mechanism to set default values for your different configuration options. Provide a mechanism to set override values for options specified through command line flags. Provide an alias system to easily rename parameters without breaking existing code. Make it easy to tell the difference between when a user has provided a command line or config file which is the same as the default. Viper uses the following precedence order. Each item takes precedence over the item below it: explicit call to Set flag env config key/value store default Viper configuration keys are case insensitive. 用例1:读取环境变量信息 绑定变量名为id，前缀spf。则环境变量中设置时必须为SPF_ID 1234567viper.SetEnvPrefix(\"spf\") // 前缀、will be uppercased automaticallyviper.BindEnv(\"id\")os.Setenv(\"SPF_ID\", \"13\") // typically done outside of the app export SPF_ID=3000id := viper.Get(\"id\") // 13fmt.Println(id) 自动绑定： 123456 viper.SetEnvPrefix(`spf`)viper.AutomaticEnv()id := viper.Get(\"id\")fmt.Println(id) 用例2:读取配置文件信息 1234567891011121314151617&#123; \"debug\": true, \"server\": &#123; \"address\": \":9090\" &#125;, \"context\":&#123; \"timeout\":2 &#125;, \"database\": &#123; \"host\": \"mysql\", \"port\": \"3306\", \"user\": \"user\", \"pass\": \"password\", \"name\": \"article\" &#125;&#125; 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"github.com/spf13/viper\")func main()&#123; viper.SetConfigFile(`config.json`) err := viper.ReadInConfig() if err != nil &#123; panic(err) &#125; if viper.GetBool(`debug`) &#123; fmt.Println(\"Service RUN on DEBUG mode\") &#125; dbHost := viper.GetString(`database.host`) dbPort := viper.GetString(`database.port`) dbUser := viper.GetString(`database.user`) dbPass := viper.GetString(`database.pass`) dbName := viper.GetString(`database.name`) connection := fmt.Sprintf(\"%s:%s@tcp(%s:%s)/%s\", dbUser, dbPass, dbHost, dbPort, dbName) fmt.Println(connection)&#125; 用例3:命令行参数： 12345678910111213141516171819package mainimport ( \"github.com/spf13/pflag\" \"github.com/spf13/viper\" \"fmt\")func main()&#123; pflag.Int(\"flagname\", 1234, \"help message for flagname\") pflag.Parse() viper.BindPFlags(pflag.CommandLine) i := viper.GetInt(\"flagname\") // retrieve values from viper instead of pflag fmt.Println(i)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言数据结构[1]--go实现快速排序的两种方式","slug":"golang-1-structure-quicksort","date":"2019-02-08T05:29:28.000Z","updated":"2019-03-10T05:31:33.090Z","comments":true,"path":"2019/02/08/golang-1-structure-quicksort/","link":"","permalink":"https://dreamerjonson.com/2019/02/08/golang-1-structure-quicksort/","excerpt":"","text":"前言 go实现快速排序的两种方式。借助Go语言slice本身的特点以及切割时的特性，在快速排序递归时，参数不用传递开始与结尾参数。 快速排序第一种方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*Copyright © 2018 jonson*/package mainimport \"fmt\"//打印func show(arr []int)&#123; for i:=0;i&lt;len(arr);i++&#123; fmt.Println(arr[i]) &#125; fmt.Println(\"----------------------------------------------\")&#125;func main()&#123; k := []int&#123;1,3,2,4,9,2,6,5,4,8&#125; show(k) quicksort(k) show(k)&#125;func quicksort(arr []int)&#123; if len(arr) &gt;1&#123;//必须要长度大于1才有意义。 end := len(arr) i := 0 j := len(arr) for i&lt;j&#123; for i &lt; end-1&#123; i++ if arr[i] &lt;= arr[0]&#123; break &#125; &#125; for j&gt;0&#123; j-- if arr[j]&gt;=arr[0]&#123; break &#125; &#125; //如果i&lt;j，说明要将这两个元素交换 if i &lt; j&#123; temp :=arr[i] arr[i] = arr[j] arr[j] = temp &#125; &#125; //交换start和 j 。 到此为止， j之前为小于start元素的，j之后为大于start元素的。 tmp := arr[j] arr[j] = arr[0] arr[0] = tmp //递归下去 if j &gt;0 &#123; quicksort(arr[0:j]) &#125; if j+1 &lt; end&#123; quicksort(arr[j+1:end]) &#125; &#125;&#125; 快速排序第二种方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*Copyright © 2018 jonson*/package mainimport \"fmt\"//打印func show(arr []int)&#123; for i:=0;i&lt;len(arr);i++&#123; fmt.Println(arr[i]) &#125; fmt.Println(\"----------------------------------------------\")&#125;func main()&#123; k := []int&#123;1,3,2,4,9,2,6,5,4,8&#125; show(k) quicksort(k) show(k)&#125;func quicksort(arr []int)&#123; if len(arr) &gt;1&#123;//必须要长度大于1才有意义。 end := len(arr) i := 0 j := len(arr) for i&lt;j&#123; for i &lt; end-1&#123; i++ if arr[i] &lt;= arr[0]&#123; break &#125; &#125; for j&gt;0&#123; j-- if arr[j]&gt;=arr[0]&#123; break &#125; &#125; //如果i&lt;j，说明要将这两个元素交换 if i &lt; j&#123; temp :=arr[i] arr[i] = arr[j] arr[j] = temp &#125; &#125; //交换start和 j 。 到此为止， j之前为小于start元素的，j之后为大于start元素的。 tmp := arr[j] arr[j] = arr[0] arr[0] = tmp //递归下去 if j &gt;0 &#123; quicksort(arr[0:j]) &#125; if j+1 &lt; end&#123; quicksort(arr[j+1:end]) &#125; &#125;&#125; c语言实现1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//打印void show(int *a,int length)&#123; for (int i = 0; i &lt; length; i++) &#123; printf(\"%d\\n\", a[i]); &#125; printf(\"---------------------------\\n\");&#125;//快速排序,不仅要写出来，而且要优美//arr 为数组//start 为开始的元素的下标//end 为结束的元素的下标+1void quick_sort(int *arr, int start, int end)&#123; if (start &lt; end) //必须要开始的元素 &lt;结束的元素才有意义。 &#123; //赋值 int i = start; int j = end; //i在++，j在--。第一个do为当i&lt;j时就继续下去。 do &#123; do //此do一直让i++，直到，发现大于start的 &#123; i++; &#125; while (i &lt; end &amp;&amp; arr[i] &lt; arr[start]); do//此do一直让j--，直到，发现小于start的元素 &#123; j--; &#125; while (j&gt;start &amp;&amp; arr[j]&gt;arr[start]); //如果i&lt;j，说明要将这两个元素交换 if (i &lt; j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; while (i&lt;j); //交换start和 j 。 到此为止， j之前为小于start元素的，j之后为大于start元素的。 int temp = arr[j]; arr[j] = arr[start]; arr[start] = temp; //递归下去 quick_sort(arr, start, j); quick_sort(arr, j + 1, end); &#125;&#125;void main()&#123; int a[10] = &#123; 1,3,2,4,9,2,6,5,4,8 &#125;; show(a, 10); quick_sort(a, 0,10); show(a, 10); system(\"pause\");&#125; c语言实现2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//打印void show(int *a,int length)&#123; for (int i = 0; i &lt; length; i++) &#123; printf(\"%d\\n\", a[i]); &#125; printf(\"---------------------------\\n\");&#125;//快速排序,不仅要写出来，而且要优美//arr 为数组//start 为开始的元素的下标//end 为结束的元素的下标+1void quick_sort2(int *arr, int start, int end)&#123; if (start &lt; end) &#123; //start &lt; end 才有进新下去的意义。 //i从第一个开始，记录下标。 int i = start; //从第二个元素开始，循环到末尾 for (int j = start+1; j &lt; end; j++) &#123; //一旦发现比其start小的 if (arr[j] &gt; arr[start]) &#123; //i++,很重要的一步，也就是让发现的小于start的数，依次放置在第2个，第3个....位置上。 i++; //交换 int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; ////交换start和i 。 到此为止， i之前为小于start元素的，i之后为大于start元素的。 int temp = arr[i]; arr[i] = arr[start]; arr[start] = temp; //递归 quick_sort2(arr, start, i); quick_sort2(arr, i+1, end); &#125;&#125;void main()&#123; int a[10] = &#123; 1,3,2,4,9,2,6,5,4,8 &#125;; show(a, 10); quick_sort2(a, 0,10); show(a, 10); system(\"pause\");&#125; JavaScript 语言实现 1234567891011121314151617function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125; JavaScript 语言实现2 123456789101112131415161718192021222324252627282930313233//上面简单版本的缺点是，它需要Ω(n)的额外存储空间，也就跟归并排序一样不好。额外需要的存储器空间配置，在实际上的实现，也会极度影响速度和高速缓存的性能。function quickSort(array) &#123; // 交换元素位置 function swap(array, i, k) &#123; var temp = array[i]; array[i] = array[k]; array[k] = temp; &#125; // 数组分区，左小右大 function partition(array, left, right) &#123; var storeIndex = left; var pivot = array[right]; // 直接选最右边的元素为基准元素 for (var i = left; i &lt; right; i++) &#123; if (array[i] &lt; pivot) &#123; swap(array, storeIndex, i); storeIndex++; // 交换位置后，storeIndex 自增 1，代表下一个可能要交换的位置 &#125; &#125; swap(array, right, storeIndex); // 将基准元素放置到最后的正确位置上 return storeIndex; &#125; function sort(array, left, right) &#123; if (left &gt; right) &#123; return; &#125; var storeIndex = partition(array, left, right); sort(array, left, storeIndex - 1); sort(array, storeIndex + 1, right); &#125; sort(array, 0, array.length - 1); return array;&#125; JavaScript 语言实现3 1234567891011121314151617181920212223242526272829303132333435363738function quickSort(arr) &#123; return sort(arr, 0, arr.length - 1); function swap(arr, i, k) &#123; var temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; function sort(arr, start, end) &#123; sort(arr, 0, arr.length - 1); return arr; function swap(arr, i, k) &#123; var temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; function sort(arr, start, end) &#123; if (start &gt;= end) return; var pivot = arr[start], i = start + 1, k = end; while (true) &#123; while (arr[i] &lt; pivot) &#123; i++; &#125; while (arr[k] &gt; pivot) &#123; k--; &#125; if (i &gt;= k) &#123; break; &#125; swap(arr, i, k); &#125; swap(arr, start, k); sort(arr, start, Math.max(0, k - 1)); sort(arr, Math.min(end, k + 1), end); &#125; &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[60]-分布式爬虫-jsonrpc抽离存储数据引擎","slug":"golang-59-crawler-rpcitemserver","date":"2019-01-25T09:49:47.000Z","updated":"2019-02-04T08:34:57.813Z","comments":true,"path":"2019/01/25/golang-59-crawler-rpcitemserver/","link":"","permalink":"https://dreamerjonson.com/2019/01/25/golang-59-crawler-rpcitemserver/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703package mainimport ( \"io/ioutil\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/unicode\" \"log\" \"regexp\" \"strconv\" \"net/http\" \"fmt\" \"time\" \"gopkg.in/olivere/elastic.v5\" \"context\" \"net/rpc/jsonrpc\" \"net/rpc\" \"net\")var rateLimiter = time.Tick(10 * time.Millisecond)/* start Fetch.go*/func Fetch(url string)([]byte ,error)&#123; //resp,err:= http.Get(url) // //if err!=nil&#123; // return nil,err //&#125; // //defer resp.Body.Close() //if resp.StatusCode != http.StatusOK&#123; // return nil,fmt.Errorf(\"Error: status code:%d\",resp.StatusCode) //&#125; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; fmt.Printf(\"get url:%s error\",url ) return nil,fmt.Errorf(\"get url:%d error\",url) &#125; req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\") resp, err := client.Do(req) if err != nil &#123; //log.Fatalln(err) fmt.Printf(\"get url:%s error\",url ) return nil,fmt.Errorf(\"get url:%d error\",url) &#125; defer resp.Body.Close() bodyReader:= bufio.NewReader(resp.Body) e:= determineEncoding(bodyReader) utf8reader:= transform.NewReader(bodyReader,e.NewDecoder()) return ioutil.ReadAll(utf8reader)&#125;func determineEncoding(r *bufio.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; log.Printf(\"Fetcher error:%v\",err) return unicode.UTF8 &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;/* end Fetch.go*//* start Type.go*/type Request struct&#123; Url string ParserFunc func([]byte) ParseResult&#125;type ParseResult struct&#123; Requests []Request Items []Item&#125;type Item struct&#123; Url string Id string Type string Payload interface&#123;&#125;&#125;func NilParser([]byte) ParseResult&#123; return ParseResult&#123;&#125;&#125;/* end Type.go*//* start parser/city.go 爬取城市下每一个用户和网址*/var cityRe = regexp.MustCompile(`&lt;a href=\"(http://album.zhenai.com/u/[\\d]+)\" target=\"_blank\"&gt;([^&lt;]+)&lt;/a&gt;`)var cityUrlRe = regexp.MustCompile(`&lt;a href=\"(http://www.zhenai.com/zhenghun/[^\"]+)\"`)func ParseCity(contents []byte) ParseResult&#123; matches:= cityRe.FindAllSubmatch(contents,-1) result := ParseResult&#123;&#125; for _,m:= range matches&#123; url:=string(m[1]) name:=string(m[2]) //println(string(m[1])) //不用用户名了 //result.Items = append(result.Items,\"User:\"+string(m[2])) result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:func(c []byte) ParseResult&#123; return PaesrProfile( c,url,name) &#125;, &#125;) &#125; //查找城市页面下的城市链接 matches= cityUrlRe.FindAllSubmatch(contents,-1) for _,m:= range matches&#123; result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/city.go *//* start parser/citylist.go */const cityListRe = `(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`func ParseCityList(contents []byte) ParseResult&#123; re:=regexp.MustCompile(cityListRe) matches:= re.FindAllSubmatch(contents,-1) result:=ParseResult&#123;&#125; for _,m :=range matches&#123; //result.Items = append(result.Items,string(m[2])) result.Requests = append( result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/citylist.go *//* start profile.go */type Profile struct &#123; Name string Age int Marry string Constellation string Height int Weight int Salary string&#125;func (p Profile) String() string&#123; return p.Name +\" \" + p.Marry + strconv.Itoa(p.Age) +\"olds \"+ strconv.Itoa(p.Height) + \"cm \" + strconv.Itoa(p.Weight)+ \"kg \"&#125;/* end profile.go *//* start parser/profile.go */var ageRe = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)岁&lt;/div&gt;`)var marry = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(已婚)&lt;/div&gt;`)var constellation = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(天秤座)&lt;/div&gt;`)var height =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)cm&lt;/div&gt;`)var weight =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)kg&lt;/div&gt;`)var salary = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;月收入:([^&lt;]+)&lt;/div&gt;`)var idRe = regexp.MustCompile(`http://album.zhenai.com/u/([\\d]+)`)//解析器 解析用户//name为上一级传递过来的func PaesrProfile(contents []byte,url string,name string) ParseResult&#123; //ioutil.WriteFile(\"test.html\",contents,0x777) //用户结构体 profile:=Profile&#123;&#125; profile.Name = name //年龄 string转换为int age,err:= strconv.Atoi(extractString(contents,ageRe)) if err==nil&#123; profile.Age = age &#125; //身高 height,err:= strconv.Atoi(extractString(contents,height)) if err==nil&#123; profile.Height = height &#125; //体重 weight,err:= strconv.Atoi(extractString(contents,weight)) if err==nil&#123; profile.Weight = weight &#125; //薪水 profile.Salary = extractString(contents,salary) //星座 profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; result:=ParseResult&#123; Items:[]Item&#123; &#123; Url:url, Type:\"zhenai\", Id:extractString([]byte(url),idRe), Payload:profile, &#125;, &#125;, &#125; return result&#125;//封装 正则表达式匹配func extractString(contents []byte,re *regexp.Regexp) string&#123; match:=re.FindSubmatch(contents) if len(match)&gt;=2&#123; return string(match[1]) &#125;else&#123; return \"\" &#125;&#125;/* end parser/profile.go *//* start engine.go 单任务版引擎*/func Run(seeds ...Request)&#123; var requests []Request for _,r := range seeds&#123; requests = append(requests,r) &#125; for len(requests) &gt;0&#123; r:=requests[0] requests = requests[1:] //fmt.Printf(\"Fetching %s\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) continue &#125; parseResult:= r.ParserFunc(body) requests = append(requests,parseResult.Requests...) for _,item:= range parseResult.Items&#123; fmt.Printf(\"Got item %s\\n\",item) &#125; &#125;&#125;//具体的工作 传递一个request，通过解析器对url进行解析func worker(r Request)(ParseResult,error)&#123; body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) return ParseResult&#123;&#125;,err &#125; return r.ParserFunc(body),nil&#125;/* start itemchan.go 存储服务器*/func ItemSaver() (chan Item,error)&#123; client,err := elastic.NewClient( elastic.SetSniff(false)) if err !=nil&#123; return nil ,err &#125; out:=make(chan Item) go func()&#123; itemCount:=0 for&#123; item:=&lt;-out //fmt.Printf(\"Item Saver: error saveing item %d,%v\",itemCount,item) log.Printf(\"Item Saversaveing item %d,%v\",itemCount,item) itemCount++ //存储到elastiicsearch err:= Save(client,item) if err!=nil&#123; log.Print(\"Item Saver: error\" + \"saveing item %v,%v\",item,err) &#125; &#125; &#125;() return out,nil&#125;func Save(client * elastic.Client,item Item) error&#123; indexServer:= client.Index().Index(\"dating_profile\").Type(item.Type).BodyJson(item) if item.Id!=\"\"&#123; indexServer.Id(item.Id) &#125; _,err := indexServer.Do(context.Background()) if err !=nil&#123; panic(err) &#125; return nil&#125;/* start itemchan.go 存储服务器*/// 并发版爬虫引擎 包含了调度器 与 工人数type ConcurrentEngine struct&#123; Scheduler Scheduler WorkerCount int //增加存储通道，有item需要存储，即发送消息到此通道，触发存储操作。 ItemChan chan Item&#125;//调度器是一个接口，扩展性type Scheduler interface &#123; //提交Request进行执行 Submit(Request) WorkerChan() chan Request WorkerReady(chan Request) Run()&#125;//并发版爬虫引擎func (e *ConcurrentEngine) Run(seeds ...Request)&#123; out:= make(chan ParseResult) //配置调度器通道 e.Scheduler.Run() //开启WorkerCount个工作 for i:=0;i&lt;e.WorkerCount;i++&#123; createWorker(e.Scheduler.WorkerChan(),out,e.Scheduler) &#125; //种子首先运行 for _,r:=range seeds&#123; e.Scheduler.Submit(r) &#125; for&#123; //out等待接受ParseResult result:=&lt;-out //打印出接收到的数据，以及个数。 for _,item:= range result.Items&#123; go func()&#123;e.ItemChan &lt;-item&#125;() &#125; //分配任务 for _,request:= range result.Requests&#123; if isDuplicate(request.Url)&#123; continue &#125; e.Scheduler.Submit(request) &#125; &#125;&#125;//存储URL、实行去掉重复URL的操作var URLstore = make(map[string]bool)func isDuplicate(url string) bool&#123; if URLstore[url]&#123; return true &#125; URLstore[url] = true return false&#125;//工作函数，逻辑是 in通道接收到request，即会调用worker函数爬每一个request中的网址，用对应的解析器。 解析完成后，将ParseResult返回给通道outfunc createWorker(in chan Request,out chan ParseResult,s Scheduler) &#123; go func()&#123; for&#123; //传递到调度器，提示可以开始工作 s.WorkerReady(in) //有任务到工作中 request := &lt;-in //开始工作 result,err:= worker(request) if err!=nil&#123; continue &#125; //工作结果返回 out &lt;-result &#125; &#125;()&#125;/* end engine.go *//* start scheduler.go 简单版调度器，用于分配工作任务 */type SimpleScheduler struct&#123; //通道 workerChan chan Request&#125;func (s *SimpleScheduler) WorkerChan() chan Request &#123; return s.workerChan&#125;func (s *SimpleScheduler) WorkerReady(chan Request) &#123;&#125;func (s *SimpleScheduler) Run() &#123; s.workerChan = make(chan Request)&#125;func ( s *SimpleScheduler) Submit( r Request) &#123; //为了防止死锁，在调度器中建立go的协程 分配任务到通道中。 go func()&#123;s.workerChan &lt;- r&#125;()&#125;/* end scheduler.go *//* start Queuescheduler.go 队列调度器，用于分配工作任务 */type QueuedScheduler struct &#123; requestChan chan Request workerChan chan chan Request&#125;func (s *QueuedScheduler) WorkerChan() chan Request &#123; return make(chan Request)&#125;//提交任务到通道，说明需要完成任务func (s *QueuedScheduler) Submit(r Request) &#123; s.requestChan &lt;-r&#125;//提交工作到通道，说明准备好工作了func (s *QueuedScheduler) WorkerReady(w chan Request)&#123; s.workerChan &lt;- w&#125;func (s * QueuedScheduler) Run()&#123; s.workerChan =make(chan chan Request) s.requestChan = make(chan Request) go func()&#123; //任务队列 var requestQ []Request //工作队列 var workQ []chan Request for&#123; var activeRequest Request var activework chan Request //即有工作又有任务，开始工作 if len(requestQ)&gt;0 &amp;&amp; len(workQ) &gt;0&#123; activework = workQ[0] activeRequest = requestQ[0] &#125; select &#123; //任务增加，添加到队列中 case r:=&lt;-s.requestChan: requestQ = append(requestQ,r) //工作增加，添加到队列中 case w:= &lt;-s.workerChan: workQ = append(workQ,w) //有工作又有任务，让工作去做任务 case activework &lt;- activeRequest: workQ = workQ[1:] requestQ=requestQ[1:] &#125; &#125; &#125;()&#125;//分布式存储服务器func ItemSaver2(host string) (chan Item,error)&#123; client,err:=Newclient(host) out:=make(chan Item) if err !=nil&#123; return nil,err &#125; go func()&#123; itemCount:=0 for&#123; item:=&lt;-out //fmt.Printf(\"Item Saver: error saveing item %d,%v\",itemCount,item) log.Printf(\"Item Saversaveing item %d,%v\",itemCount,item) itemCount++ result:=\"\" //Call RPC to save item client.Call(\"ItemSaverService.Save\",item,&amp;result) if err!=nil&#123; log.Print(\"Item Saver: error\" + \"saveing item %v,%v\",item,err) &#125; &#125; &#125;() return out,nil&#125;//抽象出的jsonrpc serverfunc ServerRpc(host string,service interface&#123;&#125;) error&#123; rpc.Register(service) listener,err:=net.Listen(\"tcp\",host) if err!=nil&#123; return err &#125; for&#123; conn,err:=listener.Accept() if err!=nil&#123; log.Printf(\"accept error:%v\",err) continue &#125; go jsonrpc.ServeConn(conn) &#125; return nil&#125;//抽象出的jsonrpc clientfunc Newclient(host string)(*rpc.Client,error)&#123; conn,err:=net.Dial(\"tcp\",host) if err!=nil&#123; return nil,err &#125; client:= jsonrpc.NewClient(conn) return client,nil&#125;type ItemSaverService struct&#123; Client *elastic.Client&#125;func (s*ItemSaverService) Save(item Item,result*string) error&#123; err:= Save(s.Client,item) log.Printf(\"Item %v saved.\",item) if err==nil&#123; *result = \"ok\" &#125;else&#123; log.Printf(\"Error save Item %v %v.\",item,err) &#125; return err&#125;/* end Queuescheduler.go 队列调度器，用于分配工作任务 */func main()&#123; //并发版爬虫+ itemchan,err := ItemSaver2(\":1234\") if err!=nil&#123; log.Panic(err) &#125; e:= ConcurrentEngine&#123; Scheduler:&amp;QueuedScheduler&#123;&#125;, WorkerCount:100, //增加存储通道 ItemChan:itemchan, &#125; e.Run(Request&#123; Url:\"http://www.zhenai.com/zhenghun\", ParserFunc:ParseCityList, &#125;) //并发调度版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;QueuedScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) // ////并发版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;SimpleScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //单任务版爬虫 //Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //paseTest()&#125; RPC服务器 12345678910111213func main() &#123; client, err :&#x3D; elastic.NewClient(elastic.SetSniff(false)) if err !&#x3D; nil &#123; panic(err) &#125; ServerRpc(&quot;:1234&quot;, &amp;ItemSaverService&#123; Client: client, &#125;)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[59]-爬虫-elastersearch数据存储","slug":"golang-58-crawler-elastersearch","date":"2019-01-25T01:10:43.000Z","updated":"2019-02-04T08:34:46.077Z","comments":true,"path":"2019/01/25/golang-58-crawler-elastersearch/","link":"","permalink":"https://dreamerjonson.com/2019/01/25/golang-58-crawler-elastersearch/","excerpt":"","text":"环境 docker docker run -d -p 9200:9200 elasticsearch:6.5.0 go接口： https://github.com/olivere/elastic 安装包：https://gopkg.in/olivere/elastic.v5 并发引擎+数据存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565package mainimport ( \"io/ioutil\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/unicode\" \"log\" \"regexp\" \"strconv\" \"net/http\" \"fmt\" \"time\" \"gopkg.in/olivere/elastic.v5\" \"context\")var rateLimiter = time.Tick(100 * time.Millisecond)/* start Fetch.go*/func Fetch(url string)([]byte ,error)&#123; //resp,err:= http.Get(url) // //if err!=nil&#123; // return nil,err //&#125; // //defer resp.Body.Close() //if resp.StatusCode != http.StatusOK&#123; // return nil,fmt.Errorf(\"Error: status code:%d\",resp.StatusCode) //&#125; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; log.Fatalln(err) &#125; req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\") resp, err := client.Do(req) if err != nil &#123; log.Fatalln(err) &#125; defer resp.Body.Close() bodyReader:= bufio.NewReader(resp.Body) e:= determineEncoding(bodyReader) utf8reader:= transform.NewReader(bodyReader,e.NewDecoder()) return ioutil.ReadAll(utf8reader)&#125;func determineEncoding(r *bufio.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; log.Printf(\"Fetcher error:%v\",err) return unicode.UTF8 &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;/* end Fetch.go*//* start Type.go*/type Request struct&#123; Url string ParserFunc func([]byte) ParseResult&#125;type ParseResult struct&#123; Requests []Request Items []interface&#123;&#125;&#125;func NilParser([]byte) ParseResult&#123; return ParseResult&#123;&#125;&#125;/* end Type.go*//* start parser/city.go 爬取城市下每一个用户和网址*/var cityRe = regexp.MustCompile(`&lt;a href=\"(http://album.zhenai.com/u/[\\d]+)\" target=\"_blank\"&gt;([^&lt;]+)&lt;/a&gt;`)var cityUrlRe = regexp.MustCompile(`&lt;a href=\"(http://www.zhenai.com/zhenghun/[^\"]+)\"`)func ParseCity(contents []byte) ParseResult&#123; matches:= cityRe.FindAllSubmatch(contents,-1) result := ParseResult&#123;&#125; for _,m:= range matches&#123; name:=string(m[2]) //println(string(m[1])) //不用用户名了 //result.Items = append(result.Items,\"User:\"+string(m[2])) result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:func(c []byte) ParseResult&#123; return PaesrProfile( c,name) &#125;, &#125;) &#125; //查找城市页面下的城市链接 matches= cityUrlRe.FindAllSubmatch(contents,-1) for _,m:= range matches&#123; result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/city.go *//* start parser/citylist.go */const cityListRe = `(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`func ParseCityList(contents []byte) ParseResult&#123; re:=regexp.MustCompile(cityListRe) matches:= re.FindAllSubmatch(contents,-1) result:=ParseResult&#123;&#125; for _,m :=range matches&#123; result.Items = append(result.Items,string(m[2])) result.Requests = append( result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/citylist.go *//* start profile.go */type Profile struct &#123; Name string Age int Marry string Constellation string Height int Weight int Salary string&#125;func (p Profile) String() string&#123; return p.Name +\" \" + p.Marry + strconv.Itoa(p.Age) +\"olds \"+ strconv.Itoa(p.Height) + \"cm \" + strconv.Itoa(p.Weight)+ \"kg \"&#125;/* end profile.go *//* start parser/profile.go */var ageRe = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)岁&lt;/div&gt;`)var marry = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(已婚)&lt;/div&gt;`)var constellation = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([^座])+&lt;/div&gt;`)var height =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)cm&lt;/div&gt;`)var weight =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)kg&lt;/div&gt;`)var salary = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;月收入:([^&lt;]+)&lt;/div&gt;`)//解析器 解析用户//name为上一级传递过来的func PaesrProfile(contents []byte,name string) ParseResult&#123; //ioutil.WriteFile(\"test.html\",contents,0x777) //用户结构体 profile:=Profile&#123;&#125; profile.Name = name //年龄 string转换为int age,err:= strconv.Atoi(extractString(contents,ageRe)) if err==nil&#123; profile.Age = age &#125; //身高 height,err:= strconv.Atoi(extractString(contents,height)) if err==nil&#123; profile.Height = height &#125; //体重 weight,err:= strconv.Atoi(extractString(contents,weight)) if err==nil&#123; profile.Weight = weight &#125; //薪水 profile.Salary = extractString(contents,salary) //星座 profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; result:=ParseResult&#123; Items:[]interface&#123;&#125;&#123;profile&#125;, &#125; return result&#125;//封装 正则表达式匹配func extractString(contents []byte,re *regexp.Regexp) string&#123; match:=re.FindSubmatch(contents) if len(match)&gt;=2&#123; return string(match[1]) &#125;else&#123; return \"\" &#125;&#125;/* end parser/profile.go *//* start engine.go 单任务版引擎*/func Run(seeds ...Request)&#123; var requests []Request for _,r := range seeds&#123; requests = append(requests,r) &#125; for len(requests) &gt;0&#123; r:=requests[0] requests = requests[1:] //fmt.Printf(\"Fetching %s\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) continue &#125; parseResult:= r.ParserFunc(body) requests = append(requests,parseResult.Requests...) for _,item:= range parseResult.Items&#123; fmt.Printf(\"Got item %s\\n\",item) &#125; &#125;&#125;//具体的工作 传递一个request，通过解析器对url进行解析func worker(r Request)(ParseResult,error)&#123; body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) return ParseResult&#123;&#125;,err &#125; return r.ParserFunc(body),nil&#125;/* start itemchan.go 存储服务器*/func ItemSaver() chan interface&#123;&#125;&#123; out:=make(chan interface&#123;&#125;) go func()&#123; itemCount:=0 for&#123; item:=&lt;-out //fmt.Printf(\"Item Saver: error saveing item %d,%v\",itemCount,item) log.Printf(\"Item Saversaveing item %d,%v\",itemCount,item) itemCount++ //存储到elastiicsearch id,err:= save(item) log.Printf(\"%v\",id) if err!=nil&#123; log.Print(\"Item Saver: error\" + \"saveing item %v,%v\",item,err) &#125; &#125; &#125;() return out&#125;func save(item interface&#123;&#125;) (id string,err error)&#123; client,err := elastic.NewClient( elastic.SetSniff(false)) if err !=nil&#123; panic(err) &#125; resp,err:= client.Index().Index(\"dating_profile\").Type(\"zhenai\").BodyJson(item).Do(context.Background()) if err !=nil&#123; panic(err) &#125; return resp.Id,nil&#125;/* start itemchan.go 存储服务器*/// 并发版爬虫引擎 包含了调度器 与 工人数type ConcurrentEngine struct&#123; Scheduler Scheduler WorkerCount int //增加存储通道，有item需要存储，即发送消息到此通道，触发存储操作。 ItemChan chan interface&#123;&#125;&#125;//调度器是一个接口，扩展性type Scheduler interface &#123; //提交Request进行执行 Submit(Request) WorkerChan() chan Request WorkerReady(chan Request) Run()&#125;//并发版爬虫引擎func (e *ConcurrentEngine) Run(seeds ...Request)&#123; out:= make(chan ParseResult) //配置调度器通道 e.Scheduler.Run() //开启WorkerCount个工作 for i:=0;i&lt;e.WorkerCount;i++&#123; createWorker(e.Scheduler.WorkerChan(),out,e.Scheduler) &#125; //种子首先运行 for _,r:=range seeds&#123; e.Scheduler.Submit(r) &#125; for&#123; //out等待接受ParseResult result:=&lt;-out //打印出接收到的数据，以及个数。 for _,item:= range result.Items&#123; go func()&#123;e.ItemChan &lt;-item&#125;() &#125; //分配任务 for _,request:= range result.Requests&#123; if isDuplicate(request.Url)&#123; continue &#125; e.Scheduler.Submit(request) &#125; &#125;&#125;//存储URL、实行去掉重复URL的操作var URLstore = make(map[string]bool)func isDuplicate(url string) bool&#123; if URLstore[url]&#123; return true &#125; URLstore[url] = true return false&#125;//工作函数，逻辑是 in通道接收到request，即会调用worker函数爬每一个request中的网址，用对应的解析器。 解析完成后，将ParseResult返回给通道outfunc createWorker(in chan Request,out chan ParseResult,s Scheduler) &#123; go func()&#123; for&#123; //传递到调度器，提示可以开始工作 s.WorkerReady(in) //有任务到工作中 request := &lt;-in //开始工作 result,err:= worker(request) if err!=nil&#123; continue &#125; //工作结果返回 out &lt;-result &#125; &#125;()&#125;/* end engine.go *//* start scheduler.go 简单版调度器，用于分配工作任务 */type SimpleScheduler struct&#123; //通道 workerChan chan Request&#125;func (s *SimpleScheduler) WorkerChan() chan Request &#123; return s.workerChan&#125;func (s *SimpleScheduler) WorkerReady(chan Request) &#123;&#125;func (s *SimpleScheduler) Run() &#123; s.workerChan = make(chan Request)&#125;func ( s *SimpleScheduler) Submit( r Request) &#123; //为了防止死锁，在调度器中建立go的协程 分配任务到通道中。 go func()&#123;s.workerChan &lt;- r&#125;()&#125;/* end scheduler.go *//* start Queuescheduler.go 队列调度器，用于分配工作任务 */type QueuedScheduler struct &#123; requestChan chan Request workerChan chan chan Request&#125;func (s *QueuedScheduler) WorkerChan() chan Request &#123; return make(chan Request)&#125;//提交任务到通道，说明需要完成任务func (s *QueuedScheduler) Submit(r Request) &#123; s.requestChan &lt;-r&#125;//提交工作到通道，说明准备好工作了func (s *QueuedScheduler) WorkerReady(w chan Request)&#123; s.workerChan &lt;- w&#125;func (s * QueuedScheduler) Run()&#123; s.workerChan =make(chan chan Request) s.requestChan = make(chan Request) go func()&#123; //任务队列 var requestQ []Request //工作队列 var workQ []chan Request for&#123; var activeRequest Request var activework chan Request //即有工作又有任务，开始工作 if len(requestQ)&gt;0 &amp;&amp; len(workQ) &gt;0&#123; activework = workQ[0] activeRequest = requestQ[0] &#125; select &#123; //任务增加，添加到队列中 case r:=&lt;-s.requestChan: requestQ = append(requestQ,r) //工作增加，添加到队列中 case w:= &lt;-s.workerChan: workQ = append(workQ,w) //有工作又有任务，让工作去做任务 case activework &lt;- activeRequest: workQ = workQ[1:] requestQ=requestQ[1:] &#125; &#125; &#125;()&#125;/* end Queuescheduler.go 队列调度器，用于分配工作任务 */func main()&#123; e:= ConcurrentEngine&#123; Scheduler:&amp;QueuedScheduler&#123;&#125;, WorkerCount:100, //增加存储通道 ItemChan:ItemSaver(), &#125; e.Run(Request&#123; Url:\"http://www.zhenai.com/zhenghun/shanghai\", ParserFunc:ParseCity, &#125;) //并发调度版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;QueuedScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) // ////并发版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;SimpleScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //单任务版爬虫 //Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //paseTest()&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"docker解决国内网络拉取镜像缓慢问题","slug":"docker-mirror","date":"2019-01-24T10:52:34.000Z","updated":"2019-11-27T02:08:39.892Z","comments":true,"path":"2019/01/24/docker-mirror/","link":"","permalink":"https://dreamerjonson.com/2019/01/24/docker-mirror/","excerpt":"","text":"众所周知，由于国内网路问题，不能拉有些docker中的镜像。 解决方法可以使用国内的镜像加速： https://www.daocloud.io/mirror","categories":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://dreamerjonson.com/tags/docker/"}]},{"title":"go语言渐入佳境[58]-爬虫-调度器优化","slug":"golang-57-crawler-schedulerup","date":"2019-01-24T07:51:15.000Z","updated":"2019-02-04T08:34:39.772Z","comments":true,"path":"2019/01/24/golang-57-crawler-schedulerup/","link":"","permalink":"https://dreamerjonson.com/2019/01/24/golang-57-crawler-schedulerup/","excerpt":"","text":"增强功能：获取城市下城市链接以及去重操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556package mainimport ( \"io/ioutil\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/unicode\" \"log\" \"regexp\" \"strconv\" \"net/http\" \"fmt\" \"time\")var rateLimiter = time.Tick(100 * time.Millisecond)/* start Fetch.go*/func Fetch(url string)([]byte ,error)&#123; //resp,err:= http.Get(url) // //if err!=nil&#123; // return nil,err //&#125; // //defer resp.Body.Close() //if resp.StatusCode != http.StatusOK&#123; // return nil,fmt.Errorf(\"Error: status code:%d\",resp.StatusCode) //&#125; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; log.Fatalln(err) &#125; req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\") resp, err := client.Do(req) if err != nil &#123; log.Fatalln(err) &#125; defer resp.Body.Close() bodyReader:= bufio.NewReader(resp.Body) e:= determineEncoding(bodyReader) utf8reader:= transform.NewReader(bodyReader,e.NewDecoder()) return ioutil.ReadAll(utf8reader)&#125;func determineEncoding(r *bufio.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; log.Printf(\"Fetcher error:%v\",err) return unicode.UTF8 &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;/* end Fetch.go*//* start Type.go*/type Request struct&#123; Url string ParserFunc func([]byte) ParseResult&#125;type ParseResult struct&#123; Requests []Request Items []interface&#123;&#125;&#125;func NilParser([]byte) ParseResult&#123; return ParseResult&#123;&#125;&#125;/* end Type.go*//* start parser/city.go 爬取城市下每一个用户和网址*/var cityRe = regexp.MustCompile(`&lt;a href=\"(http://album.zhenai.com/u/[\\d]+)\" target=\"_blank\"&gt;([^&lt;]+)&lt;/a&gt;`)var cityUrlRe = regexp.MustCompile(`&lt;a href=\"(http://www.zhenai.com/zhenghun/[^\"]+)\"`)func ParseCity(contents []byte) ParseResult&#123; matches:= cityRe.FindAllSubmatch(contents,-1) result := ParseResult&#123;&#125; for _,m:= range matches&#123; name:=string(m[2]) println(string(m[1])) result.Items = append(result.Items,\"User:\"+string(m[2])) result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:func(c []byte) ParseResult&#123; return PaesrProfile( c,name) &#125;, &#125;) &#125; //查找城市页面下的城市链接 matches= cityUrlRe.FindAllSubmatch(contents,-1) for _,m:= range matches&#123; result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/city.go *//* start parser/citylist.go */const cityListRe = `(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`func ParseCityList(contents []byte) ParseResult&#123; re:=regexp.MustCompile(cityListRe) matches:= re.FindAllSubmatch(contents,-1) result:=ParseResult&#123;&#125; for _,m :=range matches&#123; result.Items = append(result.Items,string(m[2])) result.Requests = append( result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/citylist.go *//* start profile.go */type Profile struct &#123; Name string Age int Marry string Constellation string Height int Weight int Salary string&#125;func (p Profile) String() string&#123; return p.Name +\" \" + p.Marry + strconv.Itoa(p.Age) +\"olds \"+ strconv.Itoa(p.Age) + \"cm \" + strconv.Itoa(p.Weight)+ \"kg \"&#125;/* end profile.go *//* start parser/profile.go */var ageRe = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)岁&lt;/div&gt;`)var marry = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(已婚)&lt;/div&gt;`)var constellation = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(.*)座&lt;/div&gt;`)var height =regexp.MustCompile(`160cm`)var weight =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)kg&lt;/div&gt;`)var salary = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;月收入:([^&lt;]+)&lt;/div&gt;`)//解析器 解析用户//name为上一级传递过来的func PaesrProfile(contents []byte,name string) ParseResult&#123; //ioutil.WriteFile(\"test.html\",contents,0x777) //用户结构体 profile:=Profile&#123;&#125; profile.Name = name //年龄 string转换为int age,err:= strconv.Atoi(extractString(contents,ageRe)) if err==nil&#123; profile.Age = age &#125; //身高 height,err:= strconv.Atoi(extractString(contents,height)) if err==nil&#123; profile.Height = height &#125; //体重 weight,err:= strconv.Atoi(extractString(contents,weight)) if err==nil&#123; profile.Weight = weight &#125; //薪水 profile.Salary = extractString(contents,salary) //星座 profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; result:=ParseResult&#123; Items:[]interface&#123;&#125;&#123;profile&#125;, &#125; return result&#125;//封装 正则表达式匹配func extractString(contents []byte,re *regexp.Regexp) string&#123; match:=re.FindSubmatch(contents) if len(match)&gt;=2&#123; return string(match[1]) &#125;else&#123; return \"\" &#125;&#125;/* end parser/profile.go *//* start engine.go 单任务版引擎*/func Run(seeds ...Request)&#123; var requests []Request for _,r := range seeds&#123; requests = append(requests,r) &#125; for len(requests) &gt;0&#123; r:=requests[0] requests = requests[1:] fmt.Printf(\"Fetching %s\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) continue &#125; parseResult:= r.ParserFunc(body) requests = append(requests,parseResult.Requests...) for _,item:= range parseResult.Items&#123; fmt.Printf(\"Got item %s\\n\",item) &#125; &#125;&#125;//具体的工作 传递一个request，通过解析器对url进行解析func worker(r Request)(ParseResult,error)&#123; fmt.Printf(\"Fetching %s\\n\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) return ParseResult&#123;&#125;,err &#125; return r.ParserFunc(body),nil&#125;// 并发版爬虫引擎 包含了调度器 与 工人数type ConcurrentEngine struct&#123; Scheduler Scheduler WorkerCount int&#125;//调度器是一个接口，扩展性type Scheduler interface &#123; //提交Request进行执行 Submit(Request) WorkerChan() chan Request WorkerReady(chan Request) Run()&#125;//并发版爬虫引擎func (e *ConcurrentEngine) Run(seeds ...Request)&#123; out:= make(chan ParseResult) //配置调度器通道 e.Scheduler.Run() //开启WorkerCount个工作 for i:=0;i&lt;e.WorkerCount;i++&#123; createWorker(e.Scheduler.WorkerChan(),out,e.Scheduler) &#125; //种子首先运行 for _,r:=range seeds&#123; e.Scheduler.Submit(r) &#125; itemsCount:=0 for&#123; //out等待接受ParseResult result:=&lt;-out //打印出接收到的数据，以及个数。 for _,item:= range result.Items&#123; fmt.Printf(\"Got item: #%d: %v\\n\",itemsCount,item) itemsCount++ &#125; //分配任务 for _,request:= range result.Requests&#123; if isDuplicate(request.Url)&#123; continue &#125; e.Scheduler.Submit(request) &#125; &#125;&#125;//存储URL、实行去掉重复URL的操作var URLstore = make(map[string]bool)func isDuplicate(url string) bool&#123; if URLstore[url]&#123; return true &#125; URLstore[url] = true return false&#125;//工作函数，逻辑是 in通道接收到request，即会调用worker函数爬每一个request中的网址，用对应的解析器。 解析完成后，将ParseResult返回给通道outfunc createWorker(in chan Request,out chan ParseResult,s Scheduler) &#123; go func()&#123; for&#123; //传递到调度器，提示可以开始工作 s.WorkerReady(in) //有任务到工作中 request := &lt;-in //开始工作 result,err:= worker(request) if err!=nil&#123; continue &#125; //工作结果返回 out &lt;-result &#125; &#125;()&#125;/* end engine.go *//* start scheduler.go 简单版调度器，用于分配工作任务 */type SimpleScheduler struct&#123; //通道 workerChan chan Request&#125;func (s *SimpleScheduler) WorkerChan() chan Request &#123; return s.workerChan&#125;func (s *SimpleScheduler) WorkerReady(chan Request) &#123;&#125;func (s *SimpleScheduler) Run() &#123; s.workerChan = make(chan Request)&#125;func ( s *SimpleScheduler) Submit( r Request) &#123; //为了防止死锁，在调度器中建立go的协程 分配任务到通道中。 go func()&#123;s.workerChan &lt;- r&#125;()&#125;/* end scheduler.go *//* start Queuescheduler.go 队列调度器，用于分配工作任务 */type QueuedScheduler struct &#123; requestChan chan Request workerChan chan chan Request&#125;func (s *QueuedScheduler) WorkerChan() chan Request &#123; return make(chan Request)&#125;//提交任务到通道，说明需要完成任务func (s *QueuedScheduler) Submit(r Request) &#123; s.requestChan &lt;-r&#125;//提交工作到通道，说明准备好工作了func (s *QueuedScheduler) WorkerReady(w chan Request)&#123; s.workerChan &lt;- w&#125;func (s * QueuedScheduler) Run()&#123; s.workerChan =make(chan chan Request) s.requestChan = make(chan Request) go func()&#123; //任务队列 var requestQ []Request //工作队列 var workQ []chan Request for&#123; var activeRequest Request var activework chan Request //即有工作又有任务，开始工作 if len(requestQ)&gt;0 &amp;&amp; len(workQ) &gt;0&#123; activework = workQ[0] activeRequest = requestQ[0] &#125; select &#123; //任务增加，添加到队列中 case r:=&lt;-s.requestChan: requestQ = append(requestQ,r) //工作增加，添加到队列中 case w:= &lt;-s.workerChan: workQ = append(workQ,w) //有工作又有任务，让工作去做任务 case activework &lt;- activeRequest: workQ = workQ[1:] requestQ=requestQ[1:] &#125; &#125; &#125;()&#125;/* end Queuescheduler.go 队列调度器，用于分配工作任务 */func main()&#123; e:= ConcurrentEngine&#123; Scheduler:&amp;QueuedScheduler&#123;&#125;, WorkerCount:100, &#125; e.Run(Request&#123; Url:\"http://www.zhenai.com/zhenghun/shanghai\", ParserFunc:ParseCity, &#125;) //并发调度版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;QueuedScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) // ////并发版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;SimpleScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //单任务版爬虫 //Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //paseTest()&#125;//测试func paseTest()&#123; contents,_:= ioutil.ReadFile(\"test.html\") profile:=Profile&#123;&#125; age,err:= strconv.Atoi(extractString(contents,ageRe)) if err!=nil&#123; profile.Age = age &#125; height,err:= strconv.Atoi(extractString(contents,height)) if err!=nil&#123; profile.Height = height &#125; weight,err:= strconv.Atoi(extractString(contents,weight)) if err!=nil&#123; profile.Weight = weight &#125; profile.Salary = extractString(contents,salary) profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; fmt.Printf(\"%s\",profile)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[57]-爬虫-调度器","slug":"golang-57-crawler-scheduler","date":"2019-01-24T04:55:43.000Z","updated":"2019-02-04T08:34:27.576Z","comments":true,"path":"2019/01/24/golang-57-crawler-scheduler/","link":"","permalink":"https://dreamerjonson.com/2019/01/24/golang-57-crawler-scheduler/","excerpt":"","text":"单任务与并发同时适用的调度器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509package mainimport ( \"io/ioutil\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/unicode\" \"log\" \"regexp\" \"strconv\" \"net/http\" \"fmt\" \"time\")var rateLimiter = time.Tick(100 * time.Millisecond)/* start Fetch.go*/func Fetch(url string)([]byte ,error)&#123; //resp,err:= http.Get(url) // //if err!=nil&#123; // return nil,err //&#125; // //defer resp.Body.Close() //if resp.StatusCode != http.StatusOK&#123; // return nil,fmt.Errorf(\"Error: status code:%d\",resp.StatusCode) //&#125; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; log.Fatalln(err) &#125; req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\") resp, err := client.Do(req) if err != nil &#123; log.Fatalln(err) &#125; defer resp.Body.Close() bodyReader:= bufio.NewReader(resp.Body) e:= determineEncoding(bodyReader) utf8reader:= transform.NewReader(bodyReader,e.NewDecoder()) return ioutil.ReadAll(utf8reader)&#125;func determineEncoding(r *bufio.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; log.Printf(\"Fetcher error:%v\",err) return unicode.UTF8 &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;/* end Fetch.go*//* start Type.go*/type Request struct&#123; Url string ParserFunc func([]byte) ParseResult&#125;type ParseResult struct&#123; Requests []Request Items []interface&#123;&#125;&#125;func NilParser([]byte) ParseResult&#123; return ParseResult&#123;&#125;&#125;/* end Type.go*//* start parser/city.go 爬取城市下每一个用户和网址*/const cityRe = `&lt;a href=\"(http://album.zhenai.com/u/[\\d]+)\" target=\"_blank\"&gt;([^&lt;]+)&lt;/a&gt;`func ParseCity(contents []byte) ParseResult&#123; re:= regexp.MustCompile(cityRe) matches:= re.FindAllSubmatch(contents,-1) result := ParseResult&#123;&#125; for _,m:= range matches&#123; name:=string(m[2]) println(string(m[1])) result.Items = append(result.Items,\"User:\"+string(m[2])) result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:func(c []byte) ParseResult&#123; return PaesrProfile( c,name) &#125;, &#125;) &#125; return result&#125;/* end parser/city.go *//* start parser/citylist.go */const cityListRe = `(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`func ParseCityList(contents []byte) ParseResult&#123; re:=regexp.MustCompile(cityListRe) matches:= re.FindAllSubmatch(contents,-1) result:=ParseResult&#123;&#125; for _,m :=range matches&#123; result.Items = append(result.Items,string(m[2])) result.Requests = append( result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/citylist.go *//* start profile.go */type Profile struct &#123; Name string Age int Marry string Constellation string Height int Weight int Salary string&#125;func (p Profile) String() string&#123; return p.Name +\" \" + p.Marry + strconv.Itoa(p.Age) +\"olds \"+ strconv.Itoa(p.Age) + \"cm \" + strconv.Itoa(p.Weight)+ \"kg \"&#125;/* end profile.go *//* start parser/profile.go */var ageRe = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)岁&lt;/div&gt;`)var marry = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(已婚)&lt;/div&gt;`)var constellation = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(.*)座&lt;/div&gt;`)var height =regexp.MustCompile(`160cm`)var weight =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)kg&lt;/div&gt;`)var salary = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;月收入:([^&lt;]+)&lt;/div&gt;`)//解析器 解析用户//name为上一级传递过来的func PaesrProfile(contents []byte,name string) ParseResult&#123; //ioutil.WriteFile(\"test.html\",contents,0x777) //用户结构体 profile:=Profile&#123;&#125; profile.Name = name //年龄 string转换为int age,err:= strconv.Atoi(extractString(contents,ageRe)) if err==nil&#123; profile.Age = age &#125; //身高 height,err:= strconv.Atoi(extractString(contents,height)) if err==nil&#123; profile.Height = height &#125; //体重 weight,err:= strconv.Atoi(extractString(contents,weight)) if err==nil&#123; profile.Weight = weight &#125; //薪水 profile.Salary = extractString(contents,salary) //星座 profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; result:=ParseResult&#123; Items:[]interface&#123;&#125;&#123;profile&#125;, &#125; return result&#125;//封装 正则表达式匹配func extractString(contents []byte,re *regexp.Regexp) string&#123; match:=re.FindSubmatch(contents) if len(match)&gt;=2&#123; return string(match[1]) &#125;else&#123; return \"\" &#125;&#125;/* end parser/profile.go *//* start engine.go 单任务版引擎*/func Run(seeds ...Request)&#123; var requests []Request for _,r := range seeds&#123; requests = append(requests,r) &#125; for len(requests) &gt;0&#123; r:=requests[0] requests = requests[1:] fmt.Printf(\"Fetching %s\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) continue &#125; parseResult:= r.ParserFunc(body) requests = append(requests,parseResult.Requests...) for _,item:= range parseResult.Items&#123; fmt.Printf(\"Got item %s\\n\",item) &#125; &#125;&#125;//具体的工作 传递一个request，通过解析器对url进行解析func worker(r Request)(ParseResult,error)&#123; fmt.Printf(\"Fetching %s\\n\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) return ParseResult&#123;&#125;,err &#125; return r.ParserFunc(body),nil&#125;// 并发版爬虫引擎 包含了调度器 与 工人数type ConcurrentEngine struct&#123; Scheduler Scheduler WorkerCount int&#125;//调度器是一个接口，扩展性type Scheduler interface &#123; //提交Request进行执行 Submit(Request) WorkerChan() chan Request WorkerReady(chan Request) Run()&#125;//并发版爬虫引擎func (e *ConcurrentEngine) Run(seeds ...Request)&#123; out:= make(chan ParseResult) //配置调度器通道 e.Scheduler.Run() //开启WorkerCount个工作 for i:=0;i&lt;e.WorkerCount;i++&#123; createWorker(e.Scheduler.WorkerChan(),out,e.Scheduler) &#125; //种子首先运行 for _,r:=range seeds&#123; e.Scheduler.Submit(r) &#125; itemsCount:=0 for&#123; //out等待接受ParseResult result:=&lt;-out //打印出接收到的数据，以及个数。 for _,item:= range result.Items&#123; fmt.Printf(\"Got item: #%d: %v\\n\",itemsCount,item) itemsCount++ &#125; //分配任务 for _,request:= range result.Requests&#123; e.Scheduler.Submit(request) &#125; &#125;&#125;//工作函数，逻辑是 in通道接收到request，即会调用worker函数爬每一个request中的网址，用对应的解析器。 解析完成后，将ParseResult返回给通道outfunc createWorker(in chan Request,out chan ParseResult,s Scheduler) &#123; go func()&#123; for&#123; //传递到调度器，提示可以开始工作 s.WorkerReady(in) //有任务到工作中 request := &lt;-in //开始工作 result,err:= worker(request) if err!=nil&#123; continue &#125; //工作结果返回 out &lt;-result &#125; &#125;()&#125;/* end engine.go *//* start scheduler.go 简单版调度器，用于分配工作任务 */type SimpleScheduler struct&#123; //通道 workerChan chan Request&#125;func (s *SimpleScheduler) WorkerChan() chan Request &#123; return s.workerChan&#125;func (s *SimpleScheduler) WorkerReady(chan Request) &#123;&#125;func (s *SimpleScheduler) Run() &#123; s.workerChan = make(chan Request)&#125;func ( s *SimpleScheduler) Submit( r Request) &#123; //为了防止死锁，在调度器中建立go的协程 分配任务到通道中。 go func()&#123;s.workerChan &lt;- r&#125;()&#125;/* end scheduler.go *//* start Queuescheduler.go 队列调度器，用于分配工作任务 */type QueuedScheduler struct &#123; requestChan chan Request workerChan chan chan Request&#125;func (s *QueuedScheduler) WorkerChan() chan Request &#123; return make(chan Request)&#125;//提交任务到通道，说明需要完成任务func (s *QueuedScheduler) Submit(r Request) &#123; s.requestChan &lt;-r&#125;//提交工作到通道，说明准备好工作了func (s *QueuedScheduler) WorkerReady(w chan Request)&#123; s.workerChan &lt;- w&#125;func (s * QueuedScheduler) Run()&#123; s.workerChan =make(chan chan Request) s.requestChan = make(chan Request) go func()&#123; //任务队列 var requestQ []Request //工作队列 var workQ []chan Request for&#123; var activeRequest Request var activework chan Request //即有工作又有任务，开始工作 if len(requestQ)&gt;0 &amp;&amp; len(workQ) &gt;0&#123; activework = workQ[0] activeRequest = requestQ[0] &#125; select &#123; //任务增加，添加到队列中 case r:=&lt;-s.requestChan: requestQ = append(requestQ,r) //工作增加，添加到队列中 case w:= &lt;-s.workerChan: workQ = append(workQ,w) //有工作又有任务，让工作去做任务 case activework &lt;- activeRequest: workQ = workQ[1:] requestQ=requestQ[1:] &#125; &#125; &#125;()&#125;/* end Queuescheduler.go 队列调度器，用于分配工作任务 */func main()&#123; e:= ConcurrentEngine&#123; Scheduler:&amp;QueuedScheduler&#123;&#125;, WorkerCount:100, &#125; e.Run(Request&#123; Url:\"http://www.zhenai.com/zhenghun\", ParserFunc:ParseCityList, &#125;) ////并发版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;SimpleScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //单任务版爬虫 //Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //paseTest()&#125;//测试func paseTest()&#123; contents,_:= ioutil.ReadFile(\"test.html\") profile:=Profile&#123;&#125; age,err:= strconv.Atoi(extractString(contents,ageRe)) if err!=nil&#123; profile.Age = age &#125; height,err:= strconv.Atoi(extractString(contents,height)) if err!=nil&#123; profile.Height = height &#125; weight,err:= strconv.Atoi(extractString(contents,weight)) if err!=nil&#123; profile.Weight = weight &#125; profile.Salary = extractString(contents,salary) profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; fmt.Printf(\"%s\",profile)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[56]-爬虫-并发队列引擎","slug":"golang-56-crawler-queue","date":"2019-01-24T04:38:48.000Z","updated":"2019-02-04T08:34:22.045Z","comments":true,"path":"2019/01/24/golang-56-crawler-queue/","link":"","permalink":"https://dreamerjonson.com/2019/01/24/golang-56-crawler-queue/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460package mainimport ( \"io/ioutil\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/unicode\" \"log\" \"regexp\" \"strconv\" \"net/http\" \"fmt\" \"time\")var rateLimiter = time.Tick(100 * time.Millisecond)/* start Fetch.go*/func Fetch(url string)([]byte ,error)&#123; //resp,err:= http.Get(url) // //if err!=nil&#123; // return nil,err //&#125; // //defer resp.Body.Close() //if resp.StatusCode != http.StatusOK&#123; // return nil,fmt.Errorf(\"Error: status code:%d\",resp.StatusCode) //&#125; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; log.Fatalln(err) &#125; req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\") resp, err := client.Do(req) if err != nil &#123; log.Fatalln(err) &#125; defer resp.Body.Close() bodyReader:= bufio.NewReader(resp.Body) e:= determineEncoding(bodyReader) utf8reader:= transform.NewReader(bodyReader,e.NewDecoder()) return ioutil.ReadAll(utf8reader)&#125;func determineEncoding(r *bufio.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; log.Printf(\"Fetcher error:%v\",err) return unicode.UTF8 &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;/* end Fetch.go*//* start Type.go*/type Request struct&#123; Url string ParserFunc func([]byte) ParseResult&#125;type ParseResult struct&#123; Requests []Request Items []interface&#123;&#125;&#125;func NilParser([]byte) ParseResult&#123; return ParseResult&#123;&#125;&#125;/* end Type.go*//* start parser/city.go 爬取城市下每一个用户和网址*/const cityRe = `&lt;a href=\"(http://album.zhenai.com/u/[\\d]+)\" target=\"_blank\"&gt;([^&lt;]+)&lt;/a&gt;`func ParseCity(contents []byte) ParseResult&#123; re:= regexp.MustCompile(cityRe) matches:= re.FindAllSubmatch(contents,-1) result := ParseResult&#123;&#125; for _,m:= range matches&#123; name:=string(m[2]) println(string(m[1])) result.Items = append(result.Items,\"User:\"+string(m[2])) result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:func(c []byte) ParseResult&#123; return PaesrProfile( c,name) &#125;, &#125;) &#125; return result&#125;/* end parser/city.go *//* start parser/citylist.go */const cityListRe = `(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`func ParseCityList(contents []byte) ParseResult&#123; re:=regexp.MustCompile(cityListRe) matches:= re.FindAllSubmatch(contents,-1) result:=ParseResult&#123;&#125; for _,m :=range matches&#123; result.Items = append(result.Items,string(m[2])) result.Requests = append( result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/citylist.go *//* start profile.go */type Profile struct &#123; Name string Age int Marry string Constellation string Height int Weight int Salary string&#125;func (p Profile) String() string&#123; return p.Name +\" \" + p.Marry + strconv.Itoa(p.Age) +\"olds \"+ strconv.Itoa(p.Age) + \"cm \" + strconv.Itoa(p.Weight)+ \"kg \"&#125;/* end profile.go *//* start parser/profile.go */var ageRe = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)岁&lt;/div&gt;`)var marry = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(已婚)&lt;/div&gt;`)var constellation = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(.*)座&lt;/div&gt;`)var height =regexp.MustCompile(`160cm`)var weight =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)kg&lt;/div&gt;`)var salary = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;月收入:([^&lt;]+)&lt;/div&gt;`)//解析器 解析用户//name为上一级传递过来的func PaesrProfile(contents []byte,name string) ParseResult&#123; //ioutil.WriteFile(\"test.html\",contents,0x777) //用户结构体 profile:=Profile&#123;&#125; profile.Name = name //年龄 string转换为int age,err:= strconv.Atoi(extractString(contents,ageRe)) if err==nil&#123; profile.Age = age &#125; //身高 height,err:= strconv.Atoi(extractString(contents,height)) if err==nil&#123; profile.Height = height &#125; //体重 weight,err:= strconv.Atoi(extractString(contents,weight)) if err==nil&#123; profile.Weight = weight &#125; //薪水 profile.Salary = extractString(contents,salary) //星座 profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; result:=ParseResult&#123; Items:[]interface&#123;&#125;&#123;profile&#125;, &#125; return result&#125;//封装 正则表达式匹配func extractString(contents []byte,re *regexp.Regexp) string&#123; match:=re.FindSubmatch(contents) if len(match)&gt;=2&#123; return string(match[1]) &#125;else&#123; return \"\" &#125;&#125;/* end parser/profile.go *//* start engine.go 单任务版引擎*/func Run(seeds ...Request)&#123; var requests []Request for _,r := range seeds&#123; requests = append(requests,r) &#125; for len(requests) &gt;0&#123; r:=requests[0] requests = requests[1:] fmt.Printf(\"Fetching %s\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) continue &#125; parseResult:= r.ParserFunc(body) requests = append(requests,parseResult.Requests...) for _,item:= range parseResult.Items&#123; fmt.Printf(\"Got item %s\\n\",item) &#125; &#125;&#125;//具体的工作 传递一个request，通过解析器对url进行解析func worker(r Request)(ParseResult,error)&#123; fmt.Printf(\"Fetching %s\\n\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) return ParseResult&#123;&#125;,err &#125; return r.ParserFunc(body),nil&#125;// 并发版爬虫引擎 包含了调度器 与 工人数type ConcurrentEngine struct&#123; Scheduler Scheduler WorkerCount int&#125;//调度器是一个接口，扩展性type Scheduler interface &#123; //提交Request进行执行 Submit(Request) //配置通道 ConfigureMasterWorkChan(chan Request) WorkerReady(chan Request) Run()&#125;//并发版爬虫引擎func (e *ConcurrentEngine) Run(seeds ...Request)&#123; out:= make(chan ParseResult) //配置调度器通道 e.Scheduler.Run() //开启WorkerCount个工作 for i:=0;i&lt;e.WorkerCount;i++&#123; createWorker(out,e.Scheduler) &#125; //种子首先运行 for _,r:=range seeds&#123; e.Scheduler.Submit(r) &#125; itemsCount:=0 for&#123; //out等待接受ParseResult result:=&lt;-out //打印出接收到的数据，以及个数。 for _,item:= range result.Items&#123; fmt.Printf(\"Got item: #%d: %v\\n\",itemsCount,item) itemsCount++ &#125; //分配任务 for _,request:= range result.Requests&#123; e.Scheduler.Submit(request) &#125; &#125;&#125;//工作函数，逻辑是 in通道接收到request，即会调用worker函数爬每一个request中的网址，用对应的解析器。 解析完成后，将ParseResult返回给通道outfunc createWorker(out chan ParseResult,s Scheduler) &#123; in := make(chan Request) go func()&#123; for&#123; //传递到调度器，提示可以开始工作 s.WorkerReady(in) //有任务到工作中 request := &lt;-in //开始工作 result,err:= worker(request) if err!=nil&#123; continue &#125; //工作结果返回 out &lt;-result &#125; &#125;()&#125;/* end engine.go *//* start scheduler.go 简单版调度器，用于分配工作任务 */type SimpleScheduler struct&#123; //通道 workerChan chan Request&#125;func ( s *SimpleScheduler) Submit( r Request) &#123; //为了防止死锁，在调度器中建立go的协程 分配任务到通道中。 go func()&#123;s.workerChan &lt;- r&#125;()&#125;func (s *SimpleScheduler) ConfigureMasterWorkChan(c chan Request) &#123; //in通道 s.workerChan = c&#125;/* end scheduler.go *//* start Queuescheduler.go 队列调度器，用于分配工作任务 */type QueuedScheduler struct &#123; requestChan chan Request workerChan chan chan Request&#125;//提交任务到通道，说明需要完成任务func (s *QueuedScheduler) Submit(r Request) &#123; s.requestChan &lt;-r&#125;//提交工作到通道，说明准备好工作了func (s *QueuedScheduler) WorkerReady(w chan Request)&#123; s.workerChan &lt;- w&#125;func (s *QueuedScheduler) ConfigureMasterWorkChan(chan Request) &#123; panic(\"implement me\")&#125;func (s * QueuedScheduler) Run()&#123; s.workerChan =make(chan chan Request) s.requestChan = make(chan Request) go func()&#123; //任务队列 var requestQ []Request //工作队列 var workQ []chan Request for&#123; var activeRequest Request var activework chan Request //即有工作又有任务，开始工作 if len(requestQ)&gt;0 &amp;&amp; len(workQ) &gt;0&#123; activework = workQ[0] activeRequest = requestQ[0] &#125; select &#123; //任务增加，添加到队列中 case r:=&lt;-s.requestChan: requestQ = append(requestQ,r) //工作增加，添加到队列中 case w:= &lt;-s.workerChan: workQ = append(workQ,w) //有工作又有任务，让工作去做任务 case activework &lt;- activeRequest: workQ = workQ[1:] requestQ=requestQ[1:] &#125; &#125; &#125;()&#125;/* end Queuescheduler.go 队列调度器，用于分配工作任务 */func main()&#123; e:= ConcurrentEngine&#123; Scheduler:&amp;QueuedScheduler&#123;&#125;, WorkerCount:100, &#125; e.Run(Request&#123; Url:\"http://www.zhenai.com/zhenghun\", ParserFunc:ParseCityList, &#125;) ////并发版爬虫 //e:= ConcurrentEngine&#123; // Scheduler:&amp;SimpleScheduler&#123;&#125;, // WorkerCount:100, //&#125; // //e.Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //单任务版爬虫 //Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //paseTest()&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[55]-爬虫-并发爬虫引擎","slug":"golang-55-crawler-Concurrent","date":"2019-01-23T16:41:55.000Z","updated":"2019-02-04T08:34:16.171Z","comments":true,"path":"2019/01/24/golang-55-crawler-Concurrent/","link":"","permalink":"https://dreamerjonson.com/2019/01/24/golang-55-crawler-Concurrent/","excerpt":"","text":"go语言实现并发版爬虫，拥有良好的拓展性。效率是单任务的数十倍。 并发版爬虫 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419package mainimport ( \"io/ioutil\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/unicode\" \"log\" \"regexp\" \"strconv\" \"net/http\" \"fmt\" \"time\")var rateLimiter = time.Tick(100 * time.Millisecond)/* start Fetch.go*/func Fetch(url string)([]byte ,error)&#123; //resp,err:= http.Get(url) // //if err!=nil&#123; // return nil,err //&#125; // //defer resp.Body.Close() //if resp.StatusCode != http.StatusOK&#123; // return nil,fmt.Errorf(\"Error: status code:%d\",resp.StatusCode) //&#125; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; log.Fatalln(err) &#125; req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\") resp, err := client.Do(req) if err != nil &#123; log.Fatalln(err) &#125; defer resp.Body.Close() bodyReader:= bufio.NewReader(resp.Body) e:= determineEncoding(bodyReader) utf8reader:= transform.NewReader(bodyReader,e.NewDecoder()) return ioutil.ReadAll(utf8reader)&#125;func determineEncoding(r *bufio.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; log.Printf(\"Fetcher error:%v\",err) return unicode.UTF8 &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;/* end Fetch.go*//* start Type.go*/type Request struct&#123; Url string ParserFunc func([]byte) ParseResult&#125;type ParseResult struct&#123; Requests []Request Items []interface&#123;&#125;&#125;func NilParser([]byte) ParseResult&#123; return ParseResult&#123;&#125;&#125;/* end Type.go*//* start parser/city.go 爬取城市下每一个用户和网址*/const cityRe = `&lt;a href=\"(http://album.zhenai.com/u/[\\d]+)\" target=\"_blank\"&gt;([^&lt;]+)&lt;/a&gt;`func ParseCity(contents []byte) ParseResult&#123; re:= regexp.MustCompile(cityRe) matches:= re.FindAllSubmatch(contents,-1) result := ParseResult&#123;&#125; for _,m:= range matches&#123; name:=string(m[2]) println(string(m[1])) result.Items = append(result.Items,\"User:\"+string(m[2])) result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:func(c []byte) ParseResult&#123; return PaesrProfile( c,name) &#125;, &#125;) &#125; return result&#125;/* end parser/city.go *//* start parser/citylist.go */const cityListRe = `(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`func ParseCityList(contents []byte) ParseResult&#123; re:=regexp.MustCompile(cityListRe) matches:= re.FindAllSubmatch(contents,-1) result:=ParseResult&#123;&#125; for _,m :=range matches&#123; result.Items = append(result.Items,string(m[2])) result.Requests = append( result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) &#125; return result&#125;/* end parser/citylist.go *//* start profile.go */type Profile struct &#123; Name string Age int Marry string Constellation string Height int Weight int Salary string&#125;func (p Profile) String() string&#123; return p.Name +\" \" + p.Marry + strconv.Itoa(p.Age) +\"olds \"+ strconv.Itoa(p.Age) + \"cm \" + strconv.Itoa(p.Weight)+ \"kg \"&#125;/* end profile.go *//* start parser/profile.go */var ageRe = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)岁&lt;/div&gt;`)var marry = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(已婚)&lt;/div&gt;`)var constellation = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(.*)座&lt;/div&gt;`)var height =regexp.MustCompile(`160cm`)var weight =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)kg&lt;/div&gt;`)var salary = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;月收入:([^&lt;]+)&lt;/div&gt;`)//解析器 解析用户//name为上一级传递过来的func PaesrProfile(contents []byte,name string) ParseResult&#123; //ioutil.WriteFile(\"test.html\",contents,0x777) //用户结构体 profile:=Profile&#123;&#125; profile.Name = name //年龄 string转换为int age,err:= strconv.Atoi(extractString(contents,ageRe)) if err==nil&#123; profile.Age = age &#125; //身高 height,err:= strconv.Atoi(extractString(contents,height)) if err==nil&#123; profile.Height = height &#125; //体重 weight,err:= strconv.Atoi(extractString(contents,weight)) if err==nil&#123; profile.Weight = weight &#125; //薪水 profile.Salary = extractString(contents,salary) //星座 profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; result:=ParseResult&#123; Items:[]interface&#123;&#125;&#123;profile&#125;, &#125; return result&#125;//封装 正则表达式匹配func extractString(contents []byte,re *regexp.Regexp) string&#123; match:=re.FindSubmatch(contents) if len(match)&gt;=2&#123; return string(match[1]) &#125;else&#123; return \"\" &#125;&#125;/* end parser/profile.go *//* start engine.go 单任务版引擎*/func Run(seeds ...Request)&#123; var requests []Request for _,r := range seeds&#123; requests = append(requests,r) &#125; for len(requests) &gt;0&#123; r:=requests[0] requests = requests[1:] fmt.Printf(\"Fetching %s\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) continue &#125; parseResult:= r.ParserFunc(body) requests = append(requests,parseResult.Requests...) for _,item:= range parseResult.Items&#123; fmt.Printf(\"Got item %s\\n\",item) &#125; &#125;&#125;//具体的工作 传递一个request，通过解析器对url进行解析func worker(r Request)(ParseResult,error)&#123; fmt.Printf(\"Fetching %s\\n\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) return ParseResult&#123;&#125;,err &#125; return r.ParserFunc(body),nil&#125;// 并发版爬虫引擎 包含了调度器 与 工人数type ConcurrentEngine struct&#123; Scheduler Scheduler WorkerCount int&#125;//调度器是一个接口，扩展性type Scheduler interface &#123; //提交Request进行执行 Submit(Request) //配置通道 ConfigureMasterWorkChan(chan Request)&#125;//并发版爬虫引擎func (e *ConcurrentEngine) Run(seeds ...Request)&#123; in:=make(chan Request) out:= make(chan ParseResult) //配置调度器通道 e.Scheduler.ConfigureMasterWorkChan(in) //开启WorkerCount个工作 for i:=0;i&lt;e.WorkerCount;i++&#123; createWorker(in,out) &#125; //种子首先运行 for _,r:=range seeds&#123; e.Scheduler.Submit(r) &#125; itemsCount:=0 for&#123; //out等待接受ParseResult result:=&lt;-out //打印出接收到的数据，以及个数。 for _,item:= range result.Items&#123; fmt.Printf(\"Got item: #%d: %v\\n\",itemsCount,item) itemsCount++ &#125; //每一个request都通过调度器发送给in通道，由于在调度器中使用了协程的方式，不会卡死在这里陷入死锁。 for _,request:= range result.Requests&#123; e.Scheduler.Submit(request) &#125; &#125;&#125;//工作函数，逻辑是 in通道接收到request，即会调用worker函数爬每一个request中的网址，用对应的解析器。 解析完成后，将ParseResult返回给通道outfunc createWorker(in chan Request, out chan ParseResult) &#123; go func()&#123; for&#123; request := &lt;-in result,err:= worker(request) if err!=nil&#123; continue &#125; out &lt;-result &#125; &#125;()&#125;/* end engine.go *//* start scheduler.go 简单版调度器，用于分配工作任务 */type SimpleScheduler struct&#123; //通道 workerChan chan Request&#125;func ( s *SimpleScheduler) Submit( r Request) &#123; //为了防止死锁，在调度器中建立go的协程 分配任务到通道中。 go func()&#123;s.workerChan &lt;- r&#125;()&#125;func (s *SimpleScheduler) ConfigureMasterWorkChan(c chan Request) &#123; //in通道 s.workerChan = c&#125;/* end scheduler.go */func main()&#123; //并发版爬虫 e:= ConcurrentEngine&#123; Scheduler:&amp;SimpleScheduler&#123;&#125;, WorkerCount:100, &#125; e.Run(Request&#123; Url:\"http://www.zhenai.com/zhenghun\", ParserFunc:ParseCityList, &#125;) //单任务版爬虫 //Run(Request&#123; // Url:\"http://www.zhenai.com/zhenghun\", // ParserFunc:ParseCityList, //&#125;) //paseTest()&#125;//测试func paseTest()&#123; contents,_:= ioutil.ReadFile(\"test.html\") profile:=Profile&#123;&#125; age,err:= strconv.Atoi(extractString(contents,ageRe)) if err!=nil&#123; profile.Age = age &#125; height,err:= strconv.Atoi(extractString(contents,height)) if err!=nil&#123; profile.Height = height &#125; weight,err:= strconv.Atoi(extractString(contents,weight)) if err!=nil&#123; profile.Weight = weight &#125; profile.Salary = extractString(contents,salary) profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; fmt.Printf(\"%s\",profile)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[54]-爬虫-单任务版爬虫爬取相亲页面","slug":"golang-54-crawler-zhengai","date":"2019-01-23T10:32:28.000Z","updated":"2019-02-04T08:34:11.717Z","comments":true,"path":"2019/01/23/golang-54-crawler-zhengai/","link":"","permalink":"https://dreamerjonson.com/2019/01/23/golang-54-crawler-zhengai/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305package mainimport ( \"io/ioutil\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"golang.org/x/text/encoding/unicode\" \"log\" \"regexp\" \"strconv\" \"net/http\" \"fmt\")/* start Fetch.go*/func Fetch(url string)([]byte ,error)&#123; //resp,err:= http.Get(url) // //if err!=nil&#123; // return nil,err //&#125; // //defer resp.Body.Close() //if resp.StatusCode != http.StatusOK&#123; // return nil,fmt.Errorf(\"Error: status code:%d\",resp.StatusCode) //&#125; client := &amp;http.Client&#123;&#125; req, err := http.NewRequest(\"GET\", url, nil) if err != nil &#123; log.Fatalln(err) &#125; req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\") resp, err := client.Do(req) if err != nil &#123; log.Fatalln(err) &#125; defer resp.Body.Close() bodyReader:= bufio.NewReader(resp.Body) e:= determineEncoding(bodyReader) utf8reader:= transform.NewReader(bodyReader,e.NewDecoder()) return ioutil.ReadAll(utf8reader)&#125;func determineEncoding(r *bufio.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; log.Printf(\"Fetcher error:%v\",err) return unicode.UTF8 &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;/* end Fetch.go*//* start Type.go*/type Request struct&#123; Url string ParserFunc func([]byte) ParseResult&#125;type ParseResult struct&#123; Requests []Request Items []interface&#123;&#125;&#125;func NilParser([]byte) ParseResult&#123; return ParseResult&#123;&#125;&#125;/* end Type.go*//* start parser/city.go 爬取城市下每一个用户和网址*/const cityRe = `&lt;a href=\"(http://album.zhenai.com/u/[\\d]+)\" target=\"_blank\"&gt;([^&lt;]+)&lt;/a&gt;`func ParseCity(contents []byte) ParseResult&#123; re:= regexp.MustCompile(cityRe) matches:= re.FindAllSubmatch(contents,-1) result := ParseResult&#123;&#125; for _,m:= range matches&#123; name:=string(m[2]) println(string(m[1])) result.Items = append(result.Items,\"User:\"+string(m[2])) result.Requests = append(result.Requests,Request&#123; Url:string(m[1]), ParserFunc:func(c []byte) ParseResult&#123; return PaesrProfile( c,name) &#125;, &#125;) &#125; return result&#125;/* end parser/city.go *//* start parser/citylist.go */const cityListRe = `(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`func ParseCityList(contents []byte) ParseResult&#123; re:=regexp.MustCompile(cityListRe) matches:= re.FindAllSubmatch(contents,-1) result:=ParseResult&#123;&#125; //测试，限制10个城市 limit:= 10 for _,m :=range matches&#123; result.Items = append(result.Items,string(m[2])) result.Requests = append( result.Requests,Request&#123; Url:string(m[1]), ParserFunc:ParseCity, &#125;) limit-- if limit==0&#123; break &#125; &#125; return result&#125;/* end parser/citylist.go *//* start profile.go */type Profile struct &#123; Name string Age int Marry string Constellation string Height int Weight int Salary string&#125;func (p Profile) String() string&#123; return p.Name +\" \" + p.Marry + strconv.Itoa(p.Age) +\"olds \"+ strconv.Itoa(p.Age) + \"cm \" + strconv.Itoa(p.Weight)+ \"kg \"&#125;/* end profile.go *//* start parser/profile.go */var ageRe = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)岁&lt;/div&gt;`)var marry = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(已婚)&lt;/div&gt;`)var constellation = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;(.*)座&lt;/div&gt;`)var height =regexp.MustCompile(`160cm`)var weight =regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;([\\d]+)kg&lt;/div&gt;`)var salary = regexp.MustCompile(`&lt;div class=\"m-btn purple\" data-v-bff6f798&gt;月收入:([^&lt;]+)&lt;/div&gt;`)//name为上一级传递过来的func PaesrProfile(contents []byte,name string) ParseResult&#123; //ioutil.WriteFile(\"test.html\",contents,0x777) profile:=Profile&#123;&#125; profile.Name = name age,err:= strconv.Atoi(extractString(contents,ageRe)) if err==nil&#123; profile.Age = age &#125; height,err:= strconv.Atoi(extractString(contents,height)) if err==nil&#123; profile.Height = height &#125; weight,err:= strconv.Atoi(extractString(contents,weight)) if err==nil&#123; profile.Weight = weight &#125; profile.Salary = extractString(contents,salary) profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; result:=ParseResult&#123; Items:[]interface&#123;&#125;&#123;profile&#125;, &#125; return result&#125;func extractString(contents []byte,re *regexp.Regexp) string&#123; match:=re.FindSubmatch(contents) if len(match)&gt;=2&#123; return string(match[1]) &#125;else&#123; return \"\" &#125;&#125;/* end parser/profile.go *//* start engine.go */func Run(seeds ...Request)&#123; var requests []Request for _,r := range seeds&#123; requests = append(requests,r) &#125; for len(requests) &gt;0&#123; r:=requests[0] requests = requests[1:] fmt.Printf(\"Fetching %s\",r.Url) body,err:= Fetch(r.Url) if err!=nil&#123; log.Printf(\"Fetcher:error \"+ \"fetching url %s, : %v\",r.Url,err) continue &#125; parseResult:= r.ParserFunc(body) requests = append(requests,parseResult.Requests...) for _,item:= range parseResult.Items&#123; fmt.Printf(\"Got item %s\\n\",item) &#125; &#125;&#125;/* end engine.go */func main()&#123; Run(Request&#123; Url:\"http://www.zhenai.com/zhenghun\", ParserFunc:ParseCityList, &#125;) //paseTest()&#125;func paseTest()&#123; contents,_:= ioutil.ReadFile(\"test.html\") profile:=Profile&#123;&#125; age,err:= strconv.Atoi(extractString(contents,ageRe)) if err!=nil&#123; profile.Age = age &#125; height,err:= strconv.Atoi(extractString(contents,height)) if err!=nil&#123; profile.Height = height &#125; weight,err:= strconv.Atoi(extractString(contents,weight)) if err!=nil&#123; profile.Weight = weight &#125; profile.Salary = extractString(contents,salary) profile.Constellation = extractString(contents,constellation) if extractString(contents,marry)== \"\"&#123; profile.Marry =\"未婚\" &#125;else&#123; profile.Marry =\"已婚\" &#125; fmt.Printf(\"%s\",profile)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[53]-爬虫-解决403错误","slug":"golang-53-crawler-403","date":"2019-01-23T10:11:33.000Z","updated":"2019-02-04T08:34:05.302Z","comments":true,"path":"2019/01/23/golang-53-crawler-403/","link":"","permalink":"https://dreamerjonson.com/2019/01/23/golang-53-crawler-403/","excerpt":"","text":"如下，直接用http.Get(url)进行获取信息，用浏览器可以对该URL进行访问，可是爬取时则返回403，禁止访问 resp,err := http.Get(url) 解决方案：模拟浏览器访问： 1、查看自己浏览器中的User-Agent 信息。 2、将下面代码 resp,err := http.Get(url) defer resp.Body.Close() 替换成下面的代码 client := &amp;http.Client{} req, err := http.NewRequest(&quot;GET&quot;, url, nil) if err != nil { log.Fatalln(err) } //浏览器中的User-Agent req.Header.Set(“User-Agent”, “Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36”) resp, err := client.Do(req) if err != nil { log.Fatalln(err) } defer resp.Body.Close()","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[51]-爬虫-正则表达式进行分组","slug":"golang-52-crawler-group","date":"2019-01-22T13:00:46.000Z","updated":"2019-02-04T08:34:00.534Z","comments":true,"path":"2019/01/22/golang-52-crawler-group/","link":"","permalink":"https://dreamerjonson.com/2019/01/22/golang-52-crawler-group/","excerpt":"","text":"##为正则表达式进行分组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"net/http\" \"io/ioutil\" \"fmt\" \"io\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"regexp\")func main()&#123; resp,err:= http.Get(\"http://www.zhenai.com/zhenghun\") if err!=nil&#123; panic(err) &#125; defer resp.Body.Close() if resp.StatusCode != http.StatusOK&#123; fmt.Println(\"Error: status code\",resp.StatusCode) &#125; e:= determineEncoding(resp.Body) utf8reader:= transform.NewReader(resp.Body,e.NewDecoder()) all,err:= ioutil.ReadAll(utf8reader) if err!=nil&#123; panic(err) &#125; //fmt.Printf(\"%s\\n\",all) printCityList(all)&#125;func determineEncoding(r io.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; panic(err) &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;func printCityList(contents []byte)&#123; re:=regexp.MustCompile(`(http://www.zhenai.com/zhenghun/[0-9a-z]+)\"[^&gt;]*&gt;([^&lt;]+)&lt;/a&gt;`) matches:= re.FindAllSubmatch(contents,-1) for _,m :=range matches&#123; fmt.Printf(\"City: %s,URL:%s\\n \",m[2],m[1]) &#125; fmt.Printf(\"Matches found: %d\\n\",len(matches))&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[51]-爬虫-正则获取网址","slug":"golang-51-crawler","date":"2019-01-22T12:50:15.000Z","updated":"2019-02-04T08:33:55.781Z","comments":true,"path":"2019/01/22/golang-51-crawler/","link":"","permalink":"https://dreamerjonson.com/2019/01/22/golang-51-crawler/","excerpt":"","text":"## 添加正则表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"net/http\" \"io/ioutil\" \"fmt\" \"io\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\" \"regexp\")func main()&#123; resp,err:= http.Get(\"http://www.zhenai.com/zhenghun\") if err!=nil&#123; panic(err) &#125; defer resp.Body.Close() if resp.StatusCode != http.StatusOK&#123; fmt.Println(\"Error: status code\",resp.StatusCode) &#125; e:= determineEncoding(resp.Body) utf8reader:= transform.NewReader(resp.Body,e.NewDecoder()) all,err:= ioutil.ReadAll(utf8reader) if err!=nil&#123; panic(err) &#125; //fmt.Printf(\"%s\\n\",all) printCityList(all)&#125;func determineEncoding(r io.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; panic(err) &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;func printCityList(contents []byte)&#123; //正则匹配网址http://www.zhenai.com/zhenghun/xiamen\" data-v-4e064b2c&gt;厦门&lt;/a&gt; //[^&gt;]代表以&gt;结尾，*&gt;代表到达之前&gt;之前的东西，可能有换行符。 re:=regexp.MustCompile(`http://www.zhenai.com/zhenghun/[0-9a-z]+\"[^&gt;]*&gt;[^&lt;]+&lt;/a&gt;`) matches:= re.FindAll(contents,-1) for _,m :=range matches&#123; fmt.Printf(\"%s\\n\",m) &#125; fmt.Printf(\"Matches found: %d\\n\",len(matches))&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[49]-解决下载go语言包翻墙问题","slug":"golang-49-gopm","date":"2019-01-22T10:03:46.000Z","updated":"2019-02-04T08:33:51.191Z","comments":true,"path":"2019/01/22/golang-49-gopm/","link":"","permalink":"https://dreamerjonson.com/2019/01/22/golang-49-gopm/","excerpt":"","text":"简介 国内用户在下载go语言包的时候，常常会面临翻墙问题，这里介绍的gopm工具可以解决这一问题。 网址：https://github.com/gpmgo/gopm 简单使用方法：go get -u github.com/gpmgo/gopm 执行文件将会产生在$Gopath/bin目录中。将此目录设置为PATH变量 使用方法 1234567891011121314151617181920212223242526NAME: Gopm - Go Package ManagerUSAGE: Gopm [global options] command [command options] [arguments...]COMMANDS: list list all dependencies of current project gen generate a gopmfile for current Go project get fetch remote package(s) and dependencies bin download and link dependencies and build binary config configure gopm settings run link dependencies and go run test link dependencies and go test build link dependencies and go build install link dependencies and go install clean clean all temporary files update check and update gopm resources including itself help, h Shows a list of commands or help for one commandGLOBAL OPTIONS: --noterm, -n disable color output --strict, -s strict mode --debug, -d debug mode --help, -h show help --version, -v print the version 例子： 12&gt; gopm get -g -v golang.org&#x2F;x&#x2F;text&gt; gopm get -g -v golang.org&#x2F;x&#x2F;net&#x2F;html","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[48]-gbk编码转换为Utf8编码","slug":"golang-48-gbkatoUtf8","date":"2019-01-22T10:00:08.000Z","updated":"2019-02-04T08:33:46.272Z","comments":true,"path":"2019/01/22/golang-48-gbkatoUtf8/","link":"","permalink":"https://dreamerjonson.com/2019/01/22/golang-48-gbkatoUtf8/","excerpt":"","text":"在go语言中，如果有时候获取到的中文网站是GBK编码，这时转换为UTF-8编码 需下载两个辅助包： 12&gt; gopm get -g -v golang.org&#x2F;x&#x2F;text&gt; gopm get -g -v golang.org&#x2F;x&#x2F;net&#x2F;html 下面简单的爬虫展示将gbk网址转换为UTF-8的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"net/http\" \"io/ioutil\" \"fmt\" \"io\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\")func main()&#123; resp,err:= http.Get(\"http://www.chinanews.com/\") if err!=nil&#123; panic(err) &#125; defer resp.Body.Close() if resp.StatusCode != http.StatusOK&#123; fmt.Println(\"Error: status code\",resp.StatusCode) &#125; e:= determineEncoding(resp.Body) utf8reader:= transform.NewReader(resp.Body,e.NewDecoder()) all,err:= ioutil.ReadAll(utf8reader) if err!=nil&#123; panic(err) &#125; fmt.Printf(\"%s\\n\",all)&#125;func determineEncoding(r io.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; panic(err) &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[17]-go语言建立聊天服务器的3种案例赏析","slug":"go-network-17-p2p-chat","date":"2019-01-19T14:19:18.000Z","updated":"2019-02-04T08:39:19.565Z","comments":true,"path":"2019/01/19/go-network-17-p2p-chat/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-17-p2p-chat/","excerpt":"","text":"案例1 如何在55行Golang中编写TCP聊天服务器? go net包允许你编写TCP服务器。这是一个聊天服务器，客户端发送的每个字节都被复制到每个其他客户端（包括发送者） 代码比较精彩，在主程序中建立了3个通道，分别是新链接、断开链接、广播信息。作者非常巧妙的将代码压缩到55行， 虽然每一个客户端都在抢夺通道的信息，但是作者通过通道的缓冲区来缓解这个问题，目前这套代码已经能够处理非常大量的并发聊天。 此代码的缺陷在于，在不断的广播过程中，可能会开辟无数的协程处理写入数据的操作，这时会造成消息堵塞，甚至消息不按照顺序到达。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport \"net\"func main() &#123; newConns := make(chan net.Conn, 128)//新链接 deadConns := make(chan net.Conn, 128)//断开链接 publishes := make(chan []byte, 128)//广播信息 conns := make(map[net.Conn]bool) listener, err := net.Listen(\"tcp\", \":8080\") defer listener.Close() if err != nil &#123; panic(err) &#125; //防止卡住 go func() &#123; for &#123; conn, err := listener.Accept() if err != nil &#123; panic(err) &#125; newConns &lt;- conn &#125; &#125;() for &#123; select &#123; case conn := &lt;-newConns: //新建链接后，会开辟协程不断短期客户端发出的消息 conns[conn] = true go func() &#123; buf := make([]byte, 1024) for &#123; nbyte, err := conn.Read(buf) if err != nil &#123; deadConns &lt;- conn break &#125; else &#123; fragment := make([]byte, nbyte) copy(fragment, buf[:nbyte]) publishes &lt;- fragment &#125; &#125; &#125;() case deadConn := &lt;-deadConns: //断开链接、关闭资源 _ = deadConn.Close() delete(conns, deadConn) //缺陷 case publish := &lt;-publishes: // 广播给所有的 for conn, _ := range conns &#123; go func(conn net.Conn) &#123; totalWritten := 0 for totalWritten &lt; len(publish) &#123; writtenThisCall, err := conn.Write(publish[totalWritten:]) if err != nil &#123; deadConns &lt;- conn break &#125; totalWritten += writtenThisCall &#125; &#125;(conn) &#125; &#125; &#125;&#125; 案例二： 案例二是一个服务器与客户端都混合在一起的例子。 案例二相对于案例一最大的改进在于，服务器为每一个客户端都新建了唯一的协程来处理数据。在协程中，通过一个通道来通信。当客户端通道接收到数据，即会往客户端发送消息。 程序更加稳健。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package mainimport ( \"bufio\" \"flag\" \"fmt\" \"net\" \"os\" \"strings\" \"time\")//每一个客户端，服务器都新建了通道type ClientManager struct &#123; clients map[*Client]bool broadcast chan []byte register chan *Client unregister chan *Client&#125;type Client struct &#123; socket net.Conn data chan []byte&#125;func (manager *ClientManager) start() &#123; for &#123; select &#123; case connection := &lt;-manager.register: manager.clients[connection] = true fmt.Println(\"Added new connection!\") case connection := &lt;-manager.unregister: if _, ok := manager.clients[connection]; ok &#123; close(connection.data) delete(manager.clients, connection) fmt.Println(\"A connection has terminated!\") &#125; case message := &lt;-manager.broadcast: for connection := range manager.clients &#123; select &#123; case connection.data &lt;- message: default: close(connection.data) delete(manager.clients, connection) &#125; &#125; &#125; &#125;&#125;func (manager *ClientManager) receive(client *Client) &#123; for &#123; message := make([]byte, 4096) length, err := client.socket.Read(message) if err != nil &#123; manager.unregister &lt;- client client.socket.Close() break &#125; if length &gt; 0 &#123; fmt.Println(\"RECEIVED: \" + string(message)) manager.broadcast &lt;- message &#125; &#125;&#125;func (client *Client) receive() &#123; for &#123; message := make([]byte, 4096) length, err := client.socket.Read(message) if err != nil &#123; client.socket.Close() break &#125; if length &gt; 0 &#123; fmt.Println(\"RECEIVED: \" + string(message)) &#125; &#125;&#125;func (manager *ClientManager) send(client *Client) &#123; defer client.socket.Close() for &#123; select &#123; case message, ok := &lt;-client.data: if !ok &#123; return &#125; client.socket.Write(message) &#125; &#125;&#125;func startServerMode() &#123; fmt.Println(\"Starting server...\") listener, error := net.Listen(\"tcp\", \":12345\") if error != nil &#123; fmt.Println(error) &#125; manager := ClientManager&#123; clients: make(map[*Client]bool), broadcast: make(chan []byte), register: make(chan *Client), unregister: make(chan *Client), &#125; go manager.start() for &#123; connection, _ := listener.Accept() if error != nil &#123; fmt.Println(error) &#125; client := &amp;Client&#123;socket: connection, data: make(chan []byte)&#125; manager.register &lt;- client go manager.receive(client) go manager.send(client) &#125;&#125;func startClientMode() &#123; fmt.Println(\"Starting client...\") connection, error := net.Dial(\"tcp\", \"localhost:12345\") if error != nil &#123; fmt.Println(error) &#125; client := &amp;Client&#123;socket: connection&#125; go client.receive() for &#123; reader := bufio.NewReader(os.Stdin) message, _ := reader.ReadString('\\n') connection.Write([]byte(strings.TrimRight(message, \"\\n\"))) &#125;&#125;func main() &#123; flagMode := flag.String(\"mode\", \"server\", \"start in client or server mode\") flag.Parse() if strings.ToLower(*flagMode) == \"server\" &#123; startServerMode() &#125; else &#123; startClientMode() &#125;&#125; 案例3: 案例三是go语言圣经中的一段代码demo。 这段代码有点意思，服务器端绑定的是一个通道而不是socker连接的指针。 同时每一个客户端都有一个携程来处理发送信息的操作。从这一点和案例二很相似。但是缺陷也很大，不能处理断开连接的操作。只能关闭通道。 和案例二是没有办法比较的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// Copyright © 2016 Alan A. A. Donovan &amp; Brian W. Kernighan.// License: https://creativecommons.org/licenses/by-nc-sa/4.0/// See page 254.//!+// Chat is a server that lets clients chat with each other.package mainimport ( \"bufio\" \"fmt\" \"log\" \"net\")//!+broadcastertype client chan&lt;- string // an outgoing message channelvar ( entering = make(chan client) leaving = make(chan client) messages = make(chan string) // all incoming client messages)func broadcaster() &#123; clients := make(map[client]bool) // all connected clients for &#123; select &#123; case msg := &lt;-messages: // Broadcast incoming message to all // clients' outgoing message channels. for cli := range clients &#123; cli &lt;- msg &#125; case cli := &lt;-entering: clients[cli] = true case cli := &lt;-leaving: delete(clients, cli) close(cli) &#125; &#125;&#125;//!-broadcaster//!+handleConnfunc handleConn(conn net.Conn) &#123; ch := make(chan string) // outgoing client messages go clientWriter(conn, ch) who := conn.RemoteAddr().String() ch &lt;- \"You are \" + who messages &lt;- who + \" has arrived\" entering &lt;- ch input := bufio.NewScanner(conn) for input.Scan() &#123; messages &lt;- who + \": \" + input.Text() &#125; // NOTE: ignoring potential errors from input.Err() leaving &lt;- ch messages &lt;- who + \" has left\" conn.Close()&#125;func clientWriter(conn net.Conn, ch &lt;-chan string) &#123; for msg := range ch &#123; fmt.Fprintln(conn, msg) // NOTE: ignoring network errors &#125;&#125;//!-handleConn//!+mainfunc main() &#123; listener, err := net.Listen(\"tcp\", \"localhost:8000\") if err != nil &#123; log.Fatal(err) &#125; go broadcaster() for &#123; conn, err := listener.Accept() if err != nil &#123; log.Print(err) continue &#125; go handleConn(conn) &#125;&#125;//!-main 总结 案例二具有良好的稳健型。服务器为每一个客户端都开辟了一个协程处理发送数据操作，通过通道来进行通信。能够解决案例三中不能解决的断开网络连接的操作，也能够解决案例一中开辟无数个协程以及消息堵塞不同步的问题。。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[16]-http","slug":"go-network-16-http","date":"2019-01-19T10:31:53.000Z","updated":"2019-02-04T08:39:13.915Z","comments":true,"path":"2019/01/19/go-network-16-http/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-16-http/","excerpt":"","text":"##获取网站内容 123456789101112131415161718192021222324252627package mainimport ( \"net/http\" \"io/ioutil\" \"fmt\")func main()&#123; resp,err:= http.Get(\"http://www.zhenai.com/zhenghun\") if err!=nil&#123; panic(err) &#125; defer resp.Body.Close() if resp.StatusCode == http.StatusOK&#123; all,err:=ioutil.ReadAll(resp.Body) if err!=nil&#123; panic(err) &#125; fmt.Printf(\"%s\\n\",all) &#125;&#125; 当charset为gbk时，转换为utf-8 下载辅助包 gopm get -g -v golang.org/x/text gopm get -g -v golang.org/x/net/html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"net/http\" \"io/ioutil\" \"fmt\" \"io\" \"golang.org/x/net/html/charset\" \"golang.org/x/text/encoding\" \"bufio\" \"golang.org/x/text/transform\")func main()&#123; resp,err:= http.Get(\"http://www.chinanews.com/\") if err!=nil&#123; panic(err) &#125; defer resp.Body.Close() if resp.StatusCode != http.StatusOK&#123; fmt.Println(\"Error: status code\",resp.StatusCode) &#125; e:= determineEncoding(resp.Body) utf8reader:= transform.NewReader(resp.Body,e.NewDecoder()) all,err:= ioutil.ReadAll(utf8reader) if err!=nil&#123; panic(err) &#125; fmt.Printf(\"%s\\n\",all)&#125;func determineEncoding(r io.Reader) encoding.Encoding&#123; bytes,err := bufio.NewReader(r).Peek(1024) if err !=nil&#123; panic(err) &#125; e,_,_:= charset.DetermineEncoding(bytes,\"\") return e&#125; http服务器1 访问localhost：8000，打印出URL.Path = “/” 1234567891011121314151617package mainimport ( \"fmt\" \"log\" \"net/http\")func main() &#123; http.HandleFunc(\"/\", handler) // each request calls handler log.Fatal(http.ListenAndServe(\"localhost:8000\", nil))&#125;// handler echoes the Path component of the requested URL.func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"URL.Path = %q\\n\", r.URL.Path)&#125; http服务器2 计数： 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"log\" \"net/http\" \"sync\")var mu sync.Mutexvar count intfunc main() &#123; http.HandleFunc(\"/\", handler) http.HandleFunc(\"/count\", counter) log.Fatal(http.ListenAndServe(\"localhost:8000\", nil))&#125;// handler echoes the Path component of the requested URL.func handler(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() count++ mu.Unlock() fmt.Fprintf(w, \"URL.Path = %q\\n\", r.URL.Path)&#125;// counter echoes the number of calls so far.func counter(w http.ResponseWriter, r *http.Request) &#123; mu.Lock() fmt.Fprintf(w, \"Count %d\\n\", count) mu.Unlock()&#125; http服务器2 1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\" \"log\" \"net/http\")func main() &#123; http.HandleFunc(\"/\", handler) log.Fatal(http.ListenAndServe(\"localhost:8000\", nil))&#125;//!+handler// handler echoes the HTTP request.func handler(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, \"%s %s %s\\n\", r.Method, r.URL, r.Proto) for k, v := range r.Header &#123; fmt.Fprintf(w, \"Header[%q] = %q\\n\", k, v) &#125; fmt.Fprintf(w, \"Host = %q\\n\", r.Host) fmt.Fprintf(w, \"RemoteAddr = %q\\n\", r.RemoteAddr) if err := r.ParseForm(); err != nil &#123; log.Print(err) &#125; for k, v := range r.Form &#123; fmt.Fprintf(w, \"Form[%q] = %q\\n\", k, v) &#125;&#125; 输出： 1234567891011GET &#x2F; HTTP&#x2F;1.1Header[&quot;Connection&quot;] &#x3D; [&quot;keep-alive&quot;]Header[&quot;Upgrade-Insecure-Requests&quot;] &#x3D; [&quot;1&quot;]Header[&quot;User-Agent&quot;] &#x3D; [&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;71.0.3578.98 Safari&#x2F;537.36&quot;]Header[&quot;Accept-Encoding&quot;] &#x3D; [&quot;gzip, deflate, br&quot;]Header[&quot;Cookie&quot;] &#x3D; [&quot;_ga&#x3D;GA1.1.809627859.1535126425; io&#x3D;nukCk_cXUcwmTK_-AAAC&quot;]Header[&quot;Cache-Control&quot;] &#x3D; [&quot;max-age&#x3D;0&quot;]Header[&quot;Accept&quot;] &#x3D; [&quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8&quot;]Header[&quot;Accept-Language&quot;] &#x3D; [&quot;zh-CN,zh;q&#x3D;0.9&quot;]Host &#x3D; &quot;localhost:8000&quot;RemoteAddr &#x3D; &quot;127.0.0.1:56512&quot; http文件服务器 12345678910111213141516171819202122232425262728/* File Server */package mainimport ( \"fmt\" \"net/http\" \"os\")func main() &#123; // deliver files from the directory /var/www //fileServer := http.FileServer(http.Dir(\"/var/www\")) fileServer := http.FileServer(http.Dir(\"/Users/jackson/\")) // register the handler and deliver requests to it err := http.ListenAndServe(\":8000\", fileServer) checkError(err) // That's it!&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[15]-tls","slug":"go-network-15-tls","date":"2019-01-19T09:44:23.000Z","updated":"2019-02-04T08:39:09.378Z","comments":true,"path":"2019/01/19/go-network-15-tls/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-15-tls/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* TLSEchoServer */package mainimport ( \"crypto/rand\" \"crypto/tls\" \"fmt\" \"net\" \"os\" \"time\")func main() &#123; cert, err := tls.LoadX509KeyPair(\"jan.newmarch.name.pem\", \"private.pem\") checkError(err) config := tls.Config&#123;Certificates: []tls.Certificate&#123;cert&#125;&#125; now := time.Now() config.Time = func() time.Time &#123; return now &#125; config.Rand = rand.Reader service := \"0.0.0.0:1200\" listener, err := tls.Listen(\"tcp\", service, &amp;config) checkError(err) fmt.Println(\"Listening\") for &#123; conn, err := listener.Accept() if err != nil &#123; fmt.Println(err.Error()) continue &#125; fmt.Println(\"Accepted\") go handleClient(conn) &#125;&#125;func handleClient(conn net.Conn) &#123; defer conn.Close() var buf [512]byte for &#123; fmt.Println(\"Trying to read\") n, err := conn.Read(buf[0:]) if err != nil &#123; fmt.Println(err) &#125; _, err2 := conn.Write(buf[0:n]) if err2 != nil &#123; return &#125; &#125;&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839/* TLSEchoClient */package mainimport ( \"fmt\" \"os\" \"crypto/tls\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Println(\"Usage: \", os.Args[0], \"host:port\") os.Exit(1) &#125; service := os.Args[1] conn, err := tls.Dial(\"tcp\", service, nil) checkError(err) for n := 0; n &lt; 10; n++ &#123; fmt.Println(\"Writing...\") conn.Write([]byte(\"Hello \" + string(n+48))) var buf [512]byte n, err := conn.Read(buf[0:]) checkError(err) fmt.Println(string(buf[0:n])) &#125; os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[14]-x509","slug":"go-network-13-x509","date":"2019-01-19T09:26:19.000Z","updated":"2019-02-04T08:39:03.782Z","comments":true,"path":"2019/01/19/go-network-13-x509/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-13-x509/","excerpt":"","text":"PKI是Public Key Infrastructure的首字母缩写，翻译过来就是公钥基础设施；PKI是一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。 目前使用的主要PKI基于X.509证书。例如，Web浏览器使用它们来验证网站的身份。 为网站生成自签名X.509证书并将其存储在.cer文件中的示例程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* GenX509Cert */package mainimport ( \"crypto/rand\" \"crypto/rsa\" \"crypto/x509\" \"crypto/x509/pkix\" \"encoding/gob\" \"encoding/pem\" \"fmt\" \"math/big\" \"os\" \"time\")func main() &#123; random := rand.Reader var key rsa.PrivateKey loadKey(\"private.key\", &amp;key) now := time.Now() then := now.Add(60 * 60 * 24 * 365 * 1000 * 1000 * 1000) // one year template := x509.Certificate&#123; SerialNumber: big.NewInt(1), Subject: pkix.Name&#123; CommonName: \"jan.newmarch.name\", Organization: []string&#123;\"Jan Newmarch\"&#125;, &#125;, // NotBefore: time.Unix(now, 0).UTC(), // NotAfter: time.Unix(now+60*60*24*365, 0).UTC(), NotBefore: now, NotAfter: then, SubjectKeyId: []byte&#123;1, 2, 3, 4&#125;, KeyUsage: x509.KeyUsageCertSign | x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature, BasicConstraintsValid: true, IsCA: true, DNSNames: []string&#123;\"jan.newmarch.name\", \"localhost\"&#125;, &#125; derBytes, err := x509.CreateCertificate(random, &amp;template, &amp;template, &amp;key.PublicKey, &amp;key) checkError(err) certCerFile, err := os.Create(\"jan.newmarch.name.cer\") checkError(err) certCerFile.Write(derBytes) certCerFile.Close() certPEMFile, err := os.Create(\"jan.newmarch.name.pem\") checkError(err) pem.Encode(certPEMFile, &amp;pem.Block&#123;Type: \"CERTIFICATE\", Bytes: derBytes&#125;) certPEMFile.Close() keyPEMFile, err := os.Create(\"private.pem\") checkError(err) pem.Encode(keyPEMFile, &amp;pem.Block&#123;Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(&amp;key)&#125;) keyPEMFile.Close()&#125;func loadKey(fileName string, key interface&#123;&#125;) &#123; inFile, err := os.Open(fileName) checkError(err) decoder := gob.NewDecoder(inFile) err = decoder.Decode(key) checkError(err) inFile.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; 读取： 1234567891011121314151617181920212223242526272829303132333435/* ReadX509Cert */package mainimport ( \"crypto/x509\" \"fmt\" \"os\")func main() &#123; certCerFile, err := os.Open(\"jan.newmarch.name.cer\") checkError(err) derBytes := make([]byte, 1000) // bigger than the file count, err := certCerFile.Read(derBytes) checkError(err) certCerFile.Close() // trim the bytes to actual length in call cert, err := x509.ParseCertificate(derBytes[0:count]) checkError(err) fmt.Printf(\"Name %s\\n\", cert.Subject.CommonName) fmt.Printf(\"Not before %s\\n\", cert.NotBefore.String()) fmt.Printf(\"Not after %s\\n\", cert.NotAfter.String())&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[13]-rsa","slug":"go-network-13-rsa","date":"2019-01-19T09:20:41.000Z","updated":"2019-02-04T08:38:58.886Z","comments":true,"path":"2019/01/19/go-network-13-rsa/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-13-rsa/","excerpt":"","text":"rsa公钥加密 产生公钥私钥并存入文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* GenRSAKeys */package mainimport ( \"crypto/rand\" \"crypto/rsa\" \"crypto/x509\" \"encoding/gob\" \"encoding/pem\" \"fmt\" \"os\")func main() &#123; reader := rand.Reader bitSize := 512 key, err := rsa.GenerateKey(reader, bitSize) checkError(err) fmt.Println(\"Private key primes\", key.Primes[0].String(), key.Primes[1].String()) fmt.Println(\"Private key exponent\", key.D.String()) publicKey := key.PublicKey fmt.Println(\"Public key modulus\", publicKey.N.String()) fmt.Println(\"Public key exponent\", publicKey.E) saveGobKey(\"private.key\", key) saveGobKey(\"public.key\", publicKey) savePEMKey(\"private.pem\", key)&#125;func saveGobKey(fileName string, key interface&#123;&#125;) &#123; outFile, err := os.Create(fileName) checkError(err) encoder := gob.NewEncoder(outFile) err = encoder.Encode(key) checkError(err) outFile.Close()&#125;func savePEMKey(fileName string, key *rsa.PrivateKey) &#123; outFile, err := os.Create(fileName) checkError(err) var privateKey = &amp;pem.Block&#123;Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(key)&#125; pem.Encode(outFile, privateKey) outFile.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; 反向读取 123456789101112131415161718192021222324252627282930313233343536373839404142/* LoadRSAKeys */package mainimport ( \"crypto/rsa\" \"encoding/gob\" \"fmt\" \"os\")func main() &#123; var key rsa.PrivateKey loadKey(\"private.key\", &amp;key) fmt.Println(\"Private key primes\", key.Primes[0].String(), key.Primes[1].String()) fmt.Println(\"Private key exponent\", key.D.String()) var publicKey rsa.PublicKey loadKey(\"public.key\", &amp;publicKey) fmt.Println(\"Public key modulus\", publicKey.N.String()) fmt.Println(\"Public key exponent\", publicKey.E)&#125;func loadKey(fileName string, key interface&#123;&#125;) &#123; inFile, err := os.Open(fileName) checkError(err) decoder := gob.NewDecoder(inFile) err = decoder.Decode(key) checkError(err) inFile.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[12]-ascii","slug":"go-network-12-ascii","date":"2019-01-19T08:49:07.000Z","updated":"2019-02-04T08:38:53.924Z","comments":true,"path":"2019/01/19/go-network-12-ascii/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-12-ascii/","excerpt":"","text":"ASCII码表 使用7位进行编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Oct Dec Hex Char Oct Dec Hex Char------------------------------------------------------------000 0 00 NUL &#39;\\0&#39; 100 64 40 @001 1 01 SOH 101 65 41 A002 2 02 STX 102 66 42 B003 3 03 ETX 103 67 43 C004 4 04 EOT 104 68 44 D005 5 05 ENQ 105 69 45 E006 6 06 ACK 106 70 46 F007 7 07 BEL &#39;\\a&#39; 107 71 47 G010 8 08 BS &#39;\\b&#39; 110 72 48 H011 9 09 HT &#39;\\t&#39; 111 73 49 I012 10 0A LF &#39;\\n&#39; 112 74 4A J013 11 0B VT &#39;\\v&#39; 113 75 4B K014 12 0C FF &#39;\\f&#39; 114 76 4C L015 13 0D CR &#39;\\r&#39; 115 77 4D M016 14 0E SO 116 78 4E N017 15 0F SI 117 79 4F O020 16 10 DLE 120 80 50 P021 17 11 DC1 121 81 51 Q022 18 12 DC2 122 82 52 R023 19 13 DC3 123 83 53 S024 20 14 DC4 124 84 54 T025 21 15 NAK 125 85 55 U026 22 16 SYN 126 86 56 V027 23 17 ETB 127 87 57 W030 24 18 CAN 130 88 58 X031 25 19 EM 131 89 59 Y032 26 1A SUB 132 90 5A Z033 27 1B ESC 133 91 5B [034 28 1C FS 134 92 5C \\ &#39;\\\\&#39;035 29 1D GS 135 93 5D ]036 30 1E RS 136 94 5E ^037 31 1F US 137 95 5F _040 32 20 SPACE 140 96 60 &#96;041 33 21 ! 141 97 61 a042 34 22 &quot; 142 98 62 b043 35 23 # 143 99 63 c044 36 24 $ 144 100 64 d045 37 25 % 145 101 65 e046 38 26 &amp; 146 102 66 f047 39 27 &#39; 147 103 67 g050 40 28 ( 150 104 68 h051 41 29 ) 151 105 69 i052 42 2A * 152 106 6A j053 43 2B + 153 107 6B k054 44 2C , 154 108 6C l055 45 2D - 155 109 6D m056 46 2E . 156 110 6E n057 47 2F &#x2F; 157 111 6F o060 48 30 0 160 112 70 p061 49 31 1 161 113 71 q062 50 32 2 162 114 72 r063 51 33 3 163 115 73 s064 52 34 4 164 116 74 t065 53 35 5 165 117 75 u066 54 36 6 166 118 76 v067 55 37 7 167 119 77 w070 56 38 8 170 120 78 x071 57 39 9 171 121 79 y072 58 3A : 172 122 7A z073 59 3B ; 173 123 7B &#123;074 60 3C &lt; 174 124 7C |075 61 3D &#x3D; 175 125 7D &#125;076 62 3E &gt; 176 126 7E ~077 63 3F ? 177 127 7F DEL ISO 8859 八位字节现在是字节的标准大小。这允许128个额外的代码点用于ASCII的扩展。ISO 8859系列是许多不同的代码集，用于捕获各种欧洲语言子集的所有组成部分。ISO 8859-1也被称为Latin-1，涵盖了西欧的许多语言，而本系列中的其他语言涵盖欧洲其他地区，甚至包括希伯来语，阿拉伯语和泰语。例如，ISO 8859-5包括俄罗斯等国家的西里尔字符，而ISO 8859-8包括希伯来字母。 这些字符集的标准编码是将其代码点用作8位值。例如，ISO 8859-1中的字符“Á”具有代码点193并编码为193.所有ISO 8859系列都具有与ASCII相同的底部128个值，因此ASCII字符在所有中都是相同的这些集。 用于推荐ISO 8859-1字符集的HTML规范。HTML 3.2是最后一个这样做的，之后HTML 4.0推荐使用Unicode。在2010年，谷歌估计其所看到的页面，大约20％仍然是ISO 8859格式，而20％仍然是ASCII（Unicode接近50％的网络）。 ASCII和ISO 8859都不包括基于象形文字的语言。据估计，中国有大约20,000个单独的字符，大约有5,000个常用字符。这些需要多一个字节，通常使用两个字节。这些双字节字符集有很多：Big5，EUC-TW，GB2312和GBK / GBX用于中文，JIS X 0208用于日语，等等。这些编码通常不是相互兼容的。 Unicode是一个包含标准的字符集，旨在涵盖所有正在使用的主要字符集。它包括欧洲，亚洲，印度等等。它现在是5.2版本，有超过107,000个字符。 前256个代码点对应于ISO 8859-1，US ASCII作为前128个。因此，这些主要字符集向后兼容，因为ISO 8859-1和ASCII的代码点在Unicode中完全相同。 要在计算机系统中表示Unicode字符，必须使用编码。编码UCS是使用Unicode字符的代码点值的双字节编码。但是，由于Unicode中现在有太多字符使它们全部适合2个字节，因此该编码已过时且不再使用。相反，有： UTF-32是一个4字节编码，但不常用，HTML 5明确警告不要使用它 UTF-16将最常见的字符编码为2个字节，另外2个字节用于“溢出”，ASCII和ISO 8859-1具有通常的值 UTF-8每个字符使用1到4个字节，ASCII具有通常的值（但不是ISO 8859-1） 有时使用UTF-7，但不常见 UTF-8是最常用的编码。谷歌估计它看到的50％的页面都是用UTF-8编码的。ASCII集具有相同的UTF-8编码值，因此UTF-8阅读器可以读取仅包含ASCII字符的文本以及完整Unicode集中的文本。 Go在其字符串中使用UTF-8编码的字符。每个角色都是类型rune。这是一个别名，int32因为Unicode字符可以是UTF-8编码中的1,2或4个字节。就字符而言，字符串是runes 的数组。 字符串也是一个字节数组，但您必须要小心：只有ASCII子集是一个等于字符的字节。所有其他字符占用两个，三个或四个字节。这意味着以字符（符文）表示的字符串长度通常与其字节数组的长度不同。仅当字符串仅由ASCII字符组成时，它们才相等。 以下程序片段说明了这一点。如果我们使用UTF-8字符串并测试其长度，则获得基础字节数组的长度。但是如果你将字符串转换为符文数组，[]rune那么你得到一个Unicode代码点数组，通常是字符数： 123str :&#x3D; &quot;百度一下，你就知道&quot;println(&quot;String length&quot;, len([]rune(str)))println(&quot;Byte length&quot;, len(str)) 输出： 12String length 9Byte length 27","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[11]-gob","slug":"go-network-11-gob","date":"2019-01-19T07:11:53.000Z","updated":"2019-02-04T08:38:48.801Z","comments":true,"path":"2019/01/19/go-network-11-gob/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-11-gob/","excerpt":"","text":"Gob是Go特有的序列化技术。它专门用于编码Go数据类型，目前不支持或由任何其他语言支持。它支持除通道和函数之外的所有Go数据类型。它支持所有类型和大小的整数，字符串和布尔值，结构，数组和切片。目前它在圆形结构（如环）方面存在一些问题，但随着时间的推移会有所改善。 Gob将类型信息编码为其序列化形式。这比X.509序列化中的类型信息要广泛得多，但远比XML文档中包含的类型信息更有效。 gob到文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* SaveGob */package mainimport ( \"fmt\" \"os\" \"encoding/gob\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func main() &#123; person := Person&#123; Name: Name&#123;Family: \"Newmarch\", Personal: \"Jan\"&#125;, Email: []Email&#123;Email&#123;Kind: \"home\", Address: \"jan@newmarch.name\"&#125;, Email&#123;Kind: \"work\", Address: \"j.newmarch@boxhill.edu.au\"&#125;&#125;&#125; saveGob(\"person.gob\", person)&#125;func saveGob(fileName string, key interface&#123;&#125;) &#123; outFile, err := os.Create(fileName) checkError(err) encoder := gob.NewEncoder(outFile) err = encoder.Encode(key) checkError(err) outFile.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; 文件加载到内存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* LoadGob */package mainimport ( \"fmt\" \"os\" \"encoding/gob\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func (p Person) String() string &#123; s := p.Name.Personal + \" \" + p.Name.Family for _, v := range p.Email &#123; s += \"\\n\" + v.Kind + \": \" + v.Address &#125; return s&#125;func main() &#123; var person Person loadGob(\"person.gob\", &amp;person) fmt.Println(\"Person\", person.String())&#125;func loadGob(fileName string, key interface&#123;&#125;) &#123; inFile, err := os.Open(fileName) checkError(err) decoder := gob.NewDecoder(inFile) err = decoder.Decode(key) checkError(err) inFile.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; gob服务器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* Gob EchoServer */package mainimport ( \"fmt\" \"net\" \"os\" \"encoding/gob\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func (p Person) String() string &#123; s := p.Name.Personal + \" \" + p.Name.Family for _, v := range p.Email &#123; s += \"\\n\" + v.Kind + \": \" + v.Address &#125; return s&#125;func main() &#123; service := \"0.0.0.0:1200\" tcpAddr, err := net.ResolveTCPAddr(\"tcp\", service) checkError(err) listener, err := net.ListenTCP(\"tcp\", tcpAddr) checkError(err) for &#123; conn, err := listener.Accept() if err != nil &#123; continue &#125; encoder := gob.NewEncoder(conn) decoder := gob.NewDecoder(conn) for n := 0; n &lt; 10; n++ &#123; var person Person decoder.Decode(&amp;person) fmt.Println(person.String()) encoder.Encode(person) &#125; conn.Close() // we're finished &#125;&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; gob客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* Gob EchoClient */package mainimport ( \"fmt\" \"net\" \"os\" \"encoding/gob\" \"bytes\" \"io\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func (p Person) String() string &#123; s := p.Name.Personal + \" \" + p.Name.Family for _, v := range p.Email &#123; s += \"\\n\" + v.Kind + \": \" + v.Address &#125; return s&#125;func main() &#123; person := Person&#123; Name: Name&#123;Family: \"Newmarch\", Personal: \"Jan\"&#125;, Email: []Email&#123;Email&#123;Kind: \"home\", Address: \"jan@newmarch.name\"&#125;, Email&#123;Kind: \"work\", Address: \"j.newmarch@boxhill.edu.au\"&#125;&#125;&#125; if len(os.Args) != 2 &#123; fmt.Println(\"Usage: \", os.Args[0], \"host:port\") os.Exit(1) &#125; service := os.Args[1] conn, err := net.Dial(\"tcp\", service) checkError(err) encoder := gob.NewEncoder(conn) decoder := gob.NewDecoder(conn) for n := 0; n &lt; 10; n++ &#123; encoder.Encode(person) var newPerson Person decoder.Decode(&amp;newPerson) fmt.Println(newPerson.String()) &#125; os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[10]-json","slug":"go-network-10-json","date":"2019-01-19T06:35:23.000Z","updated":"2019-03-04T15:50:52.666Z","comments":true,"path":"2019/01/19/go-network-10-json/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-10-json/","excerpt":"","text":"JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。XML、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。 Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的encoding/json、encoding/xml、encoding/asn1等包提供支持（译注：Protocol Buffers的支持由github.com/golang/ protobuf 包提供），并且这类包都有着相似的API接口。本节，我们将对重要的encoding/json包的用法做个概述。 JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。它可以用有效可读的方式表示第三章的基础数据类型和本章的数组、slice、结构体和map等聚合数据类型。 基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是\\Uhhhh转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。 这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成以系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如： boolean true number -273.15 string “She said “Hello, BF”” array [“gold”, “silver”, “bronze”] object {“year”: 1980, “event”: “archery”, “medals”: [“gold”, “silver”, “bronze”]} 考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。（在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用。） type Movie struct { Title string Year int json:&quot;released&quot; Color bool json:&quot;color,omitempty&quot; Actors []string } var movies = []Movie{ {Title: “Casablanca”, Year: 1942, Color: false, Actors: []string{“Humphrey Bogart”, “Ingrid Bergman”}}, {Title: “Cool Hand Luke”, Year: 1967, Color: true, Actors: []string{“Paul Newman”}}, {Title: “Bullitt”, Year: 1968, Color: true, Actors: []string{“Steve McQueen”, “Jacqueline Bisset”}}, // … } 这样的数据结构特别适合JSON格式，并且在两种之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成： data, err := json.Marshal(movies) if err != nil { log.Fatalf(“JSON marshaling failed: %s”, err) } fmt.Printf(&quot;%s\\n&quot;, data) Marshal函数返还一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示： [{“Title”:“Casablanca”,“released”:1942,“Actors”:[“Humphrey Bogart”,“Ingr id Bergman”]},{“Title”:“Cool Hand Luke”,“released”:1967,“color”:true,“Ac tors”:[“Paul Newman”]},{“Title”:“Bullitt”,“released”:1968,“color”:true,&quot; Actors&quot;:[“Steve McQueen”,“Jacqueline Bisset”]}] 这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进： data, err := json.MarshalIndent(movies, “”, &quot; “) if err != nil { log.Fatalf(“JSON marshaling failed: %s”, err) } fmt.Printf(”%s\\n&quot;, data) 上面的代码将产生这样的输出（译注：在最后一个成员或元素后面并没有逗号分隔符）： [ { “Title”: “Casablanca”, “released”: 1942, “Actors”: [ “Humphrey Bogart”, “Ingrid Bergman” ] }, { “Title”: “Cool Hand Luke”, “released”: 1967, “color”: true, “Actors”: [ “Paul Newman” ] }, { “Title”: “Bullitt”, “released”: 1968, “color”: true, “Actors”: [ “Steve McQueen”, “Jacqueline Bisset” ] } ] 在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。 细心的读者可能已经注意到，其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为构体成员Tag所导致的。一个构体成员Tag是和在编译阶段关联到该成员的元信息字符串： Year int json:&quot;released&quot; Color bool json:&quot;color,omitempty&quot; 结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:&quot;value&quot;键值对序列；因为值中含义双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的TotalCount成员对应到JSON中的total_count对象。Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象（这里false为零值）。果然，Casablanca是一个黑白电影，并没有输出Color成员。 编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息值填充，其它JSON成员将被忽略。 var titles []struct{ Title string } if err := json.Unmarshal(data, &amp;titles); err != nil { log.Fatalf(“JSON unmarshaling failed: %s”, err) } fmt.Println(titles) // “[{Casablanca} {Cool Hand Luke} {Bullitt}]” 许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。首先，我们要定义合适的类型和常量： 123456789101112131415161718192021222324252627&#x2F;&#x2F; Package github provides a Go API for the GitHub issue tracker.&#x2F;&#x2F; See https:&#x2F;&#x2F;developer.github.com&#x2F;v3&#x2F;search&#x2F;#search-issues.package githubimport &quot;time&quot;const IssuesURL &#x3D; &quot;https:&#x2F;&#x2F;api.github.com&#x2F;search&#x2F;issues&quot;type IssuesSearchResult struct &#123; TotalCount int &#96;json:&quot;total_count&quot;&#96; Items []*Issue&#125;type Issue struct &#123; Number int HTMLURL string &#96;json:&quot;html_url&quot;&#96; Title string State string User *User CreatedAt time.Time &#96;json:&quot;created_at&quot;&#96; Body string &#x2F;&#x2F; in Markdown format&#125;type User struct &#123; Login string HTMLURL string &#96;json:&quot;html_url&quot;&#96;&#125; 和前面一样，卽使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大小字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，GitHub服务返回的信息比我们定义的要多很多。 SearchIssues函数发出一个HTTP请求，然后解码返回的JSON格式的结果。因为用户提供的查询条件可能包含类似?和&amp;之类的特殊字符，为了避免对URL造成冲突，我们用url.QueryEscape来对查询中的特殊字符进行转义操作。 123456789101112131415161718192021222324252627282930313233package githubimport ( &quot;encoding&#x2F;json&quot; &quot;fmt&quot; &quot;net&#x2F;http&quot; &quot;net&#x2F;url&quot; &quot;strings&quot;)&#x2F;&#x2F; SearchIssues queries the GitHub issue tracker.func SearchIssues(terms []string) (*IssuesSearchResult, error) &#123; q :&#x3D; url.QueryEscape(strings.Join(terms, &quot; &quot;)) resp, err :&#x3D; http.Get(IssuesURL + &quot;?q&#x3D;&quot; + q) if err !&#x3D; nil &#123; return nil, err &#125; &#x2F;&#x2F; We must close resp.Body on all execution paths. &#x2F;&#x2F; (Chapter 5 presents &#39;defer&#39;, which makes this simpler.) if resp.StatusCode !&#x3D; http.StatusOK &#123; resp.Body.Close() return nil, fmt.Errorf(&quot;search query failed: %s&quot;, resp.Status) &#125; var result IssuesSearchResult if err :&#x3D; json.NewDecoder(resp.Body).Decode(&amp;result); err !&#x3D; nil &#123; resp.Body.Close() return nil, err &#125; resp.Body.Close() return &amp;result, nil&#125; 在早些的例子中，我们使用了json.Unmarshal函数来将JSON格式的字符串解码为字节slice。但是这个例子中，我们使用了基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据，尽管这不是必须的。如您所料，还有一个针对输出流的json.Encoder编码对象。 我们调用Decode方法来填充变量。这里有多种方法可以格式化结构。下面是最简单的一种，以一个固定宽度打印每个issue，但是在下一节我们将看到如果利用模板来输出复杂的格式。 1234567891011121314151617181920212223&#x2F;&#x2F; Issues prints a table of GitHub issues matching the search terms.package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;os&quot; &quot;gopl.io&#x2F;ch4&#x2F;github&quot;)func main() &#123; result, err :&#x3D; github.SearchIssues(os.Args[1:]) if err !&#x3D; nil &#123; log.Fatal(err) &#125; fmt.Printf(&quot;%d issues:\\n&quot;, result.TotalCount) for _, item :&#x3D; range result.Items &#123; fmt.Printf(&quot;#%-5d %9.9s %.55s\\n&quot;, item.Number, item.User.Login, item.Title) &#125;&#125; 通过命令行参数指定检索条件。下面的命令是查询Go语言项目中和JSON解码相关的问题，还有查询返回的结果： $ go build gopl.io/ch4/issues $ ./issues repo:golang/go is:open json decoder 13 issues: #5680 eaigner encoding/json: set key converter on en/decoder #6050 gopherbot encoding/json: provide tokenizer #8658 gopherbot encoding/json: use bufio #8462 kortschak encoding/json: UnmarshalText confuses json.Unmarshal #5901 rsc encoding/json: allow override type marshaling #9812 klauspost encoding/json: string tag not symmetric #7872 extempora encoding/json: Encoder internally buffers full output #9650 cespare encoding/json: Decoding gives errPhase when unmarshalin #6716 gopherbot encoding/json: include field name in unmarshal error me #6901 lukescott encoding/json, encoding/xml: option to treat unknown fi #6384 joeshaw encoding/json: encode precise floating point integers u #6647 btracey x/tools/cmd/godoc: display type kind of each named type #4237 gjemiller encoding/base64: URLEncoding padding is optional 对象存储到json文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* SaveJSON */package mainimport ( \"encoding/json\" \"fmt\" \"os\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func main() &#123; person := Person&#123; Name: Name&#123;Family: \"Newmarch\", Personal: \"Jan\"&#125;, Email: []Email&#123;Email&#123;Kind: \"home\", Address: \"jan@newmarch.name\"&#125;, Email&#123;Kind: \"work\", Address: \"j.newmarch@boxhill.edu.au\"&#125;&#125;&#125; saveJSON(\"person.json\", person)&#125;func saveJSON(fileName string, key interface&#123;&#125;) &#123; outFile, err := os.Create(fileName) checkError(err) encoder := json.NewEncoder(outFile) err = encoder.Encode(key) checkError(err) outFile.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; 解码json文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* LoadJSON */package mainimport ( \"encoding/json\" \"fmt\" \"os\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func (p Person) String() string &#123; s := p.Name.Personal + \" \" + p.Name.Family for _, v := range p.Email &#123; s += \"\\n\" + v.Kind + \": \" + v.Address &#125; return s&#125;func main() &#123; var person Person loadJSON(\"person.json\", &amp;person) fmt.Println(\"Person\", person.String())&#125;func loadJSON(fileName string, key interface&#123;&#125;) &#123; inFile, err := os.Open(fileName) checkError(err) decoder := json.NewDecoder(inFile) err = decoder.Decode(key) checkError(err) inFile.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; json客户端 客户端写入数据，服务器读取数据。 服务器写入数据，客户端读取数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* JSON EchoClient */package mainimport ( \"fmt\" \"net\" \"os\" \"encoding/json\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func (p Person) String() string &#123; s := p.Name.Personal + \" \" + p.Name.Family for _, v := range p.Email &#123; s += \"\\n\" + v.Kind + \": \" + v.Address &#125; return s&#125;func main() &#123; person := Person&#123; Name: Name&#123;Family: \"Newmarch\", Personal: \"Jan\"&#125;, Email: []Email&#123;Email&#123;Kind: \"home\", Address: \"jan@newmarch.name\"&#125;, Email&#123;Kind: \"work\", Address: \"j.newmarch@boxhill.edu.au\"&#125;&#125;&#125; if len(os.Args) != 2 &#123; fmt.Println(\"Usage: \", os.Args[0], \"host:port\") os.Exit(1) &#125; service := os.Args[1] conn, err := net.Dial(\"tcp\", service) checkError(err) encoder := json.NewEncoder(conn) decoder := json.NewDecoder(conn) for n := 0; n &lt; 10; n++ &#123; encoder.Encode(person) var newPerson Person decoder.Decode(&amp;newPerson) fmt.Println(newPerson.String()) &#125; os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; 服务器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* JSON EchoServer */package mainimport ( \"fmt\" \"net\" \"os\" \"encoding/json\")type Person struct &#123; Name Name Email []Email&#125;type Name struct &#123; Family string Personal string&#125;type Email struct &#123; Kind string Address string&#125;func (p Person) String() string &#123; s := p.Name.Personal + \" \" + p.Name.Family for _, v := range p.Email &#123; s += \"\\n\" + v.Kind + \": \" + v.Address &#125; return s&#125;func main() &#123; service := \"0.0.0.0:1200\" tcpAddr, err := net.ResolveTCPAddr(\"tcp\", service) checkError(err) listener, err := net.ListenTCP(\"tcp\", tcpAddr) checkError(err) for &#123; conn, err := listener.Accept() if err != nil &#123; continue &#125; encoder := json.NewEncoder(conn) decoder := json.NewDecoder(conn) for n := 0; n &lt; 10; n++ &#123; var person Person decoder.Decode(&amp;person) fmt.Println(person.String()) encoder.Encode(person) &#125; conn.Close() // we're finished &#125;&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Println(\"Fatal error \", err.Error()) os.Exit(1) &#125;&#125; 参考：go语言编码json 123456789101112131415161718192021From the Go JSON package specification, marshalling uses the following type-dependent default encodings:Boolean values encode as JSON booleans.Floating point and integer values encode as JSON numbers.String values encode as JSON strings, with each invalid UTF-8 sequence replaced by the encoding of the Unicode replacement character U+FFFD.Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string.Struct values encode as JSON objects. Each struct field becomes a member of the object. By default the object&#39;s key name is the struct field name converted to lower case. If the struct field has a tag, that tag will be used as the name instead.Map values encode as JSON objects. The map&#39;s key type must be string; the object keys are used directly as map keys.Pointer values encode as the value pointed to. (Note: this allows trees, but not graphs!). A nil pointer encodes as the null JSON object.Interface values encode as the value contained in the interface. A nil interface value encodes as the null JSON object.Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value cause Marshal to return an InvalidTypeError.JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package mainimport \"encoding/json\"import \"fmt\"import \"os\"// 我们将用这两个结构体来说明编码和解码type Response1 struct &#123; Page int Fruits []string&#125;type Response2 struct &#123; Page int `json:\"page\"` Fruits []string `json:\"fruits\"`&#125;func main() &#123; // 首先来看看基本类型 bolB, _ := json.Marshal(true) fmt.Println(string(bolB)) intB, _ := json.Marshal(1) fmt.Println(string(intB)) fltB, _ := json.Marshal(2.34) fmt.Println(string(fltB)) strB, _ := json.Marshal(\"gopher\") fmt.Println(string(strB)) // 切片和map集合 slcD := []string&#123;\"apple\", \"peach\", \"pear\"&#125; slcB, _ := json.Marshal(slcD) fmt.Println(string(slcB)) mapD := map[string]int&#123;\"apple\": 5, \"lettuce\": 7&#125; mapB, _ := json.Marshal(mapD) fmt.Println(string(mapB)) // 自定义结构 res1D := &amp;Response1&#123; Page: 1, Fruits: []string&#123;\"apple\", \"peach\", \"pear\"&#125;&#125; res1B, _ := json.Marshal(res1D) fmt.Println(string(res1B)) // 我们可以用标识来明确某一个json元素的 res2D := &amp;Response2&#123; Page: 1, Fruits: []string&#123;\"apple\", \"peach\", \"pear\"&#125;&#125; res2B, _ := json.Marshal(res2D) fmt.Println(string(res2B)) // 编码json数据 byt := []byte(`&#123;\"num\":6.13,\"strs\":[\"a\",\"b\"]&#125;`)//我们需要定义一个变量来存储数据，map[string]interface&#123;&#125;将map中的数据 // `map[string]interface&#123;&#125;` 将字符串映射到任意数据类型 var dat map[string]interface&#123;&#125; // 解码, 和相关错误的检查。 if err := json.Unmarshal(byt, &amp;dat); err != nil &#123; panic(err) &#125; fmt.Println(dat) // 我们需要把它们转换成合适的类型。例如，在这里，我们将值放在float64型变量中。 num := dat[\"num\"].(float64) fmt.Println(num)// 访问嵌套数据需要一系列的强制转换。 strs := dat[\"strs\"].([]interface&#123;&#125;) str1 := strs[0].(string) fmt.Println(str1)//我们也可以将JSON解码为自定义数据类型，这有助于在程序中添加额外的类型安全性，并且在访问解码数据时消除类型断言的需要 str := `&#123;\"page\": 1, \"fruits\": [\"apple\", \"peach\"]&#125;` res := Response2&#123;&#125; json.Unmarshal([]byte(str), &amp;res) fmt.Println(res) fmt.Println(res.Fruits[0]) enc := json.NewEncoder(os.Stdout) d := map[string]int&#123;\"apple\": 5, \"lettuce\": 7&#125; enc.Encode(d)&#125;执行上面代码，将得到以下输出结果 -true12.34\"gopher\"[\"apple\",\"peach\",\"pear\"]&#123;\"apple\":5,\"lettuce\":7&#125;&#123;\"Page\":1,\"Fruits\":[\"apple\",\"peach\",\"pear\"]&#125;&#123;\"page\":1,\"fruits\":[\"apple\",\"peach\",\"pear\"]&#125;map[num:6.13 strs:[a b]]6.13a&#123;1 [apple peach]&#125;apple&#123;\"apple\":5,\"lettuce\":7&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[9]-asn.1","slug":"go-network-9-asn-1","date":"2019-01-19T04:12:24.000Z","updated":"2019-02-04T08:38:37.814Z","comments":true,"path":"2019/01/19/go-network-9-asn-1/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-9-asn-1/","excerpt":"","text":"Abstract Syntax Notation One（ASN.1）最初是在1984年为电信行业设计的。 ASN.1是一个复杂的标准，Go在包“asn1”中支持它的一个子集。 它从复杂的数据结构构建自描述的序列化数据。 它在当前网络系统中的主要用途是作为在认证系统中大量使用的X.509证书的编码。 Go中的支持基于读取和写入X.509证书所需的内容。 两个函数允许我们编码和解码数据: 12func Marshal(val interface&#123;&#125;) ([]byte, os.Error)func Unmarshal(val interface&#123;&#125;, b []byte) (rest []byte, err os.Error) asn.1编码与解码整数 12345678910111213141516171819202122232425262728/* ASN.1 */package mainimport ( \"encoding/asn1\" \"fmt\" \"os\")func main() &#123; mdata, err := asn1.Marshal(13) checkError(err) var n int _, err1 := asn1.Unmarshal(mdata, &amp;n) checkError(err1) fmt.Println(\"After marshal/unmarshal: \", n)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 为了管理更复杂的数据类型，我们必须更仔细地研究ASN.1支持的数据结构，以及如何在Go中完成ASN.1支持。 任何序列化方法都能够处理某些数据类型而不处理其他数据类型。 因此，为了确定任何序列化（如ASN.1）的适用性，您必须查看支持的可能数据类型与您希望在应用程序中使用的数据类型。 以下ASN.1类型取自http://www.obj-sys.com/asn1tutorial/node4.html 简单的类型是: 123456789101112131415161718192021222324252627s :&#x3D; &quot;hello&quot;mdata, _ :&#x3D; asn1.Marshal(s)var newstr stringasn1.Unmarshal(mdata, &amp;newstr)t :&#x3D; time.LocalTime()mdata, err :&#x3D; asn1.Marshal(t)var newtime &#x3D; new(time.Time)_, err1 :&#x3D; asn1.Unmarshal(&amp;newtime, mdata)&#x2F;&#x2F; using variablesvar t1 Tt1 &#x3D; ...mdata1, _ :&#x3D; asn1.Marshal(t)var newT1 Tasn1.Unmarshal(&amp;newT1, mdata1)&#x2F;&#x2F;&#x2F; using pointersvar t2 &#x3D; new(T)*t2 &#x3D; ...mdata2, _ :&#x3D; asn1.Marshal(*t2)var newT2 &#x3D; new(T)asn1.Unmarshal(newT2, mdata2) asn.1 服务器-客户端例子 服务器： 1234567891011121314151617181920212223242526272829303132333435363738394041/* ASN1 DaytimeServer */package mainimport ( \"encoding/asn1\" \"fmt\" \"net\" \"os\" \"time\")func main() &#123; service := \":1200\" tcpAddr, err := net.ResolveTCPAddr(\"tcp\", service) checkError(err) listener, err := net.ListenTCP(\"tcp\", tcpAddr) checkError(err) for &#123; conn, err := listener.Accept() if err != nil &#123; continue &#125; daytime := time.Now() // Ignore return network errors. mdata, _ := asn1.Marshal(daytime) conn.Write(mdata) conn.Close() // we're finished &#125;&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* ASN.1 DaytimeClient */package mainimport ( \"encoding/asn1\" \"fmt\" \"io/ioutil\" \"net\" \"os\" \"time\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s host:port\", os.Args[0]) os.Exit(1) &#125; service := os.Args[1] conn, err := net.Dial(\"tcp\", service) checkError(err) defer conn.Close() result, err := ioutil.ReadAll(conn) checkError(err) var newtime time.Time _, err1 := asn1.Unmarshal(result, &amp;newtime) checkError(err1) fmt.Println(\"After marshal/unmarshal: \", newtime.String()) os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 测试： 123456服务器：$ go build .jacksondeMacBook-Pro:net jackson$ .&#x2F;net客户端：$ .&#x2F;client 127.0.0.1:1200After marshal&#x2F;unmarshal: 2019-01-19 12:32:47 +0800 CST","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[8]-conn","slug":"go-network-8-conn","date":"2019-01-19T03:43:05.000Z","updated":"2019-02-04T08:38:32.903Z","comments":true,"path":"2019/01/19/go-network-8-conn/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-8-conn/","excerpt":"","text":"到目前为止，我们已经区分了TCP的API和UDP的API，例如使用DialTCP和DialUDP分别返回TCPConn和UDPConn。 Conn类型是一个接口，TCPConn和UDPConn都实现了这个接口。 在很大程度上，您可以处理此接口而不是两种类型。 您可以使用dail函数，而不是TCP和UDP的单独功能 1func Dial(net, laddr, raddr string) (c Conn, err os.Error) 网络可以是“tcp”，“tcp4”（仅限IPv4），“tcp6”（仅限IPv6），“udp”，“udp4”（仅限IPv4），“udp6”（仅限IPv6）， “ip”，“ip4”（仅限IPv4）和“ip6”仅限IPv6。 它将返回Conn接口的适当实现。 请注意，此函数采用字符串而不是地址作为raddr参数，因此使用此函数的程序可以避免首先生成地址类型。 之前写好的客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* GetHeadInfo */package mainimport ( \"net\" \"os\" \"fmt\" \"io/ioutil\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s host:port \", os.Args[0]) os.Exit(1) &#125; service := os.Args[1] // 生成TCPAddr tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) checkError(err) // 创建网络连接 conn, err := net.DialTCP(\"tcp\", nil, tcpAddr) checkError(err) // 写数据 _, err = conn.Write([]byte(\"HEAD / HTTP/1.0\\r\\n\\r\\n\")) checkError(err) // 读数据 result, err := ioutil.ReadAll(conn) checkError(err) fmt.Println(string(result)) os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 修改为： 123456789101112131415161718192021222324252627282930313233343536373839404142/* IPGetHeadInfo */package mainimport ( \"bytes\" \"fmt\" \"io\" \"io/ioutil\" \"net\" \"os\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s host:port\", os.Args[0]) os.Exit(1) &#125; service := os.Args[1] conn, err := net.Dial(\"tcp\", service) checkError(err) defer conn.Close() _, err = conn.Write([]byte(\"HEAD / HTTP/1.0\\r\\n\\r\\n\")) checkError(err) result, err := ioutil.ReadAll(conn) checkError(err) fmt.Println(string(result)) os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 对于服务器也有两个新的方法： 12func Listen(net, laddr string) (l Listener, err os.Error)func (l Listener) Accept() (c Conn, err os.Error) 之前的服务器例子可以修改为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* ThreadedIPEchoServer */package mainimport ( \"fmt\" \"net\" \"os\")func main() &#123; service := \":1200\" listener, err := net.Listen(\"tcp\", service) checkError(err) for &#123; conn, err := listener.Accept() if err != nil &#123; continue &#125; go handleClient(conn) &#125;&#125;func handleClient(conn net.Conn) &#123; defer conn.Close() var buf [512]byte for &#123; n, err := conn.Read(buf[0:]) if err != nil &#123; return &#125; _, err2 := conn.Write(buf[0:n]) if err2 != nil &#123; return &#125; &#125;&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 如果你想编写UDP服务器，那么有一个接口PacketConn和一个返回此实现的方法： 1func ListenPacket(net, laddr string) (c PacketConn, err os.Error) 此接口具有主要方法ReadFrom和WriteTo来处理数据包读取和写入。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[7]-udp","slug":"go-network-7-udp","date":"2019-01-18T16:32:20.000Z","updated":"2019-02-04T08:38:26.659Z","comments":true,"path":"2019/01/19/go-network-7-udp/","link":"","permalink":"https://dreamerjonson.com/2019/01/19/go-network-7-udp/","excerpt":"","text":"UDP客户端和服务器使用数据包含来源以及目的地信息。客户端或服务器不会维护维护消息的状态。 无法保证消息能够到达，也无法保证按照顺序到达。 udp常见方法： 12345func ResolveUDPAddr(net, addr string) (*UDPAddr, os.Error)func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err os.Error)func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err os.Error)func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Errorfunc (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error) udp客户端和tcp类似： udp 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041/* UDPDaytimeClient */package mainimport ( \"net\" \"os\" \"fmt\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s host:port\", os.Args[0]) os.Exit(1) &#125; service := os.Args[1] udpAddr, err := net.ResolveUDPAddr(\"udp4\", service) checkError(err) conn, err := net.DialUDP(\"udp\", nil, udpAddr) checkError(err) _, err = conn.Write([]byte(\"anything\")) checkError(err) var buf [512]byte n, err := conn.Read(buf[0:]) checkError(err) fmt.Println(string(buf[0:n])) os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error %s\", err.Error()) os.Exit(1) &#125;&#125; udp服务器与tcp有较大不同： udp 服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* UDPDaytimeServer */package mainimport ( \"fmt\" \"net\" \"os\" \"time\")func main() &#123; service := \":1200\" udpAddr, err := net.ResolveUDPAddr(\"udp4\", service) checkError(err) conn, err := net.ListenUDP(\"udp\", udpAddr) checkError(err) for &#123; handleClient(conn) &#125;&#125;func handleClient(conn *net.UDPConn) &#123; var buf [512]byte _, addr, err := conn.ReadFromUDP(buf[0:]) if err != nil &#123; return &#125; daytime := time.Now().String() conn.WriteToUDP([]byte(daytime), addr) conn.Close()&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error %s\", err.Error()) os.Exit(1) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[6]-TCPConn","slug":"go-network-6-TCPConn","date":"2019-01-18T14:51:52.000Z","updated":"2019-02-04T08:38:21.326Z","comments":true,"path":"2019/01/18/go-network-6-TCPConn/","link":"","permalink":"https://dreamerjonson.com/2019/01/18/go-network-6-TCPConn/","excerpt":"","text":"TCPConn 客户端与服务器通信必备类型通信 两个主要的方法是： 12func (c *TCPConn) Write(b []byte) (n int, err os.Error)func (c *TCPConn) Read(b []byte) (n int, err os.Error) 客户端和服务器都使用TCPConn来读取和写入消息。 通常，客户端使用TCPConn将请求写入服务器，并从TCPConn读取响应。这一直持续到任一侧（或两侧）关闭连接。客户端使用下面函数建立TCP连接： 1func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error) 其中laddr是本地地址，通常设置为nil。raddr是服务器的远程地址，net是“tcp4”，“tcp6”或“tcp”之一，具体取决于您是否仅仅TCPv4连接， TCPv6连接还是两者皆可。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[5]-tcpaddr","slug":"go-network-5-tcpaddr","date":"2019-01-18T14:46:12.000Z","updated":"2019-02-04T08:38:16.420Z","comments":true,"path":"2019/01/18/go-network-5-tcpaddr/","link":"","permalink":"https://dreamerjonson.com/2019/01/18/go-network-5-tcpaddr/","excerpt":"","text":"TCPAddr type TCPAddr struct { IP IP Port int } ResolveTCPAddr函数用于创建TCPAddr 1func ResolveTCPAddr(net, addr string) (*TCPAddr, os.Error) 其中参数net是“tcp”，“tcp4”或“tcp6”之一，addr是由主机名或IP地址组成的字符串，后跟“：”后面的端口号，例如“www.google.com:80“或”127.0.0.1:22“。 12345678func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error)func (c *TCPConn) SetTimeout(nsec int64) os.Error即使客户端无需发送任何内容，客户端也可能希望保持与服务器的连接。它可以使用:func (c *TCPConn) SetKeepAlive(keepalive bool) os.Errorfunc (c *TCPConn) Write(b []byte) (n int, err os.Error)func (c *TCPConn) Read(b []byte) (n int, err os.Error) 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* GetHeadInfo */package mainimport ( \"net\" \"os\" \"fmt\" \"io/ioutil\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s host:port \", os.Args[0]) os.Exit(1) &#125; service := os.Args[1] // 生成TCPAddr tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) checkError(err) // 创建网络连接 conn, err := net.DialTCP(\"tcp\", nil, tcpAddr) checkError(err) // 写数据 _, err = conn.Write([]byte(\"HEAD / HTTP/1.0\\r\\n\\r\\n\")) checkError(err) // 读数据 result, err := ioutil.ReadAll(conn) checkError(err) fmt.Println(string(result)) os.Exit(0)&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 测试 1234567$ .&#x2F;net www.baidu.com:80HTTP&#x2F;1.0 302 FoundContent-Length: 17931Content-Type: text&#x2F;htmlDate: Fri, 18 Jan 2019 15:33:50 GMTEtag: &quot;54d9748e-460b&quot;Server: bfe&#x2F;1.0.8.18 服务器 12func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err os.Error)func (l *TCPListener) Accept() (c Conn, err os.Error) ListenTCP为服务器监听端口，Accept代表锁住，等待客户端连接 1234567891011121314151617181920212223242526272829303132333435363738/* DaytimeServer */package mainimport ( \"fmt\" \"net\" \"os\" \"time\")func main() &#123; service := \":1200\" tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) checkError(err) listener, err := net.ListenTCP(\"tcp\", tcpAddr) checkError(err) for &#123; conn, err := listener.Accept() if err != nil &#123; continue &#125; daytime := time.Now().String() conn.Write([]byte(daytime)) // don't care about return value conn.Close() // we're finished with this client &#125;&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125; 多线程服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* ThreadedEchoServer */package mainimport ( \"net\" \"os\" \"fmt\")func main() &#123; service := \":1201\" tcpAddr, err := net.ResolveTCPAddr(\"tcp4\", service) checkError(err) listener, err := net.ListenTCP(\"tcp\", tcpAddr) checkError(err) for &#123; conn, err := listener.Accept() if err != nil &#123; continue &#125; // run as a goroutine go handleClient(conn) &#125;&#125;func handleClient(conn net.Conn) &#123; // close connection on exit defer conn.Close() var buf [512]byte for &#123; // read upto 512 bytes n, err := conn.Read(buf[0:]) if err != nil &#123; return &#125; // write the n bytes read _, err2 := conn.Write(buf[0:n]) if err2 != nil &#123; return &#125; &#125;&#125;func checkError(err error) &#123; if err != nil &#123; fmt.Fprintf(os.Stderr, \"Fatal error: %s\", err.Error()) os.Exit(1) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[4]-port","slug":"go-network-4-port","date":"2019-01-18T14:31:06.000Z","updated":"2019-02-04T08:38:11.498Z","comments":true,"path":"2019/01/18/go-network-4-port/","link":"","permalink":"https://dreamerjonson.com/2019/01/18/go-network-4-port/","excerpt":"","text":"端口port 服务器运行在主机上。 IP地址将定位主机。但是在每台计算机上可能有很多服务，需要一种简单的方法来区分它们。 TCP，UDP，SCTP等使用的方法是使用端口号。 有许多“标准”端口。 Telnet通常使用端口23，TCP协议。 DNS使用端口53，使用TCP或UDP。 FTP使用端口21和20，一个用于命令，另一个用于数据传输。 HTTP通常使用端口80，但它通常使用端口8000,8080和8088，所有端口都使用TCP。 在Unix系统上，常用端口列在文件/etc/services中。 Go具有查询此文件的功能 1func LookupPort(network, service string) (port int, err os.Error) 123456789101112131415161718192021222324252627282930/* LookupPort */package mainimport ( \"net\" \"os\" \"fmt\")func main() &#123; if len(os.Args) != 3 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s network-type service\\n\", os.Args[0]) os.Exit(1) &#125; networkType := os.Args[1] service := os.Args[2] port, err := net.LookupPort(networkType, service) if err != nil &#123; fmt.Println(\"Error: \", err.Error()) os.Exit(2) &#125; fmt.Println(\"Service port \", port) os.Exit(0)&#125; 测试 12$ .&#x2F;net tcp telnetService port 23","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[3]-IPAddr","slug":"go-network-3-IPAddr","date":"2019-01-18T11:01:34.000Z","updated":"2019-02-04T08:38:07.092Z","comments":true,"path":"2019/01/18/go-network-3-IPAddr/","link":"","permalink":"https://dreamerjonson.com/2019/01/18/go-network-3-IPAddr/","excerpt":"","text":"IPAddr type IPAddr { IP IP } 此类型的主要用途是对IP主机名执行DNS查找。 1func ResolveIPAddr(net, addr string) (*IPAddr, os.Error) 123456789101112131415161718192021222324252627/* ResolveIP */package mainimport ( \"net\" \"os\" \"fmt\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s hostname\\n\", os.Args[0]) fmt.Println(\"Usage: \", os.Args[0], \"hostname\") os.Exit(1) &#125; name := os.Args[1] addr, err := net.ResolveIPAddr(\"ip\", name) if err != nil &#123; fmt.Println(\"Resolution error\", err.Error()) os.Exit(1) &#125; fmt.Println(\"Resolved address is \", addr.String()) os.Exit(0)&#125; 测试 12$ .&#x2F;net www.baidu.comResolved address is 14.215.177.39 ResolveIPAddr函数将对主机名执行DNS查找，并返回单个IP地址。 但是，主机可能有多个IP地址，通常来自多个网卡。它们也可能有多个主机名，充当别名。 1func LookupHost(name string) (addrs []string, err os.Error) 其中一个地址将被标记为“规范(canonical)”主机名。如果您希望找到规范名称，请使用 1func LookupCNAME(name string) (cname string, err os.Error) 1234567891011121314151617181920212223242526272829/* LookupHost */package mainimport ( \"net\" \"os\" \"fmt\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s hostname\\n\", os.Args[0]) os.Exit(1) &#125; name := os.Args[1] addrs, err := net.LookupHost(name) if err != nil &#123; fmt.Println(\"Error: \", err.Error()) os.Exit(2) &#125; for _, s := range addrs &#123; fmt.Println(s) &#125; os.Exit(0)&#125; 测试2 1234$ go build .jacksondeMacBook-Pro:net jackson$ .&#x2F;net www.baidu.com14.215.177.3814.215.177.39","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[2]-ipmask","slug":"go-network-2-ipmask","date":"2019-01-18T10:47:28.000Z","updated":"2019-02-04T08:38:02.361Z","comments":true,"path":"2019/01/18/go-network-2-ipmask/","link":"","permalink":"https://dreamerjonson.com/2019/01/18/go-network-2-ipmask/","excerpt":"","text":"IPMask ipmask存储掩码，掩码是指定ip地址中前多少位是网络地址的。 type IPMask []byte 123456789101112131415161718192021222324252627282930313233/* Mask */package mainimport ( \"fmt\" \"net\" \"os\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s dotted-ip-addr\\n\", os.Args[0]) os.Exit(1) &#125; dotAddr := os.Args[1] addr := net.ParseIP(dotAddr) if addr == nil &#123; fmt.Println(\"Invalid address\") os.Exit(1) &#125; mask := addr.DefaultMask() network := addr.Mask(mask) ones, bits := mask.Size() fmt.Println(\"Address is \", addr.String(), \" Default mask length is \", bits, \"Leading ones count is \", ones, \"Mask is (hex) \", mask.String(), \" Network is \", network.String()) os.Exit(0)&#125; 测试 123$ go build .$ .&#x2F;net 127.0.0.1Address is 127.0.0.1 Default mask length is 32 Leading ones count is 8 Mask is (hex) ff000000 Network is 127.0.0.0","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境-网络[1]-ipaddress","slug":"go-network-1-ipaddress","date":"2019-01-18T10:42:24.000Z","updated":"2019-02-04T08:37:52.825Z","comments":true,"path":"2019/01/18/go-network-1-ipaddress/","link":"","permalink":"https://dreamerjonson.com/2019/01/18/go-network-1-ipaddress/","excerpt":"","text":"net包中的ip类型存储ip地址 type IP []byte 1234567891011121314151617181920212223242526/* IP */package mainimport ( \"net\" \"os\" \"fmt\")func main() &#123; if len(os.Args) != 2 &#123; fmt.Fprintf(os.Stderr, \"Usage: %s ip-addr\\n\", os.Args[0]) os.Exit(1) &#125; name := os.Args[1] addr := net.ParseIP(name) if addr == nil &#123; fmt.Println(\"Invalid address\") &#125; else &#123; fmt.Println(\"The address is \", addr.String()) &#125; os.Exit(0)&#125; 测试： 123$ go build .$ .&#x2F;net 127.0.0.1The address is 127.0.0.1","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"jquery","slug":"jquery","date":"2019-01-18T08:19:13.000Z","updated":"2019-01-29T10:49:42.017Z","comments":true,"path":"2019/01/18/jquery/","link":"","permalink":"https://dreamerjonson.com/2019/01/18/jquery/","excerpt":"","text":"导入包 1、Download jQuery and link to it locally: 2、Link to a CDN(a hosted copy) api文档：http://api.jquery.com/ 修改css 1234567891011121314151617$(selector).css(property, value)//select elem with id \"special\" and give it a border$(\"#special\").css(\"border\", \"2px solid red\");//we can also pass in an object with stylesvar styles = &#123;backgroundColor : \"pink\",fontWeight: \"bold\"&#125;;$(\"#special\").css(styles);//select all li's and make them yellow$(\"li\").css(\"color\", \"yellow\");//select all elements with class \"big\"//and give them an orange border$(\".big\").css(\"border\", \"1px dashed orange\"); 方法 获取文本与修改文本： text：http://api.jquery.com/text/ html:http://api.jquery.com/html/ 获取input选择框的值。 val()😒(“input”).val():http://api.jquery.com/val/ 获取修改属性： attr(): $( “#greatphoto” ).attr( “title”, “Photo by Kelly Clark” );http://api.jquery.com/attr/ addClass() removeClass() toggleClass() 事件 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jQuery Events&lt;&#x2F;title&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;jquery&#x2F;2.1.4&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;jQuery Events&lt;&#x2F;h1&gt;&lt;h1&gt;jQuery Events&lt;&#x2F;h1&gt;&lt;h1&gt;jQuery Events&lt;&#x2F;h1&gt;&lt;input type&#x3D;&quot;text&quot;&gt;&lt;button&gt;Don&#39;t Click Me&lt;&#x2F;button&gt;&lt;button&gt;Sersiouly Don&#39;t Click Me&lt;&#x2F;button&gt;&lt;button&gt;This is your last warning!&lt;&#x2F;button&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 12345678910111213141516171819202122232425$(&#39;#submit&#39;).click(function()&#123; console.log(&quot;aaa&quot;)&#125;)$(&#39;button&#39;).click(function()&#123; alert(&quot;bbb&quot;)&#125;)$(&quot;button&quot;).click(function()&#123; var text &#x3D; $(this).text();console.log(&quot;you clicks &quot;+ text) &#125;) &#x2F;&#x2F;键盘按下事件，打印事件对象信息。 $(&quot;input&quot;).keypress(function(event)&#123; console.log(event);&#125;);$(&quot;input&quot;).keypress(function(event)&#123; &#x2F;&#x2F;判断鼠标按下 if(event.which &#x3D;&#x3D;&#x3D;13)&#123; alert(&quot;you hit enter!&quot;); &#125;&#125;); 鼠标按下事件代码： https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes","categories":[{"name":"js","slug":"js","permalink":"https://dreamerjonson.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://dreamerjonson.com/tags/js/"}]},{"title":"比特币历史上最大的一次黑客袭击事件","slug":"bitocin-attact","date":"2019-01-12T13:42:04.000Z","updated":"2019-01-12T13:43:11.952Z","comments":true,"path":"2019/01/12/bitocin-attact/","link":"","permalink":"https://dreamerjonson.com/2019/01/12/bitocin-attact/","excerpt":"","text":"参考资料： https://hackernoon.com/bitcoins-biggest-hack-in-history-184-4-ded46310d4ef https://en.bitcoinwiki.org/wiki/Value_overflow_incident","categories":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}]},{"title":"javascript","slug":"javascript","date":"2019-01-11T03:28:33.000Z","updated":"2019-01-16T14:56:09.911Z","comments":true,"path":"2019/01/11/javascript/","link":"","permalink":"https://dreamerjonson.com/2019/01/11/javascript/","excerpt":"","text":"基本类型 12345678910111213141516171819202122&#x2F;&#x2F;Numbers49.3-10&#x2F;&#x2F;Strings&quot;Hello World&quot;&quot;43&quot;&#x2F;&#x2F;Booleanstruefalse&#x2F;&#x2F;null and undefinednullundefinedtypeof 查看变量的数据类型。使用格式： typeof 变量名 number基本运算： 123456789101112131415//Numbers49.3-10//We can do some math4 + 10 //141/5 //0.2//Modulo - remainder operator10 % 3 //124 % 2 //015 % 11 //4 字符串基本运算： 1234567891011121314151617//Single or Double quotes OK\"hello world\"'hello world'//Concatenation\"charlie\" + \"brown\" //\"charliebrown\"//Escape Characters start with \"\\\"\"Singin \\\"Do wah diddy, diddy, dum diddy do\\\" \"\"This is a backslash: \\\\\"//Strings have a length property\"hello world\".length //11//Access individual characters using [] and an index\"hello\"[0] //\"h\"\"hello\"[4] //\"o\" 变量 12345678910111213141516171819202122232425262728变量 格式：var 变量名 &#x3D; 数据; 声明变量要注意的事项：1.在javascript中声明变量是 使用var关键字声明的，javascript中的变量可以存储任意的数据类型数据.2.javascript中变量数据类型是根据存储的值决定的，可以随时更改存储数据的类型。3.定义了多个同名的变量是，后定义的同名变量是覆盖前面定义的同名变量。4.声明变量的时候可以省略var关键字，但是不建议省略。&#x2F;&#x2F;Variables are simply containers that store values&#x2F;&#x2F;They follow this pattern:var yourVariableName &#x3D; yourValue;&#x2F;&#x2F;They can store all of the values we&#39;ve seenvar name &#x3D; &quot;Rusty&quot;;var secretNumber &#x3D; 73;var isAdorable &#x3D; true;&#x2F;&#x2F;Recall the stored value by calling the variable namevar name &#x3D; &quot;Rusty&quot;;&quot;hello there &quot; + name &#x2F;&#x2F;&quot;hello there Rusty&quot;var num &#x3D; 37;num + 3 + 10 &#x2F;&#x2F;50&#x2F;&#x2F;We can also update existing variablesvar name &#x3D; &quot;Robert&quot;;name &#x3D; &quot;Bob&quot;; null &amp; undefined 1234567891011&#x2F;&#x2F;The two other primitives are null and undefined&#x2F;&#x2F;Variables that are declared but not&#x2F;&#x2F;initialized are undefined&#x2F;&#x2F;The following variables are undefined:var name;var age;&#x2F;&#x2F;null is &quot;explicitly nothing&quot;var currentPlayer &#x3D; &quot;charlie&quot;;currentPlayer &#x3D; null; &#x2F;&#x2F;game over 常用输出语句 1234alert() &#x2F;&#x2F;弹出警告框console.log() &#x2F;&#x2F;只在控制台输出prompt &#x2F;&#x2F;弹出输入框案例见下 js代码分离 index.html: 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Script Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Including JS Files&lt;/h1&gt;&lt;script src=\"script.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; script.js: 123var userName = prompt(\"What is your name?\");alert(\"Nice to meet you, \" + userName);console.log(\"Also great to meet you, \" + userName); 布尔逻辑 Operator Name Example ​Result &gt; Greater than x &gt; 10 FALSE &gt;= Greater than or equal to x &gt;= 5 TRUE &lt; Less than x &lt; -50 FALSE &lt;= Less than or equal to x &lt;= 100 TRUE == Equal to x == “5” TRUE != Not equal to x != “b” TRUE === Equal value and type x === “5” FALSE !== Not equal value or equal type x !== “5” TRUE 双等号与三等号比较特殊，双等号会转换类型让两者匹配再比较大小，而三个等号会比较类型。 123456789101112131415161718192021var x = 99;x == \"99\" //truex === \"99\" //falsevar y = null;y == undefined //truey === undefined //falsetrue == \"1\" //true0 == false //truenull == undefined //trueNaN == NaN //false Operator Name Example ​Result &amp;&amp; AND x &lt; 10 &amp;&amp; x !== 5 false || OR y &gt; 9 || x === 5 true ! NOT !(x === y) true 练习1： 1234var x &#x3D; 10;var y &#x3D; &quot;a&quot;y &#x3D;&#x3D;&#x3D; &quot;b&quot; || x &gt;&#x3D; 10 练习2： 1234var x &#x3D; 3;var y &#x3D; 8;!(x &#x3D;&#x3D; &quot;3&quot; || x &#x3D;&#x3D;&#x3D; y) &amp;&amp; !(y !&#x3D; 8 &amp;&amp; x &lt;&#x3D; y) 练习3： 1234567891011!&quot;Hello World&quot;!&quot;&quot;!null!0!-1!NaN if if 判断语句的语法： if (condition) statement1 else if statement2 else statement3 如果条件计算结果为 true，则执行 statement1；如果条件计算结果为 false，则执行 statement2。 注意判断的条件会发生自动类型转换： number：如果非0为true，0为false string：如果非null或非空为true，否则为false undefined：false NaN: false 对象类型：非null为true，否则为false。 案例猜数字游戏： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Guessing Game&lt;/title&gt;&lt;script type=\"text/javascript\"&gt; //create secretNumber var secretNumber = 4; //ask user for guess var stringGuess = prompt(\"Guess a number\"); var guess = Number(stringGuess); //check if guess is right if(guess === secretNumber) &#123; alert(\"YOU GOT IT RIGHT!\"); &#125; //check if guess is higher else if(guess &gt; secretNumber)&#123; alert(\"Too high. Guess again!\"); &#125; else &#123; alert(\"Too low. Guess again!\"); &#125; //otherwise, check if lower&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; case 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051case选择语句： switch语句 switch(变量)&#123; case 值1: break; case 值2： break; case 值3: break; ..... default： break; &#125; 特殊之处： 在javascript中case后面可以跟常量与变量还可以跟表达式。 案例一： function test6() &#123; var color = \"xx\"; var value1 = \"red\", value2 = \"green\"; switch(color) &#123; case value1: alert(\"红色\"); break; case value2: alert(\"绿色\"); break; default: alert(\"执行默认default\"); &#125;&#125;这里，switch 语句用于字符串 Color，声明 case 使用的是变量 BLUE、RED 和 GREEN，这在 ECMAScript 中是完全有效的。案例二：var num = 20;switch(true) &#123; case num &gt;= 0 &amp;&amp; num &lt;= 10: alert(\"大于0小于等于10\"); break; case num&gt;10 &amp;&amp; num&lt;=20: alert(\"大于10小于等于20\"); break;&#125; 循环语句 while while循环语句： 格式： while(判断的条件){ 循环体内容 } while(count&lt;5){ document.write(“hello world”); count++; } do-while循环语句 do{ 循环语句； }while(判断条件); 需求；计算1~100奇数的总和。 var num = 1; var result = 0; do{ if(num%2!=0){ result +=num; } num++; }while(num&lt;=100); document.write(&quot;结果：&quot;+result); for循环语句: 格式： for(初始化语句; 判断的条件 ; 循环后的语句){ 循环体语句； } 需求；计算1~100偶数的总和。 var result = 0 ; for(var i = 1 ; i&lt;=100 ; i++){ if(i%2==0){ result +=i; } } document.write(“结果：”+result); 测试 1234567891011121314151617181920212223242526272829303132333435363738console.log(\"PRINTING ALL NUMBERS BETWEEN -10 AND 19\");for(var i = -10; i &lt; 20; i++)&#123; console.log(i)&#125;console.log(\"PRINTING ALL EVEN BETWEEN 10 AND 40\");// for(var i = 11; i &lt;= 40; i += 2)&#123;// console.log(i);// &#125;for(var i = 10; i &lt;= 40; i += 1)&#123; if(i % 2 === 0) &#123; console.log(i); &#125;&#125;console.log(\"PRINTING ALL ODD NUMBERS BETWEEN 300 AND 333\");for(var i = 300; i &lt;= 333; i++) &#123; if(i % 2 !== 0) &#123; console.log(i); &#125;&#125;console.log(\"PRINTING ALL NUMBERS DIVISIBLE BY 5 AND 3 BETWEEN 5 AND 50\");for(var i = 5; i &lt;= 50; i++)&#123; if(i % 5 === 0 &amp;&amp; i % 3 === 0) &#123; console.log(i); &#125;&#125; 函数function 函数的定义格式： function 函数名(形参列表){ 函数体 ; } javascript的函数要注意的细节： 1. 在 javascript中函数 定义形参时是不能使用var关键字声明变量 的。 2. 在javascript中 的函数是没有返回值类型 的，如果函数需要返回数据给调用者，直接return返回即可，如果不需要返回则不返回。 3. 在 javascript中是没有函数 重载 的概念 的，后定义的同名函数会直接覆盖前面定义同名函数。 4. 在javascript中任何的函数内部都隐式的维护了一个arguments（数组）的对象，给函数 传递数据的时候，是会先传递到arguments对象中， 然后再由arguments对象分配数据给形参的。 5.函数本身就是一个对象，此对象的名字就是函数名 需求：定义一个函数做两个参数的加法功能。 12345678910111213function add(a,b)&#123; var sum &#x3D; a+b; return sum;&#125;function add()&#123; for(var index &#x3D; 0 ; index&lt;arguments.length ; index++)&#123; console.log(arguments[index]+&quot;,&quot;); &#125;&#125;&#x2F;&#x2F;调用函数add(11,21,13,14); 函数本身就是一个对象，此对象的名字就是函数名 12345function show (a) &#123; &#x2F;&#x2F; body...&#125;var p &#x3D; show;alert(p);&#x2F;&#x2F;此语句将会把函数的所有内容都打印出来 动态函数 动态函数的特点时new一个Function对象，往对象中可以传入变量，函数体，以及输出语句。 123var show &#x3D; new Function(&quot;x&quot;,&quot;y&quot;,&quot;var sum &#x3D; x + y;return sum;&quot;);var p &#x3D; show(1,5);alert(p); 匿名函数,通常在定义事件属性的行为时较为常用。 12var show &#x3D; function()&#123;alert(&quot;哈哈&quot;)&#125;;&#x2F;&#x2F;此为常见了一个匿名函数，并为其取了一个名字show。show(); 数组 初始化数组： 123456789101112131415161718192021222324var friends &#x3D; [&quot;Charlie&quot;, &quot;Liz&quot;, &quot;David&quot;, &quot;Mattias&quot;];&#x2F;&#x2F;初始化一个空的数组var friends &#x3D; []; &#x2F;&#x2F;no friends :(var friends &#x3D; new Array() &#x2F;&#x2F;uncommon&#x2F;&#x2F;Arrays can hold any type of datavar random_collection &#x3D; [49, true, &quot;Hermione&quot;, null];Arrays let us group data together in listsArray are indexed starting at 0. Every slot has a corresponding numberWe can use those indices to retrieve datavar friends &#x3D; [&quot;Charlie&quot;, &quot;Liz&quot;, &quot;David&quot;, &quot;Mattias&quot;];console.log(friends[0]) &#x2F;&#x2F;&quot;Charlie&quot;friends[1] + &quot; &lt;3 &quot; + friends[2] &#x2F;&#x2F;&quot;Liz &lt;3 David&quot;Arrays have a length property:var nums &#x3D; [45,37,89,24];nums.length &#x2F;&#x2F;4 更新数组： 1234567var friends &#x3D; [&quot;Charlie&quot;, &quot;Liz&quot;, &quot;David&quot;, &quot;Mattias&quot;];friends[0] &#x3D; &quot;Chuck&quot;;friends[1] &#x3D; &quot;Lizzie&quot;;&#x2F;&#x2F;增加新元素var friends &#x3D; [&quot;Charlie&quot;, &quot;Liz&quot;, &quot;David&quot;, &quot;Mattias&quot;];friends[4] &#x3D; &quot;Amelie&quot;; 数组方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var colors &#x3D; [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;];colors.push(&quot;green&quot;);&#x2F;&#x2F;[&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;]var colors &#x3D; [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;];colors.pop();&#x2F;&#x2F;[&quot;red&quot;, &quot;orange&quot;]&#x2F;&#x2F;pop() returns the removed elementvar col &#x3D; colors.pop(); &#x2F;&#x2F;orangevar colors &#x3D; [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;];colors.unshift(&quot;infrared&quot;)&#x2F;&#x2F;[&quot;infrared&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;]var colors &#x3D; [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;];colors.shift();&#x2F;&#x2F;[&quot;orange&quot;, &quot;yellow&quot;]&#x2F;&#x2F;shift() also returns the removed elementvar col &#x3D; colors.shift(); &#x2F;&#x2F;orangevar friends &#x3D; [&quot;Charlie&quot;, &quot;Liz&quot;, &quot;David&quot;, &quot;Mattias&quot;, &quot;Liz&quot;];&#x2F;&#x2F;returns the first index at which a given element can be foundfriends.indexOf(&quot;David&quot;); &#x2F;&#x2F;2friends.indexOf(&quot;Liz&quot;); &#x2F;&#x2F;1, not 4&#x2F;&#x2F;returns -1 if the element is not present.friends.indexOf(&quot;Hagrid&quot;); &#x2F;&#x2F;-1var fruits &#x3D; [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Lemon&#39;, &#39;Apple&#39;, &#39;Mango&#39;];&#x2F;&#x2F;use slice to copy the 2nd and 3d fruits&#x2F;&#x2F;specify index where the new array starts(1) and ends(3)var citrus &#x3D; fruits.slice(1, 3);&#x2F;&#x2F;this does not alter the original fruits array&#x2F;&#x2F;citrus contains [&#39;Orange&#39;,&#39;Lemon&#39;]&#x2F;&#x2F;fruits contains [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Lemon&#39;, &#39;Apple&#39;, &#39;Mango&#39;];&#x2F;&#x2F;you can also use slice() to copy an entire arrayvar nums &#x3D; [1,2,3];var otherNums &#x3D; nums.slice();&#x2F;&#x2F;both arrays are [1,2,3]var fruits &#x3D; [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Lemon&#39;, &#39;Apple&#39;, &#39;Mango&#39;];&#x2F;&#x2F;use splice to remove &#39;Orange&#39; from the array&#x2F;&#x2F;specify index of the element to be removed and&#x2F;&#x2F;how many elements should be removed from that indexfruits.splice(1, 1);&#x2F;&#x2F; returns: [&quot;Orange&quot;]console.log(fruits);&#x2F;&#x2F; prints: [&quot;Banana&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;] 数组循环： 12345678910111213//with a for loopvar colors = [\"red\", \"orange\", \"yellow\", \"green\"];for(var i = 0; i &lt; colors.length; i++) &#123; console.log(colors[i]);&#125;//using forEachvar colors = [\"red\", \"orange\",\"yellow\", \"green\"];colors.forEach(function(color)&#123; console.log(color);&#125;); 案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Todo List&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var todos = [\"Buy New Turtle\"];var input = prompt(\"What would you like to do?\");while(input !== \"quit\")&#123; //handle input if(input === \"list\") &#123; printList(); &#125; else if(input === \"new\") &#123; addTodo(); &#125; else if(input === \"delete\") &#123; deleteTodo(); &#125; //ask again for new input input = prompt(\"What would you like to do?\");&#125;console.log(\"OK, YOU QUIT THE APP\");function printList() &#123; console.log(\"**********\"); todos.forEach(function(todo, index)&#123; console.log(index + \": \" + todo); &#125;); console.log(\"**********\");&#125;function addTodo()&#123; //ask for new todo var newTodo = prompt(\"Enter new todo\"); //add to todos array todos.push(newTodo); console.log(newTodo + \" added to list\")&#125;function deleteTodo()&#123; var index = prompt(\"Enter index of todo to delete\"); todos.splice(index, 1); console.log(\"Todo Removed\")&#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Todo List&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;\"new\" - Add A Todo&lt;/li&gt; &lt;li&gt;\"list\" - List All Todos&lt;/li&gt; &lt;li&gt;\"delete\" - Remove Specific Todo&lt;/li&gt; &lt;li&gt;\"quit\" - Quit App&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 案例2：构建自己的foreach 123456789101112131415161718192021222324252627// =========// VERSION 1// =========function myForEach(arr, func)&#123; for (var i = 0; i &lt; arr.length; i++) &#123; func(arr[i]); &#125;&#125;var colors = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"PURPLE\"];myForEach(colors, function(color)&#123; console.log(color);&#125;);// =========// VERSION 2// =========Array.prototype.myForEach = function(func)&#123; for(var i = 0; i &lt; this.length; i++) &#123; func(this[i]); &#125;&#125;;var colors = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"PURPLE\"];colors.myForEach(function(color)&#123; console.log(color);&#125;); 对象 1234567891011121314151617181920212223var person = &#123;name: \"Travis\",age: 21,city: \"LA\"&#125;;//bracket notation, similar to arrays:console.log(person[\"name\"]);//dot notation:console.log(person.name);There are a few differences between the 2 notations://you cannot use dot notation if the property starts with a numbersomeObject.1blah //INVALIDsomeObject[\"1blah\"] //VALID!//you can lookup using a variable with bracket notationvar str = \"name\";someObject.str //doesn't look for \"name\"someObject[str] //does evaluate str and looks for \"name\"//you cannot use dot notation for property names with spacessomeObject.fav color //INVALIDsomeObject[\"fav color\"]; //VALID 对象更新 123456789var person &#x3D; &#123;name: &quot;Travis&quot;,age: 21,city: &quot;LA&quot;&#125;;&#x2F;&#x2F;to update ageperson[&quot;age&quot;] +&#x3D; 1;&#x2F;&#x2F;to update cityperson.city &#x3D; &quot;London&quot;; 创建对象 12345678910111213141516&#x2F;&#x2F;make an empty object and then add to itvar person &#x3D; &#123;&#125;person.name &#x3D; &quot;Travis&quot;;person.age &#x3D; 21;person.city &#x3D; &quot;LA&quot;;&#x2F;&#x2F;all at oncevar person &#x3D; &#123;name: &quot;Travis&quot;,age: 21,city: &quot;LA&quot;&#125;;&#x2F;&#x2F;another way of initializing an Objectvar person &#x3D; new Object();person.name &#x3D; &quot;Travis&quot;;person.age &#x3D; 21;person.city &#x3D; &quot;LA&quot;; 对象中可以容纳任何数据 var junkObject = { age: 57, color: “purple”, isHungry: true, friends: [“Horatio”, “Hamlet”], pet: { name: “Rusty”, species: “Dog”, age: 2 } }; 对象中可以容纳方法 junkObject.add = function(a,b){ return a+b; } 使用this，使用对象中的已有元素 junkObject.print = function(){ this.friends.forEach(function(arr){console.log(arr);}); } DOM The Document Object Model is the interface between your Javascript and HTML+CSS 在控制台输入：document 以及 console.dir(document)即会显示出js文档对象 1234567891011121314151617181920As you begin working with the DOM you'll be writing some JavaScript code that selects HTML elements from the page and manipulates them.When doing this, be sure to include your JavaScript code at the bottom of the HTML document, right before the closing &lt;/body&gt; tag.The HTML will need to have loaded before the JavaScript is run, otherwise the JavaScript will throw an error because the HTML that it is trying to select and manipulate doesn't exist (yet).See example below:&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Some HTML Code Here&lt;/h1&gt; &lt;script src=\"scriptfile.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; dom 5类选择器 document.getElementById() document.getElementsByClassName() document.getElementsByTagName() document.querySelector() document.querySelectorAll() Hello Goodbye List Item 1 List Item 2 List Item 3 var tag = document.getElementById(“highlight”); var tags = document.getElementsByClassName(“bolded”); var tags = document.getElementsByTagName(“li”); //select by ID 所有都可选择 var tag = document.querySelector(&quot;#highlight&quot;); //select by Class var tag = document.querySelector(&quot;.bolded&quot;); //select by tag var tag = document.querySelector(“h1”); //select by tag var tags = document.querySelectorAll(“h1”); //select by class var tags = document.querySelectorAll(&quot;.bolded&quot;); 交互dom changing an element’s style 123456789&#x2F;SELECTvar tag &#x3D; document.getElementById(&quot;highlight&quot;);&#x2F;&#x2F;MANIPULATEtag.style.color &#x3D; &quot;blue&quot;;tag.style.border &#x3D; &quot;10px solid red&quot;;tag.style.fontSize &#x3D; &quot;70px&quot;;tag.style.background &#x3D; &quot;yellow&quot;;tag.style.marginTop &#x3D; &quot;200px&quot;; adding/removing classes 12345678910111213141516&#x2F;*DEFINE A CLASS IN CSS*&#x2F;.another-class &#123; color: purple; fontSize: 76px;&#125;var tag &#x3D; document.querySelector(&quot;h1&quot;);&#x2F;&#x2F;ADD A CLASS TO THE SELECTED ELEMENTtag.classList.add(&quot;another-class&quot;);&#x2F;&#x2F;REMOVE A CLASStag.classList.remove(&quot;another-class&quot;);&#x2F;&#x2F;TOGGLE A CLASS 改变 如果有这个class就会变为没有，如果没有这个class就会添加。tag.classList.toggle(&quot;another-class&quot;); changing the content of a tag 1234567891011&lt;p&gt; This is an &lt;strong&gt;awesome&lt;&#x2F;strong&gt; paragraph&lt;&#x2F;p&gt;&#x2F;Select the &lt;p&gt; tag:var tag &#x3D; document.querySelector(&quot;p&quot;);&#x2F;&#x2F;Retrieve the textContent:tag.textContent &#x2F;&#x2F;&quot;This is an awesome paragraph&quot;&#x2F;&#x2F;alter the textContent:tag.textContent &#x3D; &quot;blah blah blah&quot;; 123456789&lt;p&gt; This is an &lt;strong&gt;awesome&lt;&#x2F;strong&gt; paragraph&lt;&#x2F;p&gt;&#x2F;&#x2F;Select the &lt;p&gt; tag:var tag &#x3D; document.querySelector(&quot;p&quot;);tag.innerHTML&#x2F;&#x2F;&quot;This is an &lt;strong&gt;awesome&lt;&#x2F;strong&gt; paragraph&quot; changing attributes(src, href, etc.) 12345678910111213&lt;a href&#x3D;&quot;www.google.com&quot;&gt;I am a link&lt;&#x2F;a&gt;&lt;img src&#x3D;&quot;logo.png&quot;&gt;var link &#x3D; document.querySelector(&quot;a&quot;);link.getAttribute(&quot;href&quot;); &#x2F;&#x2F;&quot;www.google.com&quot;&#x2F;&#x2F;CHANGE HREF ATTRIBUTElink.setAttribute(&quot;href&quot;,&quot;www.dogs.com&quot;);&#x2F;&#x2F;&#x2F;&lt;a href&#x3D;&quot;www.dogs.com&quot;&gt;I am a link&lt;&#x2F;a&gt;&#x2F;&#x2F;TO CHANGE THE IMAGE SRCvar img &#x3D; document.querySelector(&quot;img&quot;);img.setAttribute(&quot;src&quot;, &quot;corgi.png&quot;);&#x2F;&#x2F;&lt;img src&#x3D;&quot;corgi.png&quot;&gt; DOM Events 123456789101112Clicking on a buttonHovering over a linkDragging and DroppingPressing the Enter keyTo add a listener, we use a method called addEventListenerelement.addEventListener(type, functionToCall);var button &#x3D; document.querySelector(&quot;button&quot;);button.addEventListener(&quot;click&quot;, function() &#123; console.log(&quot;SOMEONE CLICKED THE BUTTON!&quot;);&#125;); 12345678910&lt;button&gt;Click Me&lt;&#x2F;button&gt;&lt;p&gt;No One Has Clicked Me Yet&lt;&#x2F;p&gt;var button &#x3D; document.querySelector(&quot;button&quot;);var paragraph &#x3D; document.querySelector(&quot;p&quot;);&#x2F;&#x2F;SETUP CLICK LISTENERbutton.addEventListener(&quot;click&quot;, function() &#123; paragraph.textContent &#x3D; &quot;Someone Clicked the Button!&quot;;&#125;); 案例1 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Color Toggle&lt;/title&gt; &lt;style type=\"text/css\"&gt; .purple &#123; background: purple; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; var button = document.querySelector(\"button\"); // var isPurple = false; // button.addEventListener(\"click\", function()&#123; // if(isPurple)&#123; // document.body.style.background = \"white\"; // &#125; else &#123; // document.body.style.background = \"purple\"; // &#125; // isPurple = !isPurple; // &#125;);button.addEventListener(\"click\", function()&#123; document.body.classList.toggle(\"purple\");&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;CLICK ME&lt;/button&gt; &lt;script type=\"text/javascript\" src=\"toggle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 综合案例：猜颜色 第一步：布局 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Color Game&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"colorGame.css\"&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: #232323;&#125;.square &#123; width: 30%; background: purple; padding-bottom: 30%; float: left; margin: 1.66%;&#125;#container &#123; margin: 0px auto; max-width: 600px;&#125;h1 &#123; color: white;&#125;&lt;/style&gt; &lt;script type=\"text/javascript\"&gt; var colors = [ \"rgb(255, 0, 0)\", \"rgb(255, 255, 0)\", \"rgb(0, 255, 0)\", \"rgb(0, 255, 255)\", \"rgb(0, 0, 255)\", \"rgb(255, 0, 255)\" ]; var squares = document.querySelectorAll(\".square\"); var pickedColor = colors[3]; var colorDisplay = document.getElementById(\"colorDisplay\"); colorDisplay.textContent = pickedColor; for(var i = 0; i &lt; squares.length; i++)&#123; // add initial colors to squares squares[i].style.backgroundColor = colors[i]; //add click listeners to squares squares[i].addEventListener(\"click\", function() &#123; //grab color of clicked squares var clickedColor = this.style.backgroundColor; //compare color to pickedColor if(clickedColor === pickedColor) &#123; alert(\"Correct!\"); &#125; else &#123; alert(\"WRONG!!!\"); &#125; &#125;); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; The Great &lt;span id=\"colorDisplay\"&gt;RGB&lt;/span&gt; Color Game&lt;/h1&gt; &lt;div id=\"container\"&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;script type=\"text/javascript\" src=\"colorGame.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第2步：点击事件 正确时显示同一颜色，不正确时为黑色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Color Game&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"colorGame.css\"&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: #232323;&#125;.square &#123; width: 30%; background: purple; padding-bottom: 30%; float: left; margin: 1.66%;&#125;#container &#123; margin: 0px auto; max-width: 600px;&#125;h1 &#123; color: white;&#125;/*提示颜色白色*/span &#123; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; The Great &lt;span id=\"colorDisplay\"&gt;RGB&lt;/span&gt; Color Game&lt;/h1&gt;&lt;!-- 提示 --&gt;&lt;div&gt; &lt;span id=\"message\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;div id=\"container\"&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var colors = [ \"rgb(255, 0, 0)\", \"rgb(255, 255, 0)\", \"rgb(0, 255, 0)\", \"rgb(0, 255, 255)\", \"rgb(0, 0, 255)\", \"rgb(255, 0, 255)\" ]; // 正确后所有都为同一颜色 function changeColors(color) &#123; //loop through all squares for(var i = 0; i &lt; squares.length; i++) &#123; //change each color to match given color squares[i].style.backgroundColor = color; &#125; &#125;// 目标颜色随机 function pickColor() &#123; var random = Math.floor(Math.random() * colors.length); return colors[random]; &#125; var squares = document.querySelectorAll(\".square\"); var pickedColor = pickColor(); var colorDisplay = document.getElementById(\"colorDisplay\"); var messageDisplay = document.querySelector(\"#message\"); colorDisplay.textContent = pickedColor; for(var i = 0; i &lt; squares.length; i++)&#123; // add initial colors to squares squares[i].style.backgroundColor = colors[i]; //add click listeners to squares squares[i].addEventListener(\"click\", function() &#123; //grab color of clicked squares var clickedColor = this.style.backgroundColor; //compare color to pickedColor if(clickedColor === pickedColor) &#123; messageDisplay.textContent = \"Correct!\"; // 正确后所有都为同一颜色 changeColors(clickedColor); &#125; else &#123; // 不正确颜色为黑色 this.style.backgroundColor = \"#232323\"; messageDisplay.textContent = \"Try Again\"; &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第3步：随机颜色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Color Game&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"colorGame.css\"&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: #232323;&#125;.square &#123; width: 30%; background: purple; padding-bottom: 30%; float: left; margin: 1.66%;&#125;#container &#123; margin: 0px auto; max-width: 600px;&#125;h1 &#123; color: white;&#125;/*提示颜色白色*/span &#123; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; The Great &lt;span id=\"colorDisplay\"&gt;RGB&lt;/span&gt; Color Game&lt;/h1&gt;&lt;!-- 提示 --&gt;&lt;div&gt; &lt;span id=\"message\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;div id=\"container\"&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 随机颜色 var colors = generateRandomColors(6); // 正确后所有都为同一颜色 function changeColors(color) &#123; //loop through all squares for(var i = 0; i &lt; squares.length; i++) &#123; //change each color to match given color squares[i].style.backgroundColor = color; &#125; &#125; // 目标颜色随机 function pickColor() &#123; var random = Math.floor(Math.random() * colors.length); return colors[random]; &#125; function generateRandomColors(num) &#123; //make an array var arr = []; //add num random colors to arr for(var i = 0; i &lt; num; i++) &#123; //get random color and push into arr arr.push(randomColor()); &#125; //return that array return arr;&#125;function randomColor() &#123; //pick a \"red\" from 0 - 255 var r = Math.floor(Math.random() * 256); //pick a \"green\" from 0 - 255 var g = Math.floor(Math.random() * 256); //pick a \"blue\" from 0 - 255 var b = Math.floor(Math.random() * 256); return \"rgb(\" + r + \", \" + g + \", \" + b + \")\";&#125; var squares = document.querySelectorAll(\".square\"); var pickedColor = pickColor(); var colorDisplay = document.getElementById(\"colorDisplay\"); var messageDisplay = document.querySelector(\"#message\");// 获取h1标签var h1 = document.querySelector(\"h1\"); colorDisplay.textContent = pickedColor; for(var i = 0; i &lt; squares.length; i++)&#123; // add initial colors to squares squares[i].style.backgroundColor = colors[i]; //add click listeners to squares squares[i].addEventListener(\"click\", function() &#123; //grab color of clicked squares var clickedColor = this.style.backgroundColor; //compare color to pickedColor if(clickedColor === pickedColor) &#123; messageDisplay.textContent = \"Correct!\"; // 正确后所有都为同一颜色 changeColors(clickedColor); // 将h1标签颜色变为指定颜色 h1.style.background = clickedColor; &#125; else &#123; this.style.backgroundColor = \"#232323\"; messageDisplay.textContent = \"Try Again\"; &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第4步：布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Color Game&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"colorGame.css\"&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: #232323; margin: 0;&#125;.square &#123; width: 30%; background: purple; padding-bottom: 30%; float: left; margin: 1.66%; border-radius: 15%; transation:background 0.6s;-webkit-transation:background 0.6s;-moz-transation:background 0.6s;&#125;#container &#123; margin: 0px auto; max-width: 600px;&#125;h1 &#123; text-align: center; color: white; background: steelblue; margin:0; text-transform: uppercase; font-weight: normal; padding: 20px 0;&#125;/*提示颜色白色*/span &#123; color: black;&#125;#stripe &#123; background: white; height: 30px; text-align: center; color: black;&#125;.selected &#123; background: blue;&#125;button&#123; border: none; background: none; text-transform: uppercase; height: 100%; font-weight: 700; color: steelblue; letter-spacing: 1px;&#125;/*中间的*/#message&#123; display: inline-block; width: 10%;&#125;button:hover&#123; color: white; background: steelblue; transition: all 0.3s;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; The Great &lt;span id=\"colorDisplay\"&gt;RGB&lt;/span&gt; Color Game&lt;/h1&gt;&lt;!-- 信息横条--&gt;&lt;div id=\"stripe\"&gt; &lt;button id=\"reset\"&gt;New Colors&lt;/button&gt; &lt;span id=\"message\"&gt;&lt;/span&gt; &lt;button id=\"easyBtn\"&gt;Easy&lt;/button&gt; &lt;button id=\"hardBtn\" class=\"selected\"&gt;Hard&lt;/button&gt;&lt;/div&gt; &lt;div id=\"container\"&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;div class=\"square\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; // 随机颜色 var colors = generateRandomColors(6); var squares = document.querySelectorAll(\".square\"); var pickedColor = pickColor(); var colorDisplay = document.getElementById(\"colorDisplay\"); var messageDisplay = document.querySelector(\"#message\");// 获取h1标签var h1 = document.querySelector(\"h1\"); colorDisplay.textContent = pickedColor;// 点击按钮更换下一批颜色var resetButton = document.querySelector(\"#reset\");var numSquares = 6;var easyBtn = document.querySelector(\"#easyBtn\");var hardBtn = document.querySelector(\"#hardBtn\");easyBtn.addEventListener(\"click\", function() &#123; easyBtn.classList.add(\"selected\"); hardBtn.classList.remove(\"selected\"); numSquares = 3; colors = generateRandomColors(numSquares); pickedColor = pickColor(); colorDisplay.textContent = pickedColor; for(var i = 0; i &lt; squares.length; i++) &#123; if(colors[i]) &#123; squares[i].style.background = colors[i]; &#125; else &#123; squares[i].style.display = \"none\"; &#125; &#125;&#125;);hardBtn.addEventListener(\"click\", function() &#123; hardBtn.classList.add(\"selected\"); easyBtn.classList.remove(\"selected\"); numSquares = 6; colors = generateRandomColors(numSquares); pickedColor = pickColor(); colorDisplay.textContent = pickedColor; for(var i = 0; i &lt; squares.length; i++) &#123; squares[i].style.background = colors[i]; squares[i].style.display = \"block\"; &#125;&#125;);resetButton.addEventListener(\"click\", function() &#123; colors = generateRandomColors(numSquares); //pick a new random color from array pickedColor = pickColor(); //change colorDisplay to match picked Color colorDisplay.textContent = pickedColor; //change colors of squares for(var i = 0; i &lt; squares.length; i++) &#123; squares[i].style.background = colors[i]; &#125; h1.style.background = \"#232323\";&#125;); // 正确后所有都为同一颜色 function changeColors(color) &#123; //loop through all squares for(var i = 0; i &lt; squares.length; i++) &#123; //change each color to match given color squares[i].style.backgroundColor = color; &#125; &#125; // 目标颜色随机 function pickColor() &#123; var random = Math.floor(Math.random() * colors.length); return colors[random]; &#125; function generateRandomColors(num) &#123; //make an array var arr = []; //add num random colors to arr for(var i = 0; i &lt; num; i++) &#123; //get random color and push into arr arr.push(randomColor()); &#125; //return that array return arr;&#125;function randomColor() &#123; //pick a \"red\" from 0 - 255 var r = Math.floor(Math.random() * 256); //pick a \"green\" from 0 - 255 var g = Math.floor(Math.random() * 256); //pick a \"blue\" from 0 - 255 var b = Math.floor(Math.random() * 256); return \"rgb(\" + r + \", \" + g + \", \" + b + \")\";&#125; for(var i = 0; i &lt; squares.length; i++)&#123; // add initial colors to squares squares[i].style.backgroundColor = colors[i]; //add click listeners to squares squares[i].addEventListener(\"click\", function() &#123; //grab color of clicked squares var clickedColor = this.style.backgroundColor; //compare color to pickedColor if(clickedColor === pickedColor) &#123; messageDisplay.textContent = \"Correct!\"; resetButton.textContent = \"Play Again?\"; // 正确后所有都为同一颜色 changeColors(clickedColor); // 将h1标签颜色变为指定颜色 h1.style.background = clickedColor; &#125; else &#123; this.style.backgroundColor = \"#232323\"; messageDisplay.textContent = \"Try Again\"; &#125; &#125;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"js","slug":"js","permalink":"https://dreamerjonson.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://dreamerjonson.com/tags/js/"}]},{"title":"socket.io","slug":"node-socket-io","date":"2018-12-31T10:36:51.000Z","updated":"2019-01-17T15:59:53.314Z","comments":true,"path":"2018/12/31/node-socket-io/","link":"","permalink":"https://dreamerjonson.com/2018/12/31/node-socket-io/","excerpt":"","text":"项目目录 ├── package-lock.json ├── package.json ├── public │ └── index.html └── server └── server.js 初始化 npm init npm install --save express index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; server.js 12345678910111213const path = require('path');const express = require('express');//获取路劲，有讲究const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();app.use(express.static(publicPath));app.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); package.json 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;node-chat-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &#x2F;* 启动脚本 *&#x2F; &quot;start&quot;: &quot;node server&#x2F;server.js&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &#x2F;* node版本号 *&#x2F; &quot;engines&quot;: &#123; &quot;node&quot;: &quot;10.13.0&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.14.0&quot; &#125;&#125; 部署hekuro 12&gt; heroku create&gt; git push https:&#x2F;&#x2F;git.heroku.com&#x2F;rocky-shore-24556.git 使用socket.io 安装： 1npm install -save socket.io socket.io可以让服务器与客户端相互连接并触发事件。下例测试连接与断开服务器 server.html: 123456789101112131415161718192021222324const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected'); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); index.html: 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script&gt; var socket = io(); socket.on('connect', () =&gt; &#123; console.log('Connected to server'); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('Disconnected from server'); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行：打开localhost:3000即可运行，查看控制台输出的语句。 1&gt; node server&#x2F;server.js ##项目目录重构 创建和触发自定义事件。 将客户端js代码分离出来： |—— node_moudles ├── package-lock.json ├── package.json ├── public │ ├── index.html │ └── js │ └── index.js └── server └── server.js index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js: 为了让浏览器识别，将匿名函数修改为function 123456789101112131415161718var socket = io();socket.on('connect', function () &#123; console.log('Connected to server'); socket.emit('createMessage', &#123; from: 'Andrew', text: 'Yup, that works for me.' &#125;);&#125;);socket.on('disconnect', function () &#123; console.log('Disconnected from server');&#125;);socket.on('newMessage', function (message) &#123; console.log('newMessage', message);&#125;); server.js: 12345678910111213141516171819202122232425262728293031323334const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected'); socket.emit('newMessage', &#123; from: 'John', text: 'See you then', createdAt: 123123 &#125;); socket.on('createMessage', (message) =&gt; &#123; console.log('createMessage', message); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 运行：打开localhost:3000即可运行，查看控制台输出的语句。 1&gt; node server&#x2F;server.js 广播 当客户端连接服务器之后，所有的节点即会触发newMessage事件，但是当前连接的客户端与其他客户端接受的信息不相同。 当前客户端接受：Welcome to the chat app 其他客户端接受：New user joined index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js: 为了让浏览器识别，将匿名函数修改为function 12345678910111213var socket = io();socket.on('connect', function () &#123; console.log('Connected to server');&#125;);socket.on('disconnect', function () &#123; console.log('Disconnected from server');&#125;);socket.on('newMessage', function (message) &#123; console.log('newMessage', message);&#125;); server.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected');// 当客户端连接之后，即会触发newMessage事件，但是当前连接的客户端与其他客户端接受的信息不相同。 // 只发送给当前连接的节点 socket.emit('newMessage', &#123; from: 'Admin', text: 'Welcome to the chat app', createdAt: new Date().getTime() &#125;); // 只发送给当前连接的节点发送给其他节点 socket.broadcast.emit('newMessage', &#123; from: 'Admin', text: 'New user joined', createdAt: new Date().getTime() &#125;); socket.on('createMessage', (message) =&gt; &#123; console.log('createMessage', message); io.emit('newMessage', &#123; from: message.from, text: message.text, createdAt: new Date().getTime() &#125;); // socket.broadcast.emit('newMessage', &#123; // from: message.from, // text: message.text, // createdAt: new Date().getTime() // &#125;); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 测试 运行： 1&gt; node server&#x2F;server.js 分别打开两个浏览器tabs， 打开localhost:3000查看控制台输出的语句。 封装产生信息 目录 ├── package-lock.json ├── package.json ├── public │ ├── index.html │ └── js │ └── index.js └── server ├── server.js └── utils └── message.js index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js: 为了让浏览器识别，将匿名函数修改为function 12345678910111213var socket = io();socket.on('connect', function () &#123; console.log('Connected to server');&#125;);socket.on('disconnect', function () &#123; console.log('Disconnected from server');&#125;);socket.on('newMessage', function (message) &#123; console.log('newMessage', message);&#125;); message.js 123456789var generateMessage = (from, text) =&gt; &#123; return &#123; from, text, createdAt: new Date().getTime() &#125;;&#125;;module.exports = &#123;generateMessage&#125;; server.js 123456789101112131415161718192021222324252627282930313233343536373839const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const &#123;generateMessage&#125; = require('./utils/message');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected'); socket.emit('newMessage', generateMessage('Admin', 'Welcome to the chat app')); socket.broadcast.emit('newMessage', generateMessage('Admin', 'New user joined')); socket.on('createMessage', (message) =&gt; &#123; console.log('createMessage', message); io.emit('newMessage', generateMessage(message.from, message.text)); // socket.broadcast.emit('newMessage', &#123; // from: message.from, // text: message.text, // createdAt: new Date().getTime() // &#125;); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 测试 运行： 1&gt; node server&#x2F;server.js 分别打开两个浏览器tabs， 打开localhost:3000查看控制台输出的语句。 信息反馈 当客户端发出一条消息，希望得到服务器的反馈，如果服务器发送成功个，会收到消息。 index.html: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js: 为了让浏览器识别，将匿名函数修改为function 1234567891011121314151617181920var socket = io();socket.on('connect', function () &#123; console.log('Connected to server');&#125;);socket.on('disconnect', function () &#123; console.log('Disconnected from server');&#125;);socket.on('newMessage', function (message) &#123; console.log('newMessage', message);&#125;);socket.emit('createMessage', &#123; from: 'Frank', text: 'Hi'&#125;, function (data) &#123;//回调函数 console.log('Got it', data);&#125;); message.js 123456789var generateMessage = (from, text) =&gt; &#123; return &#123; from, text, createdAt: new Date().getTime() &#125;;&#125;;module.exports = &#123;generateMessage&#125;; server.js 12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const &#123;generateMessage&#125; = require('./utils/message');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected'); socket.emit('newMessage', generateMessage('Admin', 'Welcome to the chat app')); socket.broadcast.emit('newMessage', generateMessage('Admin', 'New user joined')); socket.on('createMessage', (message, callback) =&gt; &#123; console.log('createMessage', message); io.emit('newMessage', generateMessage(message.from, message.text)); callback('This is from the server.'); //客户端执行回调函数 // socket.broadcast.emit('newMessage', &#123; // from: message.from, // text: message.text, // createdAt: new Date().getTime() // &#125;); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 测试 运行： 1&gt; node server&#x2F;server.js 分别打开两个浏览器tabs， 打开localhost:3000查看控制台输出的语句。 ## 简单聊天页面 index.html: 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;ol id=\"messages\"&gt;&lt;/ol&gt;&lt;form id=\"message-form\"&gt; &lt;input name=\"message\" type=\"text\" placeholder=\"Message\"/&gt; &lt;button&gt;Send&lt;/button&gt;&lt;/form&gt; &lt;script src=\"/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js: 为了让浏览器识别，将匿名函数修改为function 1234567891011121314151617181920212223242526272829 var socket = io(); socket.on('connect', function () &#123; console.log('Connected to server'); &#125;); socket.on('disconnect', function () &#123; console.log('Disconnected from server'); &#125;);//新消息来了之后，添加到页面中 socket.on('newMessage', function (message) &#123; console.log('newMessage', message); var li = jQuery('&lt;li&gt;&lt;/li&gt;'); li.text(`$&#123;message.from&#125;: $&#123;message.text&#125;`); jQuery('#messages').append(li); &#125;); //按钮提交事件 jQuery('#message-form').on('submit', function (e) &#123; e.preventDefault(); socket.emit('createMessage', &#123; from: 'User', text: jQuery('[name=message]').val() &#125;, function () &#123; &#125;); &#125;); message.js 123456789var generateMessage = (from, text) =&gt; &#123; return &#123; from, text, createdAt: new Date().getTime() &#125;;&#125;;module.exports = &#123;generateMessage&#125;; server.js 12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const &#123;generateMessage&#125; = require('./utils/message');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected'); socket.emit('newMessage', generateMessage('Admin', 'Welcome to the chat app')); socket.broadcast.emit('newMessage', generateMessage('Admin', 'New user joined')); socket.on('createMessage', (message, callback) =&gt; &#123; console.log('createMessage', message); io.emit('newMessage', generateMessage(message.from, message.text)); callback('This is from the server.'); //客户端执行回调函数 // socket.broadcast.emit('newMessage', &#123; // from: message.from, // text: message.text, // createdAt: new Date().getTime() // &#125;); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 测试 运行： 1&gt; node server&#x2F;server.js 分别打开两个浏览器tabs， 打开localhost:3000查看控制台输出的语句。 经纬度 index.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var socket = io();socket.on('connect', function () &#123; console.log('Connected to server');&#125;);socket.on('disconnect', function () &#123; console.log('Disconnected from server');&#125;);socket.on('newMessage', function (message) &#123; console.log('newMessage', message); var li = jQuery('&lt;li&gt;&lt;/li&gt;'); li.text(`$&#123;message.from&#125;: $&#123;message.text&#125;`); jQuery('#messages').append(li);&#125;);jQuery('#message-form').on('submit', function (e) &#123; e.preventDefault(); socket.emit('createMessage', &#123; from: 'User', text: jQuery('[name=message]').val() &#125;, function () &#123; &#125;);&#125;);var locationButton = jQuery('#send-location');locationButton.on('click', function () &#123; if (!navigator.geolocation) &#123; return alert('Geolocation not supported by your browser.'); &#125; navigator.geolocation.getCurrentPosition(function (position) &#123; socket.emit('createLocationMessage', &#123; latitude: position.coords.latitude, longitude: position.coords.longitude &#125;); &#125;, function () &#123; alert('Unable to fetch location.'); &#125;);&#125;); index.html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;ol id=\"messages\"&gt;&lt;/ol&gt;&lt;form id=\"message-form\"&gt; &lt;input name=\"message\" type=\"text\" placeholder=\"Message\"/&gt; &lt;button&gt;Send&lt;/button&gt;&lt;/form&gt; &lt;button id=\"send-location\"&gt;Send Location&lt;/button&gt; &lt;script src=\"/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; message.js 123456789var generateMessage = (from, text) =&gt; &#123; return &#123; from, text, createdAt: new Date().getTime() &#125;;&#125;;module.exports = &#123;generateMessage&#125;; server.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const &#123;generateMessage&#125; = require('./utils/message');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected'); socket.emit('newMessage', generateMessage('Admin', 'Welcome to the chat app')); socket.broadcast.emit('newMessage', generateMessage('Admin', 'New user joined')); socket.on('createMessage', (message, callback) =&gt; &#123; console.log('createMessage', message); io.emit('newMessage', generateMessage(message.from, message.text)); callback('This is from the server.'); // socket.broadcast.emit('newMessage', &#123; // from: message.from, // text: message.text, // createdAt: new Date().getTime() // &#125;); &#125;); socket.on('createLocationMessage', (coords) =&gt; &#123; io.emit('newMessage', generateMessage('Admin', `$&#123;coords.latitude&#125;, $&#123;coords.longitude&#125;`)); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 谷歌经纬度 index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var socket = io();socket.on('connect', function () &#123; console.log('Connected to server');&#125;);socket.on('disconnect', function () &#123; console.log('Disconnected from server');&#125;);socket.on('newMessage', function (message) &#123; console.log('newMessage', message); var li = jQuery('&lt;li&gt;&lt;/li&gt;'); li.text(`$&#123;message.from&#125;: $&#123;message.text&#125;`); jQuery('#messages').append(li);&#125;);socket.on('newLocationMessage', function (message) &#123; var li = jQuery('&lt;li&gt;&lt;/li&gt;'); var a = jQuery('&lt;a target=\"_blank\"&gt;My current location&lt;/a&gt;'); li.text(`$&#123;message.from&#125;: `); a.attr('href', message.url); li.append(a); jQuery('#messages').append(li);&#125;);jQuery('#message-form').on('submit', function (e) &#123; e.preventDefault(); socket.emit('createMessage', &#123; from: 'User', text: jQuery('[name=message]').val() &#125;, function () &#123; &#125;);&#125;);var locationButton = jQuery('#send-location');locationButton.on('click', function () &#123; if (!navigator.geolocation) &#123; return alert('Geolocation not supported by your browser.'); &#125; navigator.geolocation.getCurrentPosition(function (position) &#123; socket.emit('createLocationMessage', &#123; latitude: position.coords.latitude, longitude: position.coords.longitude &#125;); &#125;, function () &#123; alert('Unable to fetch location.'); &#125;);&#125;); index.html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" integrity=\"sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;ol id=\"messages\"&gt;&lt;/ol&gt;&lt;form id=\"message-form\"&gt; &lt;input name=\"message\" type=\"text\" placeholder=\"Message\"/&gt; &lt;button&gt;Send&lt;/button&gt;&lt;/form&gt; &lt;button id=\"send-location\"&gt;Send Location&lt;/button&gt; &lt;script src=\"/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; message.js 1234567891011121314151617var generateMessage = (from, text) =&gt; &#123; return &#123; from, text, createdAt: new Date().getTime() &#125;;&#125;;var generateLocationMessage = (from, latitude, longitude) =&gt; &#123; return &#123; from, url: `https://www.google.com/maps?q=$&#123;latitude&#125;,$&#123;longitude&#125;`, createdAt: new Date().getTime() &#125;;&#125;;module.exports = &#123;generateMessage, generateLocationMessage&#125;; server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const path = require('path');const http = require('http');const express = require('express');const socketIO = require('socket.io');const &#123;generateMessage,generateLocationMessage&#125; = require('./utils/message');const publicPath = path.join(__dirname, '../public');const port = process.env.PORT || 3000;var app = express();var server = http.createServer(app);var io = socketIO(server);app.use(express.static(publicPath));io.on('connection', (socket) =&gt; &#123; console.log('New user connected'); socket.emit('newMessage', generateMessage('Admin', 'Welcome to the chat app')); socket.broadcast.emit('newMessage', generateMessage('Admin', 'New user joined')); socket.on('createMessage', (message, callback) =&gt; &#123; console.log('createMessage', message); io.emit('newMessage', generateMessage(message.from, message.text)); callback('This is from the server.'); // socket.broadcast.emit('newMessage', &#123; // from: message.from, // text: message.text, // createdAt: new Date().getTime() // &#125;); &#125;); socket.on('createLocationMessage', (coords) =&gt; &#123; io.emit('newLocationMessage', generateLocationMessage('Admin', coords.latitude, coords.longitude)); &#125;); socket.on('disconnect', () =&gt; &#123; console.log('User was disconnected'); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 页面优化 css/style.css: 1button,button:hover&#123;border:none;color:#fff;padding:10px&#125;.chat__messages,.chat__sidebar ul&#123;list-style-type:none&#125;*&#123;box-sizing:border-box;margin:0;padding:0;font-family:HelveticaNeue-Light,\"Helvetica Neue Light\",\"Helvetica Neue\",Helvetica,Arial,\"Lucida Grande\",sans-serif;font-weight:300;font-size:.95rem&#125;li,ul&#123;list-style-position:inside&#125;h3&#123;font-weight:600;text-align:center;font-size:1.5rem&#125;button&#123;background:#265f82;cursor:pointer;transition:background .3s ease&#125;button:hover&#123;background:#1F4C69&#125;button:disabled&#123;cursor:default;background:#698ea5&#125;.centered-form&#123;display:flex;align-items:center;height:100vh;width:100vw;justify-content:center;background:-moz-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-webkit-gradient(linear,left top,right bottom,color-stop(0,rgba(49,84,129,1)),color-stop(100%,rgba(39,107,130,1)));background:-webkit-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-o-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-ms-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:linear-gradient(325deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%)&#125;.centered-form__form&#123;background:rgba(250,250,250,.9);border:1px solid #e1e1e1;border-radius:5px;padding:0 20px;margin:20px;width:230px&#125;.form-field&#123;margin:20px 0&#125;.form-field&gt;*&#123;width:100%&#125;.form-field label&#123;display:block;margin-bottom:7px&#125;.form-field input,.form-field select&#123;border:1px solid #e1e1e1;padding:10px&#125;.chat&#123;display:flex&#125;.chat__sidebar&#123;overflow-y:scroll;width:260px;height:100vh;background:-moz-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-webkit-gradient(linear,left top,right bottom,color-stop(0,rgba(49,84,129,1)),color-stop(100%,rgba(39,107,130,1)));background:-webkit-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-o-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-ms-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:linear-gradient(325deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%)&#125;.chat__footer,.chat__sidebar li&#123;background:#e6eaee;padding:10px&#125;.chat__sidebar h3&#123;color:#e6eaee;margin:10px 20px;text-align:left&#125;.chat__sidebar li&#123;border:1px solid #e1e1e1;border-radius:5px;margin:10px&#125;.chat__main&#123;display:flex;flex-direction:column;height:100vh;width:100%&#125;.chat__messages&#123;flex-grow:1;overflow-y:scroll;-webkit-overflow-scrolling:touch;padding:10px&#125;.chat__footer&#123;display:flex;flex-shrink:0&#125;.chat__footer form&#123;flex-grow:1;display:flex&#125;.chat__footer form *&#123;margin-right:10px&#125;.chat__footer input&#123;border:none;padding:10px;flex-grow:1&#125;.message&#123;padding:10px&#125;.message__title&#123;display:flex;margin-bottom:5px&#125;.message__title h4&#123;font-weight:600;margin-right:10px&#125;.message__title span&#123;color:#999&#125;@media (max-width:600px)&#123;*&#123;font-size:1rem&#125;.chat__sidebar&#123;display:none&#125;.chat__footer&#123;flex-direction:column&#125;.chat__footer form&#123;margin-bottom:10px&#125;.chat__footer button&#123;margin-right:0&#125;&#125; index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var socket = io();socket.on('connect', function () &#123; console.log('Connected to server');&#125;);socket.on('disconnect', function () &#123; console.log('Disconnected from server');&#125;);socket.on('newMessage', function (message) &#123; console.log('newMessage', message); var li = jQuery('&lt;li&gt;&lt;/li&gt;'); li.text(`$&#123;message.from&#125;: $&#123;message.text&#125;`); jQuery('#messages').append(li);&#125;);socket.on('newLocationMessage', function (message) &#123; var li = jQuery('&lt;li&gt;&lt;/li&gt;'); var a = jQuery('&lt;a target=\"_blank\"&gt;My current location&lt;/a&gt;'); li.text(`$&#123;message.from&#125;: `); a.attr('href', message.url); li.append(a); jQuery('#messages').append(li);&#125;);jQuery('#message-form').on('submit', function (e) &#123; e.preventDefault(); socket.emit('createMessage', &#123; from: 'User', text: jQuery('[name=message]').val() &#125;, function () &#123; &#125;);&#125;);var locationButton = jQuery('#send-location');locationButton.on('click', function () &#123; if (!navigator.geolocation) &#123; return alert('Geolocation not supported by your browser.'); &#125; locationButton.attr('disabled', 'disabled').text('Sending location...'); navigator.geolocation.getCurrentPosition(function (position) &#123; locationButton.removeAttr('disabled').text('Send location'); socket.emit('createLocationMessage', &#123; latitude: position.coords.latitude, longitude: position.coords.longitude &#125;); &#125;, function () &#123; locationButton.removeAttr('disabled').text('Send location'); alert('Unable to fetch location.'); &#125;);&#125;);","categories":[],"tags":[]},{"title":"【区块链】给自己的妈妈解释什么是区块链(1)","slug":"explication-bitcoin","date":"2018-12-30T02:47:15.000Z","updated":"2019-04-28T02:47:09.377Z","comments":true,"path":"2018/12/30/explication-bitcoin/","link":"","permalink":"https://dreamerjonson.com/2018/12/30/explication-bitcoin/","excerpt":"","text":"一般人都听说过区块链的概念，即便是网络上充斥着大量有关区块链的文章，区块链对于大部分人来说也是非常朦胧的。这其实不能怪读者，因为区块链本身是一个非常庞大的概念，它是一个革命性的系统，它非常复杂、发展迅速并且拥有非常陡峭的学习曲线。 在本文以及接下来的一系列文章中，笔者试图用生动又不失内涵的语言为大家揭开区块链的神秘面纱。希望你也能给你的妈妈解释清楚，到底什么是区块链。😃 原始社会 在原始社会当中的交易,jonson要到olaya处买一头牛，jonson给了olaya一百元钱，因为是面对面的交易，交易双方都能够明确对方是指定的交易人，而不是李四、王二麻子…并且Alice能够验证到这头牛是真的，Bob能够验证到这笔钱不是伪造的。在这样的社会中，一切运转良好。 陶渊明曾经写过《桃花源记》，在桃花源这样的良田美池桑竹之属之地，每一个人都可以安居乐业、怡然自得。其实，从现代的博弈论的角度来讲，这种社会是可能存在的。因为，在封闭的信任社会当中，jonson欺骗的代价是非常之高的，甚至高到jonson没有办法承受。因为任何一次欺骗都可能会失去jonson在封闭社会当中生存下去的可能性。因此在封闭的小范围的环境下，维持信任的成本是比较低的。 图1 原始社会 现代社会 当今社会的交易是跨空间甚至于跨时间的。资源开始在全世界内进行交换和配置。现在交易的另一方可能远在世界的另外一端。如何还能够保证跟我交易的人不是一个骗子、而是我真正希望进行交易的伙伴？ 如果jonson给olaya的100元钱现在是一串数字，olaya如何能够保证jonson在支付给自己前已经将这笔钱发送给了其他人？就跟发送电子邮件一样，如何能够保证这笔数字没有被拷贝多份？为了解决上面提到的信任问题，现如今，我们需要借助于银行或者中央银行，借助支付宝微信等第三方平台。在国外有visa、paypal信用卡组织来创建信任。第三方组织保留自己的私人账簿，存储每个帐户的交易历史记录和余额。如果jonson向olaya发送100元，那么第三方组织将从jonson的账户中扣除100元，并在olaya的账户中增加100元。首先，借助第三方组织创建信任的代价是非常昂贵的。比如一家银行需要有各地的营业网点、场地。需要有律师、以及昂贵的高级管理人员。中央银行可能会乱发钞票带来通货膨胀、商业银行随意借贷资金带来整个社会的危机。另一方面，中心化的服务器会带来严重的安全问题。黑客袭击事件不胜枚举如不久前的facebook图片泄露。 图2 现代社会 区块链社会 2008年，正当金融危机席卷世界之际、人们开始反思当前的社会、金融秩序所面临的问题。2008年11月，一位化名为“ 中本聪&quot; 的研究者在密码学邮件组中发表了比特币的奠基性论文《比特币：一种点对点式的电子现金系统》（Bitcoin: A Peer-to-Peer Electronic Cash System）的论文。其在2008年8月还注册了bitcoin.org域名。在比特币白皮书中，中本聪描述了一种被他称为“比特币”的电子货币。为我们观察金钱的方式带来革命性的变化。中本聪等人希望打造一个系统，它不需要借助于任何第三方的组织或者权威的中心组织，任何人都能够拥有唯一标示的一串地址来对应特定的交易人。同时这个系统能够保证资金没有被反复使用，例如jonson既然给了olaya 100元，就不能够再次将这同样的100元转移给steven。在这样的系统中，任何人都可以参与到其中，即便系统中存在潜在的骗子，系统也能保证每一笔交易的安全性。 图3 区块链 第一个比特币在2009年1月发行。中本聪在创世区块中写下了这样一段英文：Chancellor on brink of second bailout for banks（财政部长批准对于银行的第二轮援助贷款）。这句泰晤士报上的一句话正是为了嘲讽08年的金融危机。像比特币这样的分布式网络，没有单一的攻击点。每个人都有一份分类账（区块链），没有人必须信任第三方组织，因为任何人都可以直接验证区块链中的信息。 总结 从原始社会、现代社会再到区块链社会，人类社会总是在不断提高效率中前进。笔者揭示了区块链诞生的历史及其产生的必然性。 如何在无信任的社会（有恶意的欺骗）中建立一种共识，确实是人类几十年来面临的难题。难在： 1、在互联网上的数字，和邮箱一样，我们就很难避免其他人复制N份。 2、由于每个人分散在各地，不能够保证每个人都同时在线。可以会有意外的离线、断线。 3、不能保证在这个系统中存在故意的破坏者。 中本聪关于区块链的精巧设计打开了新世界的大门。在比特币中、使用了分布式账本、p2p网络、数字签名、POW共识算法、区块链等精彩的设计。 结合了现代密码学、应用数学、计算机科学最新成果的比特币网络解决了人类几十年来难以解决的信任问题。信任带来社会的交易成本的降低，效率的提升带来社会的深刻变革。","categories":[{"name":"区块链","slug":"区块链","permalink":"https://dreamerjonson.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://dreamerjonson.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"【区块链】2018全年比特币网络重要指标图表分析","slug":"2018-bitcoin","date":"2018-12-29T06:59:18.000Z","updated":"2018-12-30T16:12:31.961Z","comments":true,"path":"2018/12/29/2018-bitcoin/","link":"","permalink":"https://dreamerjonson.com/2018/12/29/2018-bitcoin/","excerpt":"","text":"前言 2018年对于区块链、对于数字货币市场来说注定是不平凡的一年。年初，随着比特币、以太币等数字货币价格飙升,区块链得到了世界上越来越多人的关注。在之后，随着主流数字货币价格的暴跌，市场陷入一片哀嚎。然而，数字价格的波动并没有影响到区块链生态的繁荣。同时，对于金融的重塑不过是区块链强大特性的冰山一角。主流社会逐渐意识到，区块链技术将深刻的改变人类社会。 作为区块链鼻祖的比特币是一个革命性的系统，它非常复杂并且拥有非常陡峭的学习曲线。比特币常常作为市场的风向标。它不仅占领了数字货币总价值的半壁江山，也非常直接地影响了其他数字货币的价格。在这片文章中，笔者将会对2018年比特币网络的重要指标进行回顾。有一些概念可能读者闻所未闻。但是不管知不知道，它就在那里… 加密货币总市值 2018年，加密货币总市值从年初的8285亿美元下降到1300亿美元 图1 加密货币总市值 比特币总占比 2018年，比特币在加密货币中的总市值占比从年初最低的32.15%上升到第四季度50%以上 图2 比特币总占比 交易费用 2018年，比特币网络支付给矿工的费用从年初每天12,000,000美元下降到仅仅110,000美元。 图3 矿工收取的交易费用 交易额 2018年，比特币交易额超过4100亿元（ removing likely change outputs） 平均每秒钟交易13000美元 图4 比特币交易额 数据大小 2018年，比特币的总大小从150G增加到了198G。同比增长率从1月份40%跌落到25%。 图5 比特币数据大小 算力 &amp;&amp; 困难度 2018年，尽管比特币价格大幅下降导致许多矿工由于无利可图而退出，但比特币的算力在2018年期间仍然从从每秒19phash/s增加到38phash/s。据统计，如果一个黑客拥有当前全网所有的算力，重写全部比特币区块链的时间大约需要270天。 图6 比特币算力增长 信息传递 2018年，比特币区块传播速度明显提升，区块平均两秒钟即可传播到全网90%以上的节点。 图7 区块传播速度 下面是一些比较专业的概念，某些读者可能完全不懂这些数据背后的含义。 UTXO大小 比特币未花费的输出（UTXO）大小从62M减少到50M，平均每2.6秒减少一个UTXO。然而在2017年，每2秒钟就会增加一个UTXO。 图8 UTXO大小 交易输出 BTC交易输出（output）总数从3M BTC /天的峰值下降到1M BTC/天 图9 交易输出的比特币数量 每日比特币交易输出（output）在1月达到峰值1,247,000，并在2018年剩余时间内稳定在500,000和600,000之间。 图10 交易输出个数 交易大小 virtual bytes（vbyte）单位用于衡量比特币中交易在区块中的大小。交易从1月 750 vbyte的峰值下降到了450 vbyte。 这是比特币隔离验证采用率逐渐增加的结果。 图11 比特币区块中交易的大小 AsicBoost AsicBoost是一种创新，通过改变计算区块头哈希的方式，号称可以将挖矿的效率提高20%，2018年，每日使用Overt AsicBoost方式挖出的区块从0%上升到了31%。 图12 AsicBoost挖矿 OP_RETURN OP_RETURN可用于在区块链上存储任意数据。2018年OP_RETURN输出的数量大小从4M增加到10M，OP_RETURN从2017年每天增长约50到2018年每天增长300个以上。 图13 OP_RETURN输出 闪电网络 作为比特币扩容方案的闪电网络通道从0增加到了20101个，处理比特币能力从0增加到了522个。 图14 闪电网络通道与金额变化 总结 1、2018年整个加密货币市值相比年初下跌了84%，但比特币所占市值总权重却上升到了四季度的50%以上。比特币仍然是加密货币世界的半壁江山、中流砥柱。 2、比特币交易数量与交易金额从1月份峰值开始回落并稳定下来。这直接导致了比特币数据量增速放缓，矿工交易费用收益降低。尽管如此，比特币总交易额仍然超过4100亿元，平均每秒钟交易13000美元 3、尽管比特币价格大幅下降导致许多矿工由于无利可图而退出，比特币算力仍然在2018年期间仍然从从每秒19phash/s增加到38phash/s 4、关于比特币的许多创新都在加速。包括比特币扩容方案——闪电网络、隔离验证，AsicBoost挖矿，OP_RETURN等。 参考资料 https://p2sh.info/ https://coin.dance https://statoshi.info/ https://www.blockchain.com https://asicboost.dance/ https://coinmarketcap.com/charts/","categories":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}]},{"title":"bootstrap详解","slug":"bootstrap3-install","date":"2018-12-27T10:26:45.000Z","updated":"2019-01-10T09:29:36.445Z","comments":true,"path":"2018/12/27/bootstrap3-install/","link":"","permalink":"https://dreamerjonson.com/2018/12/27/bootstrap3-install/","excerpt":"","text":"网址 bootstrap官网：https://getbootstrap.com bootstrap4文档：https://getbootstrap.com/docs 高版本右上方可以切换到低版本。 bootstrap3文档:https://getbootstrap.com/docs/3.3/ bootstrap4 相对于bootstrap3的改变：https://getbootstrap.com/docs/4.2/migration/ bootstrap github:https://github.com/twbs/bootstrap 安装bootstrap css 使用bootstrap方式： 方式1：链接外部库 https://www.bootstrapcdn.com/legacy/bootstrap/ 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Primary&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 方式2：下载源文件，并link 1&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;bootstrap.css&quot;&gt; 实验 1、实验jumbotron 2、实验多行表单与form-inline一行表单 form-group添加一些属性 form-control让输入框扩展一行显示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class = \"container\"&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;Primary&lt;/button&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\" href=\"#\" role=\"button\"&gt;Learn more&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputFile\"&gt;File input&lt;/label&gt; &lt;input type=\"file\" id=\"exampleInputFile\"&gt; &lt;p class=\"help-block\"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt;&lt;/form&gt; &lt;form class=\"form-inline\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName2\"&gt;Name&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"exampleInputName2\" placeholder=\"Jane Doe\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail2\"&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail2\" placeholder=\"jane.doe@example.com\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Send invitation&lt;/button&gt;&lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 导航栏 第一步，添加前方navbar-header头部 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第2步，添加导航栏菜单navbar-nav 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 菜单栏的缩放 需要使用js，带入bootstrap js 1&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;maxcdn.bootstrapcdn.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;js&#x2F;bootstrap.min.js&quot; integrity&#x3D;&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt; bootstrap js需要jquery 1234&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-2.2.4.js&quot; integrity&#x3D;&quot;sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq&#x2F;8PuOW33aOqmvFpqI&#x3D;&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt; header内添加 缩放button 属性 data-target=&quot;#bs-nav-demo&quot; 意味着点击缩放按钮，显示id为bs-nav-demo的菜单内的内容 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-nav-demo\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\" integrity=\"sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq/8PuOW33aOqmvFpqI=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在nav-bar中添加id为bs-nav-demo的div。 意味着缩小屏幕会隐藏内部的内容。点击后会显示。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-nav-demo\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-nav-demo\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\" integrity=\"sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq/8PuOW33aOqmvFpqI=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; gird系统 将一个区域分为了12个块。 break-point： 极小屏幕：.col-xs- 小屏幕：.col-sm- 中屏幕：.col-md- 大屏幕：.col-lg- 小屏幕不设置，默认是占满，大屏幕不设置默认和最近的小屏幕的规则相同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;style type=\"text/css\"&gt; .pink &#123; background: pink; border: 1px solid purple; &#125; .orange &#123; background: orange; border: 1px dashed red; height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 大屏幕每个占1份， 中屏幕每个占2份。 小屏幕每个占4份，极小屏幕没有设置时，默认是占满。 --&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;div class=\"col-lg-1 col-md-2 col-sm-4 pink\"&gt;COL LG 1&lt;/div&gt; &lt;/div&gt;&lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\" integrity=\"sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq/8PuOW33aOqmvFpqI=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ##grid嵌套 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;BootStrap&lt;/title&gt; &lt;link href=\"https://stackpath.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;style type=\"text/css\"&gt; .pink &#123; background: pink; border: 1px solid purple; &#125; .orange &#123; background: orange; border: 1px dashed red; height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3 col-sm-6 pink\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-6 orange\"&gt;FIRST HALF&lt;/div&gt; &lt;div class=\"col-lg-6 orange\"&gt;OTHER HALF&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6 pink\"&gt;TOUR DATE!&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6 pink\"&gt;TOUR DATE!&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6 pink\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-2 orange\"&gt;&lt;/div&gt; &lt;div class=\"col-lg-2 orange\"&gt;&lt;/div&gt; &lt;div class=\"col-lg-2 orange\"&gt;&lt;/div&gt; &lt;div class=\"col-lg-2 orange\"&gt;&lt;/div&gt; &lt;div class=\"col-lg-2 orange\"&gt;&lt;/div&gt; &lt;div class=\"col-lg-2 orange\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\" integrity=\"sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq/8PuOW33aOqmvFpqI=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; grid实战 实战 使用了fontawesome。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Bootstrap Navbars&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\"&gt; &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.6.3/css/all.css\" integrity=\"sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/\" crossorigin=\"anonymous\"&gt; &lt;style type=\"text/css\"&gt; body &#123; padding-top: 70px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=\"navbar navbar-inverse navbar-fixed-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-nav-demo\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a href=\"#\" class=\"navbar-brand\"&gt;&lt;span class=\"glyphicon glyphicon-picture\"&gt;&lt;/span&gt; IMGS&lt;/a&gt; &lt;/div&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-nav-demo\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Sign Up&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Login&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;div class=\"container\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;&lt;i class=\"far fa-thumbs-up fa-2x\"&gt;&lt;/i&gt;&lt;/span&gt; The Image Gallery &lt;/h1&gt; &lt;p&gt;A bunch of beautiful images that I didn't take(except for the first one!)&lt;/p&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\" \"&gt; &lt;img src=\"http://i.imgur.com/qK42fUu.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1435771112039-1e5b2bcad966?dpr=2&amp;fit=crop&amp;fm=jpg&amp;h=825&amp;q=50&amp;w=1450\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1442406964439-e46ab8eff7c4?dpr=2&amp;fit=crop&amp;fm=jpg&amp;h=825&amp;q=50&amp;w=1450\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1439524970634-649c37a69e5c?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;w=1450&amp;h=825&amp;fit=crop&amp;s=bfda9916c885869b43b70738693428d9\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1444090542259-0af8fa96557e?dpr=2&amp;fit=crop&amp;fm=jpg&amp;h=825&amp;q=50&amp;w=1450\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1434543177303-ef2cc7707e0d?dpr=2&amp;fit=crop&amp;fm=jpg&amp;h=825&amp;q=50&amp;w=1450\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1436262513933-a0b06755c784?dpr=2&amp;fit=crop&amp;fm=jpg&amp;h=825&amp;q=50&amp;w=1450\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1439396087961-98bc12c21176?dpr=2&amp;fit=crop&amp;fm=jpg&amp;h=825&amp;q=50&amp;w=1450\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 col-sm-6\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"https://images.unsplash.com/photo-1439694458393-78ecf14da7f9?dpr=2&amp;fit=crop&amp;fm=jpg&amp;h=825&amp;q=50&amp;w=1450\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script src=\"https://code.jquery.com/jquery-2.1.4.js\"&gt;&lt;/script&gt;&lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 实战2 实战2 unsplash图片：https://unsplash.com 获取图片url：https://source.unsplash.com/lQ3go6MNPzo 使用了fontawesome。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Purrfect Match&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css\"&gt; &lt;link href=\"http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;!-- 手机小屏幕 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;style type=\"text/css\"&gt; /*背景图片*/ body &#123; background: url(https://images.unsplash.com/photo-1415369629372-26f2fe60c467); /*调整图片大小与盒子大小相适应*/ background-size: cover; /*图片居中*/ background-position: center;&#125;body,html &#123; /*扩展高度与宽度*/ width: 100%; height: 100%; font-family: \"Lato\"; color: white;&#125;h1 &#123; font-weight: 700; font-size: 5em;&#125;.content&#123; padding-top: 25%; text-align: center; /*文字阴影*/ text-shadow: 0px 4px 3px rgba(0,0,0,0.4), 0px 8px 13px rgba(0,0,0,0.1), 0px 18px 23px rgba(0,0,0,0.1);&#125;/*分割线*/hr &#123; /*不超过父元素90%的宽度*/ max-width: 90%; width: 400px; border-top: 1px solid #f8f8f8; border-bottom: 1px solid rgba(0,0,0,0.2);&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 导航栏 --&gt; &lt;nav class=\"navbar navbar-default navbar-fixed-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Purrfect Match&lt;/a&gt; &lt;/div&gt; &lt;div id=\"navbar\" class=\"collapse navbar-collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Signup &lt;i class=\"fa fa-user-plus\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;Login &lt;i class=\"fa fa-user\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;!-- 中部文字 --&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"content\"&gt; &lt;h1&gt;Purrfect Match&lt;/h1&gt; &lt;h3&gt;The Only Human-Feline Dating App&lt;/h3&gt; &lt;hr&gt; &lt;button class=\"btn btn-default btn-lg\"&gt;&lt;i class=\"fa fa-paw fa-fw\"&gt;&lt;/i&gt; Get Started!&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-2.1.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;` bootstrap4 bootstrap4 相对于bootstrap3的改变：https://getbootstrap.com/docs/4.2/migration/ 第一个bootstrap程序 测试导入的css与js库是否成功： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Hello, world!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;div class=\"card\" style=\"width: 18rem;\"&gt; &lt;div class=\"card-body\"&gt; &lt;h5 class=\"card-title\"&gt;Card title&lt;/h5&gt; &lt;h6 class=\"card-subtitle mb-2 text-muted\"&gt;Card subtitle&lt;/h6&gt; &lt;p class=\"card-text\"&gt;Some quick example text to build on the card title and make up the bulk of the card's content.&lt;/p&gt; &lt;a href=\"#\" class=\"card-link\"&gt;Card link&lt;/a&gt; &lt;a href=\"#\" class=\"card-link\"&gt;Another link&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-secondary dropdown-toggle\" type=\"button\" id=\"dropdownMenuButton\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt; Dropdown button &lt;/button&gt; &lt;div class=\"dropdown-menu\" aria-labelledby=\"dropdownMenuButton\"&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 颜色 颜色，包含了背景颜色与字体颜色：https://getbootstrap.com/docs/4.2/utilities/colors/ 1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Colors&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-primary\"&gt;I am an h1&lt;/h1&gt; &lt;h1 class=\"text-danger\"&gt;I am an h1&lt;/h1&gt; &lt;h1 class=\"text-info\"&gt;I am an h1&lt;/h1&gt; &lt;h1 class=\"text-success\"&gt;I am an h1&lt;/h1&gt; &lt;h1 class=\"text-warning\"&gt;I am an h1&lt;/h1&gt; &lt;h1 class=\"text-white bg-dark\"&gt;I am an h1&lt;/h1&gt; &lt;h1 class=\"text-success\"&gt;I am an h1&lt;/h1&gt; &lt;h1 class=\"bg-light\"&gt;I am an h1&lt;/h1&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 排版 1、 bootstrap4增加了display class 2、rem的基准从bootstrap3 中的14px变到了bootstrap4中的16px。 3、bootstrap3中 引言为标签，变为了class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Typography&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;!-- Display Headings --&gt; &lt;h1&gt;Regular H1&lt;/h1&gt; &lt;h1 class=\"display-1 text-info\"&gt;Display 1&lt;/h1&gt; &lt;h1 class=\"display-2\"&gt;Display 2&lt;/h1&gt; &lt;h1 class=\"display-3\"&gt;Display 3&lt;/h1&gt; &lt;h1 class=\"display-4\"&gt;Display 4&lt;/h1&gt; &lt;!-- Blockquotes --&gt; &lt;blockquote&gt; &lt;p class=\"mb-0\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote class=\"blockquote\"&gt; &lt;p class=\"mb-0\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;/blockquote&gt; &lt;blockquote class=\"blockquote\"&gt; &lt;p class=\"mb-0\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;footer class=\"blockquote-footer\"&gt;Written by my cat &lt;cite title=\"Blue Steele\"&gt;Blue Steele&lt;/cite&gt;&lt;/footer&gt; &lt;/blockquote&gt; &lt;blockquote class=\"blockquote text-right\"&gt; &lt;p class=\"mb-0\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.&lt;/p&gt; &lt;footer class=\"blockquote-footer\"&gt;Written by my cat &lt;cite title=\"Blue Steele\"&gt;Blue Steele&lt;/cite&gt;&lt;/footer&gt; &lt;/blockquote&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; boder padding and margin 边框的颜色可以任意的设置颜色、设置是否有边框 边框：https://getbootstrap.com/docs/4.2/utilities/borders/ padding and margin均可任意设置上下左右 margin与padding的有无与大小 padding and margin：https://getbootstrap.com/docs/4.2/utilities/spacing/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Utilities&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-center display-1\"&gt;Utilities&lt;/h1&gt; &lt;!-- Border --&gt; &lt;h5 class=\"border border-danger rounded-top\"&gt;GIVE ME A BORDER&lt;/h5&gt; &lt;h5 class=\"border-top border-info\"&gt;GIVE ME A BORDER&lt;/h5&gt; &lt;h5 class=\"border border-left-0 border-warning\"&gt;GIVE ME A BORDER&lt;/h5&gt; &lt;!-- 大小 --&gt; &lt;button class=\"btn btn-info p-0\"&gt;P0&lt;/button&gt; &lt;button class=\"btn btn-info p-1\"&gt;P1&lt;/button&gt; &lt;button class=\"btn btn-info p-2\"&gt;P2&lt;/button&gt; &lt;button class=\"btn btn-info p-3\"&gt;P3&lt;/button&gt; &lt;button class=\"btn btn-info p-4\"&gt;P4&lt;/button&gt; &lt;button class=\"btn btn-info p-5\"&gt;P5&lt;/button&gt; &lt;!-- Padding --&gt; &lt;!-- 上 --&gt; &lt;button class=\"btn btn-info pt-5\"&gt;Pt-5&lt;/button&gt; &lt;!-- 下 --&gt; &lt;button class=\"btn btn-info pb-5\"&gt;Pb-5&lt;/button&gt; &lt;!-- 上下 --&gt; &lt;button class=\"btn btn-info py-5\"&gt;Py-5&lt;/button&gt; &lt;!-- 左 --&gt; &lt;button class=\"btn btn-info pl-5\"&gt;Pl-5&lt;/button&gt; &lt;!-- 右 --&gt; &lt;button class=\"btn btn-info pr-5\"&gt;Pr-5&lt;/button&gt; &lt;!-- 左右 --&gt; &lt;button class=\"btn btn-info px-5\"&gt;Px-5&lt;/button&gt; &lt;!-- Margin --&gt; &lt;p class=\"bg-success text-white m-0\"&gt;I AM M-0&lt;/p&gt; &lt;p class=\"bg-success text-white m-1\"&gt;I AM M-1&lt;/p&gt; &lt;p class=\"bg-success text-white m-2\"&gt;I AM M-2&lt;/p&gt; &lt;p class=\"bg-success text-white m-3\"&gt;I AM M-3&lt;/p&gt; &lt;p class=\"bg-success text-white m-4\"&gt;I AM M-4&lt;/p&gt; &lt;p class=\"bg-success text-white m-5\"&gt;I AM M-5&lt;/p&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; breakpoints 与 padding margin 混合使用 bootstrap4有5个breakpoints：https://getbootstrap.com/docs/4.2/layout/overview/ 分别为：xs(最小，一般不写)，sm,md,lg,xl breakpoints 与 padding margin 混合使用: {property}{sides}-{breakpoint}-{size} padding and margin：https://getbootstrap.com/docs/4.2/utilities/spacing/ 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Breakpoints&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container text-center\"&gt; &lt;h1 class=\"display-3\"&gt;Breakpoints&lt;/h1&gt; &lt;button class=\"btn btn-warning p-sm-5 p-md-0 p-lg-5 p-xl-0\"&gt;BUTTON&lt;/button&gt; &lt;button class=\"btn btn-danger p-0 p-sm-2 p-md-3 p-lg-4 p-xl-5\"&gt;BUTTON&lt;/button&gt; &lt;button class=\"btn btn-success p-0 pl-sm-5 pt-md-5 pr-lg-5 pb-xl-5\"&gt;BUTTON&lt;/button&gt; &lt;h1&gt;Margin Example&lt;/h1&gt; &lt;button class=\"btn btn-primary p-4 mx-0 mx-sm-2 mx-md-3 mx-lg-4 mx-xl-5\"&gt;Hi&lt;/button&gt; &lt;button class=\"btn btn-primary p-4 mx-0 mx-sm-2 mx-md-3 mx-lg-4 mx-xl-5\"&gt;Hi&lt;/button&gt; &lt;button class=\"btn btn-primary p-4 mx-0 mx-sm-2 mx-md-3 mx-lg-4 mx-xl-5\"&gt;Hi&lt;/button&gt; &lt;button class=\"btn btn-primary p-4 mx-0 mx-sm-2 mx-md-3 mx-lg-4 mx-xl-5\"&gt;Hi&lt;/button&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 导航栏 相对于bootstrap3，导航兰增加了breakpoint，navbar-expand-XX根据分辨率不同发生不同的变化。 下面列出了不同分辨率的导航栏，在浏览器中去尝试！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Navbars&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-center display-3\"&gt;Navbars&lt;/h1&gt; &lt;/div&gt; &lt;nav class=\"navbar navbar-expand-sm navbar-light bg-light\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Expands at SM&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt; &lt;ul class=\"navbar-nav mr-auto\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Home &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item dropdown\"&gt; &lt;a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt; Dropdown &lt;/a&gt; &lt;div class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\"&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt; &lt;div class=\"dropdown-divider\"&gt;&lt;/div&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"form-inline my-2 my-lg-0\"&gt; &lt;input class=\"form-control mr-sm-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"&gt; &lt;button class=\"btn btn-outline-success my-2 my-sm-0\" type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;nav class=\"navbar navbar-expand-md navbar-light bg-light\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Expands at MD&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt; &lt;ul class=\"navbar-nav mr-auto\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Home &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item dropdown\"&gt; &lt;a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt; Dropdown &lt;/a&gt; &lt;div class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\"&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt; &lt;div class=\"dropdown-divider\"&gt;&lt;/div&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"form-inline my-2 my-lg-0\"&gt; &lt;input class=\"form-control mr-sm-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"&gt; &lt;button class=\"btn btn-outline-success my-2 my-sm-0\" type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;nav class=\"navbar navbar-expand-lg navbar-light bg-light\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Expands at LG&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt; &lt;ul class=\"navbar-nav mr-auto\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Home &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item dropdown\"&gt; &lt;a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt; Dropdown &lt;/a&gt; &lt;div class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\"&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt; &lt;div class=\"dropdown-divider\"&gt;&lt;/div&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"form-inline my-2 my-lg-0\"&gt; &lt;input class=\"form-control mr-sm-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"&gt; &lt;button class=\"btn btn-outline-success my-2 my-sm-0\" type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;nav class=\"navbar navbar-expand-xl navbar-light bg-light\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Expands at XL&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt; &lt;ul class=\"navbar-nav mr-auto\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Home &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item dropdown\"&gt; &lt;a class=\"nav-link dropdown-toggle\" href=\"#\" id=\"navbarDropdown\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt; Dropdown &lt;/a&gt; &lt;div class=\"dropdown-menu\" aria-labelledby=\"navbarDropdown\"&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Action&lt;/a&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Another action&lt;/a&gt; &lt;div class=\"dropdown-divider\"&gt;&lt;/div&gt; &lt;a class=\"dropdown-item\" href=\"#\"&gt;Something else here&lt;/a&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"form-inline my-2 my-lg-0\"&gt; &lt;input class=\"form-control mr-sm-2\" type=\"search\" placeholder=\"Search\" aria-label=\"Search\"&gt; &lt;button class=\"btn btn-outline-success my-2 my-sm-0\" type=\"submit\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/nav&gt; &lt;nav class=\"navbar navbar-expand-xl navbar-dark bg-info\"&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Navbar-Dark&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt; &lt;ul class=\"navbar-nav mr-auto\"&gt; &lt;li class=\"nav-item active\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Home &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; display 隐藏与显示 结合breakpoint 还可以设置inline 与 block ：https://getbootstrap.com/docs/4.2/utilities/display/ 在浏览器中拖动大小显示效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Display&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-center display-4\"&gt;Display Utility&lt;/h1&gt; &lt;h1 class=\"border border-danger d-inline\"&gt;HELLO&lt;/h1&gt; &lt;span class=\"border border-success d-block\"&gt;HELLO&lt;/span&gt; &lt;h1 class=\"d-xl-none\"&gt;HIDE ME ON XL&lt;/h1&gt; &lt;h1 class=\"d-none d-lg-block d-xl-none\"&gt;ALWAYS HIDDEN EXCEPT LG&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"jumbotron\"&gt; &lt;h1 class=\"display-4\"&gt;Hello, world!&lt;/h1&gt; &lt;p class=\"lead d-none d-md-block\"&gt;Lorem, ipsum dolor sit amet consectetur adipisicing elit. Quis odio debitis voluptatem possimus corrupti labore alias! Ad ipsa, veniam in quo a aperiam obcaecati quae. Blanditiis delectus, corrupti optio voluptatem eum deserunt officiis vitae. Similique amet facere voluptas velit maxime neque, quisquam exercitationem aliquam vitae inventore cumque ad nihil sit expedita fugiat at, quos quae. Aperiam obcaecati aut magni veritatis!&lt;/p&gt; &lt;hr class=\"my-4\"&gt; &lt;p&gt;It uses utility classes for typography and spacing to space content out within the larger container.&lt;/p&gt; &lt;a class=\"btn btn-primary btn-lg\" href=\"#\" role=\"button\"&gt;Learn more&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; flexBox https://getbootstrap.com/docs/4.2/utilities/flex/ flexBox在布局的时候非常有用。 d-flex声明盒子是一个flexbox flex-row表明盒子上下扩展 flex-column表明盒子左右扩展 flex-column-reverse、flex-row-reverse 镜像反转。 justify-content-start原本大小，不扩展 主坐标轴的排列 align-items-end 、justify-content-between、justify-content-around排列位置，这是次坐标轴的排列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Flexbox&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-center display-4\"&gt;Flexbox&lt;/h1&gt; &lt;div class=\"border border-dark d-flex flex-row justify-content-start align-items-end\" style=\"height: 200px\"&gt; &lt;button class=\"btn btn-info btn-lg\"&gt;LARGE&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;SMALL&lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt;SMALL&lt;/button&gt; &lt;/div&gt; &lt;div class=\"border border-dark d-flex flex-row-reverse justify-content-start align-items-end\" style=\"height: 200px\"&gt; &lt;button class=\"btn btn-info btn-lg\"&gt;LARGE&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;SMALL&lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt;SMALL&lt;/button&gt; &lt;/div&gt; &lt;div class=\"border border-dark d-flex flex-column justify-content-start align-items-end\" style=\"height: 200px\"&gt; &lt;button class=\"btn btn-info btn-lg\"&gt;LARGE&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;SMALL&lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt;SMALL&lt;/button&gt; &lt;/div&gt; &lt;div class=\"border border-dark d-flex flex-column-reverse justify-content-start align-items-end\" style=\"height: 200px\"&gt; &lt;button class=\"btn btn-info btn-lg\"&gt;LARGE&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;SMALL&lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt;SMALL&lt;/button&gt; &lt;/div&gt; &lt;h1 class=\"display-4 text-center\"&gt;EXAMPLE TIME&lt;/h1&gt; &lt;div class=\"d-flex flex-column flex-md-row justify-content-between\"&gt; &lt;button class=\"btn btn-dark btn-lg\"&gt;Link 1&lt;/button&gt; &lt;button class=\"btn btn-dark btn-lg\"&gt;Link 2&lt;/button&gt; &lt;button class=\"btn btn-dark btn-lg\"&gt;Link 3&lt;/button&gt; &lt;button class=\"btn btn-dark btn-lg\"&gt;Link 4&lt;/button&gt; &lt;button class=\"btn btn-dark btn-lg\"&gt;Link 5&lt;/button&gt; &lt;button class=\"btn btn-dark btn-lg\"&gt;Link 6&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; NAV + flexBox 1、NAV相对于bootstrap3做了分离： Instead of HTML-specific selectors like .nav &gt; li &gt; a, we use separate classes for .navs, .nav-items, and .nav-links. This makes your HTML more flexible while bringing along increased extensibility. 2、NAV默认是flexbox。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Navs&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-center display-4\"&gt;Navs+Flex&lt;/h1&gt; &lt;ul class=\"nav border border-primary justify-content-around\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" href=\"#\"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav nav-tabs mt-5 \"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" href=\"#\"&gt;Active&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;nav class=\"nav flex-column flex-sm-row justify-content-center align-items-center\"&gt; &lt;a class=\"nav-link active\" href=\"#\"&gt;Active&lt;/a&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;a class=\"nav-link\" href=\"#\"&gt;Link&lt;/a&gt; &lt;a class=\"nav-link disabled\" href=\"#\"&gt;Disabled&lt;/a&gt; &lt;/nav&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bootstrap4 grid https://getbootstrap.com/docs/4.2/migration/#grid-system 增加了极小的屏幕xs, sm, md, lg, and xl. 123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;The Grid&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-center display-4\"&gt;The Grid&lt;/h1&gt; &lt;div class=\"row border border-danger\"&gt; &lt;h3 class=\"col-sm-6 col-xl-3 bg-info m-0\"&gt;THING 1&lt;/h3&gt; &lt;h3 class=\"col-sm-6 col-xl-9 bg-warning m-0\"&gt;THING 2&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"row my-5\"&gt; &lt;div class=\"col bg-primary\"&gt;THING&lt;/div&gt; &lt;div class=\"col-6 bg-info\"&gt;THING&lt;/div&gt; &lt;div class=\"col bg-success\"&gt;THING&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例1 效果图 首先nav-bar 以及jumbotron 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.4.1/css/all.css\" integrity=\"sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Pattern&lt;/title&gt; &lt;style type=\"text/css\"&gt; #header&#123; background: url(imgs/header.jpeg) center center / cover no-repeat; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=\"navbar bg-dark navbar-dark\"&gt; &lt;div class=\"container\"&gt; &lt;a href=\"\" class=\"navbar-brand\"&gt;&lt;i class=\"fas fa-binoculars mr-2\"&gt;&lt;/i&gt; Pattern&lt;/a&gt; &lt;/div&gt; &lt;/nav&gt; &lt;section id=\"header\" class=\"jumbotron text-center\"&gt; &lt;h1 class=\"display-3\"&gt;PATTERN&lt;/h1&gt; &lt;p class=\"lead\"&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Maiores, pariatur?&lt;/p&gt; &lt;a href=\"\" class=\"btn btn-primary\"&gt;Do Something&lt;/a&gt; &lt;a href=\"\" class=\"btn btn-success\"&gt;Another Thing&lt;/a&gt; &lt;/section&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接着加入gird以及card 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.4.1/css/all.css\" integrity=\"sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz\" crossorigin=\"anonymous\"&gt; &lt;style&gt; #header &#123; background: url(\"imgs/header.jpeg\"); /* background: url(\"imgs/header.jpeg\") center center / cover no-repeat; */ &#125; &lt;/style&gt; &lt;title&gt;Pattern&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;nav class=\"navbar bg-dark navbar-dark\"&gt; &lt;div class=\"container\"&gt; &lt;a href=\"\" class=\"navbar-brand\"&gt;&lt;i class=\"fas fa-binoculars mr-2\"&gt;&lt;/i&gt; Pattern&lt;/a&gt; &lt;/div&gt; &lt;/nav&gt; &lt;section id=\"header\" class=\"jumbotron text-center\"&gt; &lt;h1 class=\"display-3\"&gt;PATTERN&lt;/h1&gt; &lt;p class=\"lead\"&gt;Lorem ipsum dolor sit, amet consectetur adipisicing elit. Maiores, pariatur?&lt;/p&gt; &lt;a href=\"\" class=\"btn btn-primary\"&gt;Do Something&lt;/a&gt; &lt;a href=\"\" class=\"btn btn-success\"&gt;Another Thing&lt;/a&gt; &lt;/section&gt; &lt;section id=\"gallery\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-4 mb-4\"&gt; &lt;div class=\"card\"&gt; &lt;img class=\"card-img-top\" src=\"imgs/pattern1.jpeg\" alt=\"\"&gt; &lt;div class=\"card-body\"&gt; &lt;h5 class=\"card-title\"&gt;First Thing&lt;/h5&gt; &lt;p class=\"card-text\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Assumenda corrupti quam magnam! Veniam, dolorum facere? Commodi, ut. Et, itaque quam!&lt;/p&gt; &lt;a href=\"\" class=\"btn btn-outline-success btn-sm\"&gt;Download&lt;/a&gt; &lt;a href=\"\" class=\"btn btn-outline-danger btn-sm\"&gt;&lt;i class=\"far fa-heart\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 mb-4\"&gt; &lt;div class=\"card\"&gt; &lt;img class=\"card-img-top\" src=\"imgs/pattern2.jpeg\" alt=\"\"&gt; &lt;div class=\"card-body\"&gt; &lt;h5 class=\"card-title\"&gt;First Thing&lt;/h5&gt; &lt;p class=\"card-text\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Assumenda corrupti quam magnam! Veniam, dolorum facere? Commodi, ut. Et, itaque quam!&lt;/p&gt; &lt;a href=\"\" class=\"btn btn-outline-success btn-sm\"&gt;Download&lt;/a&gt; &lt;a href=\"\" class=\"btn btn-outline-danger btn-sm\"&gt;&lt;i class=\"far fa-heart\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-lg-4 mb-4\"&gt; &lt;div class=\"card\"&gt; &lt;img class=\"card-img-top\" src=\"imgs/pattern3.jpeg\" alt=\"\"&gt; &lt;div class=\"card-body\"&gt; &lt;h5 class=\"card-title\"&gt;First Thing&lt;/h5&gt; &lt;p class=\"card-text\"&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Assumenda corrupti quam magnam! Veniam, dolorum facere? Commodi, ut. Et, itaque quam!&lt;/p&gt; &lt;a href=\"\" class=\"btn btn-outline-success btn-sm\"&gt;Download&lt;/a&gt; &lt;a href=\"\" class=\"btn btn-outline-danger btn-sm\"&gt;&lt;i class=\"far fa-heart\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; flex+ grid grid是一个flex盒子，其部件可以随意移动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Grid + Flexbox&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;h1 class=\"text-center display-4\"&gt;Grid + Flexbox&lt;/h1&gt; &lt;div class=\"row border justify-content-around align-items-center\"&gt; &lt;div class=\"col-sm-3 bg-warning\"&gt; Lorem, ipsum dolor sit amet consectetur adipisicing elit. Dolorem culpa et tempora corporis? Tempora commodi perspiciatis omnis quos ex similique! &lt;/div&gt; &lt;div class=\"col-sm-3 bg-info\"&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Blanditiis tempore minus ad ab, explicabo voluptatem officia. Voluptas sed odio nemo, nostrum cumque dolorem quam, repellat nam porro ex aperiam, ipsa eveniet numquam cupiditate sapiente esse fugiat? Et tempora eveniet inventore voluptates magnam obcaecati quasi, at, consectetur adipisci natus sunt blanditiis. &lt;/div&gt; &lt;div class=\"col-sm-3 bg-warning\"&gt; Lorem, ipsum dolor sit amet consectetur adipisicing elit. Dolorem culpa et tempora corporis? Tempora commodi perspiciatis omnis quos ex similique! &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row border justify-content-center align-items-end\"&gt; &lt;div class=\"col-2 bg-primary align-self-start\"&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Minus, non. &lt;/div&gt; &lt;div class=\"col-2 bg-primary\"&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Minus, non. &lt;/div&gt; &lt;div class=\"col-2 bg-success\"&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Quis perspiciatis earum eius saepe sint, laudantium deleniti, accusantium fugiat aut illo ab consequatur quos fuga aliquid facilis magni sed voluptates impedit! &lt;/div&gt; &lt;div class=\"col-2 bg-primary align-self-start\"&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Minus, non. &lt;/div&gt; &lt;div class=\"col-2 bg-primary\"&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Minus, non. &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row text-center justify-content-between\"&gt; &lt;div class=\"col-md-6 col-lg-5 bg-danger\"&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Hic fugit quisquam libero distinctio blanditiis, error quos architecto velit aut atque. &lt;/div&gt; &lt;div class=\"col-md-6 col-lg-5 bg-danger\"&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Hic fugit quisquam libero distinctio blanditiis, error quos architecto velit aut atque. &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 案例二 效果图 添加导航栏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Google Font --&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Nunito:200,300,400,700\" rel=\"stylesheet\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;!-- Custom CSS --&gt; &lt;link rel=\"stylesheet\" href=\"app.css\"&gt; &lt;title&gt;Museum of Candy&lt;/title&gt; &lt;style type=\"text/css\"&gt; /* 背景颜色 */ body &#123; background: #f5d9d5; font-family: \"Nunito\", sans-serif; &#125; /* 字体 */ #mainNavbar &#123; font-size: 1.5rem; font-weight: 100; &#125; /* 超链接 */ #mainNavbar .nav-link &#123; color: white; &#125; /* 超链接hover */ #mainNavbar .nav-link:hover &#123; color: #EA1C2C; &#125; /* navbar-brand字体 */ #mainNavbar .navbar-brand &#123; color: #EA1C2C; font-size: 1.5rem; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- navbar-expand-md为breakpoint，py-0间隔为0， fixed-top置顶 --&gt; &lt;nav id=\"mainNavbar\" class=\"navbar navbar-dark navbar-expand-md py-0 fixed-top\"&gt; &lt;a href=\"#\" class=\"navbar-brand\"&gt;CANDY&lt;/a&gt; &lt;button class=\"navbar-toggler\" data-toggle=\"collapse\" data-target=\"#navLinks\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navLinks\"&gt; &lt;ul class=\"navbar-nav\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;HOME&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;ABOUT&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;TICKETS&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Google Font --&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Nunito:200,300,400,700\" rel=\"stylesheet\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;!-- Custom CSS --&gt; &lt;link rel=\"stylesheet\" href=\"app.css\"&gt; &lt;title&gt;Museum of Candy&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; background: #f5d9d5; font-family: \"Nunito\", sans-serif; &#125; #mainNavbar &#123; font-size: 1.5rem; font-weight: 100; &#125; #mainNavbar .nav-link &#123; color: white; &#125; #mainNavbar .nav-link:hover &#123; color: #EA1C2C; &#125; #mainNavbar .navbar-brand &#123; color: #EA1C2C; font-size: 1.5rem; &#125; /* 左半框字体大小 */ #headingGroup span &#123; color: #EA1C2C; &#125; #headingGroup h1 &#123; font-weight: 100; font-size: 4rem; &#125;/*当页面小于1200px时，减小字体大小*/@media (max-width: 1200px) &#123; #headingGroup h1 &#123; font-weight: 100; font-size: 3rem; &#125;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav id=\"mainNavbar\" class=\"navbar navbar-dark navbar-expand-md py-0 fixed-top\"&gt; &lt;a href=\"#\" class=\"navbar-brand\"&gt;CANDY&lt;/a&gt; &lt;button class=\"navbar-toggler\" data-toggle=\"collapse\" data-target=\"#navLinks\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navLinks\"&gt; &lt;ul class=\"navbar-nav\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;HOME&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;ABOUT&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;TICKETS&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;section class=\"container-fluid px-0\"&gt; &lt;!-- 使用flex，align-items-center在y轴居中 --&gt; &lt;div class=\"row align-items-center\"&gt; &lt;div class=\"col-lg-6\"&gt; &lt;!-- text-center字体居中 d-none为屏幕比较小时隐藏，d-lg-block当页面变大时显示 --&gt; &lt;div id=\"headingGroup\" class=\"text-white text-center d-none d-lg-block mt-5\"&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- img-fluid为响应式，适应盒子大小 --&gt; &lt;div class=\"col-lg-6\"&gt; &lt;img class=\"img-fluid\" src=\"imgs/hand2.png\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 内容2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Google Font --&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Nunito:200,300,400,700\" rel=\"stylesheet\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\" integrity=\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\" crossorigin=\"anonymous\"&gt; &lt;!-- Custom CSS --&gt; &lt;link rel=\"stylesheet\" href=\"app.css\"&gt; &lt;title&gt;Museum of Candy&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; background: #f5d9d5; font-family: \"Nunito\", sans-serif; &#125; #mainNavbar &#123; font-size: 1.5rem; font-weight: 100; &#125; #mainNavbar .nav-link &#123; color: white; &#125; #mainNavbar .nav-link:hover &#123; color: #EA1C2C; &#125; #mainNavbar .navbar-brand &#123; color: #EA1C2C; font-size: 1.5rem; &#125; #headingGroup span &#123; color: #EA1C2C; &#125; #headingGroup h1 &#123; font-weight: 100; font-size: 4rem; &#125;/*内容的margin*/.content &#123; margin-top: 100px; margin-bottom: 100px;&#125;/*内容的字体颜色与大小*/ .blurb h2 &#123; color: #EA1C2C; font-weight: 100; font-size: 2.5rem;&#125;.blurb p &#123; color: #f498b8; font-weight: 100; font-size: 1.125rem; line-height: 2;&#125;/*当页面小于1200px时，减小字体大小*/@media (max-width: 1200px) &#123; #headingGroup h1 &#123; font-weight: 100; font-size: 3rem; &#125;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav id=\"mainNavbar\" class=\"navbar navbar-dark navbar-expand-md py-0 fixed-top\"&gt; &lt;a href=\"#\" class=\"navbar-brand\"&gt;CANDY&lt;/a&gt; &lt;button class=\"navbar-toggler\" data-toggle=\"collapse\" data-target=\"#navLinks\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navLinks\"&gt; &lt;ul class=\"navbar-nav\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;HOME&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;ABOUT&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a href=\"\" class=\"nav-link\"&gt;TICKETS&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;section class=\"container-fluid px-0\"&gt; &lt;div class=\"row align-items-center\"&gt; &lt;div class=\"col-lg-6\"&gt; &lt;!-- d-none为屏幕比较小时隐藏，d-lg-block当页面变大时显示 --&gt; &lt;div id=\"headingGroup\" class=\"text-white text-center d-none d-lg-block mt-5\"&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;h1 class=\"\"&gt;MUSEUM&lt;span&gt;/&lt;/span&gt;OF&lt;span&gt;/&lt;/span&gt;CANDY&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- img-fluid为响应式，适应盒子大小 --&gt; &lt;div class=\"col-lg-6\"&gt; &lt;img class=\"img-fluid\" src=\"imgs/hand2.png\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 第二个 --&gt; &lt;div class=\"row align-items-center content\"&gt; &lt;div class=\"col-md-6 text-center\"&gt; &lt;div class=\"row justify-content-center\"&gt; &lt;div class=\"col-10 col-lg-8 blurb mb-5 mb-md-0\"&gt; &lt;h2&gt;MUSEUM OF CANDY&lt;/h2&gt; &lt;img src=\"imgs/lolli_icon.png\" alt=\"\" class=\"d-none d-lg-inline\"&gt; &lt;p class=\"lead\"&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Neque, iste molestiae beatae, maiores deserunt in voluptatibus aspernatur architecto excepturi delectus soluta? Ipsa, deleniti dolorem hic consequatur repellat eveniet quidem voluptate necessitatibus dolorum delectus minus vitae, ut, veritatis sint ipsum magnam autem nam ex deserunt debitis eaque ratione! Nobis, quidem assumenda.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-6\"&gt; &lt;img src=\"imgs/gumball.png\" alt=\"\" class=\"img-fluid\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 第三个 --&gt; &lt;!-- 当breakpoint大道md后，反转两者的位置 order-2 order-md-1 --&gt; &lt;div class=\"row align-items-center content\"&gt; &lt;div class=\"col-md-6 order-2 order-md-1\"&gt; &lt;img src=\"imgs/sprinkles.png\" alt=\"\" class=\"img-fluid\"&gt; &lt;/div&gt; &lt;div class=\"col-md-6 text-center order-1 order-md-2\"&gt; &lt;div class=\"row justify-content-center\"&gt; &lt;div class=\"col-10 col-lg-8 blurb mb-5 mb-md-0\"&gt; &lt;h2&gt;MUSEUM OF CANDY&lt;/h2&gt; &lt;img src=\"imgs/lolli_icon.png\" alt=\"\" class=\"d-none d-lg-inline\"&gt; &lt;p class=\"lead\"&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Neque, iste molestiae beatae, maiores deserunt in voluptatibus aspernatur architecto excepturi delectus soluta? Ipsa, deleniti dolorem hic consequatur repellat eveniet quidem voluptate necessitatibus dolorum delectus minus vitae, ut, veritatis sint ipsum magnam autem nam ex deserunt debitis eaque ratione! Nobis, quidem assumenda.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;!-- Optional JavaScript --&gt; &lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.slim.min.js\" integrity=\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\" integrity=\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\" integrity=\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 添加js 当页面滑动时，导航栏换颜色 12","categories":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://dreamerjonson.com/categories/bootstrap/"}],"tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"https://dreamerjonson.com/tags/bootstrap/"}]},{"title":"区块链用例","slug":"use-blockchain","date":"2018-12-24T07:49:44.000Z","updated":"2018-12-24T15:53:34.553Z","comments":true,"path":"2018/12/24/use-blockchain/","link":"","permalink":"https://dreamerjonson.com/2018/12/24/use-blockchain/","excerpt":"","text":"Civil旨在使记者及其支持者能够更直接，更透明地引入新的资助模式。构建使记者能够专注于为读者提供新闻服务的生态系统。 网址：https://civil.co/ In an interview in 2015, Vitalik Buterin founder of the Ethereum Platform said: “Whereas most technologies tend to automate workers on the periphery doing menial tasks, blockchains automate away the center. Instead of putting the taxi driver out of a job, blockchain puts Uber out of a job and lets the taxi drivers work with the customer directly.” DAV是一个开源软件平台，允许任何人在分散的市场中购买或出售运输服务。 DAV集成到任何交通工具（汽车，无人机，船舶）中，使这些车辆能够相互发现，交流和交易。 网址：https://dav.network/ 解决传统区块链的隐私性以及扩展性 网址：https://enigma.co/ 区块链可以为捐赠者提供捐赠使用的完全透明度。慈善机构可以使用这项技术接受和记录交易，而无需第三方，从而提高效率，节省成本并增加捐助者的信任。项目的一个例子：ALICE alice利用区块链技术向捐赠者展示他们的钱所产生的影响。 捐赠者可以冻结他们的捐款，直到他们选择的慈善机构能够证明他们已经实现了他们的捐赠目标。使用此工具，您将确保捐助的钱被使用到了正确的地方，或者您将获得退款。 网址：https://alice.si/ 对于全世界的小企业和企业家而言，获得信贷始终是一项巨大的挑战。 在发展中国家，这导致无法获得传统金融服务或仅以过高的利率提供当地现金贷款。 实现这些投资是这些社区发展的基础。 空间项目的一个例子：Ethichub EthicHub旨在实现财务民主化，为每个人提供信贷和投资机会。 小型和无银行账户的生产者可以从较低的利率和更多的流动性中受益，这将使他们能够提高生产率，增加利润并带来更好的生活质量。 网址：https://ethichub.com/ 能源部门正在通过区块链和物联网项目蓬勃发展。 交易的完全透明性使得结算速度接近实时，同时减少中间人数量，简化流程并最终提高运营效率。 有些项目可以利用采矿设备产生的余热来为家庭，游泳池甚至鱼类和植物农场供暖！ 一个有趣的项目：Power Ledger Power Ledger的使命是让世界各地的个人和社区能够获得低成本，可靠和可再生的电力。 该项目利用区块链技术，允许买家选择他们想要使用的电力来源和产生剩余电力的家庭，以便与邻居进行交易，获得公平的回报。 网址：https://www.powerledger.io/ 2017年，世界银行估计全球有超过10亿人无法正式证明自己的身份，这对于获得医疗保健，教育，金融和其他基本服务至关重要。同样，金融包容性被视为减少贫困的关键，但全球仍有20亿人没有银行账户。这使他们无法安全地交易金钱，获取保险或建立信用记录以供将来借款。 区块链可以帮助提供数字身份，消除汇款剽窃，防止人口贩运，并提供一种在通货膨胀率达到不可持续水平的国家储值的方法。 Building Blocks是联合国世界粮食计划署推出的一个项目，该项目利用眼睛扫描和区块链技术相结合，使难民营中的现金转移更快，更便宜，更安全。 在该项目的发明者MIT技术评论的采访中，Houman Haddad解释了他的愿景：“使用这种系统的叙利亚难民可以重新获得在他们逃离家园时丢失的文件和资产的合法身份。在这种情况下，难民可以很容易地证明他的教育证书，证明他与子女的关系，并获得贷款来创业。“ VoteWatcher由Nick Spanos创立，其使命是通过提供世界上技术最先进，最可靠和最安全的投票机制，为现代选举系统带来完全的透明度并赋予每个声音权力。 网址：http://votewatcher.com/ 今年早些时候，联合国宣布帮助建立一个名为Climate Chain Coalition（CCC）的新组织。 该全球倡议旨在支持成员之间的合作，推进区块链，以帮助动员气候融资 网址：https://www.climatechaincoalition.io/","categories":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}]},{"title":"go实现区块链[2]-整合默克尔树+POW","slug":"gobuildblockchain-2-merklePOW","date":"2018-12-16T14:17:56.000Z","updated":"2018-12-16T14:30:49.333Z","comments":true,"path":"2018/12/16/gobuildblockchain-2-merklePOW/","link":"","permalink":"https://dreamerjonson.com/2018/12/16/gobuildblockchain-2-merklePOW/","excerpt":"","text":"添加merkleRoot merkleTree.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport \"crypto/sha256\"//默克尔树节点type MerkleTree struct&#123; RootNode *MerkleNode&#125;//默克尔根节点type MerkleNode struct&#123; Left *MerkleNode Right *MerkleNode Data []byte&#125;//生成默克尔树中的节点，如果是叶子节点，则Left，right为nil ，如果为非叶子节点，根据Left，right生成当前节点的hashfunc NewMerkleNode(left,right *MerkleNode,data []byte) *MerkleNode&#123; mnode := MerkleNode&#123;&#125; if left ==nil &amp;&amp; right==nil&#123; mnode.Data = data &#125;else&#123; prevhashes := append(left.Data,right.Data...) firsthash:= sha256.Sum256(prevhashes) hash:=sha256.Sum256(firsthash[:]) mnode.Data = hash[:] &#125; mnode.Left = left mnode.Right = right return &amp;mnode&#125;//构建默克尔树func NewMerkleTree(data [][]byte) *MerkleTree&#123; var nodes []MerkleNode //构建叶子节点。 for _,datum := range data&#123; node:= NewMerkleNode(nil,nil,datum) nodes = append(nodes,*node) &#125; //j代表的是某一层的第一个元素 j:=0 //第一层循环代表 nSize代表某一层的个数，每循环一次减半 for nSize :=len(data);nSize &gt;1;nSize = (nSize+1)/2&#123; //第二条循环i+=2代表两两拼接。 i2是为了当个数是基数的时候，拷贝最后的元素。 for i:=0 ; i&lt;nSize ;i+=2&#123; i2 := min(i+1,nSize-1) node := NewMerkleNode(&amp;nodes[j+i],&amp;nodes[j+i2],nil) nodes = append(nodes,*node) &#125; //j代表的是某一层的第一个元素 j+=nSize &#125; mTree := MerkleTree&#123;&amp;(nodes[len(nodes)-1])&#125; return &amp;mTree&#125; 根据交易创建merkleROOT 12345678910111213func (b*Block) createMerkelTreeRoot(transations []*Transation)&#123; var tranHash [][]byte for _,tx:= range transations&#123; tranHash = append(tranHash,tx.Hash()) &#125; mTree := NewMerkleTree(tranHash) b.Merkleroot = mTree.RootNode.Data&#125; 测试merkle 123456789101112131415161718192021222324252627282930313233func TestCreateMerkleTreeRoot()&#123; //初始化区块 block := &amp;Block&#123; 2, []byte&#123;&#125;, []byte&#123;&#125;, []byte&#123;&#125;, 1418755780, 404454260, 0, []*Transation&#123;&#125;, &#125; txin := TXInput&#123;[]byte&#123;&#125;,-1,nil&#125; txout := NewTXOutput(subsidy,\"first\") tx := Transation&#123;nil,[]TXInput&#123;txin&#125;,[]TXOutput&#123;*txout&#125;&#125; txin2 := TXInput&#123;[]byte&#123;&#125;,-1,nil&#125; txout2 := NewTXOutput(subsidy,\"second\") tx2 := Transation&#123;nil,[]TXInput&#123;txin2&#125;,[]TXOutput&#123;*txout2&#125;&#125; var Transations []*Transation Transations = append(Transations,&amp;tx,&amp;tx2) block.createMerkelTreeRoot(Transations) fmt.Printf(\"%x\\n\",block.Merkleroot)&#125; 增加挖矿逻辑 proofofwork.go: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( \"math/big\" \"bytes\" \"crypto/sha256\")type ProofOfWork struct&#123; block * Block tartget * big.Int&#125;const targetBits = 16func NewProofofWork(b*Block) * ProofOfWork&#123; target := big.NewInt(1) target.Lsh(target,uint(256-targetBits)) pow := &amp;ProofOfWork&#123;b,target&#125; return pow&#125;func (pow * ProofOfWork) prepareData(nonce int32) []byte&#123; data := bytes.Join( [][]byte&#123; IntToHex(pow.block.Version), pow.block.PrevBlockHash, pow.block.Merkleroot, IntToHex(pow.block.Time), IntToHex(pow.block.Bits), IntToHex(nonce)&#125;, []byte&#123;&#125;, ) return data&#125;func (pow * ProofOfWork) Run() (int32,[]byte)&#123; var nonce int32 var secondhash [32]byte nonce = 0 var currenthash big.Int for nonce &lt; maxnonce&#123; //序列化 data:= pow.prepareData(nonce) //double hash fitstHash := sha256.Sum256(data) secondhash = sha256.Sum256(fitstHash[:]) // fmt.Printf(\"%x\\n\",secondhash) currenthash.SetBytes(secondhash[:]) //比较 if currenthash.Cmp(pow.tartget) == -1&#123; break &#125;else&#123; nonce++ &#125; &#125; return nonce,secondhash[:]&#125;func (pow * ProofOfWork) Validate() bool&#123; var hashInt big.Int data:=pow.prepareData(pow.block.Nonce) fitstHash := sha256.Sum256(data) secondhash := sha256.Sum256(fitstHash[:]) hashInt.SetBytes(secondhash[:]) isValid:= hashInt.Cmp(pow.tartget) == -1 return isValid&#125; 测试： 12345678910111213141516171819202122func TestPow()&#123; //初始化区块 block := &amp;Block&#123; 2, []byte&#123;&#125;, []byte&#123;&#125;, []byte&#123;&#125;, 1418755780, 404454260, 0, []*Transation&#123;&#125;, &#125; pow:=NewProofofWork(block) nonce,_:= pow.Run() block.Nonce = nonce fmt.Println(\"POW:\",pow.Validate())&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go实现区块链[1]-block","slug":"gobuildblockchain-1-block","date":"2018-12-16T13:54:50.000Z","updated":"2018-12-16T14:16:47.171Z","comments":true,"path":"2018/12/16/gobuildblockchain-1-block/","link":"","permalink":"https://dreamerjonson.com/2018/12/16/gobuildblockchain-1-block/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546//定义区块结构体type Block struct&#123; Version int32 PrevBlockHash []byte Merkleroot []byte Hash []byte Time int32 Bits int32 Nonce int32&#125;//序列化func (b* Block) Serialize() []byte&#123; var encoded bytes.Buffer enc:= gob.NewEncoder(&amp;encoded) err:= enc.Encode(b) if err!=nil&#123; log.Panic(err) &#125; return encoded.Bytes()&#125;//反序列化func DeserializeBlock(d []byte) *Block&#123; var block Block decode :=gob.NewDecoder(bytes.NewReader(d)) err := decode.Decode(&amp;block) if err!=nil&#123; log.Panic(err) &#125; return &amp;block&#125;//打印区块func (b*Block)String()&#123; fmt.Printf(\"version:%s\\n\",strconv.FormatInt(int64(b.Version),10)) fmt.Printf(\"Prev.BlockHash:%x\\n\",b.PrevBlockHash) fmt.Printf(\"Prev.merkleroot:%x\\n\",b.Merkleroot) fmt.Printf(\"Prev.Hash:%x\\n\",b.Hash) fmt.Printf(\"Time:%s\\n\",strconv.FormatInt(int64(b.Time),10)) fmt.Printf(\"Bits:%s\\n\",strconv.FormatInt(int64(b.Bits),10)) fmt.Printf(\"nonce:%s\\n\",strconv.FormatInt(int64(b.Nonce),10))&#125; 打印区块、测试序列化 1234567891011121314151617181920func TestNewSerialize()&#123; //初始化区块 block := &amp;Block&#123; 2, []byte&#123;&#125;, []byte&#123;&#125;, []byte&#123;&#125;, 1418755780, 404454260, 0, []*Transation&#123;&#125;, &#125; deBlock:=DeserializeBlock(block.Serialize()) deBlock.String()&#125; 添加交易 transition.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package mainimport ( \"fmt\" \"strings\" \"bytes\" \"encoding/gob\" \"log\" \"crypto/sha256\")//挖矿奖励const subsidy = 100//交易type Transation struct&#123; ID []byte Vin []TXInput Vout []TXOutput&#125;//输入type TXInput struct &#123; TXid []byte Voutindex int Signature []byte&#125;//输出type TXOutput struct &#123; value int PubkeyHash []byte&#125;//打印func (tx Transation) String() string &#123; var lines []string lines = append(lines, fmt.Sprintf(\"--- Transaction %x:\", tx.ID)) for i, input := range tx.Vin &#123; lines = append(lines, fmt.Sprintf(\" Input %d:\", i)) lines = append(lines, fmt.Sprintf(\" TXID: %x\", input.TXid)) lines = append(lines, fmt.Sprintf(\" Out: %d\", input.Voutindex)) lines = append(lines, fmt.Sprintf(\" Signature: %x\", input.Signature)) &#125; for i, output := range tx.Vout &#123; lines = append(lines, fmt.Sprintf(\" Output %d:\", i)) lines = append(lines, fmt.Sprintf(\" Value: %d\", output.value)) lines = append(lines, fmt.Sprintf(\" Script: %x\", output.PubkeyHash)) &#125; return strings.Join(lines, \"\\n\")&#125;//序列化func (tx Transation) Serialize() []byte&#123; var encoded bytes.Buffer enc:= gob.NewEncoder(&amp;encoded) err:= enc.Encode(tx) if err!=nil&#123; log.Panic(err) &#125; return encoded.Bytes()&#125;//计算交易的hash值func (tx *Transation) Hash() []byte&#123; txcopy := *tx txcopy.ID = []byte&#123;&#125; hash:= sha256.Sum256(txcopy.Serialize()) return hash[:]&#125;//根据金额与地址新建一个输出func NewTXOutput(value int,address string) * TXOutput&#123; txo := &amp;TXOutput&#123;value,nil&#125; txo.PubkeyHash = []byte(address) return txo&#125;//第一笔coinbase交易func NewCoinbaseTX(to string) *Transation&#123; txin := TXInput&#123;[]byte&#123;&#125;,-1,nil&#125; txout := NewTXOutput(subsidy,to) tx:= Transation&#123;nil,[]TXInput&#123;txin&#125;,[]TXOutput&#123;*txout&#125;&#125; tx.ID = tx.Hash() return &amp;tx&#125; 工具类 utils.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"bytes\" \"encoding/binary\" \"log\")//计算两个数的最小值func min(a int,b int) int&#123; if(a&gt;b)&#123; return b &#125; return a&#125;//将类型转化为了字节数组,小端func IntToHex(num int32) []byte&#123; buff := new(bytes.Buffer) //binary.LittleEndian 小端模式 err:= binary.Write(buff,binary.LittleEndian,num) if err!=nil&#123; log.Panic(err) &#125; return buff.Bytes()&#125;//将类型转化为了字节数组，大端func IntToHex2(num int32) []byte&#123; buff := new(bytes.Buffer) //binary.LittleEndian 小端模式 err:= binary.Write(buff,binary.BigEndian,num) if err!=nil&#123; log.Panic(err) &#125; return buff.Bytes()&#125;//字节反转func ReverseBytes(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125; 修改区块 block.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//增加交易type Block struct&#123; Version int32 PrevBlockHash []byte Merkleroot []byte Hash []byte Time int32 Bits int32 Nonce int32 Transations []*Transation&#125;//根据前一个hash增加区块func NewBlock(prevBlockHash []byte) * Block&#123; block := &amp;Block&#123; 2, prevBlockHash, []byte&#123;&#125;, []byte&#123;&#125;, int32(time.Now().Unix()), 404454260, 0, []*Transation&#123;&#125;, &#125; pow := NewProofofWork(block) nonce,hash := pow.Run() block.Hash = hash block.Nonce = nonce return block&#125;//创世区块func NewGensisBlock() * Block&#123; block := &amp;Block&#123; 2, []byte&#123;&#125;, []byte&#123;&#125;, []byte&#123;&#125;, int32(time.Now().Unix()), 404454260, 0, []*Transation&#123;&#125;, &#125; pow:=NewProofofWork(block) nonce,hash:=pow.Run() block.Nonce = nonce block.Hash = hash //block.String() return block&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go实现区块链[4]-遍历区块链与数据库持久化(下)","slug":"gobuildblockchain-4-iterator","date":"2018-12-16T13:31:31.000Z","updated":"2018-12-16T14:30:09.253Z","comments":true,"path":"2018/12/16/gobuildblockchain-4-iterator/","link":"","permalink":"https://dreamerjonson.com/2018/12/16/gobuildblockchain-4-iterator/","excerpt":"","text":"遍历区块链 blockchain.go完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package mainimport ( \"github.com/boltdb/bolt\" \"log\" \"fmt\")const dbFile = \"blockchain.db\"const blockBucket = \"blocks\"type Blockchain struct&#123; tip []byte //最近的一个区块的hash值 db * bolt.DB&#125;type BlockChainIterateor struct&#123; currenthash []byte db * bolt.DB&#125;func (bc * Blockchain) AddBlock()&#123; var lasthash []byte err := bc.db.View(func(tx * bolt.Tx) error&#123; b:= tx.Bucket([]byte(blockBucket)) lasthash = b.Get([]byte(\"l\")) return nil &#125;) if err!=nil&#123; log.Panic(err) &#125; newBlock := NewBlock(lasthash) bc.db.Update(func(tx *bolt.Tx) error &#123; b:=tx.Bucket([]byte(blockBucket)) err:= b.Put(newBlock.Hash,newBlock.Serialize()) if err!=nil&#123; log.Panic(err) &#125; err = b.Put([]byte(\"l\"),newBlock.Hash) if err!=nil&#123; log.Panic(err) &#125; bc.tip = newBlock.Hash return nil &#125;)&#125;func NewBlockchain() * Blockchain&#123; var tip []byte db,err := bolt.Open(dbFile,0600,nil) if err!=nil&#123; log.Panic(err) &#125; err = db.Update(func(tx * bolt.Tx) error&#123; b:= tx.Bucket([]byte(blockBucket)) if b==nil&#123; fmt.Println(\"区块链不存在，创建一个新的区块链\") genesis := NewGensisBlock() b,err:=tx.CreateBucket([]byte(blockBucket)) if err!=nil&#123; log.Panic(err) &#125; err = b.Put(genesis.Hash,genesis.Serialize()) if err!=nil&#123; log.Panic(err) &#125; err = b.Put([]byte(\"l\"),genesis.Hash) tip = genesis.Hash &#125;else&#123; tip = b.Get([]byte(\"l\")) &#125; return nil &#125;) if err!=nil&#123; log.Panic(err) &#125; bc:=Blockchain&#123;tip,db&#125; return &amp;bc&#125;func (bc * Blockchain) iterator() * BlockChainIterateor&#123; bci := &amp;BlockChainIterateor&#123;bc.tip,bc.db&#125; return bci&#125;func (i * BlockChainIterateor) Next() * Block&#123; var block *Block err:= i.db.View(func(tx *bolt.Tx) error &#123; b:=tx.Bucket([]byte(blockBucket)) deblock := b.Get(i.currenthash) block = DeserializeBlock(deblock) return nil &#125;) if err!=nil&#123; log.Panic(err) &#125; i.currenthash = block.PrevBlockHash return block&#125;func (bc * Blockchain) printBlockchain()&#123; bci:=bc.iterator() for&#123; block:= bci.Next() block.String() fmt.Println() //fmt.Printf(\"长度：%d\\n\",len(block.PrevBlockHash)) if len(block.PrevBlockHash)==0&#123; break &#125; &#125;&#125; 测试 12345678910func TestBoltDB()&#123; blockchain := NewBlockchain() blockchain.AddBlock() blockchain.AddBlock() blockchain.printBlockchain()&#125;func main()&#123; TestBoltDB()&#125; 第一次执行执行： go build . ./buildingBlockChain 123456789101112131415161718192021222324区块链不存在，创建一个新的区块链version:2Prev.BlockHash:0000349e762f37b4f79f23c5270066cb2963610f5a6c999a846b781cec3152bcPrev.merkleroot:Prev.Hash:0000deb768a8e6c520081051d28756578c4c666bde404ff282d7a8e41a1e0107Time:1544966755Bits:404454260nonce:13075version:2Prev.BlockHash:0000fdcb6bd475c8275ab47ac6d8d97ab2644ae33d574a914d36f9c1024099ebPrev.merkleroot:Prev.Hash:0000349e762f37b4f79f23c5270066cb2963610f5a6c999a846b781cec3152bcTime:1544966755Bits:404454260nonce:142155version:2Prev.BlockHash:Prev.merkleroot:Prev.Hash:0000fdcb6bd475c8275ab47ac6d8d97ab2644ae33d574a914d36f9c1024099ebTime:1544966755Bits:404454260nonce:105247 再次执行./buildingBlockChain 123456789101112131415161718192021222324252627282930313233343536373839version:2Prev.BlockHash:0000c336d1f0284faac173c1d68ca196b3f2e94684d12f201b2610aca39acc7bPrev.merkleroot:Prev.Hash:0000a00ab59ad06d7c5d29e9769171676705c270d9edb1e5bd4b39da41e0d40cTime:1544966858Bits:404454260nonce:67063version:2Prev.BlockHash:0000deb768a8e6c520081051d28756578c4c666bde404ff282d7a8e41a1e0107Prev.merkleroot:Prev.Hash:0000c336d1f0284faac173c1d68ca196b3f2e94684d12f201b2610aca39acc7bTime:1544966858Bits:404454260nonce:69856version:2Prev.BlockHash:0000349e762f37b4f79f23c5270066cb2963610f5a6c999a846b781cec3152bcPrev.merkleroot:Prev.Hash:0000deb768a8e6c520081051d28756578c4c666bde404ff282d7a8e41a1e0107Time:1544966755Bits:404454260nonce:13075version:2Prev.BlockHash:0000fdcb6bd475c8275ab47ac6d8d97ab2644ae33d574a914d36f9c1024099ebPrev.merkleroot:Prev.Hash:0000349e762f37b4f79f23c5270066cb2963610f5a6c999a846b781cec3152bcTime:1544966755Bits:404454260nonce:142155version:2Prev.BlockHash:Prev.merkleroot:Prev.Hash:0000fdcb6bd475c8275ab47ac6d8d97ab2644ae33d574a914d36f9c1024099ebTime:1544966755Bits:404454260nonce:105247","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go实现区块链[3]-遍历区块链与数据库持久化","slug":"gobuildblockchain-3-boltDB","date":"2018-12-16T12:18:16.000Z","updated":"2018-12-16T14:26:28.543Z","comments":true,"path":"2018/12/16/gobuildblockchain-3-boltDB/","link":"","permalink":"https://dreamerjonson.com/2018/12/16/gobuildblockchain-3-boltDB/","excerpt":"","text":"新建blockchain.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package mainimport ( \"github.com/boltdb/bolt\" \"log\" \"fmt\")const dbFile = \"blockchain.db\"const blockBucket = \"blocks\"type Blockchain struct&#123; tip []byte //最近的一个区块的hash值 db * bolt.DB&#125;func (bc * Blockchain) AddBlock()&#123; var lasthash []byte err := bc.db.View(func(tx * bolt.Tx) error&#123; b:= tx.Bucket([]byte(blockBucket)) lasthash = b.Get([]byte(\"l\")) return nil &#125;) if err!=nil&#123; log.Panic(err) &#125; newBlock := NewBlock(lasthash) bc.db.Update(func(tx *bolt.Tx) error &#123; b:=tx.Bucket([]byte(blockBucket)) err:= b.Put(newBlock.Hash,newBlock.Serialize()) if err!=nil&#123; log.Panic(err) &#125; err = b.Put([]byte(\"l\"),newBlock.Hash) if err!=nil&#123; log.Panic(err) &#125; bc.tip = newBlock.Hash return nil &#125;)&#125;func NewBlockchain() * Blockchain&#123; var tip []byte db,err := bolt.Open(dbFile,0600,nil) if err!=nil&#123; log.Panic(err) &#125; err = db.Update(func(tx * bolt.Tx) error&#123; b:= tx.Bucket([]byte(blockBucket)) if b==nil&#123; fmt.Println(\"区块链不存在，创建一个新的区块链\") genesis := NewGensisBlock() b,err:=tx.CreateBucket([]byte(blockBucket)) if err!=nil&#123; log.Panic(err) &#125; err = b.Put(genesis.Hash,genesis.Serialize()) if err!=nil&#123; log.Panic(err) &#125; err = b.Put([]byte(\"l\"),genesis.Hash) tip = genesis.Hash &#125;else&#123; tip = b.Get([]byte(\"l\")) &#125; return nil &#125;) if err!=nil&#123; log.Panic(err) &#125; bc:=Blockchain&#123;tip,db&#125; return &amp;bc&#125; 增加newBlock的方法，根据前一个区块的hash创建区块： 12345678910111213141516171819202122func NewBlock(prevBlockHash []byte) * Block&#123; block := &amp;Block&#123; 2, prevBlockHash, []byte&#123;&#125;, []byte&#123;&#125;, int32(time.Now().Unix()), 404454260, 0, []*Transation&#123;&#125;, &#125; pow := NewProofofWork(block) nonce,hash := pow.Run() block.Hash = hash block.Nonce = nonce return block&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"css-关于字体的使用+ 谷歌字体","slug":"css-font","date":"2018-12-16T08:50:52.000Z","updated":"2018-12-30T13:15:31.769Z","comments":true,"path":"2018/12/16/css-font/","link":"","permalink":"https://dreamerjonson.com/2018/12/16/css-font/","excerpt":"","text":"源文件 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Fonts&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Fonts Demo Page&lt;/h1&gt;asjdhaklsdjasdkljalsd&lt;p&gt;Bacon ipsum dolor amet short loin &lt;span&gt;strip steak&lt;/span&gt; leberkas ribeye beef pork loin pork belly drumstick frankfurter. Corned beef ball tip pork belly pig sirloin, ham hock chuck cow fatback strip steak meatloaf. Biltong swine ball tip kielbasa picanha pork chop bacon pork boudin rump ribeye pig. Shoulder ribeye drumstick short ribs pork loin venison. Chuck andouille turducken, kielbasa t-bone short ribs beef ribs turkey doner swine pork chop biltong.&lt;/p&gt;&lt;p&gt;Shoulder shank bacon salami flank tenderloin. Ground round pig hamburger, jerky bacon meatball chuck pancetta kielbasa bresaola turkey prosciutto. Prosciutto hamburger shank brisket strip steak turducken picanha ground round chicken. Tenderloin shank chicken ham hock, pork chop ball tip pork belly jowl porchetta. Strip steak cupim tenderloin pastrami rump shoulder filet mignon tri-tip.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; CSS文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*font-family*//*https://www.cssfontstack.com/*/p &#123; font-family: Arial;&#125;h1 &#123; font-family: Georgia;&#125;/*font-size*/body &#123; font-size: 10px;&#125;/*相对于母亲元素的倍数*/h1 &#123; font-size: 5.0em;&#125;p &#123; font-size: 2.0em;&#125;span &#123; font-size: 2.0em;&#125;/*font-weight*/p&#123; font-weight: normal;&#125;/*line-height 类似于word的1.5倍行距*/p &#123; line-height: 1.5;&#125;/*text-align*/h1 &#123; text-align: right;&#125;p &#123; text-align: center;&#125;/*text-decoration*/p &#123; text-decoration: underline;&#125;/*贯穿线*/h1 &#123; text-decoration: line-through;&#125; 谷歌字体的使用 指导：https://fonts.google.com/ 使用的一个例子 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Fonts&lt;/title&gt; &lt;link href=\"https://fonts.googleapis.com/css?family=Charm\" rel=\"stylesheet\"&gt; &lt;style type=\"text/css\"&gt; /*font-family*//*https://www.cssfontstack.com/*/p &#123; font-family: Arial;&#125;h1 &#123; font-family: 'Charm', cursive;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Fonts Demo Page&lt;/h1&gt;asjdhaklsdjasdkljalsd&lt;p&gt;Bacon ipsum dolor amet short loin &lt;span&gt;strip steak&lt;/span&gt; leberkas ribeye beef pork loin pork belly drumstick frankfurter. Corned beef ball tip pork belly pig sirloin, ham hock chuck cow fatback strip steak meatloaf. Biltong swine ball tip kielbasa picanha pork chop bacon pork boudin rump ribeye pig. Shoulder ribeye drumstick short ribs pork loin venison. Chuck andouille turducken, kielbasa t-bone short ribs beef ribs turkey doner swine pork chop biltong.&lt;/p&gt;&lt;p&gt;Shoulder shank bacon salami flank tenderloin. Ground round pig hamburger, jerky bacon meatball chuck pancetta kielbasa bresaola turkey prosciutto. Prosciutto hamburger shank brisket strip steak turducken picanha ground round chicken. Tenderloin shank chicken ham hock, pork chop ball tip pork belly jowl porchetta. Strip steak cupim tenderloin pastrami rump shoulder filet mignon tri-tip.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; fontawesome awesomeCDN：https://fontawesome.com/start 网站：https://fontawesome.com 字体大小：https://fontawesome.com/how-to-use/on-the-web/styling/sizing-icons 使用例子： 123&lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.6.3/css/all.css\" integrity=\"sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/\" crossorigin=\"anonymous\"&gt;&lt;!-- fa-2x为两倍大小 --&gt;&lt;i class=\"far fa-thumbs-up fa-2x\"&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"https://dreamerjonson.com/tags/css/"}]},{"title":"【置顶】— 写给读者悄悄话","slug":"Whisper","date":"2018-12-14T02:49:44.000Z","updated":"2020-02-16T02:43:35.102Z","comments":true,"path":"2018/12/14/Whisper/","link":"","permalink":"https://dreamerjonson.com/2018/12/14/Whisper/","excerpt":"","text":"公众号:唯识相链 来关注我吧~","categories":[{"name":"置顶","slug":"置顶","permalink":"https://dreamerjonson.com/categories/%E7%BD%AE%E9%A1%B6/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"https://dreamerjonson.com/tags/%E7%BD%AE%E9%A1%B6/"}]},{"title":"go语言渐入佳境[47]-区块链-比特币交易","slug":"golang-47-blockchain-transation","date":"2018-12-13T08:29:58.000Z","updated":"2019-02-04T08:33:38.202Z","comments":true,"path":"2018/12/13/golang-47-blockchain-transation/","link":"","permalink":"https://dreamerjonson.com/2018/12/13/golang-47-blockchain-transation/","excerpt":"","text":"比特币的交易 第一笔交易比较特殊，他是coinbase交易，矿工的收益。 金额每4年减少一半，从2009年一开始一个区块奖励50BTC、后来减少为了25个BTC、一直到18年 12.5BTC。总共有2100万BTC。 交易和我们的银行的转账非常不同，比特币中没有记录账户的信息、而是交易的信息。 go实现交易 demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package mainimport ( \"bytes\" \"encoding/gob\" \"log\" \"crypto/sha256\" \"fmt\" \"strings\")const subsidy = 100type Transation struct&#123; ID []byte Vin []TXInput Vout []TXOutput&#125; type TXInput struct &#123; TXid []byte Voutindex int Signature []byte &#125;type TXOutput struct &#123; value int PubkeyHash []byte&#125;//格式化打印交易完整信息func (tx Transation) String() string &#123; var lines []string lines = append(lines, fmt.Sprintf(\"--- Transaction %x:\", tx.ID)) for i, input := range tx.Vin &#123; lines = append(lines, fmt.Sprintf(\" Input %d:\", i)) lines = append(lines, fmt.Sprintf(\" TXID: %x\", input.TXid)) lines = append(lines, fmt.Sprintf(\" Out: %d\", input.Voutindex)) lines = append(lines, fmt.Sprintf(\" Signature: %x\", input.Signature)) &#125; for i, output := range tx.Vout &#123; lines = append(lines, fmt.Sprintf(\" Output %d:\", i)) lines = append(lines, fmt.Sprintf(\" Value: %d\", output.value)) lines = append(lines, fmt.Sprintf(\" Script: %x\", output.PubkeyHash)) &#125; return strings.Join(lines, \"\\n\")&#125;//序列化func (tx Transation) Serialize() []byte&#123; var encoded bytes.Buffer enc:= gob.NewEncoder(&amp;encoded) err:= enc.Encode(tx) if err!=nil&#123; log.Panic(err) &#125; return encoded.Bytes()&#125;//计算交易的hash值func (tx *Transation) Hash() []byte&#123; txcopy := *tx txcopy.ID = []byte&#123;&#125; hash:= sha256.Sum256(txcopy.Serialize()) return hash[:]&#125;//根据金额与地址新建一个输出func NewTXOutput(value int,address string) * TXOutput&#123; txo := &amp;TXOutput&#123;value,nil&#125; txo.PubkeyHash = []byte(address) return txo&#125;//第一笔coinbase交易func NewCoinbaseTX(to string) *Transation&#123; txin := TXInput&#123;[]byte&#123;&#125;,-1,nil&#125; txout := NewTXOutput(subsidy,to) tx:= Transation&#123;nil,[]TXInput&#123;txin&#125;,[]TXOutput&#123;*txout&#125;&#125; tx.ID = tx.Hash() return &amp;tx&#125;func main()&#123; newTX := NewCoinbaseTX(\"jonson\") fmt.Printf(\"%s\",newTX.String())&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"完全卸载go语言编译器","slug":"uninstall-go-mac","date":"2018-12-13T03:56:55.000Z","updated":"2018-12-14T03:41:55.639Z","comments":true,"path":"2018/12/13/uninstall-go-mac/","link":"","permalink":"https://dreamerjonson.com/2018/12/13/uninstall-go-mac/","excerpt":"","text":"在mac中完全卸载golang编译器 如果你是通过安装包的形式 安装的go语言编译器，那么更新的方式也会非常简单，那就是直接下载新的golang安装包。 在安装新的时候，会自动删除掉旧的编译器。 手动删除 查看路径在哪里： 1&gt; which go root 权限下 删除 1&gt; rm -rf &#x2F;usr&#x2F;local&#x2F;go 删除 1&gt; rm -rf &#x2F;etc&#x2F;paths.d&#x2F;go 将环境变量，有关 go 的删了即可 1&gt; vim ~&#x2F;.bash_profile","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[46]-区块链-比特币真实挖矿过程实现","slug":"golang-46-blockchain-pow","date":"2018-12-12T15:19:59.000Z","updated":"2019-02-04T08:33:32.925Z","comments":true,"path":"2018/12/12/golang-46-blockchain-pow/","link":"","permalink":"https://dreamerjonson.com/2018/12/12/golang-46-blockchain-pow/","excerpt":"","text":"比特币真实挖矿过程实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178package mainimport ( \"bytes\" \"encoding/binary\" \"log\" \"fmt\" \"encoding/hex\" \"crypto/sha256\" \"strconv\" \"math\" \"math/big\")var ( maxnonce int32 = math.MaxInt32)type Block struct&#123; version int32 prevBlockHash []byte merkleroot [] byte hash []byte time int32 bits int32 nonce int32&#125;//将类型转化为了字节数组func IntToHex(num int32) []byte&#123; buff := new(bytes.Buffer)//binary.LittleEndian 小端模式 err:= binary.Write(buff,binary.LittleEndian,num) if err!=nil&#123; log.Panic(err) &#125; return buff.Bytes()&#125;//将类型转化为了字节数组func IntToHex2(num int32) []byte&#123; buff := new(bytes.Buffer) //binary.LittleEndian 小端模式 err:= binary.Write(buff,binary.BigEndian,num) if err!=nil&#123; log.Panic(err) &#125; return buff.Bytes()&#125;//字节反转func ReverseBytes4(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;//序列化func (block *Block) serialize() []byte&#123; result := bytes.Join( [][]byte&#123; IntToHex(block.version), block.prevBlockHash, block.merkleroot, IntToHex(block.time), IntToHex(block.bits), IntToHex(block.nonce)&#125;, []byte&#123;&#125;, ) return result&#125;func main()&#123; //前一个区块的hash prev,_ := hex.DecodeString(\"000000000000000016145aa12fa7e81a304c38aec3d7c5208f1d33b587f966a6\") ReverseBytes4(prev) fmt.Printf(\"%x\\n\",prev) //默克尔根 merkleroot,_ := hex.DecodeString(\"3a4f410269fcc4c7885770bc8841ce6781f15dd304ae5d2770fc93a21dbd70d7\") ReverseBytes4(merkleroot) fmt.Printf(\"%x\\n\",merkleroot) //初始化区块 block := &amp;Block&#123; 2, prev, merkleroot, []byte&#123;&#125;, 1418755780, 404454260, 0, &#125; //目标hash //fmt.Printf(\"targethash:%x\",CalculateTargetFast(IntToHex2(block.bits))) targetHash:=CalculateTargetFast(IntToHex2(block.bits)) //目标hash转换为bit.int var tartget big.Int tartget.SetBytes(targetHash) //当前hash var currenthash big.Int //一直计算到最大值， block.nonce的值不断变化 for block.nonce &lt; maxnonce&#123; //序列化，block.nonce的值不断变化带来序列化的变化 data:= block.serialize() //double hash fitstHash := sha256.Sum256(data) secondhash := sha256.Sum256(fitstHash[:]) //反转 ReverseBytes4(secondhash[:]) fmt.Printf(\"nonce:%d, currenthash:%x\\n\",block.nonce,secondhash) currenthash.SetBytes(secondhash[:]) //比较 if currenthash.Cmp(&amp;tartget) == -1&#123; break &#125;else&#123; block.nonce++ &#125; &#125;&#125;//18 1B7B74//计算困难度func CalculateTargetFast(bits []byte) []byte&#123; var result []byte //第一个字节 计算指数 exponent := bits[:1] fmt.Printf(\"%x\\n\",exponent) //计算后面3个系数 coeffient:= bits[1:] fmt.Printf(\"%x\\n\",coeffient) //将字节，他的16进制为\"18\" 转化为了string \"18\" str:= hex.EncodeToString(exponent) //\"18\" fmt.Printf(\"str=%s\\n\",str) //将字符串18转化为了10进制int64 24 exp,_:=strconv.ParseInt(str,16,8) fmt.Printf(\"exp=%d\\n\",exp) //拼接，计算出目标hash result = append(bytes.Repeat([]byte&#123;0x00&#125;,32-int(exp)),coeffient...) result = append(result,bytes.Repeat([]byte&#123;0x00&#125;,32-len(result))...) return result&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[45]-区块链-挖矿困难度","slug":"golang-45-blockchain-difficulty","date":"2018-12-12T14:19:50.000Z","updated":"2019-02-04T08:33:26.869Z","comments":true,"path":"2018/12/12/golang-45-blockchain-difficulty/","link":"","permalink":"https://dreamerjonson.com/2018/12/12/golang-45-blockchain-difficulty/","excerpt":"","text":"##比特币挖矿困难度 比特币的挖矿困难度 = 目标hash / 创世hash 比特币挖矿的计算 12345678910111213141516/**计算挖矿difficulty */func CalculateDifficulty(strTargetHash string) string &#123; strGeniusBlockHash := \"00000000ffff0000000000000000000000000000000000000000000000000000\" // 创世块编号 var biGeniusHash big.Int var biTargetHash big.Int biGeniusHash.SetString(strGeniusBlockHash, 16) biTargetHash.SetString(strTargetHash, 16) difficulty := big.NewInt(0) difficulty.Div(&amp;biGeniusHash, &amp;biTargetHash) //fmt.Printf(\"%T \\n\" , difficulty) return fmt.Sprintf(\"%s\", difficulty)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[44]-区块链-目标值","slug":"golang-44-blockchain-targetHash","date":"2018-12-12T10:14:47.000Z","updated":"2019-02-04T08:33:22.155Z","comments":true,"path":"2018/12/12/golang-44-blockchain-targetHash/","link":"","permalink":"https://dreamerjonson.com/2018/12/12/golang-44-blockchain-targetHash/","excerpt":"","text":"比特币目标hash计算过程 以之前的bits：181B7B74为例子 1234567891011121314151617181920212223242526272829303132333435func main()&#123; bits,_:= hex.DecodeString(\"181B7B74\") fmt.Printf(\"%x\",CalculateTargetFast(bits))&#125;//18 1B7B74func CalculateTargetFast(bits []byte) []byte&#123; var result []byte //第一个字节 计算指数 exponent := bits[:1] fmt.Printf(\"%x\\n\",exponent) //计算后面3个字节 系数 coeffient:= bits[1:] fmt.Printf(\"%x\\n\",coeffient) //将字节，他的16进制为\"18\" 转化为了string \"18\" str:= hex.EncodeToString(exponent) //\"18\" fmt.Printf(\"str=%s\\n\",str) //将字符串18转化为了10进制int64 24 exp,_:=strconv.ParseInt(str,16,8) fmt.Printf(\"exp=%d\\n\",exp) //拼接，计算出目标hash result = append(bytes.Repeat([]byte&#123;0x00&#125;,32-int(exp)),coeffient...) result = append(result,bytes.Repeat([]byte&#123;0x00&#125;,32-len(result))...) return result&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[43]-区块链-真实比特币序列化","slug":"golang-43-blockchain-serialize","date":"2018-12-12T05:18:08.000Z","updated":"2019-02-04T08:33:16.651Z","comments":true,"path":"2018/12/12/golang-43-blockchain-serialize/","link":"","permalink":"https://dreamerjonson.com/2018/12/12/golang-43-blockchain-serialize/","excerpt":"","text":"真实比特币序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package mainimport ( \"bytes\" \"encoding/binary\" \"log\" \"fmt\" \"encoding/hex\" \"crypto/sha256\")//将类型转化为了字节数组func IntToHex(num int32) []byte&#123; buff := new(bytes.Buffer)//binary.LittleEndian 小端模式 err:= binary.Write(buff,binary.LittleEndian,num) if err!=nil&#123; log.Panic(err) &#125; return buff.Bytes()&#125;//字节反转func ReverseBytes4(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;func main()&#123; //版本号 var version int32 = 2 fmt.Printf(\"%x\\n\",IntToHex(version)) //前一个区块的hash prev,_ := hex.DecodeString(\"000000000000000016145aa12fa7e81a304c38aec3d7c5208f1d33b587f966a6\") ReverseBytes4(prev) fmt.Printf(\"%x\\n\",prev)//默克尔根 merkleroot,_ := hex.DecodeString(\"3a4f410269fcc4c7885770bc8841ce6781f15dd304ae5d2770fc93a21dbd70d7\") ReverseBytes4(merkleroot) fmt.Printf(\"%x\\n\",merkleroot)//时间 var time int32 = 1418755780 fmt.Printf(\"%x\\n\",IntToHex(time))//难度 var bits int32 = 404454260 fmt.Printf(\"%x\\n\",IntToHex(bits))//随机数 var nonce int32 = 1865996595 fmt.Printf(\"%x\\n\",IntToHex(nonce))//拼接 result := bytes.Join([][]byte&#123;IntToHex(version),prev,merkleroot,IntToHex(time),IntToHex(bits),IntToHex(nonce)&#125;,[]byte&#123;&#125;) fmt.Printf(\"%x\\n\",result) //double hash256 firsthash := sha256.Sum256(result) resulthash:= sha256.Sum256(firsthash[:]) ReverseBytes4(resulthash[:]) fmt.Printf(\"%x\",resulthash)&#125; 参考资料： https://www.blockchain.com/btc/block/00000000000000000a1f57cd656e5522b7bac263aa33fc98c583ad68de309603","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[42]-区块链-go实战比特币默克尔树","slug":"golang-42-blockchain-merkletree2","date":"2018-12-11T01:34:44.000Z","updated":"2019-02-04T08:33:11.252Z","comments":true,"path":"2018/12/11/golang-42-blockchain-merkletree2/","link":"","permalink":"https://dreamerjonson.com/2018/12/11/golang-42-blockchain-merkletree2/","excerpt":"","text":"go实战比特币默克尔树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package mainimport ( &quot;crypto&#x2F;sha256&quot; &quot;encoding&#x2F;hex&quot; &quot;fmt&quot;)func min(a int,b int) int&#123; if(a&gt;b)&#123; return b &#125; return a&#125;&#x2F;&#x2F;默克尔树节点type MerkleTree struct&#123; RootNode *MerkleNode&#125;&#x2F;&#x2F;默克尔根节点type MerkleNode struct&#123; Left *MerkleNode Right *MerkleNode Data []byte&#125;&#x2F;&#x2F;生成默克尔树中的节点，如果是叶子节点，则Left，right为nil ，如果为非叶子节点，根据Left，right生成当前节点的hashfunc NewMerkleNode(left,right *MerkleNode,data []byte) *MerkleNode&#123; mnode :&#x3D; MerkleNode&#123;&#125; if left &#x3D;&#x3D;nil &amp;&amp; right&#x3D;&#x3D;nil&#123; mnode.Data &#x3D; data &#125;else&#123; prevhashes :&#x3D; append(left.Data,right.Data...) firsthash:&#x3D; sha256.Sum256(prevhashes) hash:&#x3D;sha256.Sum256(firsthash[:]) mnode.Data &#x3D; hash[:] &#125; mnode.Left &#x3D; left mnode.Right &#x3D; right return &amp;mnode&#125;&#x2F;&#x2F;构建默克尔树func NewMerkleTree(data [][]byte) *MerkleTree&#123; var nodes []MerkleNode &#x2F;&#x2F;构建叶子节点。 for _,datum :&#x3D; range data&#123; node:&#x3D; NewMerkleNode(nil,nil,datum) nodes &#x3D; append(nodes,*node) &#125; &#x2F;&#x2F;j代表的是某一层的第一个元素 j:&#x3D;0 &#x2F;&#x2F;第一层循环代表 nSize代表某一层的个数，每循环一次减半 for nSize :&#x3D;len(data);nSize &gt;1;nSize &#x3D; (nSize+1)&#x2F;2&#123; &#x2F;&#x2F;第二条循环i+&#x3D;2代表两两拼接。 i2是为了当个数是基数的时候，拷贝最后的元素。 for i:&#x3D;0 ; i&lt;nSize ;i+&#x3D;2&#123; i2 :&#x3D; min(i+1,nSize-1) node :&#x3D; NewMerkleNode(&amp;nodes[j+i],&amp;nodes[j+i2],nil) nodes &#x3D; append(nodes,*node) &#125; &#x2F;&#x2F;j代表的是某一层的第一个元素 j+&#x3D;nSize &#125; mTree :&#x3D; MerkleTree&#123;&amp;(nodes[len(nodes)-1])&#125; return &amp;mTree&#125;func ReverseBytes3(data []byte)&#123; for i,j :&#x3D;0,len(data) - 1;i&lt;j;i,j &#x3D; i+1,j - 1&#123; data[i],data[j] &#x3D; data[j],data[i] &#125;&#125;func main()&#123; &#x2F;&#x2F;测试网站下的5个hash是否能够生成merkleRoot &#x2F;&#x2F;https:&#x2F;&#x2F;www.blockchain.com&#x2F;btc&#x2F;block&#x2F;00000000000090ff2791fe41d80509af6ffbd6c5b10294e29cdf1b603acab92c &#x2F;&#x2F;传递hash data1,_:&#x3D;hex.DecodeString(&quot;6b6a4236fb06fead0f1bd7fc4f4de123796eb51675fb55dc18c33fe12e33169d&quot;) data2,_:&#x3D;hex.DecodeString(&quot;2af6b6f6bc6e613049637e32b1809dd767c72f912fef2b978992c6408483d77e&quot;) data3,_:&#x3D;hex.DecodeString(&quot;6d76d15213c11fcbf4cc7e880f34c35dae43f8081ef30c6901f513ce41374583&quot;) data4,_:&#x3D;hex.DecodeString(&quot;08c3b50053b010542dca85594af182f8fcf2f0d2bfe8a806e9494e4792222ad2&quot;) data5,_:&#x3D;hex.DecodeString(&quot;612d035670b7b9dad50f987dfa000a5324ecb3e08745cfefa10a4cefc5544553&quot;) &#x2F;&#x2F;大小段转换 ReverseBytes3(data1) ReverseBytes3(data2) ReverseBytes3(data3) ReverseBytes3(data4) ReverseBytes3(data5) hehe :&#x3D; [][]byte&#123; data1, data2, data3, data4, data5, &#125; &#x2F;&#x2F;生成默克尔树 merleroot:&#x3D; NewMerkleTree(hehe) &#x2F;&#x2F;反转 ReverseBytes3(merleroot.RootNode.Data) fmt.Printf(&quot;%x&quot;,merleroot.RootNode.Data)&#125; 参考资料 eth wiki:patricia-tree [csdn 默克尔树解释]https://blog.csdn.net/wo541075754/article/details/54632929 https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/trie源码分析.md","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[41]-区块链-默克尔树构建","slug":"golang-41-blockchain-merkletree","date":"2018-12-10T11:04:33.000Z","updated":"2019-02-04T08:33:06.170Z","comments":true,"path":"2018/12/10/golang-41-blockchain-merkletree/","link":"","permalink":"https://dreamerjonson.com/2018/12/10/golang-41-blockchain-merkletree/","excerpt":"","text":"大自然的启示 Banyan树的启示：印度banyan树，最大的一颗可以长到1万平方米以上。其如此巨大的秘密就在于其枝干也会产生根，起到支撑，从而作为附属树干，继续生成分支。大自然给人太多启示…… Merkle Tree Merkle Tree，通常也被称作Hash Tree，顾名思义，就是存储hash值的一棵树。Merkle树是一种数据结构，Merkle树的叶子是数据块(例如，文件或者文件的集合)的hash值。非叶节点是其对应子节点串联字符串的hash。 Merkle树是使区块链发挥作用的基本组成部分。虽然理论上可以在没有Merkle树的情况下制作区块链，但只需创建直接包含每个事务的巨型块头，这样做会带来巨大的可扩展性挑战，可以说无可置疑地使用区块链的能力超出了所有范围，从长远来看，功能强大的电脑。感谢Merkle树，可以构建在所有计算机和大小笔记本电脑上运行的以太网节点，智能手机，甚至是物联网设备 比特币中默克尔树的构建过程： 对于网站中的交易： https://www.blockchain.com/btc/block/000000000001741120135274584b2a0da45b39c8cc78322a14f9004ae766a8e0 1234567891011121314151617181920212223第一笔hash：16f0eb42cb4d9c2374b2cb1de4008162c06fdd8f1c18357f0c849eb423672f5f大小端转换为：5f2f6723b49e840c7f35181c8fdd6fc0628100e41dcbb274239c4dcb42ebf016第二笔hash：cce2f95fc282b3f2bc956f61d6924f73d658a1fdbc71027dd40b06c15822e061大小端转换为：61e02258c1060bd47d0271bcfda158d6734f92d6616f95bcf2b382c25ff9e2cc将两个拼接在一起：5f2f6723b49e840c7f35181c8fdd6fc0628100e41dcbb274239c4dcb42ebf01661e02258c1060bd47d0271bcfda158d6734f92d6616f95bcf2b382c25ff9e2cc将上面拼接的字符串进行两次hash如下：第一次hash结果：9b2ec096d49fee8b310752082d63d8fe198386ae2172d90533d9186bb28df63d将上面计算出的hash值再次进行hash：525894ddd0891b36c5ff8658e2a978d615b35ce6dedb5cb83f2420dbcd40a0c7大小端转换即为结果：c7a040cddb20243fb85cdbdee65cb315d678a9e25886ffc5361b89d0dd945852 go语言实现上面的验证过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"encoding/hex\" \"crypto/sha256\" \"fmt\")func ReverseBytes2(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;func main()&#123; //字符串hash转换为字节 hash1,_:= hex.DecodeString(\"16f0eb42cb4d9c2374b2cb1de4008162c06fdd8f1c18357f0c849eb423672f5f\") hash2,_:= hex.DecodeString(\"cce2f95fc282b3f2bc956f61d6924f73d658a1fdbc71027dd40b06c15822e061\") //大小端的转换 ReverseBytes2(hash1) ReverseBytes2(hash2) //拼接在一起 rawdata:=append(hash1,hash2...) //double hash256 firsthash:=sha256.Sum256(rawdata) secondhash:= sha256.Sum256(firsthash[:]) merkroot := secondhash[:] //反转，与浏览器当中的数据对比 ReverseBytes2(merkroot) fmt.Printf(\"%x\",merkroot)&#125; 参考资料 eth wiki:patricia-tree [csdn 默克尔树解释]https://blog.csdn.net/wo541075754/article/details/54632929 https://github.com/ZtesoftCS/go-ethereum-code-analysis/blob/master/trie源码分析.md","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[40]-区块链-wif倒推出私钥","slug":"golang-40-blockchain-verifyprivatekeywif","date":"2018-12-09T14:40:53.000Z","updated":"2019-02-04T08:33:00.451Z","comments":true,"path":"2018/12/09/golang-40-blockchain-verifyprivatekeywif/","link":"","permalink":"https://dreamerjonson.com/2018/12/09/golang-40-blockchain-verifyprivatekeywif/","excerpt":"","text":"wif倒推出私钥 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package mainimport ( \"encoding/hex\" \"crypto/sha256\" \"math/big\" \"bytes\" \"fmt\")//base58编码var b58Alphabet = []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")func Base58Encode(input []byte) []byte&#123; var result []byte x:= big.NewInt(0).SetBytes(input) base := big.NewInt(int64(len(b58Alphabet))) zero := big.NewInt(0) mod := &amp;big.Int&#123;&#125; for x.Cmp(zero) != 0 &#123; x.DivMod(x,base,mod) // 对x取余数 result = append(result, b58Alphabet[mod.Int64()]) &#125; ReverseBytes(result) for _,b:=range input&#123; if b ==0x00&#123; result = append([]byte&#123;b58Alphabet[0]&#125;,result...) &#125;else&#123; break &#125; &#125; return result&#125;//字节数组的反转func ReverseBytes(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;func generatePrivateKey(hexprivatekey string,compressed bool) []byte&#123; versionstr :=\"\"//判断是否对应的是压缩的公钥，如果是，需要在后面加上0x01这个字节。同时任何的私钥，我们需要在前方0x80的字节 if compressed&#123; versionstr = \"80\" + hexprivatekey + \"01\" &#125;else&#123; versionstr = \"80\" + hexprivatekey &#125; //字符串转化为16进制的字节 privatekey,_:=hex.DecodeString(versionstr)//通过 double hash 计算checksum.checksum他是两次hash256以后的前4个字节。 firsthash:=sha256.Sum256(privatekey) secondhash:= sha256.Sum256(firsthash[:]) checksum := secondhash[:4] //拼接 result := append(privatekey,checksum...) //最后进行base58的编码 base58result :=Base58Encode(result) return base58result&#125;func Base58Decode(input []byte) []byte&#123; result := big.NewInt(0) zeroBytes :=0 for _,b :=range input&#123; if b=='1'&#123; zeroBytes++ &#125;else&#123; break &#125; &#125; payload:= input[zeroBytes:] for _,b := range payload&#123; charIndex := bytes.IndexByte(b58Alphabet,b) //反推出余数 result.Mul(result,big.NewInt(58)) //之前的结果乘以58 result.Add(result,big.NewInt(int64(charIndex))) //加上这个余数 &#125; decoded :=result.Bytes() decoded = append(bytes.Repeat([]byte&#123;0x00&#125;,zeroBytes),decoded...) return decoded&#125;//检查checkWIF是否有效func checkWIF(wifprivate string) bool&#123; rawdata := []byte(wifprivate) //包含了80、私钥、checksum base58decodedata:= Base58Decode(rawdata) fmt.Printf(\"base58decodedata：%x\\n\",base58decodedata) length :=len(base58decodedata) if(length &lt;37)&#123; fmt.Printf(\"长度小于37，一定有问题\") return false &#125; private := base58decodedata[:(length-4)] //得到检查码 //fmt.Printf(\"private：%x\\n\",private) firstsha := sha256.Sum256(private) secondsha := sha256.Sum256(firstsha[:]) checksum := secondsha[:4] //fmt.Printf(\"%x\\n\",checksum) //得到原始的检查码 orignchecksum:= base58decodedata[(length-4):]// fmt.Printf(\"%x\\n\",orignchecksum) //[]byte对比 if bytes.Compare(checksum,orignchecksum)==0&#123; return true &#125; return false&#125;//通过wif格式的私钥，得到原始的私钥。func getPrivateKeyfromWIF( wifprivate string) []byte&#123; if checkWIF(wifprivate)&#123; rawdata := []byte(wifprivate) //包含了80、私钥、checksum base58decodedata:= Base58Decode(rawdata) //私钥一共32个字节，排除了0x80 return base58decodedata[1:33] &#125; return []byte&#123;&#125;&#125;func main()&#123; //得到wif格式的私钥 wifprivatekey:=generatePrivateKey(\"18d3e15d48b2df76562fab783eac137aaeb611e6ff0a193e12ceef1354220ac7\",false) fmt.Printf(\"%s\\n\",wifprivatekey) //【】byte转换为string str := fmt.Sprintf(\"%s\",wifprivatekey) //得到原始的私钥 privatekey :=getPrivateKeyfromWIF(str) fmt.Printf(\"%x\", privatekey)&#125; 参考资料 https://en.bitcoin.it/wiki/Private_key https://en.bitcoin.it/wiki/Wallet_import_format http://gobittest.appspot.com/PrivateKey","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[39]-区块链-产生wif私钥","slug":"golang-39-blockchain-generateprivatekeywif","date":"2018-12-09T10:51:37.000Z","updated":"2019-02-04T08:32:55.523Z","comments":true,"path":"2018/12/09/golang-39-blockchain-generateprivatekeywif/","link":"","permalink":"https://dreamerjonson.com/2018/12/09/golang-39-blockchain-generateprivatekeywif/","excerpt":"","text":"压缩公钥 公钥一般来说是椭圆曲线上的x,y坐标拼接在一起的。压缩的公钥其实就是x的坐标。 WIF 私钥产生 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package mainimport ( \"encoding/hex\" \"crypto/sha256\" \"math/big\" \"fmt\")//base58编码var b58Alphabet = []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")func Base58Encode(input []byte) []byte&#123; var result []byte x:= big.NewInt(0).SetBytes(input) base := big.NewInt(int64(len(b58Alphabet))) zero := big.NewInt(0) mod := &amp;big.Int&#123;&#125; for x.Cmp(zero) != 0 &#123; x.DivMod(x,base,mod) // 对x取余数 result = append(result, b58Alphabet[mod.Int64()]) &#125; ReverseBytes(result) for _,b:=range input&#123; if b ==0x00&#123; result = append([]byte&#123;b58Alphabet[0]&#125;,result...) &#125;else&#123; break &#125; &#125; return result&#125;//字节数组的反转func ReverseBytes(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;func generatePrivateKey(hexprivatekey string,compressed bool) []byte&#123; versionstr :=\"\"//判断是否对应的是压缩的公钥，如果是，需要在后面加上0x01这个字节。同时任何的私钥，我们需要在前方0x80的字节 if compressed&#123; versionstr = \"80\" + hexprivatekey + \"01\" &#125;else&#123; versionstr = \"80\" + hexprivatekey &#125; //字符串转化为16进制的字节 privatekey,_:=hex.DecodeString(versionstr)//通过 double hash 计算checksum.checksum他是两次hash256以后的前4个字节。 firsthash:=sha256.Sum256(privatekey) secondhash:= sha256.Sum256(firsthash[:]) checksum := secondhash[:4] //拼接 result := append(privatekey,checksum...) //最后进行base58的编码 base58result :=Base58Encode(result) return base58result&#125;func main()&#123; wifprivatekey:=generatePrivateKey(\"18d3e15d48b2df76562fab783eac137aaeb611e6ff0a193e12ceef1354220ac7\",true) fmt.Printf(\"%s\",wifprivatekey)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[38]-区块链- 生成比特币地址","slug":"golang-38-blockchain-generateAddress","date":"2018-12-07T08:31:18.000Z","updated":"2019-02-04T08:32:51.042Z","comments":true,"path":"2018/12/07/golang-38-blockchain-generateAddress/","link":"","permalink":"https://dreamerjonson.com/2018/12/07/golang-38-blockchain-generateAddress/","excerpt":"","text":"生成比特币地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package mainimport ( \"crypto/sha256\" \"golang.org/x/crypto/ripemd160\" \"fmt\" \"math/big\" \"encoding/hex\")//base58编码var b58Alphabet = []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")func Base58Encode(input []byte) []byte&#123; var result []byte x:= big.NewInt(0).SetBytes(input) base := big.NewInt(int64(len(b58Alphabet))) zero := big.NewInt(0) mod := &amp;big.Int&#123;&#125; for x.Cmp(zero) != 0 &#123; x.DivMod(x,base,mod) // 对x取余数 result = append(result, b58Alphabet[mod.Int64()]) &#125; ReverseBytes(result) for _,b:=range input&#123; if b ==0x00&#123; result = append([]byte&#123;b58Alphabet[0]&#125;,result...) &#125;else&#123; break &#125; &#125; return result&#125;//字节数组的反转func ReverseBytes(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;//产生比特币地址func generateAddress(pubkey []byte) []byte&#123; //1、计算pubkeuhash pubkeyHash256 :=sha256.Sum256(pubkey) PIPEMD160Hasher := ripemd160.New() _,err:= PIPEMD160Hasher.Write(pubkeyHash256[:]) if err!=nil&#123; fmt.Println(\"error\") &#125; publicRIPEMD160 := PIPEMD160Hasher.Sum(nil) //2、计算checksum versionPayload := append([]byte&#123;0x00&#125;,publicRIPEMD160...) firstSHA := sha256.Sum256(versionPayload) secondSHA := sha256.Sum256(firstSHA[:]) //checksum 是前面的4个字节 checksum:=secondSHA[:4] //3、base58编码 fullPayload := append(versionPayload,checksum...)//返回地址 address:=Base58Encode(fullPayload) return address&#125;func main()&#123; //外部得到公钥 publickpey,_:=hex.DecodeString(\"D4A6C78C0B13DBD8A07AAB17C7D79ED9CB2523B63EDAC4E7CACE93C6B66CEDC7918EE0E174E8B2B61468D0E6CAA099710EF72094ACBD70BDAE3D8E42C617ACC6\") //fmt.Printf(\"%X\",publickpey)//打印这个地址 address:=generateAddress(publickpey) fmt.Printf(\"%s\",address)&#125; 参考资料 Building Blockchain in Go. Part 5: Addresses 比特币公钥转地址工具 地址：比特币维基百科","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[37]-区块链-验证数据签名","slug":"golang-37-blockchain-verifysign","date":"2018-12-07T03:53:24.000Z","updated":"2019-02-04T08:32:46.352Z","comments":true,"path":"2018/12/07/golang-37-blockchain-verifysign/","link":"","permalink":"https://dreamerjonson.com/2018/12/07/golang-37-blockchain-verifysign/","excerpt":"","text":"验证数据签名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package mainimport ( \"crypto/ecdsa\" \"crypto/rand\" \"crypto/sha256\" \"crypto/elliptic\" \"log\" \"fmt\" \"math/big\")//生成私钥和公钥，生成的私钥为结构体ecdsa.PrivateKey的指针//type PrivateKey struct &#123;// PublicKey// D *big.Int//&#125;func newKeyPair3() (ecdsa.PrivateKey, []byte) &#123; //生成secp256k1椭圆曲线 curve := elliptic.P256() //产生的是一个结构体指针，结构体类型为ecdsa.PrivateKey private, err := ecdsa.GenerateKey(curve, rand.Reader) if err != nil &#123; log.Panic(err) &#125; //x坐标与y坐标拼接在一起，生成公钥 pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...) return *private, pubKey&#125;func main()&#123; //生成公钥要私钥 privKey,pubkey := newKeyPair3() //生成某一串信息的哈希值，需要签名的数据 hash := sha256.Sum256([]byte(\"跟着jonson老师实战区块链\\n\")) //根据私钥和信息的哈希值生成数字签名的r和s，r和s拼接在一起就是数字签名，在这里省略了拼接的步骤，欲查看，请看3.数字签名 r, s, _ := ecdsa.Sign(rand.Reader, &amp;privKey, hash[:]) //fmt.Printf(\"%v\\n\", *r) //fmt.Printf(\"%v\\n\", *s) ////生成secp256k1椭圆曲线 curve := elliptic.P256() //公钥的长度 keyLen := len(pubkey) //前一半为x轴坐标，后一半为y轴坐标 x := big.Int&#123;&#125; y := big.Int&#123;&#125; x.SetBytes(pubkey[:(keyLen / 2)]) y.SetBytes(pubkey[(keyLen / 2):]) //rawPubKey为生成PublicKey结构体，作为下面ecdsa.Verify的参数 //type PublicKey struct &#123; // elliptic.Curve // X, Y * big.Int &#125; //公钥 rawPubKey := ecdsa.PublicKey&#123;curve, &amp;x, &amp;y&#125; //根据交易哈希、公钥、数字签名验证成功。ecdsa.Verify func Verify(pub *PublicKey, hash []byte, r *big.Int, s *big.Int) bool if ecdsa.Verify(&amp;rawPubKey, hash[:], r, s) == false &#123; fmt.Printf(\"%s\\n\", \"验证失败\") &#125;else&#123; fmt.Printf(\"%s\\n\", \"验证成功\") &#125; //用其他的信息哈希——证明验证失败 hash2 := sha256.Sum256([]byte(\"我要给你200愿\\n\")) if ecdsa.Verify(&amp;rawPubKey, hash2[:], r, s) == false &#123; fmt.Printf(\"%s\\n\", \"验证失败\") &#125;else&#123; fmt.Printf(\"%s\\n\", \"验证成功\") &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[36]-区块链-数据签名生成","slug":"golang-36-blockchain-signature","date":"2018-12-07T03:47:58.000Z","updated":"2019-02-04T08:32:41.726Z","comments":true,"path":"2018/12/07/golang-36-blockchain-signature/","link":"","permalink":"https://dreamerjonson.com/2018/12/07/golang-36-blockchain-signature/","excerpt":"","text":"区块链-数据签名生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( \"crypto/ecdsa\" \"crypto/rand\" \"crypto/sha256\" \"crypto/elliptic\" \"log\" \"fmt\")//生成私钥和公钥，生成的私钥为结构体ecdsa.PrivateKey的指针//type PrivateKey struct &#123;// PublicKey// D *big.Int//&#125;func newKeyPair2() (ecdsa.PrivateKey, []byte) &#123; //生成secp256k1椭圆曲线 curve := elliptic.P256() //产生的是一个结构体指针，结构体类型为ecdsa.PrivateKey private, err := ecdsa.GenerateKey(curve, rand.Reader) if err != nil &#123; log.Panic(err) &#125; //x坐标与y坐标拼接在一起，生成公钥 pubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...) return *private, pubKey&#125;func main()&#123; //调用函数生成私钥与公钥 privKey,_ := newKeyPair2() //信息的哈希,签名什么样的数据 hash := sha256.Sum256([]byte(\"hello world\\n\")) //根据私钥和信息的哈希进行数字签名，产生r和s r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, hash[:]) if err != nil &#123; log.Panic(err) &#125; //r和s拼接在一起实现了数字签名 signature := append(r.Bytes(), s.Bytes()...) //打印数字签名的16进制显示 fmt.Printf(\"%x\\n\", signature) fmt.Printf(\"%x\\n\", r.Bytes()) fmt.Printf(\"%x\\n\", s.Bytes()) //补充：如何把一个字符串转换为16进制数据 //m := big.Int&#123;&#125; //n := big.Int&#123;&#125; //rr,_:=hex.DecodeString(\"7dccc0f58639584a3f0c879c3688d2f4a0137697cbf34245d075c764e36233d2\") //ss,_:=hex.DecodeString(\"cf3713bf4369eb1c02e476cdbefb7f76a25b572f53fb71d4e4742fa11c827526\") // //m.SetBytes(rr) //n.SetBytes(ss) // //fmt.Printf(\"%x\\n\", m.Bytes()) //fmt.Printf(\"%x\\n\", n.Bytes())&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[35]-区块链-私钥公钥生成","slug":"golang-35-blockchain-publickey","date":"2018-12-07T02:36:24.000Z","updated":"2019-02-04T08:32:37.261Z","comments":true,"path":"2018/12/07/golang-35-blockchain-publickey/","link":"","permalink":"https://dreamerjonson.com/2018/12/07/golang-35-blockchain-publickey/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132//生成私钥和公钥func newKeyPair() (ecdsa.PrivateKey,[]byte)&#123; //生成椭圆曲线, secp256r1 曲线。 比特币当中的曲线是secp256k1 curve :=elliptic.P256() private,err :=ecdsa.GenerateKey(curve,rand.Reader) if err !=nil&#123; fmt.Println(\"error\") &#125; pubkey :=append(private.PublicKey.X.Bytes(),private.PublicKey.Y.Bytes()...) return *private,pubkey&#125;func main()&#123;//调用函数生成公钥privatekey,public :=newKeyPair()//打印私钥 曲线上的x点 fmt.Printf(\"%x\\n\",privatekey.D.Bytes())//打印公钥， 曲线上的x点和y点fmt.Printf(\"%x\",public)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[34]-区块链-对称加密与非对称加密","slug":"golang-34-blockchain-privatekey","date":"2018-12-07T01:55:02.000Z","updated":"2019-02-04T08:32:32.774Z","comments":true,"path":"2018/12/07/golang-34-blockchain-privatekey/","link":"","permalink":"https://dreamerjonson.com/2018/12/07/golang-34-blockchain-privatekey/","excerpt":"","text":"对称加密 对称密钥加密（英语：Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。事实上，这组密钥成为在两个或多个成员间的共同秘密，以便维持专属的通信联系。与公开密钥加密相比，要求双方获取相同的密钥是对称密钥加密的主要缺点之一。 常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 对称加密的速度比公钥加密快很多，在很多场合都需要对称加密。 非对称加密 公开密钥加密（英语：Public-key cryptography），也称为非对称加密（英语：asymmetric cryptography），是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密的时候，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。由于加密和解密需要两个不同的密钥，故被称为非对称加密；不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。 基于公开密钥加密的特性，它还提供数字签名的功能，使电子文件可以得到如同在纸本文件上亲笔签署的效果。 公开密钥基础建设透过信任数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在TLS实现并在万维网的HTTP以HTTPS、在电子邮件的SMTP以STARTTLS引入。 非对称加密过程 在数学上，d(c(x))=x，让我们使用典型的爱丽丝与鲍伯假设来解释： 爱丽丝与鲍伯事先互不认识，也没有可靠安全的沟通渠道，但爱丽丝现在却要透过不安全的互联网向鲍伯发送信息 爱丽丝撰写好原文，原文在未加密的状态下称之为明文 x 鲍伯使用密码学安全伪随机数生成器产生一对密钥，其中一个作为公钥为 c，另一个作为私钥 d 鲍伯可以用任何方法发送公钥c 给爱丽丝，即使伊夫在中间窃听到 c 也没问题 爱丽丝用公钥c 把明文 x 进行加密，得到密文c(x) 爱丽丝可以用任何方法传输密文c(x) 给鲍伯，即使伊夫在中间窃听到密文 c(x)也没问题 鲍伯收到密文，用私钥d 对密文进行解密 d(c(x))，得到爱丽丝撰写的明文x 由于伊夫没有得到鲍伯的私钥d，所以无法得知明文 x 如果爱丽丝丢失了她自己撰写的原文x，在没有得到鲍伯的私钥d 的情况下，她的处境将等同伊夫，即无法透过鲍伯的公钥c 和密文c(x)重新得到原文x 对比 对称密钥加密牵涉到密钥管理的问题，尤其是密钥交换，它需要作者和读者在通信之前先透过另一个安全的渠道交换共享的密钥，才可以安全地把密文透过不安全的渠道发送；对称密钥一旦被窃，其所作的加密将即时失效；而在互联网，如果通信双方分隔异地而素未谋面，则对称加密事先所需要的“安全渠道”变得不可行；非对称加密则容许加密公钥随便散布，解密的私钥不发往任何用户，只在单方保管；如此，即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，极为适合在互联网上使用。 另一方面，公钥解密的特性可以形成数字签名，使数据和文件受到保护并可信赖；如果公钥透过数字证书认证机构签授成为电子证书，更可作为数字身份的认证，这都是对称密钥加密无法实现的。 不过，公钥加密在在计算上相当复杂，性能欠佳、远远不比对称加密；因此，在一般实际情况下，往往通过公钥加密来随机创建临时的对称秘钥，亦即对话键，然后才通过对称加密来传输大量、主体的数据","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[33]-区块链-hash","slug":"golang-33-blockchain-hash","date":"2018-12-05T09:48:18.000Z","updated":"2019-02-04T08:32:27.329Z","comments":true,"path":"2018/12/05/golang-33-blockchain-hash/","link":"","permalink":"https://dreamerjonson.com/2018/12/05/golang-33-blockchain-hash/","excerpt":"","text":"哈希函数有三个特点： 输入无限的字符会输出给我们固定长度的字符（即便是图书馆里面所有的数据） 输入的函数的微小变化最后都会带来哈希函数返回值的巨大变化。 哈希函数的特点是不能根据哈希函数的返回值倒推出我们输入的数据是什么。同样的，我们在计算哈希函数之前，也不能够判断出数据回输出什么样的哈希值。 用途 数字指纹 数字签名 数字防篡改 go实现hash 123456789101112131415161718192021222324252627func main()&#123; //第一种方式 sum:= sha256.Sum256([]byte(\"jonson love olaya\")) fmt.Printf(\"%X\",sum) //第2种方式 h:=sha256.New() h.Write([]byte(\"jonson love olaya\")) fmt.Printf(\"%X\",h.Sum(nil))&#125;//第3种方式:处理文件 h:=sha256.New() f,err := os.Open(\"hash.test\") if err !=nil&#123; fmt.Printf(\"error\") &#125; defer f.Close() if _,err := io.Copy(h,f);err !=nil&#123; fmt.Printf(\"error\") &#125; fmt.Printf(\"%X\",h.Sum(nil)) 参考资料 https://golang.org/pkg/crypto/sha256/#example_Sum256","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[32]-区块链-base58","slug":"golang-32-base58","date":"2018-12-05T03:03:56.000Z","updated":"2019-02-04T08:32:21.122Z","comments":true,"path":"2018/12/05/golang-32-base58/","link":"","permalink":"https://dreamerjonson.com/2018/12/05/golang-32-base58/","excerpt":"","text":"base58 Base58是用于Bitcoin中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址。相比Base64，Base58不使用数字&quot;0&quot;，字母大写&quot;O&quot;，字母大写&quot;I&quot;，和字母小写&quot;l&quot;，以及&quot;+“和”/&quot;符号。 设计Base58主要的目的是： 避免混淆。在某些字体下，数字0和字母大写O，以及字母大写I和字母小写l会非常相似。 不使用&quot;+“和”/&quot;的原因是非字母或数字的字符串作为帐号较难被接受。 没有标点符号，通常不会被从中间分行。 大部分的软件支持双击选择整个字符串。 base58编码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( \"math/big\" \"fmt\")//切片存储base58字母var b58Alphabet = []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")func Base58Encode(input []byte) []byte&#123;//定义一个字节切片，返回值 var result []byte//把字节数组input转化为了大整数big.Int x:= big.NewInt(0).SetBytes(input)//长度58的大整数 base := big.NewInt(int64(len(b58Alphabet))) //0的大整数 zero := big.NewInt(0)//大整数的指针 mod := &amp;big.Int&#123;&#125; //循环，不停地对x取余数,大小为58 for x.Cmp(zero) != 0 &#123; x.DivMod(x,base,mod) // 对x取余数 //讲余数添加到数组当中 result = append(result, b58Alphabet[mod.Int64()]) &#125;//反转字节数组 ReverseBytes(result)//如果这个字节数组的前面为字节0，会把它替换为1.for _,b:=range input&#123; if b ==0x00&#123; result = append([]byte&#123;b58Alphabet[0]&#125;,result...) &#125;else&#123; break &#125; &#125; return result&#125;//反转字节数组func ReverseBytes(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;//测试 反转操作func main()&#123; org := []byte(\"qwerty\") fmt.Println(string(org)) ReverseBytes(org) fmt.Println(string(org))//测试编码 fmt.Printf(\"%s\",string( Base58Encode([]byte(\"hello jonson\"))))&#125; 解码 12345678910111213141516171819202122232425262728func Base58Decode(input []byte) []byte&#123; result := big.NewInt(0) zeroBytes :=0 for _,b :=range input&#123; if b=='1'&#123; zeroBytes++ &#125;else&#123; break &#125; &#125; payload:= input[zeroBytes:] for _,b := range payload&#123; charIndex := bytes.IndexByte(b58Alphabet,b) //反推出余数 result.Mul(result,big.NewInt(58)) //之前的结果乘以58 result.Add(result,big.NewInt(int64(charIndex))) //加上这个余数 &#125; decoded :=result.Bytes() decoded = append(bytes.Repeat([]byte&#123;0x00&#125;,zeroBytes),decoded...) return decoded&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package mainimport ( \"math/big\" \"fmt\" \"bytes\")var b58Alphabet = []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")func Base58Encode(input []byte) []byte&#123; var result []byte x:= big.NewInt(0).SetBytes(input) base := big.NewInt(int64(len(b58Alphabet))) zero := big.NewInt(0) mod := &amp;big.Int&#123;&#125; for x.Cmp(zero) != 0 &#123; x.DivMod(x,base,mod) // 对x取余数 result = append(result, b58Alphabet[mod.Int64()]) &#125; ReverseBytes(result) for _,b:=range input&#123; if b ==0x00&#123; result = append([]byte&#123;b58Alphabet[0]&#125;,result...) &#125;else&#123; break &#125; &#125; return result&#125;func Base58Decode(input []byte) []byte&#123; result := big.NewInt(0) zeroBytes :=0 for _,b :=range input&#123; if b=='1'&#123; zeroBytes++ &#125;else&#123; break &#125; &#125; payload:= input[zeroBytes:] for _,b := range payload&#123; charIndex := bytes.IndexByte(b58Alphabet,b) //反推出余数 result.Mul(result,big.NewInt(58)) //之前的结果乘以58 result.Add(result,big.NewInt(int64(charIndex))) //加上这个余数 &#125; decoded :=result.Bytes() decoded = append(bytes.Repeat([]byte&#123;0x00&#125;,zeroBytes),decoded...) return decoded&#125;func ReverseBytes(data []byte)&#123; for i,j :=0,len(data) - 1;i&lt;j;i,j = i+1,j - 1&#123; data[i],data[j] = data[j],data[i] &#125;&#125;func main()&#123; org := []byte(\"qwerty\") fmt.Println(string(org)) ReverseBytes(org) fmt.Println(string(org)) fmt.Printf(\"%s\\n\",string( Base58Encode([]byte(\"hello jonson\")))) fmt.Printf(\"%s\",string(Base58Decode([]byte(\"2yGEbwRFyav6CimZ7\"))))&#125; 参考资料 (比特币wiki-base58编码)[https://en.bitcoin.it/wiki/Base58Check_encoding#Version_bytes] (维基百科-base58编码)[https://zh.wikipedia.org/wiki/Base58]","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"以太坊DAPP[5]-博彩-事件处理","slug":"solidity-64-lottery-project-button-submit","date":"2018-12-02T01:42:14.000Z","updated":"2018-12-02T02:12:15.363Z","comments":true,"path":"2018/12/02/solidity-64-lottery-project-button-submit/","link":"","permalink":"https://dreamerjonson.com/2018/12/02/solidity-64-lottery-project-button-submit/","excerpt":"","text":"处理按钮的提交事件： 处理了玩家入场的按钮与开始博彩的按钮。 处理按钮提交事件。如果当前的操作没有问题，会打开metamask来进行事务提交。 同时要注意的是，增加了信息提示，即如果当前交易一直在等待矿工交易确认，那么，那么就会提示等待交易完成。当交易完成后，state状态改变、从新tijiaorender。 会提示交易完成。 src/App.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.css';import web3 from './web3';import lottery from './lottery';class App extends Component &#123; state = &#123; manager:'', players:[], balance:'', value:'', message:'' &#125; async componentDidMount()&#123; const manager = await lottery.methods.manager().call(); const players = await lottery.methods.getPlayers().call(); const balance = await web3.eth.getBalance(lottery.options.address); this.setState(&#123;manager,players,balance&#125;); &#125; onSubmit = async event =&gt;&#123; event.preventDefault(); const accounts = await web3.eth.getAccounts(); this.setState(&#123;message:'等待交易完成.....'&#125;); await lottery.methods.enetr().send(&#123;from:accounts[0],value:web3.utils.toWei(this.state.value,'ether')&#125;); this.setState(&#123;message:'入场成功.....'&#125;); &#125; onClick = async ()=&gt;&#123; const accounts = await web3.eth.getAccounts(); this.setState(&#123;message:'等待交易完成......'&#125;); await lottery.methods.pickwiner().send(&#123;from:accounts[0]&#125;); this.setState(&#123;message:'赢家产生'&#125;); &#125; render() &#123; //console.log(web3.version); console.log(this.state.value); return ( &lt;div&gt; &lt;h1&gt;lottery管理者地址：&lt;/h1&gt; &lt;p&gt;this is manager by &#123;this.state.manager&#125;&lt;/p&gt; &lt;p&gt;当前的参与者的数量： &#123;this.state.players.length&#125;&lt;/p&gt; &lt;p&gt;当前资金池：&#123;web3.utils.fromWei(this.state.balance,'ether')&#125; ether&lt;/p&gt; &lt;hr/&gt; &lt;form onSubmit=&#123;this.onSubmit&#125;&gt; &lt;h4&gt;参与到博彩项目？&lt;/h4&gt; &lt;div&gt; &lt;label&gt;你想参与的金额：&lt;/label&gt; &lt;input value=&#123;this.state.value&#125; onChange=&#123;event=&gt;&#123;this.setState(&#123;value:event.target.value&#125;)&#125;&#125; /&gt; &lt;/div&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;hr/&gt; &lt;h4&gt;判断输赢&lt;/h4&gt; &lt;button onClick=&#123;this.onClick&#125;&gt;开始博彩&lt;/button&gt; &lt;p&gt;&#123;this.state.message&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default App;","categories":[{"name":"DAPP","slug":"DAPP","permalink":"https://dreamerjonson.com/categories/DAPP/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"以太坊DAPP[4]-博彩-前台展示界面","slug":"solidity-63-lottery-project-show-page","date":"2018-12-02T01:18:14.000Z","updated":"2018-12-02T02:12:19.470Z","comments":true,"path":"2018/12/02/solidity-63-lottery-project-show-page/","link":"","permalink":"https://dreamerjonson.com/2018/12/02/solidity-63-lottery-project-show-page/","excerpt":"","text":"前台页面展示 在下面的展示中，展示了管理者的地址，当前参与者的数量、当前的资金池以及玩家入场按钮与判断输赢的按钮。将玩家列表、总资金、输入框信息都存储在了state状态变量中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.css';import web3 from './web3';import lottery from './lottery';class App extends Component &#123; state = &#123; manager:'', players:[], balance:'', value:'', &#125; async componentDidMount()&#123; const manager = await lottery.methods.manager().call(); const players = await lottery.methods.getPlayers().call(); const balance = await web3.eth.getBalance(lottery.options.address); this.setState(&#123;manager,players,balance&#125;); &#125; render() &#123; //console.log(web3.version); // console.log(this.state.value); return ( &lt;div&gt; &lt;h1&gt;lottery管理者地址：&lt;/h1&gt; &lt;p&gt;this is manager by &#123;this.state.manager&#125;&lt;/p&gt; &lt;p&gt;当前的参与者的数量： &#123;this.state.players.length&#125;&lt;/p&gt; &lt;p&gt;当前资金池：&#123;web3.utils.fromWei(this.state.balance,'ether')&#125; ether&lt;/p&gt; &lt;hr/&gt; &lt;form&gt; &lt;h4&gt;参与到博彩项目？&lt;/h4&gt; &lt;div&gt; &lt;label&gt;你想参与的金额：&lt;/label&gt; &lt;input value=&#123;this.state.value&#125; onChange=&#123;event=&gt;&#123;this.setState(&#123;value:event.target.value&#125;)&#125;&#125; /&gt; &lt;/div&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;hr/&gt; &lt;h4&gt;判断输赢&lt;/h4&gt; &lt;button&gt;开始博彩&lt;/button&gt; &lt;p&gt;&#123;this.state.message&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default App;","categories":[{"name":"DAPP","slug":"DAPP","permalink":"https://dreamerjonson.com/categories/DAPP/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"以太坊DAPP[3]-博彩-react特性与博彩合约实例","slug":"solidity-62-lottery-project-react-state-manager","date":"2018-12-02T01:04:12.000Z","updated":"2018-12-02T02:12:23.357Z","comments":true,"path":"2018/12/02/solidity-62-lottery-project-react-state-manager/","link":"","permalink":"https://dreamerjonson.com/2018/12/02/solidity-62-lottery-project-react-state-manager/","excerpt":"","text":"博彩实例 在之前的课程中，我们介绍了如何编译与部署合约。现在，我们假设已经把合约部署到了ropsten的网络之上。得到了地址。 现在，我们需要通过合约的ABI接口与地址来构建博彩合约的实例。 新建文件：src/lottery.js: 1234567import web3 from './web3';const address = '0x94A261B507c4388f2ADcFfaA5685ffdF53ebcba5';const abi = [&#123;\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"address\"&#125;],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"&#125;,&#123;\"constant\":false,\"inputs\":[],\"name\":\"getPlayers\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"address[]\"&#125;],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"&#125;,&#123;\"constant\":false,\"inputs\":[],\"name\":\"enetr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"&#125;,&#123;\"constant\":false,\"inputs\":[],\"name\":\"pickwiner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"&#125;,&#123;\"constant\":true,\"inputs\":[&#123;\"name\":\"\",\"type\":\"uint256\"&#125;],\"name\":\"players\",\"outputs\":[&#123;\"name\":\"\",\"type\":\"address\"&#125;],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"&#125;,&#123;\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"&#125;];export default new web3.eth.Contract(abi,address); src/App.js: componentDidMount为react class的生命周期函数，其在reander之后执行。state是react中特殊的属性，其只是存在于class component中，用于存储属性。 当state中的状态变化之后，都会重新的执行reander函数，从而让页面展现出不同的效果。下面获取了管理者的地址并存储在了state状态变量中。在页面中显示了管理者的地址。 1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.css';import web3 from './web3';import lottery from './lottery';class App extends Component &#123; state = &#123; manager:'', &#125; async componentDidMount()&#123; const manager = await lottery.methods.manager().call(); this.setState(&#123;manager&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;lottery管理者地址：&lt;/h1&gt; &lt;p&gt;this is manager by &#123;this.state.manager&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default App;","categories":[{"name":"DAPP","slug":"DAPP","permalink":"https://dreamerjonson.com/categories/DAPP/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"以太坊DAPP[2]-博彩-react框架与web3实例","slug":"solidity-61-lottery-project-create-react-app","date":"2018-12-01T16:19:50.000Z","updated":"2018-12-02T02:12:28.002Z","comments":true,"path":"2018/12/02/solidity-61-lottery-project-create-react-app/","link":"","permalink":"https://dreamerjonson.com/2018/12/02/solidity-61-lottery-project-create-react-app/","excerpt":"","text":"安装React create-react-app 可以为我们新建一个模版react项目。让我们非常方便的使用到React。 123&gt; npm install -g create-react-app&gt; create-react-app lotterydemo&gt; npm start &#x2F;&#x2F;自动打开localhost:3000 看到react界面 web3实例 新建 src/web3.js 在这里使用到了浏览器中内置的provider，在这里默认用户安装了metamask，因为metamask会内置web3j和provider到浏览器中。但是metamask内置的web3j库是0.20版本的。我们希望使用到罪行的1.0版本的web3j。同时使用到metamask提供的provider。 123import Web3 from 'web3';const web3 = new Web3(window.web3.currentProvider);export default web3; app.js: 在浏览器打印出，web3的版本为1.0.0@beta36 12345import web3 from &#39;.&#x2F;web3&#39;;render() &#123; console.log(web3.version); ...&#125;","categories":[{"name":"DAPP","slug":"DAPP","permalink":"https://dreamerjonson.com/categories/DAPP/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"以太坊DAPP[1]-博彩-构建博彩合约","slug":"solidity-60-lottery-project-contract","date":"2018-12-01T16:08:26.000Z","updated":"2018-12-02T02:12:44.238Z","comments":true,"path":"2018/12/02/solidity-60-lottery-project-contract/","link":"","permalink":"https://dreamerjonson.com/2018/12/02/solidity-60-lottery-project-contract/","excerpt":"","text":"借助于智能合约代码公开透明的特性，其在博彩方面拥有巨大的潜力。 下面的代码构建一个博彩合约 功能如下： 1、玩家入场，必须大于0.01Ether 2、裁判判断输赢、通过随机数的方式得到赢家，赢家将会得到所有的资金。然后清空玩家列表，等待玩家从新入场。 lottery.sol 123456789101112131415161718192021222324252627282930313233343536373839404142434445pragma solidity ^0.4.23;contract Lottery&#123; //管理者 address public manager; //玩家 address[] public players;//构造函数 分配裁判 constructor() public &#123; manager = msg.sender; &#125;//玩家入场 0.01Ether function enetr() public payable&#123; require(msg.value&gt;0.01 ether); players.push(msg.sender); &#125;//产生随机数 function random() private view returns(uint)&#123; return uint(keccak256(block.difficulty,now,players)); &#125;// 权限判断 modifier restricted&#123; require(msg.sender==manager); _; &#125;// 判断输赢 function pickwiner() public&#123; uint index = random() % players.length; players[index].transfer(address(this).balance); players = new address[](0); &#125;//获取玩家列表function getPlayers() public returns(address[])&#123; return players;&#125;&#125;","categories":[{"name":"DAPP","slug":"DAPP","permalink":"https://dreamerjonson.com/categories/DAPP/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity[59]-infura-deploy","slug":"solidity-59-infura-deploy","date":"2018-12-01T14:59:52.000Z","updated":"2018-12-01T15:06:33.826Z","comments":true,"path":"2018/12/01/solidity-59-infura-deploy/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/solidity-59-infura-deploy/","excerpt":"","text":"infura 在之前，我们使用了本地的ganache-cli测试网络+mocha测试部署交互合约。现在，我们需要使用到infura将合约部署到真实的区块链的网络当中。 我们都知道，如果我们本身不是一个以太坊的节点，那么我们就需要将我们的交易发送给其他的节点来挖矿确认。infura就是默认的维护了许多的节点，我们通过它就能够与以太坊进行连接。 安装模块 1npm install --save truffle-hdwallet-provider 利用infura部署合约 deploy.js: 12345678910111213141516171819202122232425 const HDWalletProvider = require('truffle-hdwallet-provider'); const Web3 = require('web3'); const &#123;interface,bytecode&#125; = require('./compile');//借助于infura提供provider,ropsten网络 const provider = new HDWalletProvider( 'type give repair twenty split notable humor sweet obey pizza click absurd', 'https://ropsten.infura.io/v3/de22b468cb7846788b4d1ae36bcc26c2' ); const web3 = new Web3(provider); const deploy = async ()=&gt;&#123; console.log(interface); const accounts = await web3.eth.getAccounts(); //console.log('Attemp to deploy contract',accounts[0]); const result = await new web3.eth.Contract(JSON.parse(interface)).deploy(&#123;data:'0x'+bytecode&#125;) .send(&#123;from:accounts[0],gas:'1000000'&#125;); //打印出部署到合约中的地址。 console.log('contract deployed to ',result.options.address); &#125; deploy(); 部署 1&gt; node deploy.js","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity[57]-test-deploy-contract","slug":"solidity-58-test-deploy-contract","date":"2018-12-01T14:37:54.000Z","updated":"2018-12-01T14:56:58.505Z","comments":true,"path":"2018/12/01/solidity-58-test-deploy-contract/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/solidity-58-test-deploy-contract/","excerpt":"","text":"测试合约部署 1234567891011121314151617181920212223242526272829const ganache = require('ganache-cli');const Web3 = require('web3');//通过提供provider得到web3实例const web3 = new Web3(ganache.provider());//得到编译后得到的二进制文件与ABI接口。const &#123;bytecode,interface&#125; = require('../compile');//导入assert判断const assert = require('assert');var helloworld;var fetchAccounts;beforeEach( async()=&gt;&#123; //得到账号 fetchAccounts = await web3.eth.getAccounts(); //部署合约斌拿到合约实例 JSON.parse(interface) 将interface转换为JSON对象。deploy函数传递要部署的二进制文件以及构造参数。 //send函数代表真正的部署，需要传递部署的账号以及gaslimit限制。 helloworld = await new web3.eth.Contract(JSON.parse(interface)).deploy(&#123;data:bytecode,arguments:['jonson']&#125;).send(&#123;from:fetchAccounts[0],gas:'1000000'&#125;);&#125;);//获取到的helloworld实例是一个js对象，helloworld.options.address代表合约部署到以太坊上的地址。因此只要存在就意味着部署成功。繁殖部署失败describe('HelloWorld',()=&gt;&#123; it('deploy contract',()=&gt;&#123; // console.log(helloworld); assert.ok(helloworld.options.address); &#125;)&#125;) 测试合约交互——调用静态方法 1234it('call static function',async ()=&gt;&#123; const message = await helloworld.methods.getName().call(); assert.equal('jonson',message);&#125;) 测试合约交互——调用动态方法 12345it('call dynamic function',async ()=&gt;&#123; await helloworld.methods.changeName('olaya').send(&#123;from:fetchAccounts[0]&#125;); const message = await helloworld.methods.getName().call(); assert.equal('olaya',message);&#125;) 完整代码 HelloWorld.js: 12345678910111213141516171819pragma solidity ^0.4.23;contract HelloWorld&#123; string public name; constructor(string _name) public &#123; name = _name; &#125; function getName() public view returns(string)&#123; return name; &#125; function changeName(string _name) public&#123; name = _name; &#125;&#125; compile.js: 12345678910111213141516const path = require('path');const fs = require('fs');const solc = require('solc');const filepath = path.resolve(__dirname,'contracts','HelloWorld.sol');console.log(filepath);const source = fs.readFileSync(filepath,\"utf8\"); console.log(source); console.log(solc.compile(source,1).contracts[':HelloWorld']);module.exports = solc.compile(source,1).contracts[':HelloWorld']; helloworld.test.js: 1234567891011121314151617181920212223242526272829303132333435363738const ganache = require('ganache-cli');const Web3 = require('web3');const web3 = new Web3(ganache.provider()); // const helloworld = require('../compile');//helloworld.bytecode helloworld.interfaceconst &#123;bytecode,interface&#125; = require('../compile');const assert = require('assert');var helloworld;var fetchAccounts;beforeEach( async()=&gt;&#123; fetchAccounts = await web3.eth.getAccounts(); helloworld = await new web3.eth.Contract(JSON.parse(interface)).deploy(&#123;data:bytecode,arguments:['jonson']&#125;).send(&#123;from:fetchAccounts[0],gas:'1000000'&#125;); console.log(fetchAccounts); //promise&#125;);describe('HelloWorld',()=&gt;&#123; it('deploy contract',()=&gt;&#123; // console.log(helloworld); assert.ok(helloworld.options.address); &#125;) it('call static function',async ()=&gt;&#123; const message = await helloworld.methods.getName().call(); assert.equal('jonson',message); &#125;) it('call dynamic function',async ()=&gt;&#123; await helloworld.methods.changeName('olaya').send(&#123;from:fetchAccounts[0]&#125;); const message = await helloworld.methods.getName().call(); assert.equal('olaya',message); &#125;)&#125;) 测试 1&gt; npm test 返回： 1234567&gt; myproject@1.0.0 test &#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;myproject&gt; mocha HelloWorld ✓ deploy contract ✓ call static function ✓ call dynamic function (67ms) 3 passing (348ms)","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[57]-测试web3j","slug":"solidity-57-test-web3j","date":"2018-12-01T14:10:06.000Z","updated":"2018-12-03T10:53:11.438Z","comments":true,"path":"2018/12/01/solidity-57-test-web3j/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/solidity-57-test-web3j/","excerpt":"","text":"安装模块 ganache-cli 代表本地测试网络 web3j 模块与以太坊进行交互 1&gt; npm install --save ganache-cli web3 mocha 使用mocha框架测试web3j，打印出账号 pachage.json: 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha&quot; &#125;, helloworld.test.js: 12345678910111213141516const ganache = require('ganache-cli');const Web3 = require('web3');//构建web3j实例 ， provider是连接web3j与以太坊的桥梁。这里由ganache-cli提供。const web3 = new Web3(ganache.provider());const assert = require('assert');beforeEach( ()=&gt;&#123; web3.eth.getAccounts().then(fetchAccounts=&gt;&#123; console.log(fetchAccounts); &#125;);&#125;);describe('HelloWorld',()=&gt;&#123; it('deploy contract',()=&gt;&#123;&#125;)&#125;) 测试 1&gt; npm test 打印出账号 下面的10个账号是本地测试网络ganache-cli自动生成的。 12345678910[ &#39;0xa1ef752Cb11e41844898370b57d97A0E49Fe1B31&#39;, &#39;0x8D1b2f184408F3916c0d34045FFdBe175814F5d5&#39;, &#39;0x1c668849b383e87c4F6DCD6c0ee91D56187Cba13&#39;, &#39;0x68492B65b4bec8475E7112CC3Edd807cB23DAb6b&#39;, &#39;0xaF685ba6e028a592993A10c23C2E0875d95E974A&#39;, &#39;0x6226C34bf95aad9357120501f6D7651DDe925B6d&#39;, &#39;0xB31D3f8db004717d56BBc95e45d0762Dc473Ed18&#39;, &#39;0x28fFd75386de79f54cE1f9313F0F1C8f16B5Ec1e&#39;, &#39;0x2B34AD39b40D10A5D5D6d70eeAD2b9203C0858d0&#39;, &#39;0x478061329f8AfEF014a91e7A2aeAfE628D047eb2&#39; ] ES6新特性await与async await与async处理异步操作，代码更加的优雅。 123456789101112131415161718const ganache = require('ganache-cli');const Web3 = require('web3');const web3 = new Web3(ganache.provider());const assert = require('assert');beforeEach( async()=&gt;&#123; fetchAccounts = await web3.eth.getAccounts(); console.log(fetchAccounts);&#125;);describe('HelloWorld',()=&gt;&#123; it('fetchAccounts',()=&gt;&#123;&#125;)&#125;)","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[56]-solc编译智能合约","slug":"solidity-56-node-compile-contract","date":"2018-12-01T13:59:43.000Z","updated":"2018-12-04T01:40:10.764Z","comments":true,"path":"2018/12/01/solidity-56-node-compile-contract/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/solidity-56-node-compile-contract/","excerpt":"","text":"安装solc编译器 1&gt; npm install --save solc solc编译智能合约 12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path');const fs = require('fs');const solc = require('solc');//获取文件路径 跨平台const filepath = path.resolve(__dirname,'contracts','HelloWorld.sol');//打印出路径 /Users/jackson/Desktop/myproject/contracts/HelloWorld.sol//console.log(filepath);//读取文件内容const source = fs.readFileSync(filepath,\"utf8\");// console.log(source);打印出文件中的内容// pragma solidity ^0.4.23;//// contract HelloWorld&#123;// string public name;////// constructor(string _name) public &#123;// name = _name;// &#125;//// function getName() public view returns(string)&#123;// return name;// &#125;// function changeName(string _name) public&#123;// name = _name;// &#125;////// &#125;//编译后是一个对象,打印出来， 1代表1个智能合约文件 //console.log(solc.compile(source,1).contracts[':HelloWorld']);module.exports = solc.compile(source,1).contracts[':HelloWorld'];","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"nodejs渐入佳境[33]-mocha测试与自动测试","slug":"node-33-test-app","date":"2018-12-01T08:58:48.000Z","updated":"2018-12-01T10:24:02.592Z","comments":true,"path":"2018/12/01/node-33-test-app/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/node-33-test-app/","excerpt":"","text":"mocha 12&gt; npm init&gt; npm install --save-dev mocha &#x2F;&#x2F;开发者模式下有效，不会部署到服务器上 package.json 1234567891011121314&#123; &quot;name&quot;: &quot;testapplication&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha **&#x2F;*.test.js&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;mocha&quot;: &quot;^5.2.0&quot; &#125;&#125; 测试文件 12345678910let add = (a,b)=&gt;a+b;it(\"test add\",()=&gt;&#123; var res = add(11,22); if(res!=33)&#123; throw new Error(`Expected 33 ,but got $&#123;res&#125;`) &#125;&#125;); 测试 1&gt; npm test 返回： 1234567&gt; mocha **&#x2F;*.test.js ✓ test add 1 passing (4ms) 修改并测试 12345678910let add &#x3D; (a,b)&#x3D;&gt;a+b;it(&quot;test add&quot;,()&#x3D;&gt;&#123; var res &#x3D; add(11,55); if(res!&#x3D;33)&#123; throw new Error(&#96;Expected 33 ,but got $&#123;res&#125;&#96;) &#125;&#125;); 返回： 123456789101112131415&gt; testapplication@1.0.0 test &#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;testApplication&gt; mocha **&#x2F;*.test.js 1) test add 0 passing (4ms) 1 failing 1) test add: Error: Expected 33 ,but got 66 at Context.it (add.test.js:8:15)npm ERR! Test failed. See above for more details. 自动测试 12&gt; npm install --save-dev nodemon&gt; nodemon --exec &quot;npm test&quot; 添加到脚本中 package.json: 123456789101112131415&#123; &quot;name&quot;: &quot;testapplication&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha **&#x2F;*.test.js&quot;, &quot;test-watch&quot;: &quot;nodemon --exec \\&quot;npm test\\&quot;&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;mocha&quot;: &quot;^5.2.0&quot; &#125;&#125; 执行： 1&gt;npm run test-watch","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"golang语言渐入佳境[31]-错误处理","slug":"golang-31-error-handle","date":"2018-12-01T08:14:57.000Z","updated":"2019-03-02T08:33:29.335Z","comments":true,"path":"2018/12/01/golang-31-error-handle/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/golang-31-error-handle/","excerpt":"","text":"创建错误对象的两种方式 12345678910111213//1、创建error对象的方式1 err1 := errors.New(\"自己创建的错误！\") fmt.Println(err1.Error()) fmt.Println(err1) fmt.Printf(\"err1的类型：%T\\n\", err1) //*errors.errorString fmt.Println(\"-----------------\") //2、创建error对象的方式2 err2 := fmt.Errorf(\"错误的类型%d\", 10) fmt.Println(err2.Error()) fmt.Println(err2) fmt.Printf(\"err2的类型：%T\\n\", err2) //*errors.errorString fmt.Println(\"-----------------\") 错误对象的使用办法：函数多返回值 1234567891011121314151617181920212223242526package mainimport ( \"errors\" \"fmt\")func main() &#123; res , err3 := checkAge(-12) if err3 != nil &#123; fmt.Println(err3.Error()) fmt.Println(err3) &#125; else &#123; fmt.Println(res) &#125;&#125;//设计一个函数：验证年龄。如果是负数，则返回errorfunc checkAge(age int) (string, error) &#123; if age &lt; 0 &#123; err := fmt.Errorf(\"您的年龄输入是：%d ， 该数值为负数，有错误！\", age) return \"\", err &#125; else &#123; return fmt.Sprintf(\"您的年龄输入是：%d \", age), nil &#125;&#125; 自定义错误对象：实现接口 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( \"time\" \"fmt\")//1、定义结构体，表示自定义错误的类型type MyError struct &#123; When time.Time What string&#125;//2、实现Error()方法func (e MyError) Error() string &#123; return fmt.Sprintf(\"%v : %v\", e.When, e.What)&#125;//3、定义函数，返回error对象。该函数求矩形面积func getArea(width, length float64) (float64, error) &#123; errorInfo := \"\" if width &lt; 0 &amp;&amp; length &lt; 0 &#123; errorInfo = fmt.Sprintf(\"长度：%v, 宽度：%v ， 均为负数\", length, width) &#125; else if length &lt; 0 &#123; errorInfo = fmt.Sprintf(\"长度：%v, 出现负数 \", length) &#125; else if width &lt; 0 &#123; errorInfo = fmt.Sprintf(\"宽度：%v ， 出现负数\", width) &#125; if errorInfo != \"\" &#123; return 0, MyError&#123;time.Now(), errorInfo&#125; &#125; else &#123; return width * length, nil &#125;&#125;func main() &#123; res , err := getArea(-4, -5) if err != nil &#123; fmt.Printf(err.Error()) &#125; else &#123; fmt.Println(\"面积为：\" , res) &#125;&#125; 统一资源错误处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package mainimport ( \"net/http\" \"log\" \"os\" \"io/ioutil\")//当用户访问/list之后，进行资源处理func HandleFileList(writer http.ResponseWriter, request *http.Request) error &#123; path := request.URL.Path[len(\"/list/\"):] file, err := os.Open(path) if err != nil &#123; return err &#125; defer file.Close() all, err := ioutil.ReadAll(file) if err != nil &#123; return err &#125; writer.Write(all) return nil&#125;type appHandler func(writer http.ResponseWriter, request *http.Request) error//错误包装器，统一错误处理func errWrapper( handler appHandler) func( http.ResponseWriter, *http.Request) &#123; //也是一个handle返回函数，只是错误处理之后，函数式编程 return func(writer http.ResponseWriter, request *http.Request) &#123; err := handler(writer, request) if err != nil &#123; log.Printf(\"Error occurred \"+ \"handling request: %s\", err.Error()) // system error code := http.StatusOK switch &#123; case os.IsNotExist(err): code = http.StatusNotFound case os.IsPermission(err): code = http.StatusForbidden default: code = http.StatusInternalServerError &#125; http.Error(writer, http.StatusText(code), code) &#125; &#125;&#125;//web服务器func main() &#123; http.HandleFunc(\"/list/\", errWrapper(HandleFileList)) err := http.ListenAndServe(\":8888\", nil) if err != nil &#123; panic(err) &#125;&#125; recover的用例 12345678910111213141516171819202122232425262728293031323334func tryRecover() &#123; defer func() &#123; r := recover() if r == nil &#123; fmt.Println(\"Nothing to recover. \" + \"Please try uncomment errors \" + \"below.\") return &#125; if err, ok := r.(error); ok &#123; fmt.Println(\"Error occurred:\", err) &#125; else &#123; panic(fmt.Sprintf( \"I don't know what to do: %v\", r)) &#125; &#125;() // Uncomment each block to see different panic // scenarios. // Normal error //panic(errors.New(\"this is an error\")) // Division by zero //b := 0 //a := 5 / b //fmt.Println(a) // Causes re-panic //panic(123)&#125;func main() &#123; tryRecover()&#125; 统一资源错误处理2 web.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package viperimport ( \"net/http\" \"log\" \"os\")type appHandler func(writer http.ResponseWriter, request *http.Request) errorfunc errWrapper( handler appHandler) func( http.ResponseWriter, *http.Request) &#123; return func(writer http.ResponseWriter, request *http.Request) &#123; // panic defer func() &#123; if r := recover(); r != nil &#123; log.Printf(\"Panic: %v\", r) http.Error(writer, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError) &#125; &#125;() err := handler(writer, request) if err != nil &#123; log.Printf(\"Error occurred \"+ \"handling request: %s\", err.Error()) // user error if userErr, ok := err.(userError); ok &#123; http.Error(writer, userErr.Message(), http.StatusBadRequest) return &#125; // system error code := http.StatusOK switch &#123; case os.IsNotExist(err): code = http.StatusNotFound case os.IsPermission(err): code = http.StatusForbidden default: code = http.StatusInternalServerError &#125; http.Error(writer, http.StatusText(code), code) &#125; &#125;&#125;type userError interface &#123; error Message() string&#125;func main() &#123; http.HandleFunc(\"/\", errWrapper(HandleFileList)) err := http.ListenAndServe(\":8888\", nil) if err != nil &#123; panic(err) &#125;&#125; handle.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package viperimport ( \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"strings\")const prefix = \"/list/\"type usertestError stringfunc (e usertestError) Error() string &#123; return e.Message()&#125;func (e usertestError) Message() string &#123; return string(e)&#125;func HandleFileList(writer http.ResponseWriter, request *http.Request) error &#123; fmt.Println() if strings.Index( request.URL.Path, prefix) != 0 &#123; return usertestError( fmt.Sprintf(\"path %s must start \"+ \"with %s\", request.URL.Path, prefix)) &#125; path := request.URL.Path[len(prefix):] file, err := os.Open(path) if err != nil &#123; return err &#125; defer file.Close() all, err := ioutil.ReadAll(file) if err != nil &#123; return err &#125; writer.Write(all) return nil&#125; wraperror_test.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package viperimport ( \"errors\" \"fmt\" \"io/ioutil\" \"net/http\" \"net/http/httptest\" \"os\" \"strings\" \"testing\")func errPanic(_ http.ResponseWriter, _ *http.Request) error &#123; panic(123)&#125;type testingUserError stringfunc (e testingUserError) Error() string &#123; return e.Message()&#125;func (e testingUserError) Message() string &#123; return string(e)&#125;func errUserError(_ http.ResponseWriter, _ *http.Request) error &#123; return testingUserError(\"user error\")&#125;func errNotFound(_ http.ResponseWriter, _ *http.Request) error &#123; return os.ErrNotExist&#125;func errNoPermission(_ http.ResponseWriter, _ *http.Request) error &#123; return os.ErrPermission&#125;func errUnknown(_ http.ResponseWriter, _ *http.Request) error &#123; return errors.New(\"unknown error\")&#125;func noError(writer http.ResponseWriter, _ *http.Request) error &#123; fmt.Fprintln(writer, \"no error\") return nil&#125;var tests = []struct &#123; h appHandler code int message string&#125;&#123; &#123;errPanic, 500, \"Internal Server Error\"&#125;, &#123;errUserError, 400, \"user error\"&#125;, &#123;errNotFound, 404, \"Not Found\"&#125;, &#123;errNoPermission, 403, \"Forbidden\"&#125;, &#123;errUnknown, 500, \"Internal Server Error\"&#125;, &#123;noError, 200, \"no error\"&#125;,&#125;func TestErrWrapper(t *testing.T) &#123; for _, tt := range tests &#123; f := errWrapper(tt.h) response := httptest.NewRecorder() request := httptest.NewRequest( http.MethodGet, \"http://www.imooc.com\", nil) f(response, request) verifyResponse(response.Result(), tt.code, tt.message, t) &#125;&#125;func TestErrWrapperInServer(t *testing.T) &#123; for _, tt := range tests &#123; f := errWrapper(tt.h) server := httptest.NewServer( http.HandlerFunc(f)) resp, _ := http.Get(server.URL) verifyResponse( resp, tt.code, tt.message, t) &#125;&#125;func verifyResponse(resp *http.Response, expectedCode int, expectedMsg string, t *testing.T) &#123; b, _ := ioutil.ReadAll(resp.Body) body := strings.Trim(string(b), \"\\n\") if resp.StatusCode != expectedCode || body != expectedMsg &#123; t.Errorf(\"expect (%d, %s); \"+ \"got (%d, %s)\", expectedCode, expectedMsg, resp.StatusCode, body) &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"nodejs渐入佳境[32]-mongodb+express+auth middleware部署到heroku","slug":"node-32-auto-heroku","date":"2018-12-01T07:56:28.000Z","updated":"2018-12-01T10:23:27.850Z","comments":true,"path":"2018/12/01/node-32-auto-heroku/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/node-32-auto-heroku/","excerpt":"","text":"package.json 123456789101112131415161718192021222324252627282930313233&#123; &quot;name&quot;: &quot;node-todo-api&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node server&#x2F;server.js&quot;, &quot;test&quot;: &quot;export NODE_ENV&#x3D;test || SET NODE_ENV&#x3D;test &amp;&amp; mocha server&#x2F;**&#x2F;*.test.js&quot;, &quot;test-watch&quot;: &quot;nodemon --exec &#39;npm test&#39;&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;6.2.2&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;bcryptjs&quot;: &quot;^2.3.0&quot;, &quot;body-parser&quot;: &quot;^1.15.2&quot;, &quot;crypto-js&quot;: &quot;^3.1.6&quot;, &quot;express&quot;: &quot;^4.14.0&quot;, &quot;jsonwebtoken&quot;: &quot;^7.1.9&quot;, &quot;lodash&quot;: &quot;^4.15.0&quot;, &quot;mongodb&quot;: &quot;^2.2.5&quot;, &quot;mongoose&quot;: &quot;^4.5.9&quot;, &quot;validator&quot;: &quot;^5.6.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;expect&quot;: &quot;^1.20.2&quot;, &quot;mocha&quot;: &quot;^3.0.2&quot;, &quot;nodemon&quot;: &quot;^1.10.2&quot;, &quot;supertest&quot;: &quot;^2.0.0&quot; &#125;&#125; git 1234.gitignore里面的文件不会提交git initgit add .git commit -m &quot;fitst commit&quot; heroku 安装heroku-cli 略… 1234heroku login &#x2F;&#x2F; 登陆账号密码heroku create &#x2F;&#x2F;创建分支git push heroku master &#x2F;&#x2F;提交到heroku管理的远程分支hexoru open &#x2F;&#x2F;打开网址 得到：https:&#x2F;&#x2F;mighty-plateau-79112.herokuapp.com studio 3T 连接mongoDB heruku config 123jacksondeMacBook-Pro:compaign jackson$ heroku config&#x3D;&#x3D;&#x3D; mighty-plateau-79112 Config VarsMONGODB_URI: mongodb:&#x2F;&#x2F;heroku_10kx7394:ij2q2p51lgsh0grsp2dq56mgu2@ds211694.mlab.com:11694&#x2F;heroku_10kx7394 添加参数，连接远程mongoDB数据库 12345server: ds211694.mlab.comport: 11694authentication DB: heroku_10kx7394Username: heroku_10kx7394password: ij2q2p51lgsh0grsp2dq56mgu2 测试 12345678910111213141516171819202122232425262728293031323334353637381、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;https:&#x2F;&#x2F;mighty-plateau-79112.herokuapp.com&#x2F;users 保存userBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian08@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5c00a66978dd038d39dc4b89&quot;, &quot;email&quot;: &quot;zhuimengshaonian08@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr84、 选择patch 输入 &gt;https:&#x2F;&#x2F;mighty-plateau-79112.herokuapp.com&#x2F;todos&#x2F;5c00a66978dd038d39dc4b89 准备修改Body中填入：&#123; &quot;text&quot;: &quot;zhuimengshaonian09@gmail.com&quot;,&#125;header附带返回：x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr8返回：&#123; &quot;completed&quot;: false, &quot;completedAt&quot;: null, &quot;_id&quot;: &quot;5c00a66978dd038d39dc4b89&quot;, &quot;text&quot;: &quot;zhuimengshaonian09@gmail.com&quot;, &quot;_creator&quot;: &quot;5c00a58c78dd038d39dc4b87&quot;, &quot;__v&quot;: 0&#125; ##源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');const bcrypt = require('bcryptjs');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;, _creator: &#123; type: mongoose.Schema.Types.ObjectId, required: true &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;UserSchema.methods.removeToken = function (token) &#123; var user = this; return user.update(&#123; $pull: &#123; tokens: &#123;token&#125; &#125; &#125;);&#125;;UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;;UserSchema.statics.findByCredentials = function (email, password) &#123; var User = this; return User.findOne(&#123;email&#125;).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; return new Promise((resolve, reject) =&gt; &#123; // Use bcrypt.compare to compare password and user.password bcrypt.compare(password, user.password, (err, res) =&gt; &#123; if (res) &#123; resolve(user); &#125; else &#123; reject(); &#125; &#125;); &#125;); &#125;);&#125;;//在保存之前执行操作。UserSchema.pre('save', function (next) &#123; var user = this;//保存时对于密码的更新 if (user.isModified('password')) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; //密码变为了hash bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;);var User = mongoose.model('User', UserSchema);//auth middlewirevar authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;app.delete('/users/me/token', authenticate, (req, res) =&gt; &#123; req.user.removeToken(req.token).then(() =&gt; &#123; res.status(200).send(); &#125;, () =&gt; &#123; res.status(400).send(); &#125;);&#125;);app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;);// POST /users/login &#123;email, password&#125;app.post('/users/login', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); User.findByCredentials(body.email, body.password).then((user) =&gt; &#123; return user.generateAuthToken().then((token) =&gt; &#123; res.header('x-auth', token).send(user); &#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//express routeapp.post('/todos',authenticate,(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text, _creator:req.user._id &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', authenticate,(req, res) =&gt; &#123; Todo.find(&#123; _creator:req.user._id &#125;).then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', authenticate,(req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findOne(&#123; _id:id, _creator:req.user._id &#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', authenticate,(req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findOneAndRemove(&#123; _id: id, _creator: req.user._id &#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id',authenticate, (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findOneAndUpdate(&#123;_id: id, _creator: req.user._id&#125;, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[31]-mongodb+express+middleware绑定用户权限2","slug":"node-31-bind-user-auth2","date":"2018-12-01T03:53:21.000Z","updated":"2018-12-01T10:23:24.009Z","comments":true,"path":"2018/12/01/node-31-bind-user-auth2/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/node-31-bind-user-auth2/","excerpt":"","text":"继续绑定用户权限，要执行操作必须要有token 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');const bcrypt = require('bcryptjs');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;, _creator: &#123; type: mongoose.Schema.Types.ObjectId, required: true &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;UserSchema.methods.removeToken = function (token) &#123; var user = this; return user.update(&#123; $pull: &#123; tokens: &#123;token&#125; &#125; &#125;);&#125;;UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;;UserSchema.statics.findByCredentials = function (email, password) &#123; var User = this; return User.findOne(&#123;email&#125;).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; return new Promise((resolve, reject) =&gt; &#123; // Use bcrypt.compare to compare password and user.password bcrypt.compare(password, user.password, (err, res) =&gt; &#123; if (res) &#123; resolve(user); &#125; else &#123; reject(); &#125; &#125;); &#125;); &#125;);&#125;;//在保存之前执行操作。UserSchema.pre('save', function (next) &#123; var user = this;//保存时对于密码的更新 if (user.isModified('password')) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; //密码变为了hash bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;);var User = mongoose.model('User', UserSchema);//auth middlewirevar authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;app.delete('/users/me/token', authenticate, (req, res) =&gt; &#123; req.user.removeToken(req.token).then(() =&gt; &#123; res.status(200).send(); &#125;, () =&gt; &#123; res.status(400).send(); &#125;);&#125;);app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;);// POST /users/login &#123;email, password&#125;app.post('/users/login', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); User.findByCredentials(body.email, body.password).then((user) =&gt; &#123; return user.generateAuthToken().then((token) =&gt; &#123; res.header('x-auth', token).send(user); &#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//express routeapp.post('/todos',authenticate,(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text, _creator:req.user._id &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', authenticate,(req, res) =&gt; &#123; Todo.find(&#123; _creator:req.user._id &#125;).then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', authenticate,(req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findOne(&#123; _id:id, _creator:req.user._id &#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', authenticate,(req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findOneAndRemove(&#123; _id: id, _creator: req.user._id &#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id',authenticate, (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findOneAndUpdate(&#123;_id: id, _creator: req.user._id&#125;, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637381、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;users 保存userBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian08@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5c00a66978dd038d39dc4b89&quot;, &quot;email&quot;: &quot;zhuimengshaonian08@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr84、 选择patch 输入 &gt;localhost:3000&#x2F;todos&#x2F;5c00a66978dd038d39dc4b89 准备修改Body中填入：&#123; &quot;text&quot;: &quot;zhuimengshaonian09@gmail.com&quot;,&#125;header附带返回：x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr8返回：&#123; &quot;completed&quot;: false, &quot;completedAt&quot;: null, &quot;_id&quot;: &quot;5c00a66978dd038d39dc4b89&quot;, &quot;text&quot;: &quot;zhuimengshaonian09@gmail.com&quot;, &quot;_creator&quot;: &quot;5c00a58c78dd038d39dc4b87&quot;, &quot;__v&quot;: 0&#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"golang语言渐入佳境[30]-rand-package","slug":"golang-30-rand-package","date":"2018-12-01T03:38:29.000Z","updated":"2018-12-01T08:20:24.685Z","comments":true,"path":"2018/12/01/golang-30-rand-package/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/golang-30-rand-package/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( \"fmt\" \"math/rand\" \"time\")func main() &#123; randTest() randAnswer()&#125;func randTest() &#123; //1、通过默认的随机数种子获取随机数. //系统默认的rand对象，随机种子默认都是1 fmt.Println(rand.Int()) fmt.Println(rand.Intn(50)) fmt.Println(rand.Float64()) // 2、动态随机种子，生成随机资源，实例化成随机对象，通过随机对象获取随机数 s1 := rand.NewSource(time.Now().UnixNano()) r1 := rand.New(s1) randnum := r1.Intn(10) fmt.Println(randnum) //3、简写形式：动态种子来获取随机数 // [0,10] rand.Seed(time.Now().UnixNano()) fmt.Println(rand.Intn(10)) fmt.Println(rand.Float64()) //[5,11] num := rand.Intn(7) + 5 fmt.Println(num)&#125;func randAnswer() &#123; answers := []string&#123; \"It is certain\", \"It is decidedly so\", \"Without a doubt\", \"Yes definitely\", \"You may rely on it\", \"As I see it yes\", \"Most likely\", \"Outlook good\", \"Yes\", \"Signs point to yes\", \"Reply hazy try again\", \"Ask again later\", \"Better not tell you now\", \"Cannot predict now\", \"Concentrate and ask again\", \"Don't count on it\", \"My reply is no\", \"My sources say no\", \"Outlook not so good\", \"Very doubtful\", &#125; rand.Seed(time.Now().UnixNano()) randnum := rand.Intn(len(answers)) fmt.Println(\"随机回答\", answers[randnum])&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[29]-math包核心方法","slug":"golang-29-math-package","date":"2018-12-01T03:34:41.000Z","updated":"2018-12-01T08:20:19.147Z","comments":true,"path":"2018/12/01/golang-29-math-package/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/golang-29-math-package/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package mainimport ( \"fmt\" \"math\")/*1、func IsNaN(f float64) (is bool) ● 报告f是否表示一个NaN（Not A Number）值。2、func Ceil(x float64) float64 ● 返回不小于x的最小整数（的浮点值）3、func Floor(x float64) float64 ● 返回不大于x的最小整数（的浮点值）4、func Trunc(x float64) float64 ● 返回x的整数部分（的浮点值）。5、func Abs(x float64) float64 ● 返回x的绝对值6、func Max(x, y float64) float64 ● 返回x和y中最大值7、func Min(x, y float64) float64 ● 返回x和y中最小值8、func Dim(x, y float64) float64 ● 函数返回x-y和0中的最大值9、func Mod(x, y float64) float64 ● 取余运算，可以理解为 x-Trunc(x/y)*y，结果的正负号和x相同10、func Sqrt(x float64) float64 ● 返回x的二次方根11、func Cbrt(x float64) float64 ● 返回x的三次方根，特例如下：12、func Hypot(p, q float64) float64 ● 返回Sqrt(p*p + q*q)13、func Pow(x, y float64) float64 ● 返回x^y14、func Sin(x float64) float64 ● 求正弦。15、func Cos(x float64) float64 ● 求余弦。16、func Tan(x float64) float64 ● 求正切。17、func Log(x float64) float64 ● 求自然对数18、func Log2(x float64) float64 ● 求2为底的对数。19、func Log10(x float64) float64求10为底的对数。 */func main() &#123; fmt.Println(math.IsNaN(3.4)) //false fmt.Println(math.Ceil(1.000001)) //2 fmt.Println(math.Floor(1.999999)) //1 fmt.Println(math.Trunc(1.999999)) //1 fmt.Println(math.Abs(-1.3)) //1.3 fmt.Println(math.Max(-1.3, 0)) //0 fmt.Println(math.Min(-1.3, 0)) //-1.3 fmt.Println(math.Dim(-12, -19)) //7 fmt.Println(math.Dim(-12, 19)) //0 fmt.Println(math.Mod(9, 4)) //1 fmt.Println(math.Sqrt(9)) //3 fmt.Println(math.Cbrt(8)) //2 fmt.Println(math.Hypot(3, 4)) //5 fmt.Println(math.Pow(2, 8)) //256 fmt.Println(math.Log(1)) //0 fmt.Println(math.Log2(16)) //4 fmt.Println(math.Log10(1000)) //3&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[28]-time包核心方法","slug":"golang-28-time-package","date":"2018-12-01T03:30:33.000Z","updated":"2018-12-01T08:20:15.449Z","comments":true,"path":"2018/12/01/golang-28-time-package/","link":"","permalink":"https://dreamerjonson.com/2018/12/01/golang-28-time-package/","excerpt":"","text":"time包核心方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package mainimport ( \"time\" \"fmt\")/*//1、Now()返回当前本地时间//2、Local()将时间转成本地时区，但指向同一时间点的Time。//3、UTC()将时间转成UTC和零时区，但指向同一时间点的Time。//4、Date()可以根据指定数值，返回一个本地或国际标准的时间格式。//5、Parse()能将一个格式化的时间字符串解析成它所代表的时间。就是string转time//6、Format()根据指定的时间格式，将时间格式化成文本。就是time转string//7、String()将时间格式化成字符串，格式为：\"2006-01-02 15:04:05.999999999 -0700 MST\"//8、Unix()将t表示为Unix时间（时间戳，一个int64整数），即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位秒）。//9、UnixNano()将t表示为Unix时间（时间戳，一个int64整数），即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位纳秒）。//10、Equal()判断时间是否相等//11、Before()如果t代表的时间点在u之前，返回真；否则返回假。//12、After()如果t代表的时间点在u之后，返回真；否则返回假。//13、Date()返回时间点对应的年、月、日信息//14、Year()返回时间点对应的年的信息//15、Month()返回时间点对应的月的信息//16、Day()返回时间点对应的日的信息//17、Weekday()返回时间点对应的星期的信息//18、Clock()返回时间点对应的时、分、秒信息//19、Hour()返回时间点对应的小时的信息//20、Minute()返回时间点对应的分的信息//21、Second()返回时间点对应的秒的信息//22、Nanosecond()返回时间点对应的纳秒的信息//23、Sub()返回一个时间段t-u。//24、Hours()将时间段表示为float64类型的小时数。//25、Minutes()将时间段表示为float64类型的分钟数。//26、Seconds()将时间段表示为float64类型的秒数。//27、Nanoseconds()将时间段表示为int64类型的纳秒数，等价于int64(d)。//28、String()返回时间段采用\"72h3m0.5s\"格式的字符串表示。//29、ParseDuration解析一个时间段字符串。//30、Add()返回时间点t+d。//31、AddDate()返回增加了给出的年份、月份和天数的时间点Time。 */func main() &#123; time1 := time.Now() testTime() time2 := time.Now() //计算函数执行时间 fmt.Println(time2.Sub(time1).Seconds())&#125;func testTime() &#123; //1、Now()返回当前本地时间 t := time.Now() fmt.Println(\"1、\", t) //2、Local()将时间转成本地时区，但指向同一时间点的Time。 fmt.Println(\"2、\", t.Local()) //3、UTC()将时间转成UTC和零时区，但指向同一时间点的Time。 fmt.Println(\"3、\", t.UTC()) //4、Date()可以根据指定数值，返回一个本地或国际标准的时间格式。 t = time.Date(2018, time.January, 1, 1, 1, 1, 0, time.Local) fmt.Printf(\"4、本地时间%s ， 国际统一时间：%s \\n\", t, t.UTC()) //5、Parse()能将一个格式化的时间字符串解析成它所代表的时间。就是string转time //预定义的ANSIC、UnixDate、RFC3339 //ANSIC = \"Mon Jan _2 15:04:05 2006\"//1 1 2 3 4 5 6 t, _ = time.Parse(\"2006-01-02 15:04:05\", \"2018-07-19 05:47:13\") fmt.Println(\"5、\", t) //6、Format()根据指定的时间格式，将时间格式化成文本。就是time转string fmt.Println(\"6、\" , time.Now().Format(\"2006-01-02 15:04:05\")) //7、String()将时间格式化成字符串，格式为：\"2006-01-02 15:04:05.999999999 -0700 MST\" fmt.Println(\"7、\" , time.Now().String()) //8、Unix()将t表示为Unix时间（时间戳，一个int64整数），即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位秒）。 fmt.Println(\"8、\" , time.Now().Unix()) //9、UnixNano()将t表示为Unix时间（时间戳，一个int64整数），即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位纳秒）。 fmt.Println(\"9、\" , time.Now().UnixNano()) //10、Equal()判断时间是否相等 fmt.Println(\"10、\" , t.Equal(time.Now())) //11、Before()如果t代表的时间点在u之前，返回真；否则返回假。 fmt.Println(\"11、\" , t.Before(time.Now())) //12、After()如果t代表的时间点在u之后，返回真；否则返回假。 fmt.Println(\"12、\" , t.After(time.Now())) //13、Date()返回时间点对应的年、月、日信息 year , month , day := time.Now().Date() fmt.Println(\"13、\" , year , month ,day) //14、Year()返回时间点对应的年的信息 fmt.Println(\"14、\" , time.Now().Year()) //15、Month()返回时间点对应的月的信息 fmt.Println(\"15、\" , time.Now().Month()) //16、Day()返回时间点对应的日的信息 fmt.Println(\"16、\" , time.Now().Day()) //17、Weekday()返回时间点对应的星期的信息 fmt.Println(\"17、\" , time.Now().Weekday()) //18、Clock()返回时间点对应的时、分、秒信息 hour , minute , second := time.Now().Clock() fmt.Println(\"18、\" , hour , minute , second) //19、Hour()返回时间点对应的小时的信息 fmt.Println(\"19、\" , time.Now().Hour()) //20、Minute()返回时间点对应的分的信息 fmt.Println(\"20、\" , time.Now().Minute()) //21、Second()返回时间点对应的秒的信息 fmt.Println(\"21、\" , time.Now().Second()) //22、Nanosecond()返回时间点对应的纳秒的信息 fmt.Println(\"22、\" , time.Now().Nanosecond()) //23、Sub()返回一个时间段t-u。 fmt.Println(\"23、\" , time.Now().Sub(time.Now())) //24、Hours()将时间段表示为float64类型的小时数。 fmt.Println(\"24、\" , time.Now().Sub(time.Now()).Hours()) //25、Minutes()将时间段表示为float64类型的分钟数。 fmt.Println(\"25、\" , time.Now().Sub(time.Now()).Minutes()) //26、Seconds()将时间段表示为float64类型的秒数。 fmt.Println(\"26、\" , time.Now().Sub(time.Now()).Seconds()) //27、Nanoseconds()将时间段表示为int64类型的纳秒数，等价于int64(d)。 fmt.Println(\"27、\" , time.Now().Sub(time.Now()).Nanoseconds()) //28、String()返回时间段采用\"72h3m0.5s\"格式的字符串表示。 fmt.Println(\"28、\" , \"时间间距：\", t.Sub(time.Now()).String()) //29、ParseDuration解析一个时间段字符串。 d,_:=time.ParseDuration(\"1h30m\") fmt.Println(\"29、\" , d) //30、Add()返回时间点t+d。 fmt.Println(\"30、\" , \"交卷时间：\" , time.Now().Add(d)) //31、AddDate()返回增加了给出的年份、月份和天数的时间点Time。 fmt.Println(\"31、\" , \"一年一个月零一天之后的日期：\" , time.Now().AddDate(1,1,1))&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[27]-其他类型转string函数","slug":"golang-27-string-package6","date":"2018-11-30T09:34:51.000Z","updated":"2018-11-30T10:07:38.629Z","comments":true,"path":"2018/11/30/golang-27-string-package6/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/golang-27-string-package6/","excerpt":"","text":"其他类型转string函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package mainimport ( \"fmt\" \"strconv\")/*1、func Itoa(i int) stringItoa 是 FormatInt(int64(i), 10) 的缩写。2、func FormatInt(i int64, base int) stringFormatInt 返回给定基数中的i的字符串表示，对于2 &lt;= base &lt;= 36.结果对于数字值&gt; = 10使用小写字母 'a' 到 'z' 。3、func FormatUint(i uint64, base int) stringFormatUint 返回给定基数中的 i 的字符串表示，对于2 &lt;= base &lt;= 36.结果对于数字值&gt; = 10使用小写字母 'a' 到 'z' 。4、func FormatFloat(f float64, fmt byte, prec, bitSize int) stringFormatFloat 根据格式 fmt 和 precision prec 将浮点数f转换为字符串。它将结果进行四舍五入，假设原始数据是从 bitSize 位的浮点值获得的（float32为32，float64为64）。格式 fmt 是 'b'，'e'，'E'，'f'，'g'或 'G'。5、func FormatBool(b bool) stringFormatBool 根据 b 的值返回“true”或“false” */func main() &#123; TestItoa() TestFormatInt() TestFormatUint() TestFormatFloat() TestFormatBool()&#125;func TestItoa() &#123; s := strconv.Itoa(199) fmt.Printf(\"%T , %v , 长度：%d \\n\", s, s, len(s)) fmt.Println(\"----------------\")&#125;func TestFormatInt() &#123; s := strconv.FormatInt(-19968, 16)//4e00 s = strconv.FormatInt(-40869, 16)//9fa5 fmt.Printf(\"%T , %v , 长度：%d \\n\", s, s, len(s)) fmt.Println(\"----------------\")&#125;func TestFormatUint() &#123; s := strconv.FormatUint(19968, 16)//4e00 s = strconv.FormatUint(40869, 16)//9fa5 fmt.Printf(\"%T , %v , 长度：%d \\n\", s, s, len(s)) fmt.Println(\"----------------\")&#125;func TestFormatFloat() &#123; s := strconv.FormatFloat(3.1415926 , 'g' , -1 , 64) fmt.Printf(\"%T , %v , 长度：%d \\n\", s, s, len(s)) fmt.Println(\"----------------\")&#125;func TestFormatBool() &#123; s := strconv.FormatBool(true) s = strconv.FormatBool(false) fmt.Printf(\"%T , %v , 长度：%d \\n\", s, s, len(s)) fmt.Println(\"----------------\")&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[26]-string转其他类型函数","slug":"golang-26-string-package5","date":"2018-11-30T09:31:34.000Z","updated":"2018-11-30T09:38:53.615Z","comments":true,"path":"2018/11/30/golang-26-string-package5/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/golang-26-string-package5/","excerpt":"","text":"string转其他类型函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package mainimport ( \"strconv\" \"fmt\")/*1、func Atoi(s string) (int, error)Atoi 返回 ParseInt(s, 10, 0) 转换为 int 类型的结果。【alphabet：字母】2、func ParseInt(s string, base int, bitSize int) (i int64, err error)ParseInt 解释给定基础（2到36）中的字符串 s 并返回相应的值 i。如果 base == 0，则基数由字符串的前缀隐含：base 16代表“0x”，base 8代表“0”，否则以10为底数。3、func ParseUint(s string, base int, bitSize int) (uint64, error)ParseUint 就像 ParseInt，但是对于无符号数字。4、func ParseFloat(s string, bitSize int) (float64, error)ParseFloat 将字符串 s 转换为浮点数，精度由 bitSize：32指定，float32为64; float64为64。当 bitSize = 32时，结果仍然具有 float64 类型，但可以在不更改其值的情况下将其转换为 float32。5、func ParseBool(str string) (bool, error)ParseBool 返回字符串表示的布尔值。它接受1，t，T，TRUE，true，True，0，f，F，FALSE，false，False。任何其他值都会返回错误。 */func main() &#123; TestAtoi() TestParseInt() TestParseUint() TestParseFloat() TestParseBool()&#125;func TestAtoi() &#123; a, _ := strconv.Atoi(\"100\") fmt.Printf(\"%T , %v \\n\", a, a+2) fmt.Println(\"---------------\")&#125;func TestParseInt() &#123; num, _ := strconv.ParseInt(\"-4e00\", 16, 64) fmt.Printf(\"%T , %v \\n\", num, num) num, _ = strconv.ParseInt(\"01100001\", 2, 64) fmt.Printf(\"%T , %v\\n\", num, num) num, _ = strconv.ParseInt(\"-01100001\", 10, 64) fmt.Printf(\"%T , %v\\n\", num, num) num, _ = strconv.ParseInt(\"4e00\", 10, 64) fmt.Printf(\"%T , %v\\n\", num, num) fmt.Println(\"---------------\")&#125;func TestParseUint() &#123; num, _ := strconv.ParseUint(\"4e00\", 16, 64) fmt.Printf(\"%T , %v \\n\", num, num) num, _ = strconv.ParseUint(\"01100001\", 2, 64) fmt.Printf(\"%T , %v\\n\", num, num) num, _ = strconv.ParseUint(\"-1100001\", 10, 64) fmt.Printf(\"%T , %v\\n\", num, num) num, _ = strconv.ParseUint(\"4e00\", 10, 64) fmt.Printf(\"%T , %v\\n\", num, num) fmt.Println(\"---------------\")&#125;func TestParseFloat() &#123; pi := \"3.1415926\" num , _ := strconv.ParseFloat(pi , 64) fmt.Printf(\"%T , %v\\n\", num, num*2) fmt.Println(\"---------------\")&#125;func TestParseBool() &#123; //1, t, T, TRUE, true, True, // 0, f, F, FALSE, false, False. flag , _:=strconv.ParseBool(\"steven\") fmt.Printf(\"%T , %v\\n\", flag, flag) fmt.Println(\"---------------\")&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[25]-string-trim修剪类函数","slug":"golang-25-string-package4","date":"2018-11-30T09:29:19.000Z","updated":"2018-11-30T09:38:49.773Z","comments":true,"path":"2018/11/30/golang-25-string-package4/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/golang-25-string-package4/","excerpt":"","text":"string-trim修剪类函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package mainimport ( \"fmt\" \"strings\" \"unicode\")/*1、func Trim(s string, cutset string) string将字符串s中首尾包含cutset中的任一字符去掉返回2、func TrimFunc(s string, f func(rune) bool) string将字符串s首尾满足函数f(r)==true的字符去掉返回3、func TrimLeft(s string, cutset string) string将字符串s左边包含cutset中的任一字符去掉返回4、func TrimLeftFunc(s string, f func(rune) bool) string将字符串s左边满足函数f(r)==true的字符去掉返回5、func TrimRight(s string, cutset string) string将字符串s右边包含cutset中的任一字符去掉返回6、func TrimRightFunc(s string, f func(rune) bool) string将字符串s右边满足函数f(r)==true的字符去掉返回7、func TrimSpace(s string) string将字符串s首尾空白去掉返回8、func TrimPrefix(s, prefix string) string将字符串s中前缀字符串prefix去掉返回9、func TrimSuffix(s, suffix string) string将字符串s中后缀字符串prefix去掉返回 */func main() &#123; TestTrim() TestTrimFunc() TestTrimLeft() TestTrimLeftFunc() TestTrimRight() TestTrimRightFunc() TestTrimSpace() TestTrimPrefix() TestTrimSuffix()&#125;func TestTrim() &#123; fmt.Println(strings.Trim(\" steven wang \" , \" \"))//steven wang&#125;func TestTrimFunc() &#123; f := func(c rune) bool &#123; return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c) &#125; fmt.Println(strings.TrimFunc(\"！@#￥%steven wang%￥#@\" , f))//steven wang&#125;func TestTrimLeft() &#123; fmt.Println(strings.TrimLeft(\" steven wang \" , \" \"))//steven wang&#125;func TestTrimLeftFunc() &#123; f := func(c rune) bool &#123; return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c) &#125; fmt.Println(strings.TrimLeftFunc(\"！@#￥%steven wang%￥#@\" , f))//steven wang%￥#@&#125;func TestTrimRight() &#123; fmt.Println(strings.TrimRight(\" steven wang \" , \" \"))// steven wang&#125;func TestTrimRightFunc() &#123; f := func(c rune) bool &#123; return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c) &#125; fmt.Println(strings.TrimRightFunc(\"！@#￥%steven wang%￥#@\" , f))//！@#￥%steven wang&#125;func TestTrimSpace() &#123; fmt.Println(strings.TrimSpace(\" \\t\\n a lone gopher \\n\\t\\r\\n\"))//a lone gopher&#125;func TestTrimPrefix() &#123; var s = \"Goodbye,world!\" s = strings.TrimPrefix(s, \"Goodbye\")//,world! fmt.Println(s)&#125;func TestTrimSuffix() &#123; var s = \"Hello, goodbye, etc!\" s = strings.TrimSuffix(s, \"goodbye, etc!\")//Hello, fmt.Println(s)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[24]-string-大小写转换类函数","slug":"golang-24-string-package3","date":"2018-11-30T09:26:57.000Z","updated":"2018-11-30T09:38:46.078Z","comments":true,"path":"2018/11/30/golang-24-string-package3/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/golang-24-string-package3/","excerpt":"","text":"string-大小写转换类函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( \"fmt\" \"strings\")/*1、func Title(s string) string将字符串s每个单词首字母大写返回2、func ToLower(s string) string将字符串s转换成小写返回3、func ToLowerSpecial(_case unicode.SpecialCase, s string) string将字符串s中所有字符按_case指定的映射转换成小写返回4、func ToTitle(s string) string将字符串s转换成大写返回5、func ToTitleSpecial(_case unicode.SpecialCase, s string) string将字符串s中所有字符按_case指定的映射转换成大写返回6、func ToUpper(s string) string将字符串s转换成大写返回7、func ToUpperSpecial(_case unicode.SpecialCase, s string) string将字符串s中所有字符按_case指定的映射转换成大写返回 */func main() &#123; TestTitle() TestToTitle() TestToLower() TestToUpper()&#125;func TestTitle() &#123; fmt.Println(strings.Title(\"her royal highness\"))&#125;func TestToTitle() &#123; fmt.Println(strings.ToTitle(\"louD noises\"))&#125;//func TestToTitleSpecial() &#123;//&#125;func TestToLower() &#123; fmt.Println(strings.ToLower(\"Gopher\"))&#125;//func TestToLowerSpecial() &#123;////&#125;func TestToUpper() &#123; fmt.Println(strings.ToUpper(\"Gopher\"))&#125;//func TestToUpperSpecial() &#123;////&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[23]-string分割类函数","slug":"golang-23-string-package2","date":"2018-11-30T09:19:43.000Z","updated":"2018-11-30T09:38:42.534Z","comments":true,"path":"2018/11/30/golang-23-string-package2/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/golang-23-string-package2/","excerpt":"","text":"string分割类函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( \"fmt\" \"strings\" \"unicode\")/*1、func Fields(s string) []string将字符串s以空白字符分割，返回一个切片2、func FieldsFunc(s string, f func(rune) bool) []string将字符串s以满足f(r)==true的字符分割，返回一个切片3、func Split(s, sep string) []string将字符串s以sep作为分隔符进行分割，分割后字符最后去掉sep4、func SplitAfter(s, sep string) []string将字符串s以sep作为分隔符进行分割，分割后字符最后附上sep5、func SplitAfterN(s, sep string, n int) []string将字符串s以sep作为分隔符进行分割，分割后字符最后附上sep，n决定返回的切片数6、func SplitN(s, sep string, n int) []string将字符串s以sep作为分隔符进行分割，分割后字符最后去掉sep，n决定返回的切片数 */func main() &#123; TestSplitAfterN()&#125;func TestFields() &#123; fmt.Println(strings.Fields(\" abc 123 ABC xyz XYZ\")) //[abc 123 ABC xyz XYZ]&#125;func TestFieldsFunc() &#123; f := func(c rune) bool &#123; //return c == '=' return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c) &#125; fmt.Println(strings.FieldsFunc(\"abc@123*ABC&amp;xyz%XYZ\" , f)) //[abc 123 ABC xyz XYZ]&#125;func TestSplit() &#123; fmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))//[a b c] fmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))//[\"\" \"man \" \"plan \" \"canal panama\"] fmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))//[\" \" \"x\" \"y\" \"z\" \" \"] fmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))//[\"\"]&#125;func TestSplitN() &#123; fmt.Printf(\"%q\\n\", strings.SplitN(\"a,b,c\", \",\", 2))//[\"a\" \"b,c\"] fmt.Printf(\"%q\\n\", strings.SplitN(\"a,b,c\", \",\", 1))//[\"a,b,c\"]&#125;func TestSplitAfter() &#123; fmt.Printf(\"%q\\n\", strings.SplitAfter(\"a,b,c\", \",\"))//[\"a,\" \"b,\" \"c\"]&#125;func TestSplitAfterN() &#123; fmt.Printf(\"%q\\n\", strings.SplitAfterN(\"a,b,c\", \",\", 2))//[\"a,\" \"b,c\"]&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[22]-string检索类函数","slug":"golang-22-string-package","date":"2018-11-30T09:17:41.000Z","updated":"2018-11-30T09:38:39.312Z","comments":true,"path":"2018/11/30/golang-22-string-package/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/golang-22-string-package/","excerpt":"","text":"string检索类函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package mainimport ( \"fmt\" \"strings\" \"unicode\")/*1、func Contains(s, substr string) bool判断字符串s是否包含substr字符串2、func ContainsAny(s, chars string) bool判断字符串s是否包含chars字符串中的任一字符3、func ContainsRune(s string, r rune) bool判断字符串s是否包含unicode码值r4、func Count(s, sep string) int返回字符串s包含字符串sep的个数5、func HasPrefix(s, prefix string) bool判断字符串s是否有前缀字符串prefix6、func HasSuffix(s, suffix string) bool判断字符串s是否有后缀字符串suffix7、func Index(s, sep string) int返回字符串s中字符串sep首次出现的位置8、func IndexAny(s, chars string) int返回字符串chars中的任一unicode码值r在s中首次出现的位置9、func IndexByte(s string, c byte) int返回字符串s中字符c首次出现位置10、func IndexFunc(s string, f func(rune) bool) int返回字符串s中满足函数f(r)==true字符首次出现的位置11、func IndexRune(s string, r rune) int返回unicode码值r在字符串中首次出现的位置12、func LastIndex(s, sep string) int返回字符串s中字符串sep最后一次出现的位置13、func LastIndexAny(s, chars string) int返回字符串s中任意一个unicode码值r最后一次出现的位置14、func LastIndexByte(s string, c byte) int返回字符串s中字符c最后一次出现的位置15、func LastIndexFunc(s string, f func(rune) bool) int返回字符串s中满足函数f(r)==true字符最后一次出现的位置 */func main() &#123; TestLastIndexFunc()&#125;func TestContains() &#123; fmt.Println(strings.Contains(\"seafood\", \"foo\"))//true fmt.Println(strings.Contains(\"seafood\", \"bar\"))//false fmt.Println(strings.Contains(\"seafood\", \"\"))//true fmt.Println(strings.Contains(\"\", \"\"))//true fmt.Println(strings.Contains(\"jonson郑2008\", \"郑\"))//true&#125;func TestContainsAny() &#123; fmt.Println(strings.ContainsAny(\"team\", \"i\"))//false fmt.Println(strings.ContainsAny(\"failure\", \"u &amp; i\"))//true fmt.Println(strings.ContainsAny(\"foo\", \"\"))//false fmt.Println(strings.ContainsAny(\"\", \"\"))//false&#125;func TestContainsRune() &#123; fmt.Println(strings.ContainsRune(\"一丁丂\", '丁'))//true fmt.Println(strings.ContainsRune(\"一丁丂\", 19969))//true&#125;func TestCount() &#123; fmt.Println(strings.Count(\"cheese\", \"e\"))//3 fmt.Println(strings.Count(\"one\", \"\"))//4&#125;func TestHasPrefix() &#123; fmt.Println(strings.HasPrefix(\"1000phone news\", \"1000\"))//true fmt.Println(strings.HasPrefix(\"1000phone news\", \"1000a\"))//false&#125;func TestHasSuffix() &#123; fmt.Println(strings.HasSuffix(\"1000phone news\", \"news\"))//true fmt.Println(strings.HasSuffix(\"1000phone news\", \"new\"))//false&#125;func TestIndex() &#123; fmt.Println(strings.Index(\"chicken\", \"ken\"))//4 fmt.Println(strings.Index(\"chicken\", \"dmr\"))//-1&#125;func TestIndexAny() &#123; fmt.Println(strings.IndexAny(\"abcABC120\", \"教育基地A\"))//3&#125;func TestIndexByte() &#123; fmt.Println(strings.IndexByte(\"123abc\", 'a'))//3&#125;func TestIndexRune() &#123; fmt.Println(strings.IndexRune(\"abcABC120\", 'C'))//5 fmt.Println(strings.IndexRune(\"It培训教育\", '教'))//8&#125;func TestIndexFunc() &#123; f := func(c rune) bool &#123; return unicode.Is(unicode.Han , c) &#125; fmt.Println(strings.IndexFunc(\"Hello123,中国\" , f))//9&#125;func TestLastIndex() &#123; fmt.Println(strings.LastIndex(\"jonson learn english\", \"e\"))//13 fmt.Println(strings.Index(\"go gopher\", \"go\"))//0 fmt.Println(strings.LastIndex(\"go gopher\", \"go\"))//3 fmt.Println(strings.LastIndex(\"go gopher\", \"rodent\"))//-1&#125;func TestLastIndexAny() &#123; fmt.Println(strings.LastIndexAny(\"chicken\", \"aeiouy\"))//5 fmt.Println(strings.LastIndexAny(\"crwth\", \"aeiouy\"))//-1&#125;func TestLastIndexByte() &#123; fmt.Println(strings.LastIndexByte(\"abcABCA123\", 'A'))//6&#125;func TestLastIndexFunc() &#123; f := func(c rune) bool &#123; return unicode.Is(unicode.Han, c) &#125; fmt.Println(strings.LastIndexFunc(\"Hello,世界\", f))//9 fmt.Println(strings.LastIndexFunc(\"Hello,world中国人\", f))//17&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[21]-string类型详解","slug":"golang-21-string","date":"2018-11-30T08:43:17.000Z","updated":"2019-01-26T02:06:05.785Z","comments":true,"path":"2018/11/30/golang-21-string/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/golang-21-string/","excerpt":"","text":"string的本质 string是一个引用类型，string包含了两个部分。一个部分是指针，指向了底层的一个字节数组。另一个部分是字节数组的长度。 当复制字符串时，也只是复制了指针与长度。底层的那个字节数组是不能够改变的。 字符串使用UTF-8编码。 打印字符串 12345func main()&#123; str :&#x3D; &quot;跟着建勋老师学编程&quot; fmt.Println([]byte(str)) &#x2F;&#x2F; 转换为字节数组&#125; 转换为字节数组 1234func main()&#123; str :&#x3D; &quot;跟着建勋老师学编程&quot; fmt.Println([]byte(str))&#125; 字符串中特殊字符 12345678910\\a U+0007 alert or bell\\b U+0008 backspace\\f U+000C form feed\\n U+000A line feed or newline\\r U+000D carriage return\\t U+0009 horizontal tab\\v U+000b vertical tab\\\\ U+005c backslash\\&#39; U+0027 single quote (valid escape only within rune literals)\\&quot; U+0022 double quote (valid escape only within string literals) 字符串长度len 1234func main()&#123; str :&#x3D; &quot;跟着建勋老师学编程&quot; fmt.Println(len(str)) &#x2F;&#x2F;27 总的字节个数 &#125; 字符串序号 1234func main()&#123; str :&#x3D; &quot;跟着建勋老师学编程&quot; fmt.Println(str[20]) &#x2F;&#x2F;仍然是字节&#125; 字符串slice 截断无压力 1234func main()&#123; str :&#x3D; &quot;跟着建勋老师学编程&quot; fmt.Println(str[3:]) &#x2F;&#x2F;打印出：着建勋老师学编程&#125; 字符串+连接 12345func main()&#123; str1 :&#x3D; &quot;jonson love &quot; str2 :&#x3D;&quot;olaya&quot; fmt.Println(str1+str2) &#x2F;&#x2F;jonson love olaya&#125; Rune打印字符串 Rune为4个字节，存储国际版的字符 12345678910package mainimport &quot;fmt&quot;func main() &#123; str:&#x3D;&quot;i love 建勋老师&quot; for i,ch:&#x3D; range str&#123; fmt.Printf(&quot; (%d %x) &quot;,i,ch) &#125;&#125; 输出结果为：(0 69) (1 20) (2 6c) (3 6f) (4 76) (5 65) (6 20) (7 5efa) (10 52cb) (13 8001) (16 5e08) 每一个中文在底层占了3个字节，range str 时 前面的序号为所在字符的首字节位置。 循环每个字符： 1234567891011package mainimport &quot;fmt&quot;func main() &#123; str:&#x3D;&quot;i love 建勋老师&quot; for i,ch:&#x3D; range []rune(str)&#123; fmt.Printf(&quot; (%d %c) &quot;,i,ch) &#125;&#125; UTF8包中有不少方法，如utf8.DecodeRune为读取一个Rune以及其字节大小，案例如下： 1234567891011121314151617package mainimport ( \"fmt\" \"unicode/utf8\")func main() &#123; str:=\"i love 建勋老师\" bytes:= []byte(str) for len(bytes) &gt;0&#123; ch,size:= utf8.DecodeRune(bytes) bytes=bytes[size:] fmt.Printf(\"%c\",ch) &#125; fmt.Println()&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"nodejs渐入佳境[30]-mongodb+express+middleware绑定用户权限","slug":"node-30-bind-user-auth","date":"2018-11-30T02:56:29.000Z","updated":"2018-12-01T10:23:20.103Z","comments":true,"path":"2018/11/30/node-30-bind-user-auth/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/node-30-bind-user-auth/","excerpt":"","text":"修改todos模型 增加_creator，将用户绑定起来 123456789101112131415161718192021//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;, _creator: &#123; type: mongoose.Schema.Types.ObjectId, required: true &#125;&#125;); 添加权限控制 添加权限控制并且存储了用户的id。 用户访问/todos 必须要有authenticate这个middleware。通过以后，说明用户是可信的。就可以保存todo到数据库中。并且将todo与创建的用户链接在了一起 12345678910111213141516171819202122232425262728//express routeapp.post('/todos',authenticate,(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text, _creator:req.user._id &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', authenticate,(req, res) =&gt; &#123; Todo.find(&#123; _creator:req.user._id &#125;).then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');const bcrypt = require('bcryptjs');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;, _creator: &#123; type: mongoose.Schema.Types.ObjectId, required: true &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;UserSchema.methods.removeToken = function (token) &#123; var user = this; return user.update(&#123; $pull: &#123; tokens: &#123;token&#125; &#125; &#125;);&#125;;UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;;UserSchema.statics.findByCredentials = function (email, password) &#123; var User = this; return User.findOne(&#123;email&#125;).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; return new Promise((resolve, reject) =&gt; &#123; // Use bcrypt.compare to compare password and user.password bcrypt.compare(password, user.password, (err, res) =&gt; &#123; if (res) &#123; resolve(user); &#125; else &#123; reject(); &#125; &#125;); &#125;); &#125;);&#125;;//在保存之前执行操作。UserSchema.pre('save', function (next) &#123; var user = this;//保存时对于密码的更新 if (user.isModified('password')) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; //密码变为了hash bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;);var User = mongoose.model('User', UserSchema);//auth middlewirevar authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;app.delete('/users/me/token', authenticate, (req, res) =&gt; &#123; req.user.removeToken(req.token).then(() =&gt; &#123; res.status(200).send(); &#125;, () =&gt; &#123; res.status(400).send(); &#125;);&#125;);app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;);// POST /users/login &#123;email, password&#125;app.post('/users/login', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); User.findByCredentials(body.email, body.password).then((user) =&gt; &#123; return user.generateAuthToken().then((token) =&gt; &#123; res.header('x-auth', token).send(user); &#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//express routeapp.post('/todos',authenticate,(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text, _creator:req.user._id &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', authenticate,(req, res) =&gt; &#123; Todo.find(&#123; _creator:req.user._id &#125;).then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 123456789101112131415161718192021222324252627282930313233343536371、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;users 保存userBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr84、 选择post 输入 &gt;localhost:3000&#x2F;todosBody中填入：&#123; &quot;text&quot;: &quot;zhuimengshaonian07@gmail.com&quot;,&#125;header附带返回：x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr8返回：&#123; &quot;completed&quot;: false, &quot;completedAt&quot;: null, &quot;_id&quot;: &quot;5c00a66978dd038d39dc4b89&quot;, &quot;text&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;_creator&quot;: &quot;5c00a58c78dd038d39dc4b87&quot;, &quot;__v&quot;: 0&#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[29]-mongodb+express+middleware删除用户权限","slug":"node-29-user-delete-token","date":"2018-11-30T02:16:09.000Z","updated":"2018-11-30T03:11:20.571Z","comments":true,"path":"2018/11/30/node-29-user-delete-token/","link":"","permalink":"https://dreamerjonson.com/2018/11/30/node-29-user-delete-token/","excerpt":"","text":"删除用户的token 12345678910UserSchema.methods.removeToken = function (token) &#123; var user = this; return user.update(&#123; $pull: &#123; tokens: &#123;token&#125; &#125; &#125;);&#125;; url 1234567app.delete('/users/me/token', authenticate, (req, res) =&gt; &#123; req.user.removeToken(req.token).then(() =&gt; &#123; res.status(200).send(); &#125;, () =&gt; &#123; res.status(400).send(); &#125;);&#125;); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');const bcrypt = require('bcryptjs');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;UserSchema.methods.removeToken = function (token) &#123; var user = this; return user.update(&#123; $pull: &#123; tokens: &#123;token&#125; &#125; &#125;);&#125;;UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;;UserSchema.statics.findByCredentials = function (email, password) &#123; var User = this; return User.findOne(&#123;email&#125;).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; return new Promise((resolve, reject) =&gt; &#123; // Use bcrypt.compare to compare password and user.password bcrypt.compare(password, user.password, (err, res) =&gt; &#123; if (res) &#123; resolve(user); &#125; else &#123; reject(); &#125; &#125;); &#125;); &#125;);&#125;;//在保存之前执行操作。UserSchema.pre('save', function (next) &#123; var user = this;//保存时对于密码的更新 if (user.isModified('password')) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; //密码变为了hash bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;);var User = mongoose.model('User', UserSchema);//auth middlewirevar authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;app.delete('/users/me/token', authenticate, (req, res) =&gt; &#123; req.user.removeToken(req.token).then(() =&gt; &#123; res.status(200).send(); &#125;, () =&gt; &#123; res.status(400).send(); &#125;);&#125;);app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;);// POST /users/login &#123;email, password&#125;app.post('/users/login', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); User.findByCredentials(body.email, body.password).then((user) =&gt; &#123; return user.generateAuthToken().then((token) =&gt; &#123; res.header('x-auth', token).send(user); &#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 123456789101112131415161718192021221、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;users 保存userBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr84、 选择delete 输入 &gt;localhost:3000&#x2F;users&#x2F;me&#x2F;token header附带返回：x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr8完成删除。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[28]-mongodb+express+middleware验证用户登陆信息","slug":"node-28-mongodb-user-login","date":"2018-11-29T09:37:03.000Z","updated":"2018-11-30T03:11:37.428Z","comments":true,"path":"2018/11/29/node-28-mongodb-user-login/","link":"","permalink":"https://dreamerjonson.com/2018/11/29/node-28-mongodb-user-login/","excerpt":"","text":"登陆验证 用户使用邮箱和密码登陆，与mongodb数据库查找 验证用户是否有效 首先用户存在，并且密码匹配。 1234567891011121314151617181920UserSchema.statics.findByCredentials = function (email, password) &#123; var User = this; return User.findOne(&#123;email&#125;).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; return new Promise((resolve, reject) =&gt; &#123; // Use bcrypt.compare to compare password and user.password bcrypt.compare(password, user.password, (err, res) =&gt; &#123; if (res) &#123; resolve(user); &#125; else &#123; reject(); &#125; &#125;); &#125;); &#125;);&#125;; url 登陆成功header也会返回access toekn 123456789101112// POST /users/login &#123;email, password&#125;app.post('/users/login', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); User.findByCredentials(body.email, body.password).then((user) =&gt; &#123; return user.generateAuthToken().then((token) =&gt; &#123; res.header('x-auth', token).send(user); &#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');const bcrypt = require('bcryptjs');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;;UserSchema.statics.findByCredentials = function (email, password) &#123; var User = this; return User.findOne(&#123;email&#125;).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; return new Promise((resolve, reject) =&gt; &#123; // Use bcrypt.compare to compare password and user.password bcrypt.compare(password, user.password, (err, res) =&gt; &#123; if (res) &#123; resolve(user); &#125; else &#123; reject(); &#125; &#125;); &#125;); &#125;);&#125;;//在保存之前执行操作。UserSchema.pre('save', function (next) &#123; var user = this;//保存时对于密码的更新 if (user.isModified('password')) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; //密码变为了hash bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;);var User = mongoose.model('User', UserSchema);//auth middlewirevar authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;);// POST /users/login &#123;email, password&#125;app.post('/users/login', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); User.findByCredentials(body.email, body.password).then((user) =&gt; &#123; return user.generateAuthToken().then((token) =&gt; &#123; res.header('x-auth', token).send(user); &#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 123456789101112131415161718192021222324252627282930311、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;users 保存userBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr84、 选择post 输入 &gt;localhost:3000&#x2F;login 登陆userBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;header附带返回：x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr8","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[27]-express+mongodb+middleware实现密码哈希","slug":"node-27-mongodb-password-hash","date":"2018-11-29T02:56:55.000Z","updated":"2018-11-30T03:11:40.710Z","comments":true,"path":"2018/11/29/node-27-mongodb-password-hash/","link":"","permalink":"https://dreamerjonson.com/2018/11/29/node-27-mongodb-password-hash/","excerpt":"","text":"保存密码前对密码进行hash 123456789101112131415UserSchema.pre('save', function (next) &#123; var user = this; if (user.isModified('password')) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');const bcrypt = require('bcryptjs');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;;//在保存之前执行操作。UserSchema.pre('save', function (next) &#123; var user = this;//保存时对于密码的更新 if (user.isModified('password')) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; //密码变为了hash bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;);var User = mongoose.model('User', UserSchema);//auth middlewirevar authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;);//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 1234567891011121314151617181、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;usersBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr84、查看studio 3T 发现密码变为了hash之后的数字。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[26]-bcryptjs库实现密码哈希","slug":"node-26-password-hash","date":"2018-11-29T01:53:17.000Z","updated":"2018-11-29T03:17:23.107Z","comments":true,"path":"2018/11/29/node-26-password-hash/","link":"","permalink":"https://dreamerjonson.com/2018/11/29/node-26-password-hash/","excerpt":"","text":"加密 防撞库 1&gt; npm install --save bcryptjs 12345678910111213141516const bcrypt = require('bcryptjs')var password = '123abc!';//加密， salt password 是为了防止撞库攻击、密码概率攻击bcrypt.genSalt(10, (err, salt) =&gt; &#123; bcrypt.hash(password, salt, (err, hash) =&gt; &#123; console.log(hash); &#125;);&#125;);//解密var hashedPassword = '$2a$10$huAU4qTnQuGPifHEXfV9cOmPJ7p61oKaoXrY1WviiDAznE/rW8oLK';bcrypt.compare('123abc!', hashedPassword, (err, res) =&gt; &#123; console.log(res);&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[25]-express-middleware+mongoDB实现用户权限验证","slug":"node-25-auth-middleware","date":"2018-11-28T16:15:41.000Z","updated":"2018-11-29T03:16:48.440Z","comments":true,"path":"2018/11/29/node-25-auth-middleware/","link":"","permalink":"https://dreamerjonson.com/2018/11/29/node-25-auth-middleware/","excerpt":"","text":"查找token 查找数据库Token是否存在 12345678910111213141516UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;; auth-middleware 12345678910111213141516//auth middlewire,代码重用性高。var authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;; url 123app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;); 完整代码 postman.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, 'abc123'); &#125; catch (e) &#123; return Promise.reject(); &#125; return User.findOne(&#123; '_id': decoded._id, 'tokens.token': token, 'tokens.access': 'auth' &#125;);&#125;;var User = mongoose.model('User', UserSchema);//auth middlewirevar authenticate = (req, res, next) =&gt; &#123; var token = req.header('x-auth'); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;app.get('/users/me', authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;);//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 12345678910111213141516171819202122232425261、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;usersBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr84、localhost:3000&#x2F;users&#x2F;me增加header：x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr8查询后返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[24]-用户权限-express+mongoDB+authtoken","slug":"node-24-auth-token","date":"2018-11-28T10:17:23.000Z","updated":"2018-11-29T03:15:46.326Z","comments":true,"path":"2018/11/28/node-24-auth-token/","link":"","permalink":"https://dreamerjonson.com/2018/11/28/node-24-auth-token/","excerpt":"","text":"设置用户模版 12345678910111213141516171819202122232425262728293031323334353637383940414243var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; //产生token var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString();//toekn添加到user中 user.tokens = user.tokens.concat([&#123;access,token&#125;]);//从新保存到数据库中 return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;var User = mongoose.model('User', UserSchema); 访问url 保存数据 123456789101112app.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');const jwt = require('jsonwebtoken');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = 'auth'; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, 'abc123').toString(); user.tokens = user.tokens.concat([&#123;access,token&#125;]); return user.save().then(() =&gt; &#123; return token; //返回token &#125;);&#125;;var User = mongoose.model('User', UserSchema);//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then(() =&gt; &#123; return user.generateAuthToken(); //调用方法，产生auth token并保存。 &#125;).then((token) =&gt; &#123; res.header('x-auth', token).send(user); //设置了响应头 &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 123456789101112131415161718192021221、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;usersBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian05@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe6fd7363da36a46a2add5&quot;, &quot;email&quot;: &quot;zhuimengshaonian05@gmail.com&quot;, &quot;password&quot;: &quot;123abc!&quot;, &quot;tokens&quot;: [ &#123; &quot;_id&quot;: &quot;5bfe6fd7363da36a46a2add6&quot;, &quot;access&quot;: &quot;auth&quot;, &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNmZkNzM2M2RhMzZhNDZhMmFkZDUiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxNDMxfQ.uBCgcUymEQLY0l5rusBHESLZb23xsrxDD3XwXUn4kNQ&quot; &#125; ], &quot;__v&quot;: 1&#125; 重写toJSON方法 重写后，对象转换为json的方法，只会返回id和email。而不会返回token。 123456UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, ['_id', 'email']);&#125;; 测试2 123456789101112131415161、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;usersBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe716591e78c6a4ad8c164&quot;, &quot;email&quot;: &quot;zhuimengshaonian07@gmail.com&quot;&#125;header:x-auth →eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1YmZlNzE2NTkxZTc4YzZhNGFkOGMxNjQiLCJhY2Nlc3MiOiJhdXRoIiwiaWF0IjoxNTQzNDAxODI5fQ.wOKNzkls_w_jA5YVkCo0r9gFZ4-KtD6GarRiCDpAPr8","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[23]-hash函数","slug":"node-23-hash","date":"2018-11-28T09:29:16.000Z","updated":"2018-11-29T03:14:56.578Z","comments":true,"path":"2018/11/28/node-23-hash/","link":"","permalink":"https://dreamerjonson.com/2018/11/28/node-23-hash/","excerpt":"","text":"加密库 1npm install --save crypto-js 使用hash函数 123456const &#123;SHA256&#125; = require('crypto-js');var message = 'I am user number 3';var hash = SHA256(message).toString();console.log(`Message: $&#123;message&#125;`);console.log(`Hash: $&#123;hash&#125;`); 返回值： 12Message: I am user number 3Hash: 9da4d19e100809d42da806c2b7df5cf37e72623d42f1669eb112e23f5c9d45a3 利用哈希模拟数据的加密解密 12345678910111213141516const &#123;SHA256&#125; = require('crypto-js');var data = &#123; id: 4&#125;;var token = &#123; data, hash: SHA256(JSON.stringify(data) + 'somesecret').toString() // 密码+data 并hash&#125;//如果data和密码都是正确的，那么数据没有被修改过。否则数据被修改。var resultHash = SHA256(JSON.stringify(token.data) + 'somesecret').toString();if (resultHash === token.hash) &#123; console.log('Data was not changed');&#125; else &#123; console.log('Data was changed. Do not trust!');&#125; jsonwebtoken进行数据的加密解密 123456789101112const &#123;SHA256&#125; = require('crypto-js');const jwt = require('jsonwebtoken');var data = &#123; id: 10&#125;;var token = jwt.sign(data, '123abc'); //加密console.log(token);var decoded = jwt.verify(token, '123abc'); //解密console.log('decoded', decoded); 123返回值eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MTAsImlhdCI6MTU0MzM5NzgwMn0.TMQoQEsCuUptXkix0-vYCN5FGJnynj7tSSeMda33giAdecoded &#123; id: 10, iat: 1543397802 &#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[22]-express+mongoDB+mongoose验证","slug":"node-22-mongoose-validate","date":"2018-11-28T08:46:07.000Z","updated":"2018-11-29T03:14:45.230Z","comments":true,"path":"2018/11/28/node-22-mongoose-validate/","link":"","permalink":"https://dreamerjonson.com/2018/11/28/node-22-mongoose-validate/","excerpt":"","text":"安装 validator 1&gt; npm install --save validators user-model 123456789101112131415161718192021222324252627282930313233343536var User = mongoose.model('User', &#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; //验证 validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);// &#123;// email: 'andrew@example.com',// password: 'adpsofijasdfmpoijwerew',// tokens: [&#123;// access: 'auth',// token: 'poijasdpfoimasdpfjiweproijwer'// &#125;]// &#125; express保存user 1234567891011// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then((user) =&gt; &#123; res.send(user); &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;); 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');var _ = require('lodash');const validator = require('validator');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//Promisemongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);var User = mongoose.model('User', &#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: '&#123;VALUE&#125; is not a valid email' &#125; &#125;, password: &#123; type: String, require: true, minlength: 6 &#125;, tokens: [&#123; access: &#123; type: String, required: true &#125;, token: &#123; type: String, required: true &#125; &#125;]&#125;);// &#123;// email: 'andrew@example.com',// password: 'adpsofijasdfmpoijwerew',// tokens: [&#123;// access: 'auth',// token: 'poijasdpfoimasdpfjiweproijwer'// &#125;]// &#125;//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;);// POST /usersapp.post('/users', (req, res) =&gt; &#123; var body = _.pick(req.body, ['email', 'password']); var user = new User(body); user.save().then((user) =&gt; &#123; res.send(user); &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; 测试 123456789101112131415161、打开mongoDB &gt; .&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data2、运行 &gt;node postman.js3、打开postman 选择post 输入 &gt;localhost:3000&#x2F;usersBody中填入：&#123; &quot;email&quot;: &quot;zhuimengshaonian@gmail.com&quot;, &quot;password&quot; : &quot;123abc!&quot;&#125;返回：&#123; &quot;_id&quot;: &quot;5bfe54f072e64d6885bf4b2c&quot;, &quot;email&quot;: &quot;zhuimengshaonian@gmail.com&quot;, &quot;password&quot;: &quot;123abc!&quot;, &quot;tokens&quot;: [], &quot;__v&quot;: 0&#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"golang语言渐入佳境[20]-协程与通道","slug":"golang-20-channel","date":"2018-11-27T14:08:15.000Z","updated":"2018-11-28T08:28:34.437Z","comments":true,"path":"2018/11/27/golang-20-channel/","link":"","permalink":"https://dreamerjonson.com/2018/11/27/golang-20-channel/","excerpt":"","text":"协程引入 通过状态检查器checkLink，不断的获取切片当中的网址，并且打印了出来。 顺序执行。这也就意味着，一旦我访问google.com等网站就会陷入到等待的状况中。后面的网址无法访问。 123456789101112131415161718192021222324252627282930313233package mainimport ( \"net/http\" \"fmt\")func main()&#123; links := []string&#123; \"http://www.baidu.com\", \"http://www.jd.com\", \"http://www.taobao.com\", \"http://www.163.com\", \"http://www.sohu.com\", &#125; for _,link := range links&#123; checkLink(link) &#125;&#125;func checkLink(link string)&#123; _,err := http.Get(link) if err !=nil&#123; fmt.Printf(link,\"没有连接上\") return &#125; fmt.Println(link,\"连接上了\")&#125; go的协程 在函数的前方，加入go关键字，代表开辟一个新的协程。 运行一个go语言的程序的时候，都会开辟一个main协程。子协程通过go的关键字来创建。 通过Go的调度器，会将go的协程分配给CPU core取执行。当某一个子协程陷入了暂停或结束，Go的调度器会立即切换到其他的协程工作。因此大大的提高了效率。 但是当前的程序，直接退出了。因为main协程终止以后，子协程全部都会被销毁。 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;net&#x2F;http&quot; &quot;fmt&quot;)func main()&#123; links :&#x3D; []string&#123; &quot;http:&#x2F;&#x2F;www.baidu.com&quot;, &quot;http:&#x2F;&#x2F;www.jd.com&quot;, &quot;http:&#x2F;&#x2F;www.taobao.com&quot;, &quot;http:&#x2F;&#x2F;www.163.com&quot;, &quot;http:&#x2F;&#x2F;www.sohu.com&quot;, &#125; for _,link :&#x3D; range links&#123; go checkLink(link) &#125;&#x2F;&#x2F;main协程终止以后，子协程全部都会被销毁&#125;func checkLink(link string)&#123; _,err :&#x3D; http.Get(link) if err !&#x3D;nil&#123; fmt.Printf(link,&quot;没有连接上&quot;) return &#125; fmt.Println(link,&quot;连接上了&quot;)&#125; channel通道 通道就是实现协程之间的通信。 通道的创建 c:= make(chan string) 代表创建了一个通道，此通道只能够传递字符串类型。 通道实例 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"net/http\" \"fmt\")func main()&#123; links := []string&#123; \"http://www.baidu.com\", \"http://www.jd.com\", \"http://www.taobao.com\", \"http://www.163.com\", \"http://www.sohu.com\", &#125; c:= make(chan string) for _,link := range links&#123; go checkLink(link,c) &#125; fmt.Println(&lt;-c) //等待通道的消息并打印，但是这里只是等待了一条通道。&#125;func checkLink(link string,c chan string)&#123; //通道的参数 _,err := http.Get(link) if err !=nil&#123; fmt.Printf(link,\"没有连接上\") c&lt;-\"没有连接上\" //为通道传递消息 return &#125; fmt.Println(link,\"连接上了\") c&lt;-\"连接上了\"//为通道传递消息&#125; 执行结果 12http:&#x2F;&#x2F;www.baidu.com 连接上了连接上了 上面的代码输出的结果为： 意味着百度连接上之后就退出了。这是由于主协程fmt.Println(&lt;-c)陷入等待，当百度的子协程运行完毕，为通道添加信息之后。那么主协程退出，但是其他的协程还没有运行完毕。但是会直接销毁。 通道等待 如果想要全部打印出来，增加了多个等待通道的指令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"net/http\" \"fmt\")func main()&#123; links := []string&#123; \"http://www.baidu.com\", \"http://www.jd.com\", \"http://www.taobao.com\", \"http://www.163.com\", \"http://www.sohu.com\", &#125; c:= make(chan string) for _,link := range links&#123; go checkLink(link,c) &#125; // fmt.Println(&lt;-c) // fmt.Println(&lt;-c) // fmt.Println(&lt;-c) // fmt.Println(&lt;-c) // fmt.Println(&lt;-c) // fmt.Println(&lt;-c) for i:=0;i&lt;len(links);i++&#123; //等待所有的结果。 fmt.Println(&lt;-c) &#125;&#125;func checkLink(link string,c chan string)&#123; _,err := http.Get(link) if err !=nil&#123; fmt.Printf(link,\"没有连接上\") c&lt;-\"没有连接上\" return &#125; fmt.Println(link,\"连接上了\") c&lt;-\"连接上了\"&#125; 执行结果 12345678910http:&#x2F;&#x2F;www.baidu.com 连接上了连接上了http:&#x2F;&#x2F;www.163.com 连接上了连接上了http:&#x2F;&#x2F;www.taobao.com 连接上了连接上了http:&#x2F;&#x2F;www.sohu.com 连接上了连接上了http:&#x2F;&#x2F;www.jd.com 连接上了连接上了 并不是顺序执行的。 通道无限循环 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport ( \"net/http\" \"fmt\")func main()&#123; links := []string&#123; \"http://www.baidu.com\", \"http://www.jd.com\", \"http://www.taobao.com\", \"http://www.163.com\", \"http://www.sohu.com\", &#125; c:= make(chan string) for _,link := range links&#123; go checkLink(link,c) &#125; for&#123; go checkLink(&lt;-c,c) //一旦接收到通道的信息，就再次的创建协程，将链接作为第一个参数。 &#125;&#125;func checkLink(link string,c chan string)&#123; _,err := http.Get(link) if err !=nil&#123; fmt.Printf(link,\"没有连接上\") c&lt;-link //将链接放置到通道中 return &#125; fmt.Println(link,\"连接上了\") c&lt;-link //将链接放置到通道中&#125; go的通道遍历 比上一个代码效果一样，更加的清晰 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"net/http\" \"fmt\")func main()&#123; links := []string&#123; \"http://www.baidu.com\", \"http://www.jd.com\", \"http://www.taobao.com\", \"http://www.163.com\", \"http://www.sohu.com\", &#125; c:= make(chan string) for _,link := range links&#123; go checkLink(link,c) &#125; //for&#123; // go checkLink(&lt;-c,c) //&#125; for l:=range c&#123; go checkLink(l,c) &#125;&#125;func checkLink(link string,c chan string)&#123; time.Sleep(2*time.Second) //等待两秒钟 _,err := http.Get(link) if err !=nil&#123; fmt.Printf(link,\"没有连接上\") c&lt;-link return &#125; fmt.Println(link,\"连接上了\") c&lt;-link&#125; 高级写法的错误代码 下面的代码有一个非常严重的问题， 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"net/http\" \"fmt\")func main()&#123; links := []string&#123; \"http://www.baidu.com\", \"http://www.jd.com\", \"http://www.taobao.com\", \"http://www.163.com\", \"http://www.sohu.com\", &#125; c:= make(chan string) for _,link := range links&#123; go checkLink(link,c) &#125;//下面的代码有一个非常严重的问题，当等待2秒钟之后，l这个地址的字符串全部变为了相同的了。并传递到了所有的协程中。 for l:=range c&#123; go func() &#123; time.Sleep(2*time.Second) checkLink(l,c) &#125;() &#125;&#125;func checkLink(link string,c chan string)&#123; _,err := http.Get(link) if err !=nil&#123; fmt.Printf(link,\"没有连接上\") c&lt;-link return &#125; fmt.Println(link,\"连接上了\") c&lt;-link&#125; 更高级的正确写法 上面写法的改进，不再是引用，而是每一个副本。传递到函数中。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"net/http\" \"fmt\" \"time\")func main()&#123; links := []string&#123; \"http://www.baidu.com\", \"http://www.jd.com\", \"http://www.taobao.com\", \"http://www.163.com\", \"http://www.sohu.com\", &#125; c:= make(chan string) for _,link := range links&#123; go checkLink(link,c) &#125;//无限遍历通道。 匿名函数的方式 for l:=range c&#123; go func(link string) &#123; //上面写法的改进，不再是引用，而是每一个副本。首先传递到函数中。 time.Sleep(2*time.Second) checkLink(link,c) &#125;(l) &#125;&#125;func checkLink(link string,c chan string)&#123; _,err := http.Get(link) if err !=nil&#123; fmt.Printf(link,\"没有连接上\") c&lt;-link return &#125; fmt.Println(link,\"连接上了\") c&lt;-link&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[19]-从go源代码读懂interface接口","slug":"golang-19-source-interface","date":"2018-11-27T13:36:54.000Z","updated":"2018-11-27T15:30:15.867Z","comments":true,"path":"2018/11/27/golang-19-source-interface/","link":"","permalink":"https://dreamerjonson.com/2018/11/27/golang-19-source-interface/","excerpt":"","text":"go源代码中的接口 http库中，get方法： 1func Get(url string) (resp *Response, err error) Response: 123456789type Response struct &#123; Status string &#x2F;&#x2F; e.g. &quot;200 OK&quot; StatusCode int &#x2F;&#x2F; e.g. 200 Proto string &#x2F;&#x2F; e.g. &quot;HTTP&#x2F;1.0&quot; ProtoMajor int &#x2F;&#x2F; e.g. 1 ProtoMinor int &#x2F;&#x2F; e.g. 0 Header Header Body io.ReadCloser io.ReadCloser: 1234type ReadCloser interface &#123; Reader Closer&#125; Reader: 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; Closer: 123type Closer interface &#123; Close() error&#125; 不管是读取文件、网络等操作，都实现了相同的Reader接口。当传递[]byte进去，会将读取到的byte放置进去。成功会返回成功的个数。 123456789101112131415161718192021package mainimport ( \"net/http\" \"fmt\" \"os\")func main()&#123; resp,err := http.Get(\"http://tmall.com\") if err !=nil&#123; fmt.Println(\"Error:\",err) os.Exit(1) &#125; //设置大一点，read方法不会自动的扩容。 bs:=make([]byte,99999) //read函数将读取到的数据放入到bs中。 resp.Body.Read(bs) fmt.Println(string(bs))&#125; write接口 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; io.opy 1234567891011121314151617181920package mainimport ( \"net/http\" \"fmt\" \"os\" \"io\")func main()&#123; resp,err := http.Get(\"http://tmall.com\") if err !=nil&#123; fmt.Println(\"Error:\",err) os.Exit(1) &#125; //读取resp.Body中的信息，写到os.Stdout中。os.Stdout实现了write接口，resp.Body实现了read接口。 io.Copy(os.Stdout,resp.Body)&#125; io.copy源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func Copy(dst Writer, src Reader) (written int64, err error) &#123; return copyBuffer(dst, src, nil)&#125;---------func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) &#123; if buf != nil &amp;&amp; len(buf) == 0 &#123; panic(\"empty buffer in io.CopyBuffer\") &#125; return copyBuffer(dst, src, buf)&#125;---------func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) &#123; // If the reader has a WriteTo method, use it to do the copy. // Avoids an allocation and a copy. if wt, ok := src.(WriterTo); ok &#123; return wt.WriteTo(dst) &#125; // Similarly, if the writer has a ReadFrom method, use it to do the copy. if rt, ok := dst.(ReaderFrom); ok &#123; return rt.ReadFrom(src) &#125; size := 32 * 1024 if l, ok := src.(*LimitedReader); ok &amp;&amp; int64(size) &gt; l.N &#123; if l.N &lt; 1 &#123; size = 1 &#125; else &#123; size = int(l.N) &#125; &#125; if buf == nil &#123; buf = make([]byte, size)//分配 &#125; for &#123; //疯狂读取并写入 nr, er := src.Read(buf) if nr &gt; 0 &#123; nw, ew := dst.Write(buf[0:nr]) if nw &gt; 0 &#123; written += int64(nw) &#125; if ew != nil &#123; err = ew break &#125; if nr != nw &#123; err = ErrShortWrite break &#125; &#125; if er != nil &#123; if er != EOF &#123; err = er &#125; break &#125; &#125; return written, err&#125; 自定义Writer函数 12345678910111213141516171819202122232425262728293031package mainimport ( \"net/http\" \"fmt\" \"os\" \"io\")type logWriter struct&#123;&#125;func main()&#123; resp,err := http.Get(\"http://tmall.com\") if err !=nil&#123; fmt.Println(\"Error:\",err) os.Exit(1) &#125; lw:= logWriter&#123;&#125; //读取resp.Body中的信息，写到os.Stdout中。os.Stdout实现了write接口，resp.Body实现了read接口。 io.Copy(lw,resp.Body)&#125;func (logWriter) Write(bs []byte)(int,error)&#123; fmt.Println(string(bs)) fmt.Println(\"Just wrote this many bytes\",len(bs)) return len(bs),nil&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[18]-interface接口","slug":"golang-18-interface","date":"2018-11-27T09:54:19.000Z","updated":"2019-02-23T15:27:16.200Z","comments":true,"path":"2018/11/27/golang-18-interface/","link":"","permalink":"https://dreamerjonson.com/2018/11/27/golang-18-interface/","excerpt":"","text":"interface接口 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。 在本章，我们会开始看到接口类型和值的一些基本技巧。顺着这种方式我们将学习几个来自标准库的重要接口。很多Go程序中都尽可能多的去使用标准库中的接口。 目前为止，我们看到的类型都是具体的类型。一个具体的类型可以准确的描述它所代表的值并且展示出对类型本身的一些操作方式就像数字类型的算术操作，切片类型的索引、附加和取范围操作。具体的类型还可以通过它的方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。 在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。 在本书中，我们一直使用两个相似的函数来进行字符串的格式化：fmt.Printf它会把结果写到标准输出和fmt.Sprintf它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数fmt.Fprintf来进行封装。fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。 12345678910package fmtfunc Fprintf(w io.Writer, format string, args ...interface&#123;&#125;) (int, error)func Printf(format string, args ...interface&#123;&#125;) (int, error) &#123; return Fprintf(os.Stdout, format, args...)&#125;func Sprintf(format string, args ...interface&#123;&#125;) string &#123; var buf bytes.Buffer Fprintf(&amp;buf, format, args...) return buf.String()&#125; Fprintf的前缀F表示文件(File)也表明格式化输出结果应该被写入第一个参数提供的文件中。在Printf函数中的第一个参数os.Stdout是*os.File类型；在Sprintf函数中的第一个参数&amp;buf是一个指向可以写入字节的内存缓冲区，然而它并不是一个文件类型尽管它在某种意义上和文件类型相似。 卽使Fprintf函数中的第一个参数也不是一个文件类型。它是io.Writer类型这是一个接口类型定义如下： 123456789101112package io&#x2F;&#x2F; Writer is the interface that wraps the basic Write method.type Writer interface &#123; &#x2F;&#x2F; Write writes len(p) bytes from p to the underlying data stream. &#x2F;&#x2F; It returns the number of bytes written from p (0 &lt;&#x3D; n &lt;&#x3D; len(p)) &#x2F;&#x2F; and any error encountered that caused the write to stop early. &#x2F;&#x2F; Write must return a non-nil error if it returns n &lt; len(p). &#x2F;&#x2F; Write must not modify the slice data, even temporarily. &#x2F;&#x2F; &#x2F;&#x2F; Implementations must not retain p. Write(p []byte) (n int, err error)&#125; io.Writer类型定义了函数Fprintf和这个函数调用者之间的约定。一方面这个约定需要调用者提供具体类型的值就像os.File和bytes.Buffer，这些类型都有一个特定签名和行为的Write的函数。另一方面这个约定保证了Fprintf接受任何满足io.Writer接口的值都可以工作。Fprintf函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用Write函数的值。 因为fmt.Fprintf函数没有对具体操作的值做任何假设而是仅仅通过io.Writer接口的约定来保证行为，所以第一个参数可以安全地传入一个任何具体类型的值只需要满足io.Writer接口。一个类型可以自由的使用另一个满足相同接口的类型来进行替换被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。 让我们通过一个新的类型来进行校验，下面ByteCounter类型里的Write方法，仅仅在丢失写向它的字节前统计它们的长度。(在这个+=赋值语句中，让len§的类型和c的类型匹配的转换是必须的。) 12345678910111213type ByteCounter intfunc (c *ByteCounter) Write(p []byte) (int, error) &#123; *c +&#x3D; ByteCounter(len(p)) &#x2F;&#x2F; convert int to ByteCounter return len(p), nil&#125;因为*ByteCounter满足io.Writer的约定，我们可以把它传入Fprintf函数中；Fprintf函数执行字符串格式化的过程不会去关注ByteCounter正确的累加结果的长度。var c ByteCounterc.Write([]byte(&quot;hello&quot;))fmt.Println(c) &#x2F;&#x2F; &quot;5&quot;, &#x3D; len(&quot;hello&quot;)c &#x3D; 0 &#x2F;&#x2F; reset the countervar name &#x3D; &quot;Dolly&quot;fmt.Fprintf(&amp;c, &quot;hello, %s&quot;, name)fmt.Println(c) &#x2F;&#x2F; &quot;12&quot;, &#x3D; len(&quot;hello, Dolly&quot;) 除了io.Writer这个接口类型，还有另一个对fmt包很重要的接口类型。Fprintf和Fprintln函数向类型提供了一种控制它们值输出的途径。在2.5节中，我们为Celsius类型提供了一个String方法以便于可以打印成这样&quot;100°C&quot; ，在6.5节中我们给*IntSet添加一个String方法，这样集合可以用传统的符号来进行表示就像&quot;{1 2 3}&quot;。给一个类型定义String方法，可以让它满足最广泛使用之一的接口类型fmt.Stringer： 1234567package fmt&#x2F;&#x2F; The String method is used to print values passed&#x2F;&#x2F; as an operand to any format that accepts a string&#x2F;&#x2F; or to an unformatted printer such as Print.type Stringer interface &#123; String() string&#125; 接口类型 12345678910111213141516171819202122232425262728293031接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。io.Writer类型是用的最广泛的接口之一，因为它提供了所有的类型写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。io包中定义了很多其它有用的接口类型。Reader可以代表任意可以读取bytes的类型，Closer可以是任意可以关闭的值，例如一个文件或是网络链接。（到现在你可能注意到了很多Go语言中单方法接口的命名习惯）package iotype Reader interface &#123; Read(p []byte) (n int, err error)&#125;type Closer interface &#123; Close() error&#125;在往下看，我们发现有些新的接口类型通过组合已经有的接口来定义。下面是两个例子：type ReadWriter interface &#123; Reader Writer&#125;type ReadWriteCloser interface &#123; Reader Writer Closer&#125;上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名另一个接口，而不用声明它所有的方法。这种方式本称为接口内嵌。尽管略失简洁，我们可以像下面这样，不使用内嵌来声明io.Writer接口。type ReadWriter interface &#123; Read(p []byte) (n int, err error) Write(p []byte) (n int, err error)&#125;或者甚至使用种混合的风格：type ReadWriter interface &#123; Read(p []byte) (n int, err error) Writer&#125;上面3种定义方式都是一样的效果。方法的顺序变化也没有影响，唯一重要的就是这个集合里面的方法。 接口声明与定义 interface关键字，在接口中有函数，但是没有实现。 123type Phone interface &#123; call()&#125; 例子 一旦有结构体实现了此函数，那么就可以用接口来接收此结构体。 1234567891011121314151617181920212223242526272829303132333435package mainimport \"fmt\"type Phone interface &#123; call()&#125;type AndroidPhone struct &#123;&#125;type IPhone struct &#123;&#125;func (a AndroidPhone) call() &#123; fmt.Println(\"我是安卓手机，可以打电话了\")&#125;func (i IPhone) call() &#123; fmt.Println(\"我是苹果手机，可以打电话了\")&#125;func main() &#123; // 定义接口类型的变量 var phone Phone phone = new(AndroidPhone) phone = AndroidPhone&#123;&#125; fmt.Printf(\"%T , %v , %p \\n\" , phone , phone , &amp;phone) phone.call() phone = new(IPhone) phone = IPhone&#123;&#125; fmt.Printf(\"%T , %v , %p \\n\" , phone , phone , &amp;phone) phone.call()&#125; 案例2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport \"fmt\"type Income interface &#123; calculate() float64 //计算收入总额 source() string //用来说明收入来源&#125;//固定账单项目type FixedBilling struct &#123; projectName string //工程项目 biddedAmount float64 //项目招标总额&#125;//定时生产项目(定时和材料项目)type TimeAndMaterial struct &#123; projectName string workHours float64 //工作时长 hourlyRate float64 //每小时工资率&#125;//固定收入项目func (f FixedBilling) calculate() float64 &#123; return f.biddedAmount&#125;func (f FixedBilling) source() string &#123; return f.projectName&#125;//定时收入项目func (t TimeAndMaterial) calculate() float64 &#123; return t.workHours * t.hourlyRate&#125;func (t TimeAndMaterial) source() string &#123; return t.projectName&#125;//通过广告点击获得收入type Advertisement struct &#123; adName string clickCount int incomePerclick float64&#125;func (a Advertisement) calculate() float64 &#123; return float64(a.clickCount) * a.incomePerclick&#125;func (a Advertisement) source() string &#123; return a.adName&#125;func main() &#123; p1 := FixedBilling&#123;\"项目1\", 5000&#125; p2 := FixedBilling&#123;\"项目2\", 10000&#125; p3 := TimeAndMaterial&#123;\"项目3\", 100, 40&#125; p4 := TimeAndMaterial&#123;\"项目4\", 250, 20&#125; p5 := Advertisement&#123;\"广告1\", 10000, 0.1&#125; p6 := Advertisement&#123;\"广告2\", 20000, 0.05&#125; ic := []Income&#123;p1, p2, p3, p4, p5, p6&#125; fmt.Println(calculateNetIncome(ic))&#125;//计算净收入func calculateNetIncome(ic []Income) float64 &#123; netincome := 0.0 for _, income := range ic &#123; fmt.Printf(\"收入来源：%s ，收入金额：%.2f \\n\", income.source(), income.calculate()) netincome += income.calculate() &#125; return netincome&#125;//说明：// 没有对calculateNetIncome函数做任何更改，尽管添加了新的收入方式。全靠多态性而起作用。// 由于新的Advertisement类型也实现了Income接口，可以将它添加到ic切片中。// calculateNetIncome函数在没有任何更改的情况下工作，因为它可以调用Advertisement类型的calculate()和source()方法。 空接口 12type A interface &#123;&#125; 空接口可以接受任何的数据类型 1234567type A interface &#123;&#125;var a1 A &#x3D; Cat&#123;&quot;Mimi&quot;, 1&#125;var a2 A &#x3D; Person&#123;&quot;Steven&quot;, &quot;男&quot;&#125;var a3 A &#x3D; &quot;Learn golang with me!&quot;var a4 A &#x3D; 100var a5 A &#x3D; 3.14 定义map。value是任何数据类型 12345&#x2F;&#x2F;2、定义map。value是任何数据类型map1 :&#x3D; make(map[string]interface&#123;&#125;)map1[&quot;name&quot;] &#x3D; &quot;Daniel&quot;map1[&quot;age&quot;] &#x3D; 13map1[&quot;height&quot;] &#x3D; 1.71 定义一个切片，其中存储任意数据类型 123slice1 :&#x3D; make([]interface&#123;&#125;, 0, 10)slice1 &#x3D; append(slice1, a1, a2, a3, a4, a5)fmt.Println(slice1) 完整案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\")type A interface &#123;&#125;type Cat struct &#123; name string age int&#125;type Person struct &#123; name string sex string&#125;func main() &#123; var a1 A = Cat&#123;\"Mimi\", 1&#125; var a2 A = Person&#123;\"jonson\", \"男\"&#125; var a3 A = \"Learn golang with me!\" var a4 A = 100 var a5 A = 3.14 showInfo(a1) showInfo(a2) showInfo(a3) showInfo(a4) showInfo(a5) fmt.Println(\"------------------\") //1、fmt.println参数就是空接口 fmt.Println(\"println的参数就是空接口，可以是任何数据类型\", 100, 3.14, Cat&#123;\"旺旺\", 2&#125;) //2、定义map。value是任何数据类型 map1 := make(map[string]interface&#123;&#125;) map1[\"name\"] = \"Daniel\" map1[\"age\"] = 13 map1[\"height\"] = 1.71 fmt.Println(map1) fmt.Println(\"------------------\") // 3、定义一个切片，其中存储任意数据类型 slice1 := make([]interface&#123;&#125;, 0, 10) slice1 = append(slice1, a1, a2, a3, a4, a5) fmt.Println(slice1)&#125;func showInfo(a A) &#123; fmt.Printf(\"%T , %v \\n\", a, a)&#125; 接口对象转型的两种方式 123456789101112131415161718192021222324//接口对象转型方式1//instance,ok := 接口对象.(实际类型)func getType(s Shape) &#123; if instance, ok := s.(Rectangle); ok &#123; fmt.Printf(\"矩形：长度%.2f , 宽度%.2f , \", instance.a, instance.b) &#125; else if instance, ok := s.(Triangle); ok &#123; fmt.Printf(\"三角形：三边分别：%.2f , %.2f , %.2f , \", instance.a, instance.b, instance.c) &#125; else if instance, ok := s.(Circle); ok &#123; fmt.Printf(\"圆形：半径%.2f , \", instance.radius) &#125;&#125;//接口对象转型——方式2//接口对象.(type), 配合switch和case语句使用func getType2(s Shape) &#123; switch instance := s.(type) &#123; case Rectangle: fmt.Printf(\"矩形：长度为%.2f ， 宽为%.2f ，\\t\", instance.a, instance.b) case Triangle: fmt.Printf(\"三角形：三边分别为%.2f ，%.2f ， %.2f ，\\t\", instance.a, instance.b, instance.c) case Circle: fmt.Printf(\"圆形：半径为%.2f ，\\t\", instance.radius) &#125;&#125; 接口对象转型案例 求周长或者面积 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package mainimport ( \"math\" \"fmt\")//1、定义接口type Shape interface &#123; perimeter() float64 area() float64&#125;//2.矩形type Rectangle struct &#123; a, b float64&#125;//3.三角形type Triangle struct &#123; a, b, c float64&#125;//4.圆形type Circle struct &#123; radius float64&#125;//定义实现接口的方法func (r Rectangle) perimeter() float64 &#123; return (r.a + r.b) * 2&#125;func (r Rectangle) area() float64 &#123; return r.a * r.b&#125;func (t Triangle) perimeter() float64 &#123; return t.a + t.b + t.c&#125;func (t Triangle) area() float64 &#123; //海伦公式 p := t.perimeter() / 2 //半周长 return math.Sqrt(p * (p - t.a) * (p - t.b) * (p - t.c))&#125;func (c Circle) perimeter() float64 &#123; return 2 * math.Pi * c.radius&#125;func (c Circle) area() float64 &#123; return math.Pow(c.radius, 2) * math.Pi&#125;//接口对象转型方式1//instance,ok := 接口对象.(实际类型)func getType(s Shape) &#123; if instance, ok := s.(Rectangle); ok &#123; fmt.Printf(\"矩形：长度%.2f , 宽度%.2f , \", instance.a, instance.b) &#125; else if instance, ok := s.(Triangle); ok &#123; fmt.Printf(\"三角形：三边分别：%.2f , %.2f , %.2f , \", instance.a, instance.b, instance.c) &#125; else if instance, ok := s.(Circle); ok &#123; fmt.Printf(\"圆形：半径%.2f , \", instance.radius) &#125;&#125;//接口对象转型——方式2//接口对象.(type), 配合switch和case语句使用func getType2(s Shape) &#123; switch instance := s.(type) &#123; case Rectangle: fmt.Printf(\"矩形：长度为%.2f ， 宽为%.2f ，\\t\", instance.a, instance.b) case Triangle: fmt.Printf(\"三角形：三边分别为%.2f ，%.2f ， %.2f ，\\t\", instance.a, instance.b, instance.c) case Circle: fmt.Printf(\"圆形：半径为%.2f ，\\t\", instance.radius) &#125;&#125;func getResult(s Shape) &#123; getType2(s) fmt.Printf(\"周长：%.2f ，面积:%.2f \\n\", s.perimeter(), s.area())&#125;func main() &#123; var s Shape s = Rectangle&#123;3, 4&#125; getResult(s) showInfo(s) s = Triangle&#123;3, 4, 5&#125; getResult(s) showInfo(s) s = Circle&#123;1&#125; getResult(s) showInfo(s) x := Triangle&#123;3, 4, 5&#125; fmt.Println(x)&#125;func (t Triangle) String() string &#123; return fmt.Sprintf(\"Triangle对象，属性分别为：%.2f, %.2f, %.2f\", t.a, t.b, t.c)&#125;func showInfo(s Shape) &#123; fmt.Printf(\"%T ,%v \\n\", s, s) fmt.Println(\"-------------------\")&#125; flag.Value接口 在本章，我们会学到另一个标准的接口类型flag.Value是怎么帮助命令行标记定义新的符号的。思考下面这个会休眠特定时间的程序： 12345678var period &#x3D; flag.Duration(&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)func main() &#123; flag.Parse() fmt.Printf(&quot;Sleeping for %v...&quot;, *period) time.Sleep(*period) fmt.Println()&#125; 在它休眠前它会打印出休眠的时间周期。fmt包调用time.Duration的String方法打印这个时间周期是以用户友好的注解方式，而不是一个纳秒数字： $ go build gopl.io/ch7/sleep $ ./sleep Sleeping for 1s… 默认情况下，休眠周期是一秒，但是可以通过-period 这个命令行标记来控制。flag.Duration函数创建一个time.Duration类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和String方法相同的符号排版形式。这种对称设计使得用户交互良好。 $ ./sleep -period 50ms Sleeping for 50ms… $ ./sleep -period 2m30s Sleeping for 2m30s… $ ./sleep -period 1.5h Sleeping for 1h30m0s… $ ./sleep -period “1 day” invalid value “1 day” for flag -period: time: invalid duration 1 day 因为时间周期标记值非常的有用，所以这个特性被构建到了flag包中；但是我们为我们自己的数据类型定义新的标记符号是简单容易的。我们只需要定义一个实现flag.Value接口的类型，如下： 1234567package flag&#x2F;&#x2F; Value is the interface to the value stored in a flag.type Value interface &#123; String() string Set(string) error&#125; String方法格式化标记的值用在命令行帮组消息中；这样每一个flag.Value也是一个fmt.Stringer。Set方法解析它的字符串参数并且更新标记变量的值。实际上，Set方法和String是两个相反的操作，所以最好的办法就是对他们使用相同的注解方式。 让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。注意celsiusFlag内嵌了一个Celsius类型(§2.5)，因此不用实现本身就已经有String方法了。为了实现flag.Value，我们只需要定义Set方法： 123456789101112131415161718192021222324252627282930// gopl.io/ch7/tempconvtype celsiusFlag struct&#123;Celsius&#125;func (f *celsiusFlag) Set(s string) error &#123; var unit string var value float64 fmt.Sscanf(s, \"%f%s\", &amp;value, &amp;unit) // no error check needed switch unit &#123; case \"C\", \"°C\": f.Celsius = Celsius(value) return nil case \"F\", \"°F\": f.Celsius = FToC(Fahrenheit(value)) return nil &#125; return fmt.Errorf(\"invalid temperature %q\", s)&#125;//!-celsiusFlag//!+CelsiusFlag// CelsiusFlag defines a Celsius flag with the specified name,// default value, and usage, and returns the address of the flag variable.// The flag argument must have a quantity and a unit, e.g., \"100C\".func CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123; f := celsiusFlag&#123;value&#125; flag.CommandLine.Var(&amp;f, name, usage) return &amp;f.Celsius&#125; 调用fmt.Sscanf函数从输入s中解析一个浮点数（value）和一个字符串（unit）。虽然通常必须检查Sscanf的错误返回，但是在这个例子中我们不需要因为如果有错误发生，就没有switch case会匹配到。 下面的CelsiusFlag函数将所有逻辑都封装在一起。它返回一个内嵌在celsiusFlag变量f中的Celsius指针给调用者。Celsius字段是一个会通过Set方法在标记处理的过程中更新的变量。调用Var方法将标记加入应用的命令行标记集合中，有异常复杂命令行接口的全局变量flag.CommandLine.Programs可能有几个这个类型的变量。调用Var方法将一个celsiusFlag参数赋值给一个flag.Value参数,导致编译器去检查 celsiusFlag是否有必须的方法。 // CelsiusFlag defines a Celsius flag with the specified name, // default value, and usage, and returns the address of the flag variable. // The flag argument must have a quantity and a unit, e.g., “100C”. 12345func CelsiusFlag(name string, value Celsius, usage string) *Celsius &#123; f :&#x3D; celsiusFlag&#123;value&#125; flag.CommandLine.Var(&amp;f, name, usage) return &amp;f.Celsius&#125; 现在我们可以开始在我们的程序中使用新的标记： 1234567// gopl.io/ch7/tempflagvar temp = tempconv.CelsiusFlag(\"temp\", 20.0, \"the temperature\")func main() &#123; flag.Parse() fmt.Println(*temp)&#125; 下面是典型的场景： $ go build gopl.io/ch7/tempflag $ ./tempflag 20°C $ ./tempflag -temp -18C -18°C $ ./tempflag -temp 212°F 100°C $ ./tempflag -temp 273.15K invalid value “273.15K” for flag -temp: invalid temperature “273.15K” Usage of ./tempflag: -temp value the temperature (default 20°C) $ ./tempflag -help Usage of ./tempflag: -temp value the temperature (default 20°C) 接口值 概念上讲一个接口的值，接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。 下面4个语句中，变量w得到了3个不同的值。（开始和最后的值是相同的） var w io.Writer w = os.Stdout w = new(bytes.Buffer) w = nil 让我们进一步观察在每一个语句后的w变量的值和动态行为。第一个语句定义了变量w: var w io.Writer 在Go语言中，变 量总是被一个定义明确的值初始化，卽使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil。 一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判读接口值是否为空。调用一个空接口值上的任意方法都会产生panic: w.Write([]byte(“hello”)) // panic: nil pointer dereference 第二个语句将一个os.File类型的值赋给变量w: w = os.Stdout 这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，都会刻畵出操作到的类型和值。这个接口值的动态类型被设为os.Stdout指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针（图7.2） 。 调用一个包含os.File类型指针的接口值的Write方法，使得(*os.File).Write方法被调用。这个调用输出“hello”。 w.Write([]byte(“hello”)) // “hello” 通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样： os.Stdout.Write([]byte(“hello”)) // “hello” 第三个语句给接口值赋了一个bytes.Buffer类型的值 w = new(bytes.Buffer) 现在动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针（图7.3）。 Write方法的调用也使用了和之前一样的机制： w.Write([]byte(“hello”)) // writes “hello” to the bytes.Buffers 这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。 最后，第四个语句将nil赋给了接口值： w = nil 这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态图，在图7.1中可以看到。 一个接口值可以持有任意大的动态值。例如，表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值, var x interface{} = time.Now() 结果可能和图7.4相似。从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型；具体的实现可能会非常不同） 接口值可以使用＝＝和！＝来进行比较。两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的＝＝操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。 然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic: 12var x interface&#123;&#125; &#x3D; []int&#123;1, 2, 3&#125;fmt.Println(x &#x3D;&#x3D; x) &#x2F;&#x2F; panic: comparing uncomparable type []int 考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。 当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用fmt包的%T动作: 123456var w io.Writerfmt.Printf(&quot;%T\\n&quot;, w) &#x2F;&#x2F; &quot;&lt;nil&gt;&quot;w &#x3D; os.Stdoutfmt.Printf(&quot;%T\\n&quot;, w) &#x2F;&#x2F; &quot;*os.File&quot;w &#x3D; new(bytes.Buffer)fmt.Printf(&quot;%T\\n&quot;, w) &#x2F;&#x2F; &quot;*bytes.Buffer&quot; sort.interface 排序包中，对于一些 基本类型的切片，如[]int, []string, and []float64 都有现成的排序方式，如下： 12345678910111213141516171819202122232425262728package mainimport ( \"sort\" \"fmt\")func main()&#123; s:= []string&#123;\"a\",\"c\",\"b\"&#125; fmt.Println(s) sort.Strings(s) fmt.Println(s)&#125;func init() &#123; //!+ints values := []int&#123;3, 1, 4, 1&#125; fmt.Println(sort.IntsAreSorted(values)) // \"false\" sort.Ints(values) fmt.Println(values) // \"[1 1 3 4]\" fmt.Println(sort.IntsAreSorted(values)) // \"true\" sort.Sort(sort.Reverse(sort.IntSlice(values))) fmt.Println(values) // \"[4 3 1 1]\" fmt.Println(sort.IntsAreSorted(values)) // \"false\" //!-ints&#125; 如果是自定义的类型，则需要实现接口: 123456package sorttype Interface interface &#123; Len() int Less(i, j int) bool // i, j are indices of sequence elements Swap(i, j int)&#125; 注意反转sort.Reverse很有意思，其实际是修改了比较函数 1234package sorttype reverse struct&#123; Interface &#125; &#x2F;&#x2F; that is, sort.Interfacefunc (r reverse) Less(i, j int) bool &#123; return r.Interface.Less(j, i) &#125;func Reverse(data Interface) Interface &#123; return reverse&#123;data&#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package mainimport ( \"fmt\" \"os\" \"sort\" \"text/tabwriter\" \"time\")//!+maintype Track struct &#123; Title string Artist string Album string Year int Length time.Duration&#125;var tracks = []*Track&#123; &#123;\"Go\", \"Delilah\", \"From the Roots Up\", 2012, length(\"3m38s\")&#125;, &#123;\"Go\", \"Moby\", \"Moby\", 1992, length(\"3m37s\")&#125;, &#123;\"Go Ahead\", \"Alicia Keys\", \"As I Am\", 2007, length(\"4m36s\")&#125;, &#123;\"Ready 2 Go\", \"Martin Solveig\", \"Smash\", 2011, length(\"4m24s\")&#125;,&#125;func length(s string) time.Duration &#123; d, err := time.ParseDuration(s) if err != nil &#123; panic(s) &#125; return d&#125;//!-main//!+printTracksfunc printTracks(tracks []*Track) &#123; const format = \"%v\\t%v\\t%v\\t%v\\t%v\\t\\n\" tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, ' ', 0) fmt.Fprintf(tw, format, \"Title\", \"Artist\", \"Album\", \"Year\", \"Length\") fmt.Fprintf(tw, format, \"-----\", \"------\", \"-----\", \"----\", \"------\") for _, t := range tracks &#123; fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length) &#125; tw.Flush() // calculate column widths and print table&#125;//!-printTracks//!+artistcodetype byArtist []*Trackfunc (x byArtist) Len() int &#123; return len(x) &#125;func (x byArtist) Less(i, j int) bool &#123; return x[i].Artist &lt; x[j].Artist &#125;func (x byArtist) Swap(i, j int) &#123; x[i], x[j] = x[j], x[i] &#125;//!-artistcode//!+yearcodetype byYear []*Trackfunc (x byYear) Len() int &#123; return len(x) &#125;func (x byYear) Less(i, j int) bool &#123; return x[i].Year &lt; x[j].Year &#125;func (x byYear) Swap(i, j int) &#123; x[i], x[j] = x[j], x[i] &#125;//!-yearcodefunc main() &#123; fmt.Println(\"byArtist:\") sort.Sort(byArtist(tracks)) printTracks(tracks) fmt.Println(\"\\nReverse(byArtist):\") sort.Sort(sort.Reverse(byArtist(tracks))) printTracks(tracks) fmt.Println(\"\\nbyYear:\") sort.Sort(byYear(tracks)) printTracks(tracks) fmt.Println(\"\\nCustom:\") //!+customcall sort.Sort(customSort&#123;tracks, func(x, y *Track) bool &#123; if x.Title != y.Title &#123; return x.Title &lt; y.Title &#125; if x.Year != y.Year &#123; return x.Year &lt; y.Year &#125; if x.Length != y.Length &#123; return x.Length &lt; y.Length &#125; return false &#125;&#125;) //!-customcall printTracks(tracks)&#125;/*//!+artistoutputTitle Artist Album Year Length----- ------ ----- ---- ------Go Ahead Alicia Keys As I Am 2007 4m36sGo Delilah From the Roots Up 2012 3m38sReady 2 Go Martin Solveig Smash 2011 4m24sGo Moby Moby 1992 3m37s//!-artistoutput//!+artistrevoutputTitle Artist Album Year Length----- ------ ----- ---- ------Go Moby Moby 1992 3m37sReady 2 Go Martin Solveig Smash 2011 4m24sGo Delilah From the Roots Up 2012 3m38sGo Ahead Alicia Keys As I Am 2007 4m36s//!-artistrevoutput//!+yearoutputTitle Artist Album Year Length----- ------ ----- ---- ------Go Moby Moby 1992 3m37sGo Ahead Alicia Keys As I Am 2007 4m36sReady 2 Go Martin Solveig Smash 2011 4m24sGo Delilah From the Roots Up 2012 3m38s//!-yearoutput//!+customoutTitle Artist Album Year Length----- ------ ----- ---- ------Go Moby Moby 1992 3m37sGo Delilah From the Roots Up 2012 3m38sGo Ahead Alicia Keys As I Am 2007 4m36sReady 2 Go Martin Solveig Smash 2011 4m24s//!-customout*///!+customcodetype customSort struct &#123; t []*Track less func(x, y *Track) bool&#125;func (x customSort) Len() int &#123; return len(x.t) &#125;func (x customSort) Less(i, j int) bool &#123; return x.less(x.t[i], x.t[j]) &#125;func (x customSort) Swap(i, j int) &#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125; error Since the beg inning of this book, we’ve been using and cre ating values of the mysteriou s predeclare d error type wit hout explaining what it really is. In fac t, it’s just an int erface typ e with a single met hod that retur ns an error message: 123type error interface &#123;Error() string&#125; errors.New() 1234package errorsfunc New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125;type errorString struct &#123; text string &#125;func (e *errorString) Error() string &#123; return e.text &#125; fmt.Println(errors.New(“EOF”) == errors.New(“EOF”)) // “false” fmt.Errorf也是一样的 12345package fmtimport &quot;errors&quot;func Errorf(format string, args ...interface&#123;&#125;) error &#123;return errors.New(Sprintf(format, args...))&#125; syscall包中的错误。 1234567891011121314package syscalltype Errno uintptr &#x2F;&#x2F; operating system error codevar errors &#x3D; [...]string&#123;1: &quot;operation not permitted&quot;, &#x2F;&#x2F; EPERM2: &quot;no such file or directory&quot;, &#x2F;&#x2F; ENOENT3: &quot;no such process&quot;, &#x2F;&#x2F; ESRCH&#x2F;&#x2F; ...&#125;func (e Errno) Error() string &#123;if 0 &lt;&#x3D; int(e) &amp;&amp; int(e) &lt; len(errors) &#123;return errors[e]&#125;return fmt.Sprintf(&quot;errno %d&quot;, e)&#125; var err error = syscall.Errno(2) fmt.Println(err.Error()) // “no such file or directory” fmt.Println(err) // “no such file or directory”","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[17]-Map表","slug":"golang-17-mapping","date":"2018-11-26T08:51:46.000Z","updated":"2019-02-15T15:24:51.956Z","comments":true,"path":"2018/11/26/golang-17-mapping/","link":"","permalink":"https://dreamerjonson.com/2018/11/26/golang-17-mapping/","excerpt":"","text":"Map 声明 12345678910111213//1、声明map的方式1var map1 map[string]string//2、声明map的方式2map2 := make(map[string]string)//3、map中key可以是：int、float、bool、string、数组// 一定不可以是：切片、函数、mapvar m1 map[int]stringvar m2 map[float64]stringvar m3 map[bool]stringvar m4 map[string]string mapping定义与初始化 1、声明时同时初始化 123456789101112var country &#x3D; map[string]string&#123; &quot;China&quot;: &quot;Beijing&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New Delhi&quot;, &quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;,&#125;fmt.Println(country)&#x2F;&#x2F;短变量声明初始化方式rating :&#x3D; map[string]float64&#123;&quot;c&quot;: 5, &quot;Go&quot;: 4.5, &quot;Python&quot;: 4.5, &quot;C++&quot;: 3&#125;fmt.Println(rating) 2、创建map后再赋值 123456countryMap :&#x3D; make(map[string]string)countryMap[&quot;China&quot;] &#x3D; &quot;Beijing&quot;countryMap[&quot;Japan&quot;] &#x3D; &quot;Tokyo&quot;countryMap[&quot;India&quot;] &#x3D; &quot;New Delhi&quot;countryMap[&quot;France&quot;] &#x3D; &quot;Paris&quot;countryMap[&quot;Italy&quot;] &#x3D; &quot;Rome&quot; mapping遍历 (1)、key 、value都遍历 123for k, v :&#x3D; range countryMap &#123; fmt.Println(&quot;国家&quot;, k, &quot;首都&quot;, v)&#125; (2)、只展示value 123for _, v :&#x3D; range countryMap &#123; fmt.Println(&quot;国家&quot;, &quot;首都&quot;, v)&#125; (3)、只展示key 123for k :&#x3D; range countryMap &#123; fmt.Println(&quot;国家&quot;, k , &quot;首都&quot;, countryMap[k])&#125; (4)、查看元素是否在map中存在 12345678910111213141516value , ok :&#x3D; countryMap[&quot;England&quot;]fmt.Printf(&quot;%q \\n&quot; , value)fmt.Printf(&quot;%T , %v \\n&quot; , ok , ok)if ok &#123; fmt.Println(&quot;首都：&quot; , value)&#125; else &#123; fmt.Println(&quot;首都信息未检索到！&quot;)&#125;&#x2F;&#x2F;第二种方式if value ,ok :&#x3D;countryMap[&quot;USA&quot;];ok &#123; fmt.Println(&quot;首都：&quot; , value)&#125; else &#123; fmt.Println(&quot;首都信息未检索到！&quot;)&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport \"fmt\"func main() &#123; //1、声明时同时初始化 var country = map[string]string&#123; \"China\": \"Beijing\", \"Japan\": \"Tokyo\", \"India\": \"New Delhi\", \"France\": \"Paris\", \"Italy\": \"Rome\", &#125; fmt.Println(country) //短变量声明初始化方式 rating := map[string]float64&#123;\"c\": 5, \"Go\": 4.5, \"Python\": 4.5, \"C++\": 3&#125; fmt.Println(rating) //2、创建map后再赋值 countryMap := make(map[string]string) countryMap[\"China\"] = \"Beijing\" countryMap[\"Japan\"] = \"Tokyo\" countryMap[\"India\"] = \"New Delhi\" countryMap[\"France\"] = \"Paris\" countryMap[\"Italy\"] = \"Rome\" // 3、遍历map（无序） // (1)、key 、value都遍历 for k, v := range countryMap &#123; fmt.Println(\"国家\", k, \"首都\", v) &#125; fmt.Println(\"-----------\") //(2)、只展示value for _, v := range countryMap &#123; fmt.Println(\"国家\", \"首都\", v) &#125; fmt.Println(\"-----------\") //(3)、只展示key for k := range countryMap &#123; fmt.Println(\"国家\", k , \"首都\", countryMap[k]) &#125; fmt.Println(\"-----------\") //4、查看元素是否在map中存在 value , ok := countryMap[\"England\"] fmt.Printf(\"%q \\n\" , value) fmt.Printf(\"%T , %v \\n\" , ok , ok) if ok &#123; fmt.Println(\"首都：\" , value) &#125; else &#123; fmt.Println(\"首都信息未检索到！\") &#125; //或者 if value ,ok :=countryMap[\"USA\"];ok &#123; fmt.Println(\"首都：\" , value) &#125; else &#123; fmt.Println(\"首都信息未检索到！\") &#125;&#125; mapping 删除 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; //1、声明并初始化一个map map1 := map[string]string &#123; \"element\":\"div\", \"width\" :\"100px\", \"height\":\"200px\", \"border\":\"solid\", \"background\":\"none\", &#125; //2、根据key删除map中的某个元素 fmt.Println(\"删除前：\",map1) if _,ok := map1[\"background\"]; ok &#123; delete(map1 , \"background\") &#125; fmt.Println(\"删除后：\",map1) //3、清空map //map1 = map[string]string&#123;&#125; map1 = make(map[string]string) fmt.Println(\"清空后：\",map1)&#125; 补充 哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。 在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所以的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。 内置的make函数可以创建一个map： ages := make(map[string]int) // mapping from strings to ints 我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value： ages := map[string]int{ “alice”: 31, “charlie”: 34, } 这相当于 ages := make(map[string]int) ages[“alice”] = 31 ages[“charlie”] = 34 因此，另一种创建空的map的表达式是map[string]int{}。 Map中的元素通过key对应的下标语法访问： ages[“alice”] = 32 fmt.Println(ages[“alice”]) // “32” 使用内置的delete函数可以删除元素： delete(ages, “alice”) // remove element ages[“alice”] 所有这些操作是安全的，卽使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，卽使map中不存在“bob”下面的代码也可以正常工作，因为ages[“bob”]失败时将返回0。 ages[“bob”] = ages[“bob”] + 1 // happy birthday! 而且x += y和x等简短赋值语法也可以用在map上，所以上面的代码可以改写成 ages[“bob”] += 1 更简单的写法 ages[“bob”] 但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作： _ = &amp;ages[“bob”] // compile error: cannot take address of map element 禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。 要想遍历map中全部的key/value对的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。下面的迭代语句将在每次迭代时设置name和age变量，它们对应下一个键/值对： for name, age := range ages { fmt.Printf(&quot;%s\\t%d\\n&quot;, name, age) } Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。下面是常见的处理方式： 12345678910import &quot;sort&quot;var names []stringfor name :&#x3D; range ages &#123; names &#x3D; append(names, name)&#125;sort.Strings(names)for _, name :&#x3D; range names &#123; fmt.Printf(&quot;%s\\t%d\\n&quot;, name, ages[name])&#125; 因为我们一开始就知道names的最终大小，因此给slice分配一个合适的大小将会更有效。下面的代码创建了一个空的slice，但是slice的容量刚好可以放下map中全部的key： names := make([]string, 0, len(ages)) 在上面的第一个range循环中，我们只关心map中的key，所以我们忽略了第二个循环变量。在第二个循环中，我们只关心names中的名字，所以我们使用下划线来忽略第一个循环变量，也就是迭代slice时的索引。 map类型的零值是nil，也就是没有引用任何哈希表。 var ages map[string]int fmt.Println(ages == nil) // “true” fmt.Println(len(ages) == 0) // “true” map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常： ages[“carol”] = 21 // panic: assignment to entry in nil map 在向map存数据前必须先创建map。 通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值，正如我们前面看到的ages[“bob”]那样。这个规则很实用，但是有时候可能需要知道对应的元素是否眞的是在map之中。例如，如果元素类型是一个数字，你可以需要区分一个已经存在的0，和不存在而返回零值的0，可以像下面这样测试： 12age, ok :&#x3D; ages[&quot;bob&quot;]if !ok &#123; &#x2F;* &quot;bob&quot; is not a key in this map; age &#x3D;&#x3D; 0. *&#x2F; &#125; 你会经常看到将这两个结合起来使用，像这样： 1if age, ok :&#x3D; ages[&quot;bob&quot;]; !ok &#123; &#x2F;* ... *&#x2F; &#125; 在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否眞的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。 和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现： 1234567891011func equal(x, y map[string]int) bool &#123; if len(x) !&#x3D; len(y) &#123; return false &#125; for k, xv :&#x3D; range x &#123; if yv, ok :&#x3D; y[k]; !ok || yv !&#x3D; xv &#123; return false &#125; &#125; return true&#125; 要注意我们是如何用!ok来区分元素缺失和元素不同的。我们不能简单地用xv != y[k]判断，那样会导致在判断下面两个map时产生错误的结果： // True if equal is written incorrectly. equal(map[string]int{“A”: 0}, map[string]int{“B”: 42}) Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。为了说明这一点，下面的dedup程序读取多行输入，但是只打印第一次出现的行。（它是1.3节中出现的dup程序的变体。）dedup程序通过map来表示所有的输入行所对应的set集合，以确保已经在集合存在的行不会被重复打印。 12345678910111213141516func main() &#123; seen := make(map[string]bool) // a set of strings input := bufio.NewScanner(os.Stdin) for input.Scan() &#123; line := input.Text() if !seen[line] &#123; seen[line] = true fmt.Println(line) &#125; &#125; if err := input.Err(); err != nil &#123; fmt.Fprintf(os.Stderr, \"dedup: %v\\n\", err) os.Exit(1) &#125;&#125; Go程序员将这种忽略value的map当作一个字符串集合，并非所有map[string]bool类型value都是无关紧要的；有一些则可能会同时包含tue和false的值。 有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。 下面的例子演示了如何使用map来记录提交相同的字符串列表的次数。它使用了fmt.Sprintf函数将字符串列表转换为一个字符串以用于map的key，通过%q参数忠实地记录每个字符串元素的信息 var m = make(map[string]int) func k(list []string) string { return fmt.Sprintf(&quot;%q&quot;, list) } func Add(list []string) { m[k(list)]++ } func Count(list []string) int { return m[k(list)] } 使用同样的技术可以处理任何不可比较的key类型，而不仅仅是slice类型。这种技术对于想使用自定义key比较函数的时候也很有用，例如在比较字符串的时候忽略大小写。同时，辅助函数k(x)也不一定是字符串类型，它可以返回任何可比较的类型，例如整数、数组或结构体等。 这是map的另一个例子，下面的程序用于统计输入中每个Unicode码点出现的次数。虽然Unicode全部码点的数量巨大，但是出现在特定文档中的字符种类并没有多少，使用map可以用比较自然的方式来跟踪那些出现过字符的次数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Charcount computes counts of Unicode characters.package mainimport ( \"bufio\" \"fmt\" \"io\" \"os\" \"unicode\" \"unicode/utf8\")func main() &#123; counts := make(map[rune]int) // counts of Unicode characters var utflen [utf8.UTFMax + 1]int // count of lengths of UTF-8 encodings invalid := 0 // count of invalid UTF-8 characters in := bufio.NewReader(os.Stdin) for &#123; r, n, err := in.ReadRune() // returns rune, nbytes, error if err == io.EOF &#123; break &#125; if err != nil &#123; fmt.Fprintf(os.Stderr, \"charcount: %v\\n\", err) os.Exit(1) &#125; if r == unicode.ReplacementChar &amp;&amp; n == 1 &#123; invalid++ continue &#125; counts[r]++ utflen[n]++ &#125; fmt.Printf(\"rune\\tcount\\n\") for c, n := range counts &#123; fmt.Printf(\"%q\\t%d\\n\", c, n) &#125; fmt.Print(\"\\nlen\\tcount\\n\") for i, n := range utflen &#123; if i &gt; 0 &#123; fmt.Printf(\"%d\\t%d\\n\", i, n) &#125; &#125; if invalid &gt; 0 &#123; fmt.Printf(\"\\n%d invalid UTF-8 characters\\n\", invalid) &#125;&#125; ReadRune方法执行UTF-8解码并返回三个值：解码的rune字符的值，字符UTF-8编码后的长度，和一个错误值。我们可预期的错误值只有对应文件结尾的io.EOF。如果输入的是无效的UTF-8编码的字符，返回的将是unicode.ReplacementChar表示无效字符，并且编码长度是1。 charcount程序同时打印不同UTF-8编码长度的字符数目。对此，map并不是一个合适的数据结构；因为UTF-8编码的长度总是从1到utf8.UTFMax（最大是4个字节），使用数组将更有效。 作为一个实验，我们用charcount程序对英文版原稿的字符进行了统计。虽然大部分是英语，但是也有一些非ASCII字符。下面是排名前10的非ASCII字符： 下面是不同UTF-8编码长度的字符的数目： len count 1 765391 2 60 3 70 4 0 Map的value类型也可以是一个聚合类型，比如是一个map或slice。在下面的代码中，图graph的key类型是一个字符串，value类型map[string]bool代表一个字符串集合。从概念上将，graph将一个字符串类型的key映射到一组相关的字符串集合，它们指向新的graph的key。 1234567891011121314var graph = make(map[string]map[string]bool)func addEdge(from, to string) &#123; edges := graph[from] if edges == nil &#123; edges = make(map[string]bool) graph[from] = edges &#125; edges[to] = true&#125;func hasEdge(from, to string) bool &#123; return graph[from][to]&#125; 其中addEdge函数惰性初始化map是一个惯用方式，也就是说在每个值首次作为key时才初始化。addEdge函数显示了如何让map的零值也能正常工作；卽使from到to的边不存在，graph[from][to]依然可以返回一个有意义的结果。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang语言渐入佳境[16]-结构体拷贝","slug":"golang-16-struct-copy","date":"2018-11-26T08:11:09.000Z","updated":"2018-11-27T15:29:25.588Z","comments":true,"path":"2018/11/26/golang-16-struct-copy/","link":"","permalink":"https://dreamerjonson.com/2018/11/26/golang-16-struct-copy/","excerpt":"","text":"结构体拷贝 12345678910111213141516171819202122232425262728type Dog struct &#123; name string color string age int8 kind string&#125;func main() &#123; //1、struct是值类型，默认的复制就是深拷贝 d1 := Dog&#123;\"豆豆\", \"黑色\", 2, \"二哈\"&#125; fmt.Printf(\"d1: %T , %v , %p \\n\", d1, d1, &amp;d1) d2 := d1 //值拷贝 fmt.Printf(\"d2: %T , %v , %p \\n\", d2, d2, &amp;d2) d2.name = \"毛毛\" fmt.Println(\"d2修改后：\", d2) fmt.Println(\"d1：\", d1) fmt.Println(\"------------------\") //2、直接赋值指针地址 d3 := &amp;d1 fmt.Printf(\"d3: %T , %v , %p \\n\", d3, d3, d3) d3.name = \"球球\" d3.color = \"白色\" d3.kind = \"萨摩耶\" fmt.Println(\"d3修改后：\", d3) fmt.Println(\"d1：\", d1) fmt.Println(\"------------------\") 结构体作为函数参数 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport \"fmt\"type Flower struct &#123; name, color string&#125;func main() &#123; //1、结构体作为参数的用法 f1 := Flower&#123;\"玫瑰\", \"红\"&#125; fmt.Printf(\"f1: %T , %v , %p \\n\" , f1 , f1 , &amp;f1) fmt.Println(\"----------------------\") //将结构体对象作为参数 changeInfo1(f1) fmt.Printf(\"f1: %T , %v , %p \\n\" , f1 , f1 , &amp;f1) fmt.Println(\"----------------------\") // 将结构体指针作为参数 changeInfo2(&amp;f1) fmt.Printf(\"f1: %T , %v , %p \\n\" , f1 , f1 , &amp;f1) fmt.Println(\"----------------------\")&#125;//返回结构体对象func getFlower1() (f Flower)&#123; f = Flower&#123;\"牡丹\", \"白\"&#125; fmt.Printf(\"函数getFlower1内f: %T , %v , %p \\n\" , f , f , &amp;f) return&#125;//返回结构体指针func getFlower2() (f *Flower)&#123; //f = &amp;Flower&#123;\"芙蓉\", \"红\"&#125; temp := Flower&#123;\"芙蓉\", \"红\"&#125; fmt.Printf(\"函数getFlower2内temp: %T , %v , %p \\n\" , temp , temp , &amp;temp) f = &amp;temp fmt.Printf(\"函数getFlower2内f: %T , %v , %p , %p \\n\" , f , f , f , &amp;f) return&#125; 结构体作为函数返回值 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport \"fmt\"type Flower struct &#123; name, color string&#125;func main() &#123; //2、结构体作为返回值的用法 //结构体对象作为返回值 f2 := getFlower1() f3 := getFlower1() fmt.Println(\"更改前\" , f2 , f3) f2.name = \"杏花\" fmt.Println(\"更改后\" , f2 , f3) //结构体指针作为返回值 f4 := getFlower2() f5 := getFlower2() fmt.Println(\"更改前\" , f4 , f5) f4.name = \"桃花\" fmt.Println(\"更改后\" , f4 , f5)&#125;//返回结构体对象func getFlower1() (f Flower)&#123; f = Flower&#123;\"牡丹\", \"白\"&#125; fmt.Printf(\"函数getFlower1内f: %T , %v , %p \\n\" , f , f , &amp;f) return&#125;//返回结构体指针func getFlower2() (f *Flower)&#123; //f = &amp;Flower&#123;\"芙蓉\", \"红\"&#125; temp := Flower&#123;\"芙蓉\", \"红\"&#125; fmt.Printf(\"函数getFlower2内temp: %T , %v , %p \\n\" , temp , temp , &amp;temp) f = &amp;temp fmt.Printf(\"函数getFlower2内f: %T , %v , %p , %p \\n\" , f , f , f , &amp;f) return&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[15]-struct声明与定义","slug":"golang-15-struct","date":"2018-11-26T07:53:32.000Z","updated":"2019-03-19T09:27:17.666Z","comments":true,"path":"2018/11/26/golang-15-struct/","link":"","permalink":"https://dreamerjonson.com/2018/11/26/golang-15-struct/","excerpt":"","text":"结构体的声明 123456&#x2F;&#x2F;声明Teacher结构体type Teacher struct &#123; name string age int8 sex byte&#125; 结构体的定义 方式1 //1、var声明方式实例化结构体，初始化方式为：对象.属性=值 1234var t1 Teacher t1.name &#x3D; &quot;jonson&quot; t1.age &#x3D; 35 t1.sex &#x3D; 1 方式2 变量简短声明格式实例化结构体，初始化方式为：对象.属性=值 1234t2 :&#x3D; Teacher&#123;&#125;t2.name &#x3D; &quot;olaya&quot;t2.age &#x3D; 30t2.sex &#x3D; 1 方式3 3、变量简短声明格式实例化结构体，声明时初始化。初始化方式为：属性:值 。属性:值可以同行，也可以换行。（类似map的用法） 123456t3 :&#x3D; Teacher&#123; name: &quot;Josh&quot;, age: 28, sex: 1,&#125;t3 &#x3D; Teacher&#123;name: &quot;Josh2&quot;, age: 27, sex: 1&#125; 方式4 变量简短声明格式实例化结构体，声明时初始化，不写属性名，按属性顺序只写属性值 1t4 :&#x3D; Teacher&#123;&quot;Ruby&quot;, 30, 0&#125; 方式5 创建指针类型的结构体 1234567t5 := new(Teacher)(*t5).name = \"Running\"(*t5).age = 31(*t5).sex = 0t5.name = \"Running2\"t5.age = 31t5.sex = 0 方式6 匿名结构体 123addr := struct &#123; province, city string&#125;&#123;\"陕西省\", \"西安市\"&#125; 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport \"fmt\"//定义Teacher结构体type Teacher struct &#123; name string age int8 sex byte&#125;func main() &#123; //1、var声明方式实例化结构体，初始化方式为：对象.属性=值 var t1 Teacher fmt.Println(t1) fmt.Printf(\"t1:%T , %v , %q \\n\", t1, t1, t1) //if t1 == nil &#123; // fmt.Println() //&#125; t1.name = \"Steven\" t1.age = 35 t1.sex = 1 fmt.Println(t1) fmt.Println(\"-------------------\") //2、变量简短声明格式实例化结构体，初始化方式为：对象.属性=值 t2 := Teacher&#123;&#125; t2.name = \"David\" t2.age = 30 t2.sex = 1 fmt.Println(t2) fmt.Println(\"-------------------\") //3、变量简短声明格式实例化结构体，声明时初始化。初始化方式为：属性:值 。属性:值可以同行，也可以换行。（类似map的用法） t3 := Teacher&#123; name: \"Josh\", age: 28, sex: 1, &#125; t3 = Teacher&#123;name: \"Josh2\", age: 27, sex: 1&#125; fmt.Println(t3) fmt.Println(\"-------------------\") //4、变量简短声明格式实例化结构体，声明时初始化，不写属性名，按属性顺序只写属性值 t4 := Teacher&#123;\"Ruby\", 30, 0&#125; fmt.Println(t4) fmt.Println(\"-------------------\") //5、创建指针类型的结构体 t5 := new(Teacher) fmt.Printf(\"t5:%T , %v , %p \\n\", t5, t5, t5) //(*t5).name = \"Running\" //(*t5).age = 31 //(*t5).sex = 0 //语法简写形式——语法糖 t5.name = \"Running2\" t5.age = 31 t5.sex = 0 fmt.Println(t5) fmt.Println(\"-------------------\")&#125; 结构体匿名字段 123456789101112131415161718192021222324252627package mainimport \"fmt\"type User struct &#123; //name string //sex byte //age int8 //height float64 //weight float64 string byte int8 float64&#125;func main() &#123; // 实例化结构体 user:= User&#123;\"jonson\" , 'm' , 35 , 177.5&#125; fmt.Println(user) //如果想依次输出姓名、年龄、身高、性别 fmt.Printf(\"姓名：%s \\n\" , user.string) fmt.Printf(\"身高：%.2f \\n\" , user.float64) fmt.Printf(\"性别：%c \\n\" , user.byte) fmt.Printf(\"年龄：%d \\n\" , user.int8)&#125; 结构体 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。用结构体的经典案例处理公司的员工信息，每个员工信息包含一个唯一的员工编号、员工的名字、家庭住址、出生日期、工作岗位、薪资、上级领导等等。所有的这些信息都需要绑定到一个实体中，可以作为一个整体单元被复制，作为函数的参数或返回值，或者是被存储到数组中，等等。 下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert： type Employee struct { ID int Name string Address string DoB time.Time Position string Salary int ManagerID int } var dilbert Employee dilbert结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。因为dilbert是一个变量，它所有的成员也同样是变量，我们可以直接对每个成员赋值： dilbert.Salary -= 5000 // demoted, for writing too few lines of code 或者是对成员取地址，然后通过指针访问： 12position :&#x3D; &amp;dilbert.Position*position &#x3D; &quot;Senior &quot; + *position &#x2F;&#x2F; promoted, for outsourcing to Elbonia 点操作符也可以和指向结构体的指针一起工作： 12var employeeOfTheMonth *Employee &#x3D; &amp;dilbertemployeeOfTheMonth.Position +&#x3D; &quot; (proactive team player)&quot; 相当于下面语句 1(*employeeOfTheMonth).Position +&#x3D; &quot; (proactive team player)&quot; 1234567下面的EmployeeByID函数将根据给定的员工ID返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员：func EmployeeByID(id int) *Employee &#123; &#x2F;* ... *&#x2F; &#125;fmt.Println(EmployeeByID(dilbert.ManagerID).Position) &#x2F;&#x2F; &quot;Pointy-haired boss&quot;id :&#x3D; dilbert.IDEmployeeByID(id).Salary &#x3D; 0 &#x2F;&#x2F; fired for... no real reason 后面的语句通过EmployeeByID返回的结构体指针更新了Employee结构体的成员。如果将EmployeeByID函数的返回值从*Employee指针类型改为Employee值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。 通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样： 12345678type Employee struct &#123; ID int Name, Address string DoB time.Time Position string Salary int ManagerID int&#125; 结构体成员的输入顺序也有重要的意义。我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。通常，我们只是将相关的成员写到一起。 如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。 结构体类型往往是冗长的，因为它的每个成员可能都会占一行。虽然我们每次都可以重写整个结构体成员，但是重复会令人厌烦。因此，完整的结构体写法通常只在类型声明语句的地方出现，就像Employee类型声明语句那样。 一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。在下面的代码中，我们使用一个二叉树来实现一个插入排序： 12345678910111213141516171819202122232425262728293031323334353637383940type tree struct &#123; value int left, right *tree&#125;// Sort sorts values in place.func Sort(values []int) &#123; var root *tree for _, v := range values &#123; root = add(root, v) &#125; appendValues(values[:0], root)&#125;// appendValues appends the elements of t to values in order// and returns the resulting slice.func appendValues(values []int, t *tree) []int &#123; if t != nil &#123; values = appendValues(values, t.left) values = append(values, t.value) values = appendValues(values, t.right) &#125; return values&#125;func add(t *tree, value int) *tree &#123; if t == nil &#123; // Equivalent to return &amp;tree&#123;value: value&#125;. t = new(tree) t.value = value return t &#125; if value &lt; t.value &#123; t.left = add(t.left, value) &#125; else &#123; t.right = add(t.right, value) &#125; return t&#125; 结构体类型的零值是每个成员都对是零值。通常会将零值作为最合理的默认值。例如，对于bytes.Buffer类型，结构体初始值就是一个随时可用的空缓存，还有在第9章将会讲到的sync.Mutex的零值也是有效的未锁定状态。有时候这种零值可用的特性是自然获得的，但是也有些类型需要一些额外的工作。 如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。有些Go语言程序员用map带模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所有我们通常避免避免这样的用法。 123456seen := make(map[string]struct&#123;&#125;) // set of strings// ...if _, ok := seen[s]; !ok &#123; seen[s] = struct&#123;&#125;&#123;&#125; // ...first time seeing s...&#125; 结构体值也可以用结构体面值表示，结构体面值可以指定每个成员的值。 123type Point struct&#123; X, Y int &#125;p := Point&#123;1, 2&#125; 这里有两种形式的结构体面值语法，上面的是第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如image.Point{x, y}或color.RGBA{ red, green, blue, alpha}。 其实更常用的是第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员 anim := gif.GIF{LoopCount: nframes} 在这种形式的结构体面值写法中，如果成员被忽略的话将默认用零值。因为，提供了成员的名字，所有成员出现的顺序并不重要。 两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员。 1234567package ptype T struct&#123; a, b int &#125; // a and b are not exportedpackage qimport \"p\"var _ = p.T&#123;a: 1, b: 2&#125; // compile error: can't reference a, bvar _ = p.T&#123;1, 2&#125; // compile error: can't reference a, b 虽然上面最后一行代码的编译错误信息中并没有显式提到未导出的成员，但是这样企图隐式使用未导出成员的行为也是不允许的。 结构体可以作为函数的参数和返回值。例如，这个Scale函数将Point类型的值缩放后返回： func Scale(p Point, factor int) Point { return Point{p.X * factor, p.Y * factor} } fmt.Println(Scale(Point{1, 2}, 5)) // “{5 10}” 如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回， 123func Bonus(e *Employee, percent int) int &#123; return e.Salary * percent &#x2F; 100&#125; 如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。 123func AwardAnnualRaise(e *Employee) &#123; e.Salary = e.Salary * 105 / 100&#125; 因为结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址： pp := &amp;Point{1, 2} 它是下面的语句是等价的 12pp :&#x3D; new(Point)*pp &#x3D; Point&#123;1, 2&#125; 不过&amp;Point{1, 2}写法可以直接在表达式中使用，比如一个函数调用。 结构体比较 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用或!=运算符进行比较。相等比较运算符将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的： 123456type Point struct&#123; X, Y int &#125;p :&#x3D; Point&#123;1, 2&#125;q :&#x3D; Point&#123;2, 1&#125;fmt.Println(p.X &#x3D;&#x3D; q.X &amp;&amp; p.Y &#x3D;&#x3D; q.Y) &#x2F;&#x2F; &quot;false&quot;fmt.Println(p &#x3D;&#x3D; q) &#x2F;&#x2F; &quot;false&quot; 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。 1234567type address struct &#123; hostname string port int&#125;hits :&#x3D; make(map[address]int)hits[address&#123;&quot;golang.org&quot;, 443&#125;]++ 结构体嵌入和匿名成员 在本节中，我们将看到如何使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符xf来访问匿名成员链中嵌套的xdef成员。 考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义： 1234567type Circle struct &#123; X, Y, Radius int&#125;type Wheel struct &#123; X, Y, Radius, Spokes int&#125; 一个Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和一个Radius表示的半径信息。一个Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。我们可以这样创建一个wheel变量： 12345var w Wheelw.X &#x3D; 8w.Y &#x3D; 8w.Radius &#x3D; 5w.Spokes &#x3D; 20 随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来： 12345678910111213type Point struct &#123; X, Y int&#125;type Circle struct &#123; Center Point Radius int&#125;type Wheel struct &#123; Circle Circle Spokes int&#125; 这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐： 12345var w Wheelw.Circle.Center.X &#x3D; 8w.Circle.Center.Y &#x3D; 8w.Circle.Radius &#x3D; 5w.Spokes &#x3D; 20 Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。 123456789type Circle struct &#123; Point Radius int&#125;type Wheel struct &#123; Circle Spokes int&#125; 得意于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径： 12345var w Wheelw.X &#x3D; 8 &#x2F;&#x2F; equivalent to w.Circle.Point.X &#x3D; 8w.Y &#x3D; 8 &#x2F;&#x2F; equivalent to w.Circle.Point.Y &#x3D; 8w.Radius &#x3D; 5 &#x2F;&#x2F; equivalent to w.Circle.Radius &#x3D; 5w.Spokes &#x3D; 20 在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是眞的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。 不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过： 12w &#x3D; Wheel&#123;8, 8, 5, 20&#125; &#x2F;&#x2F; compile error: unknown fieldsw &#x3D; Wheel&#123;X: 8, Y: 8, Radius: 5, Spokes: 20&#125; &#x2F;&#x2F; compile error: unknown fields 结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的： 12345678910111213141516171819w = Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;w = Wheel&#123; Circle: Circle&#123; Point: Point&#123;X: 8, Y: 8&#125;, Radius: 5, &#125;, Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)&#125;fmt.Printf(\"%#v\\n\", w)// Output:// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;w.X = 42fmt.Printf(\"%#v\\n\", w)// Output:// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125; 需要注意的是Printf函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。 因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。卽使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员 w.X = 8 // equivalent to w.circle.point.X = 8 但是在包外部，因为circle和point没有导出不能访问它们的成员，因此简短的匿名成员访问语法也是禁止的。 到目前未知，我们看到匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。稍后，我们将会看到匿名成员并不要求是结构体类型；其实任何命令的类型都可以作为结构体的匿名成员。但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？ 答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一个有简单行为的对象组合成有复杂行为的对象","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"solidity智能合约[55]-数字货币发行(上)","slug":"solidity-55-token","date":"2018-11-26T02:07:34.000Z","updated":"2018-12-01T14:00:06.385Z","comments":true,"path":"2018/11/26/solidity-55-token/","link":"","permalink":"https://dreamerjonson.com/2018/11/26/solidity-55-token/","excerpt":"","text":"数字货币 货币是用来交换、偿还债务的媒介。古代货币为金、银、贝壳等实物。现代中央银行发行的纸币等。相对于古代的一般等价物而言 现在的货币本质上是由政府信用的背书。其本身并没有价值。 同理、比特币与以太币本身并没有价值，但是依托于区块链网络的特性，使得其拥有货币的完美属性。包括： ·便携 ·耐用 ·可分割 ·可识别 ·可替代 ·稀缺且难以仿冒 数字货币引入 如下是一段简单的代币代码。balanceOf映射表存储金额。构造函数，定义了初始化发行与管理者。 transfer函数定义了转账操作。完成了货币存储与转移的功能。 本质上，此货币就是存储在balanceOf映射表中的数字。数字本身并没有价值，只有当你认为他有价值的时候，它才会有价值。所以，数字货币的背后，常常是对应与一定的商业价值。例如公司的股权等。 1234567891011121314151617pragma solidity ^0.4.23;contract tokenDemo&#123; mapping(address=&gt;uint) public balanceOf; address owner; constructor(uint initSupply) public &#123; balanceOf[msg.sender] = initSupply; owner = msg.sender; &#125; function transfer(address _to,uint _value) public &#123; balanceOf[owner] -= _value; balanceOf[_to] += _value; &#125;&#125; 一般代币合约的缺陷 如上面写好的简单代币demo，有三种缺陷。 1、没有权限的控制，任何人都可以调用transfer进行转账 2、没有防止溢出攻击 3、功能有限 4、没有统一的规范。 想象一下，如果每一个人或企业都写一个属于自己的代币合约。每一个合约都有自己的查询资金的函数名。都有自己的转账的函数名。那么每一次当我们需要用到其他人的代币，都需要查询，此代币合约中，每一个函数的功能。大大降低了效率。 这就为我们引出了ERC20代币。 ERC20协议 ERC是以太坊征求意见( Ethereum Request for Comment-20)的缩写. 20代表它的序号。其规范了代币合约，也就意味着，一旦合约满足了ERC20代币的规范，那么其必然有规范的函数标准。如下，就是ERC20代币协议规定的不同的函数及其功能。ERC20协议只是定义了函数的定义与功能，需要代币设计者自定义的实现函数功能。 1234567891011121314151617interface ERC20Interface &#123; &#x2F;&#x2F;总发行数量 function totalSupply() external returns (uint); &#x2F;&#x2F;查询数量 function balanceOf(address tokenOwner) external returns (uint balance); &#x2F;&#x2F;查询授权数量 function allowance(address tokenOwner, address spender) external returns (uint remaining); &#x2F;&#x2F;转账 function transfer(address to, uint tokens) external returns (bool success); &#x2F;&#x2F;授权 function approve(address spender, uint tokens) external returns (bool success); &#x2F;&#x2F;授权转账 function transferFrom(address from, address to, uint tokens) external returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#125; ERC20代币实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198pragma solidity ^0.4.18;&#x2F;&#x2F; ----------------------------------------------------------------------------&#x2F;&#x2F; &#39;&#39; token contract&#x2F;&#x2F;&#x2F;&#x2F; 部署地址 :&#x2F;&#x2F; 标志 : LOVE&#x2F;&#x2F; 名字 : LOVE TOKEN&#x2F;&#x2F; 总供应量 100000000000000000000000000&#x2F;&#x2F; 精度 : 18&#x2F;&#x2F; ---------------------------------------------------------------------------&#x2F;&#x2F; ----------------------------------------------------------------------------&#x2F;&#x2F; SafeMath安全库&#x2F;&#x2F; ----------------------------------------------------------------------------contract SafeMath &#123; function safeAdd(uint a, uint b) public pure returns (uint c) &#123; c &#x3D; a + b; require(c &gt;&#x3D; a); &#125; function safeSub(uint a, uint b) public pure returns (uint c) &#123; require(b &lt;&#x3D; a); c &#x3D; a - b; &#125; function safeMul(uint a, uint b) public pure returns (uint c) &#123; c &#x3D; a * b; require(a &#x3D;&#x3D; 0 || c &#x2F; a &#x3D;&#x3D; b); &#125; function safeDiv(uint a, uint b) public pure returns (uint c) &#123; require(b &gt; 0); c &#x3D; a &#x2F; b; &#125;&#125;&#x2F;&#x2F; ----------------------------------------------------------------------------&#x2F;&#x2F; ERC20 代币标准&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;ethereum&#x2F;EIPs&#x2F;blob&#x2F;master&#x2F;EIPS&#x2F;eip-20-token-standard.md&#x2F;&#x2F; ----------------------------------------------------------------------------contract ERC20Interface &#123; &#x2F;&#x2F;总发行数量 function totalSupply() public constant returns (uint); &#x2F;&#x2F;查询数量 function balanceOf(address tokenOwner) public constant returns (uint balance); &#x2F;&#x2F;查询授权数量 function allowance(address tokenOwner, address spender) public constant returns (uint remaining); &#x2F;&#x2F;转账 function transfer(address to, uint tokens) public returns (bool success); &#x2F;&#x2F;授权 function approve(address spender, uint tokens) public returns (bool success); &#x2F;&#x2F;授权转账 function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#125;&#x2F;&#x2F; ----------------------------------------------------------------------------&#x2F;&#x2F; 所有者合约&#x2F;&#x2F; ----------------------------------------------------------------------------contract Owned &#123; address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public &#123; owner &#x3D; msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender &#x3D;&#x3D; owner); _; &#125; function transferOwnership(address _newOwner) public onlyOwner &#123; newOwner &#x3D; _newOwner; &#125; function acceptOwnership() public &#123; require(msg.sender &#x3D;&#x3D; newOwner); OwnershipTransferred(owner, newOwner); owner &#x3D; newOwner; newOwner &#x3D; address(0); &#125;&#125;&#x2F;&#x2F; ----------------------------------------------------------------------------&#x2F;&#x2F; ERC20代币，增加标志、名字、精度&#x2F;&#x2F; 代币转移&#x2F;&#x2F; ----------------------------------------------------------------------------contract LOVEToken is ERC20Interface, Owned, SafeMath &#123; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address &#x3D;&gt; uint) balances; mapping(address &#x3D;&gt; mapping(address &#x3D;&gt; uint)) allowed; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 构造函数 &#x2F;&#x2F; ------------------------------------------------------------------------ function LOVEToken() public &#123; symbol &#x3D; &quot;LOVER&quot;; name &#x3D; &quot;LOVER Token&quot;; decimals &#x3D; 18; _totalSupply &#x3D; 100000000000000000000000000; balances[0x6AFe57C1F589C4744ab9FF4ac8899080695a6f5e] &#x3D; _totalSupply; Transfer(address(0), 0x6AFe57C1F589C4744ab9FF4ac8899080695a6f5e, _totalSupply); &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 总供应量 &#x2F;&#x2F; ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) &#123; return _totalSupply - balances[address(0)]; &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 得到资金的数量 &#x2F;&#x2F; ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) &#123; return balances[tokenOwner]; &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 转账从代币拥有者的账户到其他账户 &#x2F;&#x2F; - 所有者的账户必须有充足的资金去转账 &#x2F;&#x2F; - 0值的转账也是被允许的 &#x2F;&#x2F; ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) &#123; balances[msg.sender] &#x3D; safeSub(balances[msg.sender], tokens); balances[to] &#x3D; safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 授权 &#x2F;&#x2F; ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) &#123; allowed[msg.sender][spender] &#x3D; tokens; Approval(msg.sender, spender, tokens); return true; &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 和approve连接在一起 &#x2F;&#x2F; &#x2F;&#x2F; The calling account must already have sufficient tokens approve(...)-d &#x2F;&#x2F; for spending from the from account and &#x2F;&#x2F; - From account must have sufficient balance to transfer &#x2F;&#x2F; - Spender must have sufficient allowance to transfer &#x2F;&#x2F; - 0 value transfers are allowed &#x2F;&#x2F; ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) &#123; balances[from] &#x3D; safeSub(balances[from], tokens); allowed[from][msg.sender] &#x3D; safeSub(allowed[from][msg.sender], tokens); balances[to] &#x3D; safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 返回授权数量 &#x2F;&#x2F; ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) &#123; return allowed[tokenOwner][spender]; &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; 合约不接受以太币 &#x2F;&#x2F; ------------------------------------------------------------------------ function () public payable &#123; revert(); &#125; &#x2F;&#x2F; ------------------------------------------------------------------------ &#x2F;&#x2F; Owner can transfer out any accidentally sent ERC20 tokens &#x2F;&#x2F;所有者能够转移任何ERC20代币的接口 &#x2F;&#x2F; ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) &#123; return ERC20Interface(tokenAddress).transfer(owner, tokens); &#125;&#125; ERC20代币的缺陷 1、当为合约转移了一笔钱的时候，这笔钱就会永久的消失。因为合约不能够自己去执行转账、提钱的操作。 如下面一些ERC20代币因为误操作带来的损失。 12345678910111213QTUM, $1,204,273 lost. watch on EtherscanEOS, $1,015,131 lost. watch on EtherscanGNT, $249,627 lost. watch on EtherscanSTORJ, $217,477 lost. watch on EtherscanTronix , $201,232 lost. watch on EtherscanDGD, $151,826 lost. watch on EtherscanOMG, $149,941 lost. watch on Etherscan ERC223代币引入 ERC223协议正是为了解决ERC20代币所带来的缺陷而设计的。 ERC223代币仍然可以给某一个合约转账，但是其必须要实现方法： function tokenFallback(address _from, uint _value, bytes data) ERC223代币还有一个重要的特征就是需要识别一个账户地址，其是外部账户还是合约账户。 内联汇编判断账户地址类型 12345678function isContract(address _addr) returns (bool is_contract) &#123; uint length; assembly &#123; length :&#x3D; extcodesize(_addr) &#125; return (length&gt;0); &#125; ERC223代币+ERC20代币 erc223协议有许多和erc20协议相同的方法，在下面我们将实现一个继承了ERC20、ERC223接口的代币合约 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150pragma solidity ^0.4.23;import \"./safemathlibrary.sol\";interface ERC20Interface &#123; //总发行数量 function totalSupply() external returns (uint); //查询数量 function balanceOf(address tokenOwner) external returns (uint balance); //查询授权数量 function allowance(address tokenOwner, address spender) external returns (uint remaining); //转账 function transfer(address to, uint tokens) external returns (bool success); //授权 function approve(address spender, uint tokens) external returns (bool success); //授权转账 function transferFrom(address from, address to, uint tokens) external returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens);&#125; interface ContractReceiver &#123; function tokenFallback(address _from, uint _value, bytes _data);&#125;interface ERC223 &#123; //可以发动给合约。 function transfer(address to, uint value, bytes data) public returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);&#125;contract Owned &#123; address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public &#123; owner = msg.sender; &#125; modifier onlyOwner &#123; require(msg.sender == owner); _; &#125; function transferOwnership(address _newOwner) public onlyOwner &#123; newOwner = _newOwner; &#125; function acceptOwnership() public &#123; require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); &#125;&#125;contract LoveToken is ERC20Interface,ERC223,Owned &#123; using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; mapping(address =&gt; uint) balances; mapping(address =&gt; mapping(address =&gt; uint)) allowed;// A ---&gt;B 5 token constructor() public &#123; symbol=\"LOVE\"; name=\"LOVE TOKEN\"; decimals=18; _totalSupply = 10000 * 10 **18; balances[owner] = _totalSupply; emit Transfer(address(0),owner,_totalSupply); &#125; function isContract(address _addr) returns (bool is_contract) &#123; uint length; assembly &#123; length := extcodesize(_addr) &#125; return (length&gt;0); &#125; function totalSupply() public view returns (uint) &#123; return _totalSupply.sub(balances[address(0)]); &#125; function balanceOf(address tokenOwner) public view returns (uint balance) &#123; return balances[tokenOwner]; &#125; function transfer(address to, uint tokens) public returns (bool success) &#123; balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender,to,tokens); return true; &#125;//转账给合约function transfer(address to, uint value, bytes data) public returns (bool ok)&#123; if(isContract(to))&#123; balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); ContractReceiver c = ContractReceiver(to); c.tokenFallback(msg.sender,value,data); emit Transfer(msg.sender,to,value,data); &#125;&#125; function approve(address spender, uint tokens) public returns (bool success) &#123; allowed[msg.sender][spender] = tokens; emit Approval(msg.sender,spender,tokens); return true; &#125; function transferFrom(address from, address to, uint tokens) public returns (bool success) &#123; balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from,to,tokens); return true; &#125; function allowance(address tokenOwner, address spender) public view returns (uint remaining) &#123; return allowed[tokenOwner][spender]; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[54]-安全—取反","slug":"solidity-54-negation","date":"2018-11-25T11:46:57.000Z","updated":"2018-11-27T15:31:56.725Z","comments":true,"path":"2018/11/25/solidity-54-negation/","link":"","permalink":"https://dreamerjonson.com/2018/11/25/solidity-54-negation/","excerpt":"","text":"相反数 有符号的solidity整数类型如果有N位。那么其值的范围是-2^(N-1) to 2^(N-1)-1。 这意味着该类型负数的最大值取相反数之后不能够被接收。 相反数陷阱 如下的Negation合约说明了负数在面临取相反数操作时可能遇到的问题。由于对于负数取相反数。实则是取负数的补码操作。因此、当某int类型最大的负数取相反数的时候，会是其本身。如当int8的最大值-128传递到negate8执行取反操作的时候，会返回128。 123456789101112131415contract Negation &#123; function negate8(int8 _i) public pure returns(int8) &#123; return -_i; &#125; function negate16(int16 _i) public pure returns(int16) &#123; return -_i; &#125; int8 public d = negate8(127); // -127 int8 public a = negate8(-128); // -128 int16 public b = negate16(-128); // 128 int16 public c = negate16(-32768); // -32768&#125; 解决办法 1、使用更大的类型来接收可以避免出现问题。 2、检查是否达到了该类型的最大负数。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[53]-安全-重入攻击","slug":"solidity-53-security-reentrancy","date":"2018-11-25T03:53:03.000Z","updated":"2018-11-27T15:31:52.557Z","comments":true,"path":"2018/11/25/solidity-53-security-reentrancy/","link":"","permalink":"https://dreamerjonson.com/2018/11/25/solidity-53-security-reentrancy/","excerpt":"","text":"重入攻击 当调用外部的合约时，外部合约会接管控制流程，从而可能给自己的数据带来意想不到的修改。2016年6月，以太坊最大众筹项目The DAO被攻击，黑客获得超过350万个以太币。正是由于此陷阱。 重入攻击本质 1、调用外部合约 2、fallback回调函数被多次执行 3、逻辑顺序出现问题 4、call函数没有gaslimit的限制。 5、call函数返回值为true或false。出错不会执行回滚。 案例剖析 1、部署合约Vulnerable、Malicious、transferEther，假设地址为 addrA、addrB、addrC 2、 将addrB传递到 Vulnerable合约的 add中。 完成此操作后，将balance映射的金额增加100。附带5 ether。让Vulnerable合约一开始就有5 ether。 3、将addrA的地址传递到Malicious合约的instance中，存储地址。 4、调用transferEther合约的test方法，传递addrB的地址。由于合约的转账方法出发了fallback回调函数。因此执行了Vulnerable合约中的withdrawEquity方法。此方法执行了语句 msg.sender.call.value(x)();而当前的msg.sender为Malicious合约地址，又会再次执行Malicious合约的回调函数。而这时， ____balanceOf[msg.sender] 的金额还没有变为0.使得Vulnerable不停的转移资金给Malicious合约。一直到到达了gaslimit的限制从而终止。但是由于call函数返回值为true或false。只有最后的函数出错会执行回滚。其他函数会正常的执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455contract Vulnerable&#123; mapping(address =&gt;uint) public _balanceOf; function withdrawEquity() public returns(bool)&#123; uint x = _balanceOf[msg.sender]; msg.sender.call.value(x)(); _balanceOf[msg.sender] = 0 ; return true; &#125; function add(address _addr) payable&#123; _balanceOf[_addr] = 100; &#125; function getBalance() returns(uint)&#123; return this.balance; &#125;&#125;contract Malicious&#123; address private _owner; Vulnerable public vul; function setInstance(address addr) public&#123; vul = Vulnerable(addr); &#125; function Malicious() public &#123; _owner = msg.sender; &#125; function () public payable&#123; vul.withdrawEquity(); &#125; function winnerWinnerChickenDinner() public&#123; _owner.transfer(this.balance); &#125; function getBalance() returns(uint)&#123; return this.balance; &#125;&#125;contract transferEther&#123; function test(address _addr) payable&#123; _addr.call.value(5 ether)(); &#125;&#125; 解决办法 1、替换顺序，这样当重复执行withdrawEquity函数时，资金已经变为了0。 1234567891011121314function withdrawEquity() public returns(bool)&#123; uint x &#x3D; _balanceOf[msg.sender]; msg.sender.call.value(x)(); _balanceOf[msg.sender] &#x3D; 0 ; return true;&#125;替换为：function withdrawEquity() public returns(bool)&#123; uint x &#x3D; _balanceOf[msg.sender]; _balanceOf[msg.sender] &#x3D; 0 ; msg.sender.call.value(x)(); return true;&#125; 2、替换为更安全的send、transfer函数 3、对于调用外部合约的时候保持警惕。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[52]-安全-storage陷阱","slug":"solidity-52-security-storage","date":"2018-11-25T02:33:07.000Z","updated":"2018-11-27T15:31:47.750Z","comments":true,"path":"2018/11/25/solidity-52-security-storage/","link":"","permalink":"https://dreamerjonson.com/2018/11/25/solidity-52-security-storage/","excerpt":"","text":"storage陷阱 下面的合约是一个锁定金额的合约，用户将资金存储在此合约中，只有当过了一段时间时候才能够提取出来。 下面的案例是为了说明storage属性预设性带来的陷阱。payIn函数是当用户存储金额时调用的函数。传递的参数似乎解锁的时间。在合约payIn中，HoldRecord newRecord; 其实默认为storage类型，并且，当不为storage变量赋值的时候，变量默认引用的位置是storage空间中的0号位置。这也意味着在当前的案例中，newRecord指针指向了ownerAmount，当对newRecord 执行newRecord.amount += msg.value; 实则将ownerAmount即合约拥有者的金额增加了。 这时，合约拥有者就可以调用ownerWithdrawal将用户存储在合约的钱转移出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051pragma solidity ^0.4.23;contract HodlFraud &#123; uint public ownerAmount; //合约拥有者的金钱 uint public numberOfPayouts; //次数 address public owner; //合约的拥有者 struct HoldRecord &#123; uint amount; //存储的金钱 uint unlockTime; //解锁的时间 &#125; mapping (address =&gt; HoldRecord) public balance; //地址 =&gt; 存储的金钱，时间 //构造函数初始化 function HodlFraud () public payable &#123; owner = msg.sender; ownerAmount = msg.value; &#125; //某一个用户存储金钱， //@param holdTime 代表的是解锁时间 function payIn(uint holdTime) public payable &#123; require(msg.value &gt; 0); HoldRecord newRecord; newRecord.amount += msg.value; newRecord.unlockTime = now + holdTime; balance[msg.sender] = newRecord; &#125; //转账，使用这笔钱 function withdraw () public &#123; require(balance[msg.sender].unlockTime &lt; now &amp;&amp; balance[msg.sender].amount &gt; 0); msg.sender.transfer(balance[msg.sender].amount); balance[msg.sender].amount = 0; numberOfPayouts++; &#125; //合约的拥有着，转移自己的钱 function ownerWithdrawal () public &#123; require(msg.sender == owner &amp;&amp; ownerAmount &gt; 0); msg.sender.transfer(ownerAmount); ownerAmount = 0; &#125;&#125; 解决办法 HoldRecord newRecord 修改为 HoldRecord memory newRecord 总结 123&#x2F;&#x2F; 这个例子是要举出在 smart contract 中 storage 预设行为的危险性。其实只要维持一个原则就可以避免这个问题。&#x2F;&#x2F; 养成明确定义使用 storage 还是 memory 的好习惯&#x2F;&#x2F; 一般来说，指定 storage 时就直接给初始值；而在 function 里面需要用到的缓存器都用 memory，除非想要直接修改链上的值。现在 compiler 都会很聪明的提醒开发者要定义 storage 还是 memory，而当 storage pointer 没有初始值时也会提醒开发者。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[51]-安全—dos攻击","slug":"solidity-51-dos-attrack","date":"2018-11-24T15:50:46.000Z","updated":"2018-11-27T15:31:43.730Z","comments":true,"path":"2018/11/24/solidity-51-dos-attrack/","link":"","permalink":"https://dreamerjonson.com/2018/11/24/solidity-51-dos-attrack/","excerpt":"","text":"Dos攻击 dos攻击也叫做拒绝服务攻击，通过使程序操作无效完成攻击的目的。 下面的一段合约是2016年KotET（“纷争时代”）合约，其遭受了dos攻击。本小节将揭开此合约被攻击的秘密。 源代码 在下面KotET合约代码中，模拟了争夺皇位的功能。只有出价最高的人才能够夺得桂冠。 合约中的bid方法正是最核心的竞价合约。只有当msg.value即附带的以太币大于当前最大的出价人，就会首先将从前的最高价格转移给从前的出价人。完成之后，新的价格和资金会替换掉旧的资金。 123456789101112131415pragma solidity ^0.4.23;contract Auction&#123; address public currentLeader; //当前最高出价人 uint256 public highestBid; //当前最高价格 mapping(address=&gt;uint) balance; //资金表 //竞价合约 function bid() public payable&#123; require(msg.value &gt;highestBid); require(currentLeader.send(highestBid)); currentLeader = msg.sender; highestBid= msg.value; &#125;&#125; 攻击合约 下面是黑客攻击的合约。攻击手法为：首先部署POC合约。假设为0x3456 将Auction合约的地址传递给setInstance，构建auInstance接口实例。从而能够在外部调用合约。执行attack方法，附带以太坊，例如100wei。假设还没有进行过拍卖，那么当前的最高出价地址为当前合约，最高价格为100wei。假设有另外一个人想争夺皇位，其出价了200wei 调用了Auction合约的bid方法。虽然其价格最高，但是这笔操作不能成功。原因就在于currentLeader.send(highestBid)转账，如果是合约地址，会调用合约中自定义的回调函数，而在当前案例中的回调函数，revert()意味着操作回滚，不成功。因此始终没有办法将钱还给合约，此合约将霸占王位。 123456789101112131415161718192021222324252627282930pragma solidity ^0.4.23;interface Auction&#123; function bid() external payable;&#125;contract POC&#123; address owner; Auction auInstance; constructor() public&#123; owner = msg.sender; &#125; modifier onlyOwner()&#123; require(owner==msg.sender); _; &#125; function setInstance(address addr) public onlyOwner&#123; auInstance = Auction(addr); &#125; function attack() public payable onlyOwner&#123; auInstance.bid.value(msg.value)(); &#125; function() external payable&#123; revert(); &#125;&#125; 解决办法 让用户自己去取钱，而不是自动的转移资金到失败者的账户中。 123456789101112131415161718192021pragma solidity ^0.4.23;contract Auction&#123; address public currentLeader; uint256 public highestBid; &#x2F;&#x2F;存储金额 mapping(address&#x3D;&gt;uint) public balance; function bid() public payable&#123; require(msg.value &gt;highestBid); balance[currentLeader] &#x3D; highestBid; currentLeader &#x3D; msg.sender; highestBid&#x3D; msg.value; &#125; &#x2F;&#x2F;用户提钱 function withdraw() public&#123; require(balance[msg.sender]!&#x3D;0); msg.sender.transfer(balance[msg.sender]); balance[msg.sender] &#x3D; 0; &#125;&#125; dos攻击案例2 dos攻击的第二个例子是，谨慎的使用循环。 如下，refundAll方法为动态数组refundAddresses中每一个账户转移资金。由于refundAddresses长度不确定。一旦超过了以太坊gaslimit的限制，就会导致这笔操作不能够成功。 对可以被外部用户人为操纵的数据结构进行批量操作，建议使用取回模式而不是发送模式，每个投资者可以使用withdrawFunds取回自己应得的代币。 如果实在必须通过遍历一个变长数组来进行转账，最好估计完成它们大概需要多少个区块以及多少笔交易。 下面合约的第二个错误在于，一旦某一个账户转账不成功，就会导致所以交易回滚，全部失败。 123456789address[] private refundAddresses;mapping (address &#x3D;&gt; uint) public refunds;function refundAll() public &#123; for(uint x; x &lt; refundAddresses.length; x++) &#123; require(refundAddresses[x].send(refunds[refundAddresses[x]])) &#125;&#125; 参考资料 https://consensys.github.io","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[50]-assembly内联汇编","slug":"solidity-50-assembly","date":"2018-11-24T04:23:28.000Z","updated":"2018-11-27T15:31:39.724Z","comments":true,"path":"2018/11/24/solidity-50-assembly/","link":"","permalink":"https://dreamerjonson.com/2018/11/24/solidity-50-assembly/","excerpt":"","text":"内联汇编 对于普通的solidity智能合约来说，通过solc编译器的优化操作，将源代码转换为以太坊能够识别的二进制文件。但是solc编译器不是万能的，在某些情况下，例如循环操作的时候，并不能达到最佳的执行方式。通过在solidity智能合约中内嵌汇编代码，可以阻止编译器的优化，在某些时候能够到达节约gas的作用。同时，内嵌汇编代码可以增加solidity语言的功能。例如在判断账户地址为合约地址还是外部地址的时候，只能够通过汇编代码来实现。 内联汇编语法 123assembly&#123; 内联汇编语句&#125; 将for循环转换变为内联汇编 let指令定义变量。 add函数是内联汇编中内置的加法操作，solidity内联汇编中有很多内置的函数。jumpi为跳转函数，跳转到loop语句执行。 It函数为小于函数，lt(i,9)判断i是否小于9 12345678910111213141516171819function nativeLoop() public returns(uint _r)&#123; for(uint i &#x3D; 0;i&lt;10;i++)&#123; _r +&#x3D; i; &#125; &#125; function asmloop() public returns(uint _r)&#123; assembly&#123; let i :&#x3D;0 loop: i:&#x3D;add(i,1) _r :&#x3D; add(_r,i) jumpi(loop,lt(i,9)) &#125; &#125; 条件语句转换为内联汇编 1234567891011121314151617181920212223242526272829function nativeConditional(uint _v) returns(uint _r)&#123; if(5&#x3D;&#x3D;_v)&#123; _r &#x3D; 55; &#125; else if(6 &#x3D;&#x3D;_v)&#123; _r &#x3D; 66; &#125; _r &#x3D; 11;&#125;function asmConditional(uint _v) public returns(uint _r)&#123; assembly&#123; switch _v case 5&#123; _r:&#x3D;55 &#125; case 6&#123; _r:&#x3D;66 &#125; default&#123; _r:&#x3D;11 &#125; &#125;&#125; 内联汇编解析1 下面的合约中，msize()代表的是当前已经使用的memory空间的最大位置。加1之后，代表的是可用的指针所在的位置。 mstore代表将值_v赋值给_ptr。 return (ptr,0x20)代表的是从位置_ptr开始，往下读取0x20也就是32个字节 1234567function asmReturens(uint _v) public returns(uint)&#123; assembly&#123; let _ptr :=add(msize(),1) mstore(_ptr,_v) return (_ptr,0x20) &#125; &#125; 内联汇编解析2 mload（40）代表获取0x40位置往下32个字节存储的数据。0x40位置非常特殊，其存储的是最小的可用的memory内存的地址。 例如为0x80. mstore(add(freemem_pointer,0x00),“36e5236fcd4c610449678014f0d085”) 存储字符串到&quot;36e5236fcd4c610449678014f0d085&quot; 到0x80往下32个字节的空间中。 mstore(add(freemem_pointer,0x20),“36e5236fcd4c610449678014f0d086”) 首先将0x80加上32个字节，变为了0xa0。之后便加上32个字节，存储字符串&quot;36e5236fcd4c610449678014f0d086&quot; 到0xa0往下32个字节的空间中。 let arr1:=mload(freemem_pointer)定义了变量arr1. 获取freemem_pointer往下32个字节。由于freemem_pointer当前仍然为0x80，因此arr1的值为字符串&quot;36e5236fcd4c610449678014f0d085&quot;。 最后的语句mstore(add(freemem_pointer,0x40),arr1)。存储了arr1到0xc0地址往下的32个字节的空间中。 12345678910111213141516pragma solidity ^0.4.23;contract cat&#123; function test()&#123; assembly&#123; let freemem_pointer :=mload(0x40) //0x80 mstore(add(freemem_pointer,0x00),\"36e5236fcd4c610449678014f0d085\") mstore(add(freemem_pointer,0x20),\"36e5236fcd4c610449678014f0d086\") let arr1:=mload(freemem_pointer) mstore(add(freemem_pointer,0x40),arr1) &#125; &#125;&#125; 内联汇编解析3 下面的函数，实现了将地址转换为动态字节数组的操作。 let m := mload(0x40)获取0x40位置往下32个字节存储的数据。0x40位置非常特殊，其存储的是最小的可用的memory内存的地址。例如为0x80. add(m, 20) 将0x80加上了20个字节(0x14)，到达0x94. xor为位运算的异或操作。相等为0，不等为1。0x140000000000000000000000000000000000000000的长度为168位，币地址多了6位。假设地址为0xca35b7d915458ef540ade6068dfe2f44e8fa733c。那么异或之后，变为了0x14ca35b7d915458ef540ade6068dfe2f44e8fa733c，一共有21个字节。填充为32个字节之后变为了0x000000000000000000000014ca35b7d915458ef540ade6068dfe2f44e8fa733c，通过mstore存储到0x94地址之后的32个字节中。 在memory空间中 0x80 0x0000000000000000000000000000000000000000000000000000000000000014 0xa0 0xca35b7d915458ef540ade6068dfe2f44e8fa733c000000000000000000000000 从而14代表长度为20个字节。其后面是地址。将0x80的地址赋值给动态长度字节变量b。由于动态长度字节数组首先32个字节存储长度，后面存储内容。因此将地址转换为了动态长度数组。 1234567891011contract dog&#123; function toBytes(address a) constant returns (bytes b)&#123; assembly &#123; let m := mload(0x40) mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a)) mstore(0x40, add(m, 52)) b := m &#125;&#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[49]-安全-溢出攻击","slug":"solidity-49-overflow","date":"2018-11-24T00:58:48.000Z","updated":"2018-11-26T08:35:31.801Z","comments":true,"path":"2018/11/24/solidity-49-overflow/","link":"","permalink":"https://dreamerjonson.com/2018/11/24/solidity-49-overflow/","excerpt":"","text":"攻击回顾 12345672016年6月，以太坊最大众筹项目The DAO被攻击，黑客获得超过350万个以太币，最终导致以太坊分叉为ETH和ETC。2016年拒绝服务攻击：GovernMental&#39;s 1100 ETH2016年KotET（“纷争时代”）合约遭受攻击。2017年Parity钱包,遭受delecate call注入,销毁了合约。损失513,774.16 Ether2017年ANT Token遭受重入漏洞。2017年Simoleon合约被攻击。黑客通过部署攻击合约获得了超过700万的token，从57万账户中脱颖而出，一举成为该合约token的第四大持有者。2018年BEC代币遭到袭击，攻击手法被披露的24小时内，就有30多个合约遭受攻击 溢出 孔子曾经说过 过犹不及。做事情都有限度，一旦超过了限度就会适得其反。理解溢出问题最好的是在千禧之年爆发的千年虫事件。过去，由于计算机程序中使用两个数字来表示年份，如1998年被表示为“98”、1999年被表示为“99”；而2000年被表示为“00”，这样将会导致某些程序在计算时得到不正确的结果，如把“00”误解为1900年。在嵌入式系统中可能存在同样的问题，这有可能导致设备停止运转或者发生更加灾难性的后果。 solidity中的溢出问题 下面是一个简单的函数，其功能是将桉树加1.例如传递4，返回5。传递200，返回201。但是里面暗藏着陷阱。例如当传递255的时候，会返回0…这就是溢出。这是由于uint8的最大值为255，在内存中：为1111 1111。一旦加1之后，变为了 1 0000 0000,但是最大的位数为8位。截断之后，变为了0000 0000 因此返回的结果为0。 123function add(uint8 a) public pure returns(uint8)&#123; return a+1;&#125; safeMath避免溢出问题 因此我们可以看到，对于4则运算，很容易的发生溢出问题。OpenZeppelin 建立了一个叫做 SafeMath 的 库。这就规避掉溢出问题。 123456789101112131415161718library SafeMath &#123; function add(uint a, uint b) internal pure returns (uint c) &#123; c &#x3D; a + b; require(c &gt;&#x3D; a); &#125; function sub(uint a, uint b) internal pure returns (uint c) &#123; require(b &lt;&#x3D; a); c &#x3D; a - b; &#125; function mul(uint a, uint b) internal pure returns (uint c) &#123; c &#x3D; a * b; require(a &#x3D;&#x3D; 0 || c &#x2F; a &#x3D;&#x3D; b); &#125; function div(uint a, uint b) internal pure returns (uint c) &#123; require(b &gt; 0); c &#x3D; a &#x2F; b; &#125;&#125; BEC代币攻击全纪实 如下为BEC代币的源代码抽离出来的部分。2018年4月份BEC代币遭到黑客的溢出袭击。黑客为自己的两个账号转移了2^255次方的代币。导致市场的恐慌，币价一度一文不值。攻击手法被披露的24小时内，就有类似30多个合约遭受攻击 在TokenExample合约中，有一个batchTransfer函数。此函数的功能为对账户进行转账操作。第一个参数为动态长度地址，明确要转账的账户。第二个参数为转账的金额。 要转账成功，必须要保证在balance资金表中，发送者必须有超过总金额(账户数量转账金额)。但是 uint256 amount = uint256(cnt) value;这段代码并没有做安全的乘法，导致可能会发生溢出攻击。当黑客调用合约的时候，在remix中： 输入地址数组以及：[“0xb4D30Cac5124b46C2Df0CF3e3e1Be05f42119033”,“0x0e823fFE018727585EaF5Bc769Fa80472F76C3d7”]， 以及 value&quot;0x8000000000000000000000000000000000000000000000000000000000000000&quot;即2*255， 使得amount=2^255 * 2,超出uint256类型的范围[0,2**256-1]，溢出为0，发送者账户余额不减少，并且，本例中，发送者的代币可以为零，实现&quot;无中生有&quot;。 123456789101112131415161718192021222324252627282930313233343536373839library SafeMath&#123; function sub(uint256 a,uint256 b) internal pure returns(uint256)&#123; assert(b&lt;=a); return a-b; &#125; function add(uint256 a,uint256 b) internal pure returns(uint256 c)&#123; c=a+b; assert(c&gt;=a); return c; &#125;&#125;contract TokenExample&#123; //使用safemath库 using SafeMath for uint256; //资金表 mapping(address=&gt;uint256) public balance; function batchTransfer(address[] _receivers,uint256 _value) public returns(bool)&#123; //要转移的地址的数量 uint cnt = _receivers.length; //转账总金额 uint256 amount = uint256(cnt)*_value; //判断转账地址必须大于0 require(cnt &gt;0 &amp;&amp; cnt &lt;=20); //判断发送者拥有的金额必须大于转账的总金额 require(_value &gt;0 &amp;&amp; balance[msg.sender]&gt;=amount); //发送者账户金额减少 20 balance[msg.sender] = balance[msg.sender].sub(amount); //接受者金额增加 10 for(uint i =0 ;i&lt;cnt;i++)&#123; balance[_receivers[i]] = balance[_receivers[i]].add(_value); &#125; return true; &#125;&#125; 减法溢出案例 调用distribute函数，传入地址数组： [“0x14723a09acff6d2a60dcdf7aa4aff308fddc160c”,“0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db”] owner分别向这两个地址发送2000 * 108代币，超过owner余额，balances[owner]产生减法溢出；查询owner账户余额，等于2256-2000*10**8 12345678910111213141516171819202122232425contract TokenExample&#123; address public owner; mapping(address =&gt;uint256) public balances; mapping(address =&gt;mapping(address=&gt;uint256)) public allowed; event Transfer(address _from,address _to,uint256 _value); modifier onlyOwner&#123; require(msg.sender==owner); _; &#125; constructor() public &#123; owner = msg.sender; balances[owner] = 2000*10**8; &#125; function distribute(address[] addresses) public onlyOwner&#123; for(uint i =0;i&lt;addresses.length;i++)&#123; balances[owner] -=2000*10**8; balances[addresses[i]] +=2000*10**8; emit Transfer(owner,addresses[i],2000*10**8); &#125; &#125;&#125; 加法溢出 1、部署合约； 2、向target预先转一部分代币，模拟目标账户中已有的代币：调用transfer函数，传入target地址： 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c， 以及转账额度，比如： 2000000000000000000（2 * 10**uint256(decimals)）; 3、如果owner想控制target的余额减半，那么，他只需要向target增发 2*256-balanceOf[target]+10*18=0xfffffffffffffffffffffffffffffffffffffffffffffffff21f494c589c0000， 现在调用mintToken函数，向target地址转入上述数量的代币： 4、查询target余额 1234567891011121314151617181920212223242526272829303132333435contract TokenExample&#123; address public owner; mapping(address=&gt;uint256) public balanceOf; uint256 public totalSupply; uint8 public decimals = 18; event Transfer(address _from,address _to,uint256 _value); modifier onlyOwner&#123; require(msg.sender==owner); _; &#125; constructor() public&#123; owner = msg.sender; totalSupply = 2000 * 10**uint256(decimals); balanceOf[owner] = totalSupply; &#125; function transfer(address _to,uint256 _value) public returns(bool success)&#123; require(balanceOf[msg.sender] &gt;=_value); require(balanceOf[_to] +_value &gt;=balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] +=_value; emit Transfer(msg.sender,_to,_value); return true; &#125; function mintToken(address target,uint256 mintedAmount) public onlyOwner&#123; balanceOf[target] +=mintedAmount; totalSupply +=mintedAmount; emit Transfer(0,this,mintedAmount); emit Transfer(this,target,mintedAmount); &#125;&#125; 溢出列表 溢出运算列表： 12345678910111213141516171819exception on overflow in unsigned-&gt;signed conversion exception on overflow in signed-&gt;unsigned conversion exception on overflow in size-decreasing implicit conversion exception on overflow in addition of two signed numbers exception on overflow in addition of two unsigned numbers exception on underflow in subtraction of two signed numbers exception on underflow in subtraction of two unsigned numbers exception on overflow in multiplication of two signed numbers exception on overflow in multiplication of two unsigned numbers exception on overflow in shifts exception on overflow in ++ on a signed number exception on overflow in ++ on an unsigned number exception on underflow in -- on a signed number exception on underflow in -- on an unsigned number exception on overflow in +&#x3D; exception on overflow in -&#x3D; exception on overflow in *&#x3D; exception on overflow in &#x2F;&#x3D; make sure no optimizations are relying on (a + b - b &#x3D;&#x3D; a); lest they remove overflow exceptions","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[48]-call函数","slug":"solidity-48-call","date":"2018-11-23T14:55:33.000Z","updated":"2018-11-27T15:31:32.805Z","comments":true,"path":"2018/11/23/solidity-48-call/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-48-call/","excerpt":"","text":"调用外部合约的代码 在之前我们已经看到过，使用interface、library的方式调用外部合约的代码。 接下来，我们将为大家补充第三种形式： 在下面的代码中，部署cat合约之后，例如地址为 0x345678.. 在部署animal合约时，传递此cat合约地址。从而能够存储合约的引用。调用test方法即可调用到外部合约的方法。 1234567891011121314151617181920212223pragma solidity ^0.4.23;contract cat&#123; uint public a&#x3D;5; function eat() public returns(uint)&#123; a &#x3D; 256; return a; &#125;&#125;contract animal&#123; cat c; constructor(address _addr)&#123; c &#x3D; cat(_addr); &#125; function test() public returns(uint)&#123; return c.eat(); &#125;&#125; call函数 不管是interface、library还是上面看到的形式，要调用外部代码，都是底层调用了call或者是delecall函数。 call函数基本使用方法 call函数的使用方法，首先需要外部合约的地址。如下例中的animalCall合约，在部署合约时，传递了外部合约cat的地址 0x345678.. ，存储在address c当中。 通过合约地址.call(函数标志符)的方式来调用合约。函数标志符是对于函数声明哈希之后的前4个字节的数据。 如下例中，c.call(bytes4(keccak256(“eat()”)))将调用cat合约中的eat方法 123456789101112131415161718192021contract cat&#123; uint public a&#x3D;5; function eat() public returns(uint)&#123; a &#x3D; 256; return a; &#125;&#125;contract animalCall&#123; address c; constructor(address _addr)&#123; c &#x3D; _addr; &#125; function test1() public returns(bool)&#123; return c.call(bytes4(keccak256(&quot;eat()&quot;))); &#125; function test2() public returns(bool)&#123; return c.call(bytes4(keccak256(&quot;eat&quot;))); &#125;&#125; call函数返回值 call函数的返回值为true或者false。只有当能够找到此方法并执行成功后，会返回true，而如果不能够找到此函数或执行失则会返回false。因此调用test1方法会返回true，调用test2方法会返回false，因为找不到函数。 call 函数与回调函数 call函数如果找不到函数，默认会调用回调函数。 回调函数是特殊的函数，其没有函数名。 其形式为： 123function()&#123;&#125; 对于如下的cat合约。书写了回调函数。假设合约地址为c.那么在外部调用c.call(“abc”);会找不到此函数，默认会执行回调函数.因此在外部调用的c.call(“abc”) 会使得cat合约的状态变量变为999。而且call函数会返回true。 1234567891011121314contract cat&#123; uint public a=5; function eat() public returns(uint)&#123; a = 256; return a; &#125; function ()&#123; a=999; &#125;&#125; call函数与msg.data 回调函数是非常有用的，例如我们可以在外部调用失败的时候，执行某一些操作。 对于如下的cat合约。书写了回调函数。假设合约地址为c.那么在外部调用c.call(“abc”);会找不到此函数，默认会执行回调函数.回调函数中，将msg.data的值赋值给了fail变量。通过getfail函数可查看call函数传递过来的完整数据。fail变量的值为32个字节0x6162630000000000000000000000000000000000000000000000000000000000，前3个字节是参数字母a、b、c的ASCII码。61、62、63. 1234567891011121314pragma solidity ^0.4.23;contract cat&#123; bytes fail; function ()&#123; fail = msg.data; &#125; function getfail() returns(bytes)&#123; return fail; &#125;&#125; call函数修改外部合约的状态变量 在下例中，cat合约与animalcall合约中都有状态变量我们首先部署cat合约，得到地址0x3456..， 接下来，将合约地址作为参数部署anumalCall合约。 调用test2方法，其调用了cat合约的eat方法，修改了cat合约中a的值为256. call函数调用外部合约，修改外部合约中的状态变量。 123456789101112131415161718192021pragma solidity ^0.4.23;contract cat&#123; uint public a&#x3D;5; function eat() public returns(uint)&#123; a &#x3D; 256; return a; &#125;&#125;contract animalCall&#123; uint public a&#x3D;4; address c; constructor(address _addr)&#123; c &#x3D; _addr; &#125; function test2() public returns(bool)&#123; return c.call(bytes4(keccak256(&quot;eat()&quot;))); &#125;&#125; delegatecall delegatecall函数的使用方法和call函数一样，通过合约地址.delegatecall(函数标志符)的方式来调用合约。函数标志符是对于函数声明哈希之后的前4个字节的数据。 library库的远程调用正是使用了delegatecall函数。delegatecall与call不同之处在于，delegatecall不会修改外部合约中的状态变量，其好像是将外部函数的代码加载到了本地合约中执行。会修改本地合约状态变量的值。 例如下面的代码，首先部署cat合约，得到地址0x3456..， 接下来，将合约地址作为参数部署anumalCall合约。 调用test2方法，其调用了cat合约的eat方法，但是却是修改了animalcall合约中的状态变量a。因此当查询后发现，cat合约中的a并没有变化，animalCall合约变量a变为了了256。 123456789101112131415161718192021pragma solidity ^0.4.23;contract cat&#123; uint public a&#x3D;5; function eat() public returns(uint)&#123; a &#x3D; 256; return a; &#125;&#125;contract animalCall&#123; uint public a&#x3D;4; address c; constructor(address _addr)&#123; c &#x3D; _addr; &#125; function test2() public returns(bool)&#123; return c.delegatecall(bytes4(keccak256(&quot;eat()&quot;))); &#125;&#125; call函数转账与回调函数细节 call函数可以进行转账，并且是transfer与send的底层函数。call函数转账的使用方法是 地址.call.value(转账金额)() 要注意的是，执行转账的时候，如果转账的地址为合约，并且转账合约中有回调函数。那么将默认会执行回调函数。 但是以太坊为了避免重入攻击，对于transfer与send函数进行了限制。当使用transfer与send函数，回调函数中执行的操作最多不能够超过2300gas。这也就意味着不能够执行转账、赋值等操作，而只能够执行事件触发等操作。 例如下面的代码： 首先部署Receiver合约，得到地址0x3456..，再传递Receiver的地址部署Sender合约。当调用sendMoney方法的时候，为合约地址0x3456..转账的操作会触发回调函数，将状态变量balance的数量增加。但是由于修改状态变量的操作超过了最大2300gas的限制，所以下面的操作不会成功。 1234567891011121314151617pragma solidity ^0.4.23;contract Sender &#123; function sendMoney(address _receiver) payable &#123; _receiver.send(msg.value); &#125;&#125;contract Receiver &#123; uint public balance &#x3D; 0; function () payable &#123; balance +&#x3D; msg.value; &#125;&#125; call函数能够让上面的操作成功。call函数能够指定gas的限制，超过2300gas限制的约束。 如下例所示： 首先部署Receiver合约，得到地址0x3456..，再传递Receiver的地址部署Sender合约。当调用sendMoney方法转移100wei的时候，为合约地址0x3456..转账的操作会触发回调函数，将状态变量balance的数量增加。由于call函数指定的最大gas限制为20317，所以触发回调函数可以将balance的金额修改为100.但是要注意，正因为此，call函数是危险的底层函数，不能够避免重入攻击的问题。 123456789101112131415pragma solidity ^0.4.23;contract Sender &#123; function send(address _receiver) payable &#123; _receiver.call.value(msg.value).gas(20317)(); &#125;&#125;contract Receiver &#123; uint public balance &#x3D; 0; function () payable &#123; balance +&#x3D; msg.value; &#125;&#125; 回调函数细节 由于回调函数在转账或者call找不到函数的时候都会触发。因此，需要通过require(msg.data.length == 0)来明确当前的 必须为转账而不是call在调用函数。 12345&#x2F;&#x2F; 坏的方式function() payable &#123; LogDepositReceived(msg.sender); &#125;&#x2F;&#x2F; 好的方式function() payable &#123; require(msg.data.length &#x3D;&#x3D; 0); LogDepositReceived(msg.sender); &#125; delegatecall陷阱与建议 如下例中，如果Worker合约远程调用Destructor合约的dowork方法，其实会销毁Worker合约。导致合约中的所有以太币被销毁。 12345678910111213141516contract Destructor&#123; function doWork() external &#123; selfdestruct(0); &#125;&#125;contract Worker&#123; function doWork(address _internalWorker) public &#123; &#x2F;&#x2F; unsafe _internalWorker.delegatecall(bytes4(keccak256(&quot;doWork()&quot;))); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[47]-interface","slug":"solidity-47-interface","date":"2018-11-23T14:32:59.000Z","updated":"2018-11-27T15:31:28.802Z","comments":true,"path":"2018/11/23/solidity-47-interface/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-47-interface/","excerpt":"","text":"接口 接口本意是物体之间连接的部位。例如电脑的usb接口可以用来连接鼠标也可以连接U盘和硬盘。因此，使用标准的接口可以极大的拓展程序的功能。在solidity语言中，接口可以用来接受相同规则的合约，实现可更新的智能合约。 接口定义 接口需要有interface关键字，并且内部只需要有函数的声明，不用实现。 只要某合约中有和词接口相同的函数声明，就可以被此合约所接受。 123interface 接口名&#123; 函数声明;&#125; 例子： 123interface animalEat&#123; function eat() public returns(string);&#125; 接口使用 在下面的例子中，定义了cat合约以及dog合约。他们都有eat方法.以此他们都可以被上面的animalEat接口所接收。 12345678910111213141516171819202122232425262728293031323334353637383940contract cat&#123; string name; function eat() public returns(string)&#123; return \"cat eat fish\"; &#125; function sleep() public returns(string)&#123; return \"sleep\"; &#125;&#125;contract dog&#123; string name; function eat() public returns(string)&#123; return \"dog miss you\"; &#125; function swim() public returns(string)&#123; return \"sleep\"; &#125;&#125;interface animalEat&#123; function eat() public returns(string);&#125;contract animal&#123; function test(address _addr) returns(string)&#123; animalEat generalEat = animalEat(_addr); return generalEat.eat(); &#125;&#125; 在合约animal中，调用函数test，如果传递的是部署的cat的合约地址，那么我们在调用接口的eat方法时，实则调用了cat合约的eat方法。 同理，如果传递的是部署的dog的合约地址，那么我们在调用接口的eat方法时，实则调用了dog合约的eat方法。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity[46]-随机数与事件","slug":"solidity-46-random","date":"2018-11-23T13:43:53.000Z","updated":"2018-11-23T14:38:14.830Z","comments":true,"path":"2018/11/23/solidity-46-random/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-46-random/","excerpt":"","text":"随机数 solidity语言中提供了内置的哈希函数keccak256来产生随机数。 由于哈希函数的特点，产生的哈希值随着传递参数值与数量的不同而不同。 keccak256函数特性 1、可以传递多了参数,多种类型的值例如：keccak256(1,2,“jonson”,0x32); 2、keccak256的返回值是bytes32类型，意味着其返回值是一个256位的随机数。 3、一般，我们使用全局属性，例如时间now,msg.sender,block.number等全局属性来构造随机数。 随机数案例 构造一个游戏，有70%的概率赢下游戏。 如下函数，通过时间来构造随机数。首先将bytes32类型强制的转换为uint256类型。 取模操作，uint256(keccak256(now,msg.sender)) % 100在0-100之间均匀分布，因此小于70的概率位70%。 从而有70%的可能性会返回正确结果。 12345function test() returns(bool)&#123; if(uint256(keccak256(now,msg.sender)) % 100 &lt; 70)&#123; return true; &#125; &#125; 事件 事件 是dapp程序和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。 例子: 12345678910111213// 这里建立事件event IntegersAdded(uint x, uint y, uint result);function add(uint _x, uint _y) public &#123; uint result = _x + _y; //触发事件，通知app IntegersAdded(_x, _y, result); return result;&#125;你的 app 前端可以监听这个事件。JavaScript 实现如下:YourContract.IntegersAdded(function(error, result) &#123; // 干些事&#125; 事件例子 如上面的游戏合约中，赢下游戏就会触发事件 12345678910pragma solidity ^0.4.23;contract random&#123; event eve(string); function test() returns(bool)&#123; if(uint256(keccak256(now,msg.sender)) % 100 &lt; 70)&#123; emit eve(\"win\"); return true; &#125; &#125;&#125; 事件本质 触发后的事件记录会存储在区块链上。 当触发事件后，在remix控制台之上会出现事件的记录。 from：代表合约地址 topic：代表的是事件的唯一标示，其本质也是hash函数，如在此例子中，为keccak256（eve(string)）的结果。 event：代表事件的名字 args：参数以及长度 1234567891011[ &#123; &quot;from&quot;: &quot;0x692a70d2e424a56d2c6c27aa97d1a86395877b3a&quot;, &quot;topic&quot;: &quot;0xb753f213c434015869c7cc20def5e88c589e415518548d45d73ebbc2e4ea2ba2&quot;, &quot;event&quot;: &quot;eve&quot;, &quot;args&quot;: &#123; &quot;0&quot;: &quot;win&quot;, &quot;length&quot;: 1 &#125; &#125;] 完整代码 12345678910111213141516171819202122pragma solidity ^0.4.23;contract random&#123; event eve(string); function test() returns(bool)&#123; if(uint256(keccak256(now,msg.sender)) % 100 &lt; 70)&#123; emit eve(&quot;win&quot;); return true; &#125; &#125; function test2() returns(bytes32)&#123; emit eve(&quot;win&quot;); return keccak256(&quot;eve(string)&quot;); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[45]-library库","slug":"solidity-45-library","date":"2018-11-23T10:04:31.000Z","updated":"2018-11-23T14:39:42.569Z","comments":true,"path":"2018/11/23/solidity-45-library/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-45-library/","excerpt":"","text":"library引入 常常，我们会进行加减乘除的操作，如下的函数就是对两个函数参数进行了四则运算。 123456function operate(uint a, uint b) pure returns(uint,uint,uint,uint)&#123; uint add = a+b; uint sub = a-b; uint mul = a*b; uint div = a/b;&#125; library库 上面的函数其实是有问题的，因为它不能够避免出错，例如如果为b传递为0，就会报错。并且没有防止溢出攻击的问题。有很多时候，对于一些基础性的操作，我们可以把他们封装起来，这就是library库的作用。 library的定义 如下例所示，就是上面4则运算使用的library库，对于溢出等进行了问题规避。 library库中，不能包含状态变量、 12345678910111213141516171819202122232425262728library SafeMath&#123; function mul(uint a,uint b) pure returns(uint)&#123; uint c &#x3D; a*b; assert(c&#x2F;a&#x3D;&#x3D;b); return c; &#125; function div(uint a,uint b) pure returns(uint)&#123; uint c &#x3D; a&#x2F;b; assert(a&#x3D;&#x3D; b*c +a%b); return c; &#125; function sub(uint a,uint b) pure returns(uint)&#123; assert(a&gt;&#x3D;b); return a-b; &#125; function add(uint a,uint b) pure returns(uint)&#123; uint c &#x3D; a+b; assert(c&gt;&#x3D;a); return c; &#125;&#125; library库的使用 直接使用库函数中的函数。 12345678function operate(uint a,uint b) pure returns(uint,uint,uint,uint)&#123; uint jia = SafeMath.add(a,b); uint jian = SafeMath.sub(a,b); uint cheng =SafeMath.mul(a,b); uint chu = SafeMath.div(a,b); return(jia,jian,cheng,chu); &#125; 方式2:使用 using SafeMath for uint之后，可以调用库函数。例如a.add(b) 意味着 执行了safemath库中的 add(a,b) 12345678 using SafeMath for uint;function operate2(uint a,uint b) pure returns(uint,uint,uint,uint)&#123; uint jia = a.add(b); uint jian = a.sub(b); uint cheng =a.mul(b); uint chu = a.div(b); return(jia,jian,cheng,chu); &#125; library库深入机制 使用library，底层是使用了delegatecall来远程的调用另外一个合约的代码。只有在某些极少数的情况下，并不是使用了远程调用，而是编译器直接将library库的代码嵌套进了合约中。 例如：下面的例子中，library库中的代码全是pure类型，并且使用了SafeMath.add的方式来调用合约，因此，在编译的时候，会直接将library库的add方法加载到合约中。 123456789101112131415161718pragma solidity 0.4.23;library SafeMath&#123; function add(uint a,uint b) pure returns(uint)&#123; uint c &#x3D; a+b; assert(c&gt;&#x3D;a); return c; &#125;&#125;contract math&#123; function operate(uint a,uint b) returns(uint)&#123; uint jia &#x3D; SafeMath.add(a,b); return(jia); &#125;&#125; 当library库中，有this关键字，函数参数中有storage属性，或者使用了using SafeMath for uint来调用library库的时候，会使用到远程的library库。 下面的例子，编译器都会需要外部的一个library库的地址，从而能够远程调用到library合约。 123456789101112131415161718pragma solidity 0.4.23;library SafeMath&#123; function add(uint a,uint b) pure returns(uint)&#123; uint c &#x3D; a+b; assert(c&gt;&#x3D;a); return c; &#125;&#125;contract math&#123; using SafeMath for uint; function operate(uint a,uint b) returns(uint)&#123; uint jia &#x3D; a.add(b); return(jia); &#125;&#125; 编译math合约的时候，其二进制代码如下： 1&quot;608060405234801561001057600080fd5b5061017c806100206000396000f300608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063db17ebcd14610046575b600080fd5b34801561005257600080fd5b5061007b6004803603810190808035906020019092919080359060200190929190505050610091565b6040518082815260200191505060405180910390f35b6000808373__browser&#x2F;test6.sol:SafeMath____________63771602f79091856040518363ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401808381526020018281526020019250505060206040518083038186803b15801561010957600080fd5b505af415801561011d573d6000803e3d6000fd5b505050506040513d602081101561013357600080fd5b8101908080519060200190929190505050905080915050929150505600a165627a7a7230582006c538588770740653d6eba03016e0ef64c5da4f370291bdb71ea916cfbf166a0029&quot; 注意到，在此二进制代码中，有一段预留的标识符，其是__browser/test6.sol:SafeMath____________.这一段预留的标识符就是远程library库的地址。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657pragma solidity 0.4.23;library SafeMath&#123; function mul(uint a,uint b) pure returns(uint)&#123; uint c = a*b; assert(c/a==b); return c; &#125; function div(uint a,uint b) pure returns(uint)&#123; uint c = a/b; assert(a== b*c +a%b); return c; &#125; function sub(uint a,uint b) pure returns(uint)&#123; assert(a&gt;=b); return a-b; &#125; function add(uint a,uint b) pure returns(uint)&#123; uint c = a+b; assert(c&gt;=a); return c; &#125;&#125;contract math&#123; using SafeMath for uint; function operate(uint a,uint b) returns(uint,uint,uint,uint)&#123; uint jia = SafeMath.add(a,b); uint jian = SafeMath.sub(a,b); uint cheng =SafeMath.mul(a,b); uint chu = SafeMath.div(a,b); return(jia,jian,cheng,chu); &#125; function operate2(uint a,uint b) returns(uint,uint,uint,uint)&#123; uint jia = a.add(b); uint jian = a.sub(b); uint cheng =a.mul(b); uint chu = a.div(b); return(jia,jian,cheng,chu); &#125;&#125; 复杂library例子 下例中，CounterContract合约 使用了CounterLib库中的结构体构建了自己的结构体变量counter。并调用了CounterLib库中的方法，实现了counter中i加一的操作。 12345678910111213141516171819pragma solidity ^0.4.23;library CounterLib &#123; struct Counter &#123; uint i; &#125; function incremented(Counter storage self) returns (uint) &#123; return ++self.i; &#125;&#125;contract CounterContract &#123; using CounterLib for CounterLib.Counter; CounterLib.Counter counter;// struct Counter &#123; uint i; &#125; function increment() returns (uint) &#123; return counter.incremented(); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[44]-以太坊测试网络与metamask","slug":"solidity-44-test-network","date":"2018-11-23T09:06:35.000Z","updated":"2018-12-03T10:09:21.010Z","comments":true,"path":"2018/11/23/solidity-44-test-network/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-44-test-network/","excerpt":"","text":"测试网络 在之前的案例中，大部分都是在remix在线的本地虚拟环境下做的测试。这一小节将在以太坊测试网络中交互合约。 除了主网、以太坊有多个测试网络，用于对于智能合约进行测试。那么之间的主要区别在于共识算法以及确认时间。 网络 网络id 共识算法 确认时间 Main 1 POW 15秒左右 Ropsten 3 POW 不到30秒 Ropsten 4 POA 仅geth支持 15秒 kovan 42 POA 仅parity支持 4秒 remix部署智能合约到测试网络的流程 1、书写智能合约 2、solc编译器编译合约为二进制文件与ABI接口文件 3、借助于web3j库将二进制文件部署到智能合约。 4、借助于web3j库于ABI接口于网络进行交互 metamask 在浏览器中，我们需要借助于metamask与以太坊网络进行交互。metamask是一个谷歌浏览器的插件，其可以管理账户，并在浏览器与以太坊网络之间起到架接的作用。 其存储私钥但是只是将数据签名后的信息传播，所以并不会将私钥传播到互联网上。其本质是在浏览器中注入了web3的库，利用web3j实现与以太坊网络的交互 测试网络之间的关系 相同的外部地址和合约地址可以同时存在于不同的测试网络中，但是可能有不同的以太币，不同的部署代码。这是由于测试网络之间本身互不影响。 助记词（Mneminic） 在安装metamask的时候，会有12个助记词。助记词的作用是为了方便进行账户的管理。想象一下当你有多个账户，不同的账户可能处理不同的业务。例如消费、存储、商业活动。我们如果每一个账户都需要把私钥存储起来，那就太费劲了。因此我们使用了12个助记词来帮助我们管理账户。12个助剂词，根据以太坊bip39算法，可以对应着10多个账户的私钥。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[43]-众筹案例","slug":"solidity-43-campaign","date":"2018-11-23T08:49:59.000Z","updated":"2018-11-23T13:00:00.454Z","comments":true,"path":"2018/11/23/solidity-43-campaign/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-43-campaign/","excerpt":"","text":"综合案例：众筹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354pragma solidity ^0.4.23;contract campaign&#123; //捐赠者的对象 struct funder&#123; address funderaddress; //捐赠者的地址 uint Tomoney; //捐赠者捐赠的金钱 &#125; //受益人的对象 struct needer&#123; address Neederaddress; //受益人的地址 uint goal;//受益人的目标值 uint amount; //当前的已经募集到了多少钱 uint funderAcoount; //捐赠者的id mapping(uint =&gt; funder) map; //映射，将捐赠者的id与捐赠者绑定在一起，从而能够得知，是谁给当前的受益人捐钱了。 &#125; uint neederAmount; //受益人的id数 mapping(uint=&gt; needer) needmap; //通过mapping将受益人的id与受益人绑定在额一起，从而能够能耗的管理受益人 //实现一个众筹的事件 function NewNeeder(address _Neederaddress, uint _goal )&#123; //将受益人id与受益人绑定 neederAmount++; needmap[neederAmount] = needer(_Neederaddress,_goal,0,0); &#125; //@param _address 捐赠者的地址 ， //@param _neederAmount 受益人的id function contribute( address _address, uint _neederAmount) payable&#123; //通过id获取到受益人对象 needer storage _needer = needmap[_neederAmount]; //聚集到的资金增加 _needer.amount += msg.value; // 捐赠人数增加 _needer.funderAcoount++; //将受益人id与受益人绑定 _needer.map[ _needer.funderAcoount] = funder(_address , msg.value ); &#125; //当募集到的资金满足条件，就会给给受益人的地址转账 //@param _neederAmount 受益人的id function ISconpelete( uint _neederAmount)&#123; needer storage _needer = needmap[_neederAmount]; if(_needer.amount &gt;=_needer.goal )&#123; _needer.Neederaddress.transfer(_needer.amount); &#125; &#125; function test() view returns(uint,uint,uint)&#123; return (needmap[1].goal, needmap[1].amount,needmap[1].funderAcoount); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[42]-memory与storage相互转换","slug":"solidity-42-memory-storage","date":"2018-11-23T08:22:55.000Z","updated":"2018-11-23T12:59:43.753Z","comments":true,"path":"2018/11/23/solidity-42-memory-storage/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-42-memory-storage/","excerpt":"","text":"memory 赋值 状态变量 下面的例子说明了memory赋值给storage的情况。在test函数中，memory空间的变量s复制给了状态变量stu。为值的拷贝问题。并且由于这两个空间互不影响。因此修改变量的值不会影响到另一个变量的值。 当调用call函数时，返回100，&quot;jonson&quot;。s的修改不会影响变量stu。 123456789101112131415161718192021222324pragma solidity ^0.4.23;contract MemoryTostorage&#123; struct student&#123; uint grade; string name; &#125; student stu; function test(student memory s) internal&#123; stu = s; s.name = \"alice\"; &#125; function call() returns(uint,string)&#123; student memory guy = student(100,\"jackson\"); test(guy); return (stu.grade,stu.name); &#125;&#125; storage 赋值 memory 如下例，说明了storage复制给结构体 memory变量的情况。在test函数中，其实质是将s引用的状态变量的值赋值给了guy。 变量guy不是存储的引用，而是一个结构体空间。当调用call函数时，返回100，&quot;jonson&quot;。对于guy的修改不会影响到stu的修改。 123456789101112131415161718192021contract storageToMemory&#123; struct student&#123; uint grade; string name; &#125; student stu = student(100,\"jackson\");function test(student storage s) internal&#123; student memory guy = s; guy.grade = 50;&#125;function call() public returns(uint,string)&#123; test(stu); return (stu.grade,stu.name);&#125; memory 转 memory memory与memory之间的相互转换是值传递。 在下面的例子中，当调用call函数时，在memory中开辟了结构体的三个实例空间a、b、c。赋值为值的拷贝。他们之间互不影响。 修改一个变量不会影响其他变量的值。 1234567891011121314151617181920pragma solidity ^0.4.23;contract memoryTomemory&#123; struct student&#123; uint grade; string name; &#125; function test(student memory b) internal&#123; student memory c = b; c.name = \"jonson\"; &#125; function call() returns(string)&#123; student memory a = student(100,\"olaya\"); test(a); return a.name; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[41]-structdeep","slug":"solidity-41-structdeep","date":"2018-11-23T02:56:59.000Z","updated":"2018-11-23T12:59:38.809Z","comments":true,"path":"2018/11/23/solidity-41-structdeep/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-41-structdeep/","excerpt":"","text":"结构体中的mapping ###定义时，不用初始化mapping 1、结构体中的变量，在定义的时候是不能缺省的，但是结构体中的mapping映射除外。 2、在memory中的结构体变量s是不能够操作其中mapping映射。这是由于mapping映射只能够存储在storage空间中 1234567struct student&#123; uint grade; string name; mapping(uint&#x3D;&gt;string) map; &#125;student memory s &#x3D; student(100,&quot;jonson&quot;); &#x2F;&#x2F;初始化不用管mapping&#x2F;&#x2F; s.map[2] &#x3D; &quot;alice&quot;;错误，mapping映射只能够存储在storage空间中 3、要想操作结构体中的mapping映射，那么必须要将结构体定义为状态变量。 如下面的例子中，定义了状态变量 student stu。因此可以操作其mapping映射。 下例中的变量guy在栈中，对于guy的操作视同于对于状态变量stu的操作。 12345678910111213141516171819202122232425262728contract structdeep&#123; struct student&#123; uint grade; string name; mapping(uint=&gt;string) map; &#125; student stu; function init() public view returns(string)&#123; student memory s = student(100,\"jonson\"); //将memory中 结构体s的值赋值给状态变量中的stu。 stu = s; //操作mapping映射 stu.map[2] = \"alice\"; //引用 student storage guy = stu; guy.map[2] = \"bob\"; return stu.map[2]; &#125; 带参数结构体与memory 函数参数为结构体时，由于函数参数是在memory的空间中，因此默认时memory属性。必须要用memroy来接受，不能使用storage类型来接受。 123456789struct student&#123; uint grade; string name;&#125;function structParam(student s) internal&#123; student memory guy &#x3D; s;&#125; 错误写法： 123456789struct student&#123; uint grade; string name;&#125;function structParam(student s) internal&#123; student guy &#x3D; s;&#125; 错误写法2： 12345678struct student&#123; uint grade; string name;&#125;function structParam(student s) internal&#123; student storage guy &#x3D; s;&#125; 函数参数为结构体引用 如果希望使用到storage来接受，那么需要强制为参数加上storage属性。这时，传递的参数必须是状态变量。 12345678910function structParam2(student storage s) internal&#123; student storage guy &#x3D; s; guy.grade &#x3D; 1000;&#125;function call() public returns(uint)&#123; structParam2(stu); return stu.grade;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[40]-memory属性","slug":"solidity-40-memory","date":"2018-11-23T02:40:22.000Z","updated":"2018-11-23T12:59:31.787Z","comments":true,"path":"2018/11/23/solidity-40-memory/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-40-memory/","excerpt":"","text":"memory引入 函数中结构体变量默认是是storage类型 下面是一段错误的代码，错误的原因在于，init函数中，student s 默认会加上storage的属性，但是storage属性必须要引用storage空间中的状态变量。但是实例化的student(100,“jackson”)并不在storage中。 123456789struct student&#123; uint grade; string name; &#125;function init() public pure returns(uint,string)&#123; student s &#x3D; student(100,&quot;jackson&quot;); return (s.grade,s.name); &#125; 因此，正确的做法是，必须要变量的初始化放在memory空间中。加上了memory属性的变量，意味着变量存储在memory的空间中。 123456789struct student&#123; uint grade; string name; &#125;function init() public pure returns(uint,string)&#123; student memory s &#x3D; student(100,&quot;jackson&quot;); return (s.grade,s.name); &#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[39]-结构体","slug":"solidity-39-struct","date":"2018-11-23T02:19:26.000Z","updated":"2018-11-23T12:59:16.963Z","comments":true,"path":"2018/11/23/solidity-39-struct/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-39-struct/","excerpt":"","text":"struct语法 struct类似于对于一个对象属性的封装。例如一个学生，可能会有姓名、学号等属性。将这些属性封装起来，成为一个结构体。 1234struct 对象名&#123; 变量类型1 变量名1; 变量类型2 变量名2;&#125; struct声明 定义一个学生类 1234struct student&#123; uint grade; string name; &#125; 结构体不能包含自身 12345struct student&#123; uint grade; string name; &#x2F;&#x2F;student s;结构体不能包含自身 &#125; 结构体可以嵌套 一个结构体内部可以包含另一个结构体。 12345678910struct student&#123; uint grade; string name; &#125;struct student2&#123; uint grade; string name; student ss; &#x2F;&#x2F;包含另一个结构体&#125; 结构体内部可以包含自身的动态数组 12345struct student3&#123; uint grade; string name; student3[] stu;&#x2F;&#x2F;结构体内部可以包含自身的动态数组&#125; 结构体内部可以包含自身的mapping映射。 12345struct student4&#123; uint grade; string name; mapping(uint&#x3D;&gt;student4) studentMap;&#125; struct实例化 定义一个结构体有多种方式 123456789struct student&#123; uint grade; string name; &#125;&#x2F;&#x2F;方式一、将100、&quot;jackson&quot; 按顺序赋值给student。student(100,&quot;jackson&quot;)&#x2F;&#x2F;方式二、按名字赋值student(&#123;name:&quot;jackson&quot;,grade:100&#125;) 完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.23;contract structTest&#123; struct student&#123; uint grade; string name; //student s; &#125; struct student2&#123; uint grade; string name; student ss; &#125; struct student3&#123; uint grade; string name; student ss; student3[] stu; &#125; struct student4&#123; uint grade; string name; student ss; student3[] stu; mapping(uint=&gt;student4) studentMap; &#125; function init() public pure returns(uint,string)&#123; student memory s = student(100,\"jackson\"); student3[3] memory stu; return (s.grade,s.name); &#125; function init2() public pure returns(uint,string)&#123; student memory s = student(&#123;name:\"jackson\",grade:100&#125;); return (s.grade,s.name); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[38]-storage引用","slug":"solidity-38-storage","date":"2018-11-23T02:06:34.000Z","updated":"2018-11-23T12:59:07.629Z","comments":true,"path":"2018/11/23/solidity-38-storage/","link":"","permalink":"https://dreamerjonson.com/2018/11/23/solidity-38-storage/","excerpt":"","text":"storage引入 storage属性是一种引用类型。在如下的合约中，定义了动态长度数组arrx，arrx存储在以太坊虚拟机storage空间中的变量。 当调用test方法之后，定义了变量uint[] Z。这个时候，如果我们在remix浏览器中进行编译，我们会看到一个警告。因为默认的情况下，对于动态数组 会加上storage属性。也就是：uint[] storage x。storage属性是一种引用类型，其引用了以太坊虚拟机storage空间中的状态变量。而不是对于值的拷贝 因此，在test函数中，当修改了Z的长度和Z的内容之后，再次查看arrx的长度和内容，会发现对应发生了变化。 123456789101112131415161718192021222324pragma solidity ^0.4.23;contract storageStart&#123; uint[] public arrx=[1,2,3,4,5]; function test() public&#123; uint[] Z = arrx; Z[0] = 100; Z.length = 10; &#125; function getLength() public view returns(uint)&#123; return arrx.length; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[37]-以太坊虚拟机数据存储","slug":"solidity-37-evm-datastorage","date":"2018-11-22T15:31:21.000Z","updated":"2018-11-23T12:58:47.968Z","comments":true,"path":"2018/11/22/solidity-37-evm-datastorage/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-37-evm-datastorage/","excerpt":"","text":"EVM 当调用solidity函数时，都会在以太坊虚拟机当中来执行。因此了解以太坊虚拟机的细节，了解其数据的存储机制变得尤为重要。 以太坊虚拟机中的空间分为3大部分。分别为storage、stack与memory。 storage空间非常特殊，其值会被矿工提交到区块链上，改变区块链的状态。 下面我们将分析下面例子中，每一个变量所在以太坊evm中的位置。 下面的例子中，在运行合约中的代码时，变量a会存储在以太坊evm的storage空间中。其实所有的状态变量都会存储在storage空间中。 add函数中的函数参数num存储在memory空间中。 在函数中定义的变量，如在test函数中的i、j都存储在stack空间中。 当调用cahngeIt函数时，会修改storage空间中的a值。 当调用add函数时，会将memory空间中的num值加1. 当调用test方法时，会在stack中开辟空间i、j。i赋值为2. j赋值为add函数的返回值3. 1234567891011121314151617181920contract storageAndMemory&#123; uint a = 5; function changeIt() public &#123; a = 1000; &#125; function add(uint num) public returns(uint)&#123; num = num +1; return num; &#125; function test() public returns(uint,uint)&#123; uint i = 2; uint j = add(i); return(i,j); &#125;&#125; 总结 1234567状态变量总是存在于storage中函数的参数默认在memory中函数中的本地变量默认是在stack中storage与memory都需要消耗gas，但是storage更贵","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[36]-连续继承与多重继承","slug":"solidity-36-inheritdeep","date":"2018-11-22T11:50:18.000Z","updated":"2018-11-23T12:58:25.227Z","comments":true,"path":"2018/11/22/solidity-36-inheritdeep/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-36-inheritdeep/","excerpt":"","text":"连续继承 合约可以被连续的继承，在下面的合约中，father继承了grandfather、son继承了father。那么son也同样继承了grandfather中的状态变量和方法。 12345678910111213contract grandfather&#123; uint public money&#x3D;10000; function dahan() public pure returns(string)&#123; return &quot;dahan&quot;; &#125;&#125;contract father is grandfather&#123;&#125;contract son is father&#123;&#125; 连续继承重名问题 下面的合约中，grandfather合约与 father合约中状态变量的名字、函数的名字都是相同的，这时，son中的状态变量money和继承的函数 以父类father合约中的状态变量和函数为准。 12345678910111213141516171819202122pragma solidity ^0.4.23;contract grandfather&#123; uint public money=10000; function dahan() public pure returns(string)&#123; return \"dahan\"; &#125;&#125;contract father is grandfather&#123; uint public money=9999; function dahan() public pure returns(string)&#123; return \"alice\"; &#125;&#125;contract son is father&#123; function getMonry() returns(uint)&#123; return money; &#125;&#125; 多重继承 合约可以继承多个合约，也可以被多个合约继承。如下所示： 12345678910contract father&#123;&#125;contract mother&#123;&#125;contract son is father,mother&#123;&#125; 多重继承有重名 多重继承有重名时，继承的顺序时很重要的，以最后继承的为主。例如下面的例子中，son合约最后继承了mother，因此以mother合约中的money=8888为准。 123456789101112131415161718contract father is grandfather&#123; uint public money&#x3D;9999; function dahan() public pure returns(string)&#123; return &quot;alice&quot;; &#125;&#125;contract mother&#123; uint public money&#x3D;8888; uint public weight&#x3D;100;&#125;contract son is father,mother&#123;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[35]-function-automatic","slug":"solidity-35-function-automatic","date":"2018-11-22T10:56:40.000Z","updated":"2018-11-23T12:58:20.391Z","comments":true,"path":"2018/11/22/solidity-35-function-automatic/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-35-function-automatic/","excerpt":"","text":"自动生成函数 public属性的状态变量会自动的生成同名的函数。如果有何其一样的函数定义，则会替换掉默认的函数。 一般类型如int、bytes32、bool类型的函数会自动的生成同名的函数。 但是要注意的是，生成的函数的属性为external属性。 12345uint public num = 100;自动生成的函数为: function num() external pure returns(uint)&#123; return 200; &#125; 动态数组与mapping类型函数会自动生成带参数的函数： 12345mapping(uint =&gt;string) public map;//自动生成的函数function map(uint key) external view returns(string)&#123; return map[key];&#125; 复杂的自动生成函数 12345mapping(uint=&gt;mapping(uint=&gt;uint)) public grademap;//自动生成的函数function grademap(uint key1,uint key2) external view returns(uint)&#123; return grademap[key1][key2];&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[34]-合约继承与可见性","slug":"solidity-34-inherit","date":"2018-11-22T10:00:52.000Z","updated":"2018-11-23T12:58:15.601Z","comments":true,"path":"2018/11/22/solidity-34-inherit/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-34-inherit/","excerpt":"","text":"继承 继承是面向对象语言的重要特征。继承是为了模拟现实中的现象，并且可以简化代码的书写。 例如猫与够都属于动物。他们都继承动物的某些特征。 继承语法 当前合约继承父类合约的属性和方法。 123456789101112131415161718192021222324252627contract 合约名 is 父类合约名&#123;&#125;&#96;&#96;&#96; ## 继承例子下面的例子中。直接部署son合约后，son合约继承了father合约的状态变量money与函数dahan，所以在son合约中，仍然可以访问或修改父类的状态变量和方法。同时，在son合约中，有属于自己特有的状态变量和方法。&#96;&#96;&#96;jspragma solidity ^0.4.23;contract father&#123; uint public money &#x3D;10000; function dahan() public returns(string)&#123; return &quot;dahan&quot;; &#125;&#125;contract son is father&#123; uint public girlfriend; &#x2F;&#x2F;修改父类属性 function change() public&#123; money &#x3D; 99; &#125;&#125; 继承与可见性 public 状态变量默认是public的类型，可以被继承，可以在外部与内部被调用 123456789contract father&#123; uint money &#x3D; 10000;&#125;contract son is father&#123; function getMoney() public view returns(uint)&#123; return money; &#125;&#125; 函数默认为public属性,可以被继承，可以在外部与内部被调用 1234567891011contract father&#123; function dahan() pure returns(string)&#123; return &quot;dahan&quot;; &#125;&#125;contract son is father&#123; function test() public view returns(string)&#123; return dahan(); &#125;&#125; internal 当为状态变量添加了inernal属性，仍然可以被继承，internal属性只能够被合约中的方法调用，不能够在外部被直接调用。 123456789contract father&#123; uint internal money &#x3D; 10000;&#125;contract son is father&#123; function getMoney() public view returns(uint)&#123; return money; &#125;&#125; 当为函数添加了inernal属性，仍然可以被继承，internal属性只能够被合约中的方法调用，不能够在外部被直接调用。 1234567891011contract father&#123; function dahan() internal pure returns(string)&#123; return &quot;dahan&quot;; &#125;&#125;contract son is father&#123; function test() public view returns(string)&#123; return dahan(); &#125;&#125; external 状态变量没有external属性，但是函数有。 当为函数加上external属性后，意味着合约只能够在外部被调用，不能够在内部被调用。 如果想合约在内部被调用，需要使用到如下this.函数的方式： 12345678910111213contract father&#123; function dahan() external pure returns(string)&#123; return &quot;dahan&quot;; &#125;&#125;contract son is father&#123; function test() public view returns(string)&#123; return this.dahan(); &#125;&#125; 能够调用external的第二种方式。 12345678910111213contract father&#123; function dahan() external pure returns(string)&#123; return &quot;dahan&quot;; &#125;&#125;contract testExternal&#123; father f &#x3D; new father(); function test() public view returns(string)&#123; return f.dahan(); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[33]-modifire-deep","slug":"solidity-33-modifire-deep","date":"2018-11-22T09:21:28.000Z","updated":"2018-11-23T12:58:10.123Z","comments":true,"path":"2018/11/22/solidity-33-modifire-deep/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-33-modifire-deep/","excerpt":"","text":"带参modifire modifire还可以带参数，如下面的例子，模拟了游戏中的升级操作。如果玩家等级达到2级，就可以修改名字。如果玩家等级达到10级，就可以修改DNA。 通过带参数的modifire实现对于代码的封装。 12345678910111213141516171819202122pragma solidity^0.4.23;contract modifiererParam&#123; uint public level = 9; string public name; uint public DNA; modifier controlLevel(uint _needlevel)&#123; require(level&gt;_needlevel); _; &#125; //修改名字 function changeName(string _name) public controlLevel(2)&#123; name = _name; &#125; //修改DNA function changeDNA(uint _dna) public controlLevel(10)&#123; DNA = _dna; &#125;&#125; 通过上面的例子，我们能够看到带参数的modifire的使用方法。首先在modifire中添加参数。接着在函数定义中，在修饰符与return返回值之间加上controlLevel(传递的参数). 例如，当调用changeName函数执行的语句为： 12require(level&gt;2);name &#x3D; _name; 例如，当调用changeDNA函数执行的语句为： 12require(level&gt;10);name &#x3D; _name; 多重modifire 函数可以有多个modifire，这种情况要相对复杂得多。 我们从下面的例子，来讲解多重modifire的执行过程。 案例1 123456789101112131415contract mulmodifiererDeep&#123; uint public a &#x3D; 0; modifier mod1&#123; a &#x3D; 1; _; a &#x3D; 2; &#125; function test() public mod1&#123; a &#x3D; 100; &#125;&#125; 下面的例子中，当执行test方法后，状态变量a的值会变为2. 我们提到过，modifire中的下划线指代了函数中的所有语句。 所以执行流程为 a = 1 a = 100 a = 2 案例2 下面的例子中，使用了多重的modire。 12345678910111213141516171819contract mulmodifiererDeep2&#123; uint public a &#x3D; 0; modifier mod1&#123; a &#x3D; 1; _; a &#x3D; 2; &#125; modifier mod2&#123; a &#x3D; 3; _; a &#x3D; 4; &#125; function test() public mod1 mod2&#123; a &#x3D; 100; &#125;&#125; 在上面的例子中test函数使用了modifire：mod1、mod2 嵌套规则为，首先函数中的a = 100嵌套到mod2的_中。整个语句变为了 a = 3; a = 100; a = 4; 接下来，将上面的语句添加到mod1的下划线中，所以整个执行语句变为了 12345a &#x3D; 1;a &#x3D; 3;a &#x3D; 100;a &#x3D; 4;a &#x3D; 2; 最后执行结果为 a = 2。 案例3 多重modifire的顺序非常的重要的。 下面的例子，和案例2相同但是修改了mod1与mod2在函数中的顺序。 12345678910111213141516171819contract mulmodifiererDeep2&#123; uint public a &#x3D; 0; modifier mod1&#123; a &#x3D; 1; _; a &#x3D; 2; &#125; modifier mod2&#123; a &#x3D; 3; _; a &#x3D; 4; &#125; function test() public mod2 mod1&#123; a &#x3D; 100; &#125;&#125; 在上面的例子中test函数使用了modifire：mod2、mod1 嵌套规则为，首先函数中的a = 100嵌套到mod1的_中。整个语句变为了 a = 1; a = 100; a = 2; 接下来，将上面的语句添加到mod1的下划线中，所以整个执行语句变为了 12345a &#x3D; 3;a &#x3D; 1;a &#x3D; 100;a &#x3D; 2;a &#x3D; 4; 最后执行结果为 a = 4。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[32]-函数modifire","slug":"solidity-32-modifire","date":"2018-11-22T08:32:55.000Z","updated":"2018-11-23T12:57:55.381Z","comments":true,"path":"2018/11/22/solidity-32-modifire/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-32-modifire/","excerpt":"","text":"函数modifire 函数modifire用于在执行函数前，执行某些初始化的操作。例如权限的判断。 modifire可以起到封装的作用，简化代码的书写。 modifire的定义 添加modifire关键字， 在花括号内部输入语句，并在最后加上下划线_。 1234modifier 函数名()&#123; 语句; _;&#125; modifire使用 modifire的使用方法是，将modifer的名字加在函数修饰符与返回值之间，如下所示 12345678910111213modifier OnlyOwner()&#123; require(msg.sender==owner); _;&#125;function changeIt(uint _num) public OnlyOwner&#123; a = _num;&#125; function getIt() view public OnlyOwner returns(address) &#123; return owner;&#125; 对于上面加上了modifire的函数changeIt和getIt。 changeIt函数的执行流程为 首先执行require(msg.sender==owner)，再执行函数体内部的所有语句，这里是 a = _num。 所以，modifier中的下划线其实是指代的函数体内部所有语句。在执行函数内部代码前，会先执行modifire中的语句。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[31]-构造函数","slug":"solidity-31-constructor","date":"2018-11-22T08:07:29.000Z","updated":"2018-11-23T12:57:59.047Z","comments":true,"path":"2018/11/22/solidity-31-constructor/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-31-constructor/","excerpt":"","text":"构造函数的作用 构造函数是特殊的函数，在部署合约的时候，就会被调用。而且只能够在此时被调用。 常常用于对于某一些状态变量的初始化。 构造函数 在老版本的solidity编译器中，构造函数是和合约名字同名的 1234567891011contract ontractinit&#123;uint public a ;//无参数的构造函数function ontractinit() public&#123; a = 100;&#125;//带参数的构造函数 function ontractinit(uint _a,uint _b) public&#123; a = _a;&#125; 新版本的solidity编译器中，使用关键词constructor作为构造函数 12345678910111213uint public a ;address public owner;// 将部署者地址存储到owner变量constructor() public &#123; owner = msg.sender;&#125;//带参构造函数constructor(uint _a) public&#123; a = _a;&#125; 完整代码 1234567891011121314151617181920pragma solidity ^0.4.23;contract ontractinit&#123; // function ontractinit() public&#123; // a = 100; // &#125; // function ontractinit(uint _a,uint _b) public&#123; // a = _a; // &#125; uint public a ; address public owner; constructor(uint _a) public&#123; a = _a; &#125; constructor() public &#123; owner = msg.sender; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[30]-值拷贝","slug":"solidity-30-value-copy","date":"2018-11-22T07:38:23.000Z","updated":"2018-11-23T12:58:03.276Z","comments":true,"path":"2018/11/22/solidity-30-value-copy/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-30-value-copy/","excerpt":"","text":"状态变量的值拷贝问题 如下例子中，将状态变量a的值赋值给状态变量b。a与b都是以太坊虚拟机storage中不同的两个空间，所以当调用change方法修改b的值的时候，不会影响到a空间中的值。 1234567uint public a &#x3D; 100;uint public b &#x3D; a ;function change() public &#123; b &#x3D; 999;&#125; 函数体内部变量的值拷贝 在函数体内部，将状态变量a的值赋值给状态变量b。a与b都是以太坊虚拟机栈中不同的两个空间。所以当修改b的值的时候，不会影响到a空间中的值。 123456function change2() public pure returns(uint,uint)&#123; uint a1 = 100; uint b1 = a1; b1 = 999; return (a1,b1);&#125; 函数参数的值拷贝问题 在下面的例子中，test函数调用了change函数，并传递了参数a。 传递的参数a会赋值给以太坊虚拟机memory空间中的变量num。由于函数的参数num和状态变量a是不同的两个空间。仅仅是将a的值赋值给了num。所以对于变量num值的修改不会改变a变量的值 12345678910uint public a = 100;function change(uint num) public returns(uint)&#123; num++; return num;&#125;function test() returns(uint)&#123; uint result = change3(a); return result;&#125; 完整代码 1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.23;contract valueCopy&#123; uint public a = 100; uint public b = a ; function change() public &#123; b = 999; &#125; function change2() public pure returns(uint,uint)&#123; uint a1 = 100; uint b1 = a1; b1 = 999; return (a1,b1); &#125; function change3(uint num) public returns(uint)&#123; num++; return num; &#125; function test() returns(uint)&#123; uint result = change3(a); return result; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[29]-函数作用域","slug":"solidity-29-function-scpoe","date":"2018-11-22T07:23:01.000Z","updated":"2018-11-23T12:57:17.759Z","comments":true,"path":"2018/11/22/solidity-29-function-scpoe/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-29-function-scpoe/","excerpt":"","text":"函数重名与函数作用域问题 1、当状态变量中已经有了一个变量a、状态变量中就不能够再有一个同名的状态变量。 2、当状态变量中和函数体内部已经有了都有一个同名的函数的时候，默认处理的是函数体内部的变量。也就是说，变量的操作和其他语言一样，仍然满足就近原则。 12345678910uint public a &#x3D; 100;uint b &#x3D; 200;&#x2F;&#x2F; uint public a &#x3D; 999; 当状态变量中已经有了一个变量a、状态变量中就不能够再有一个同名的状态变量。function scopeTest() pure public returns(uint)&#123; uint a &#x3D; 88; a &#x3D; 77; &#x2F;&#x2F;修改的是函数体内部的a return a ;&#x2F;&#x2F;返回的是函数体内部的a。&#125; 3、在函数的参数中，可以有和状态变量同名的函数a。 但是一旦函数中参数中有了变量名字为a，函数体内部的任何位置都不能再次有对于a的定义。 1234567891011121314151617181920function scopeTest2(uint a) pure public returns(uint)&#123; &#x2F;&#x2F;错误1&#x2F;&#x2F; uint a &#x3D; 0; &#x2F;&#x2F;错误2&#x2F;&#x2F; for(uint a &#x3D; 0;a&lt;8;a++)&#123;&#x2F;&#x2F; &#125;&#x2F;&#x2F;错误3:&#123; &#x2F;&#x2F; uint a &#x3D; 0; a &#x3D; 99; &#x2F;&#x2F;可以修改 return a ;&#x2F;&#x2F;可以返回&#125;&#125; 完整代码 123456789101112131415161718192021222324252627282930pragma solidity ^0.4.23;contract scope&#123; uint public a &#x3D; 100; uint b &#x3D; 200; &#x2F;&#x2F; uint public a &#x3D; 999; function scopeTest() pure public returns(uint)&#123; uint a &#x3D; 88; a &#x3D; 77; return a ; &#125; function scopeTest2(uint a) pure public returns(uint)&#123; &#x2F;&#x2F; uint a &#x3D; 0; &#x2F;&#x2F; for(uint a &#x3D; 0;a&lt;8;a++)&#123; &#x2F;&#x2F; &#125; &#123; &#x2F;&#x2F; uint a &#x3D; 0; a &#x3D; 99; return a ; &#125; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[28]-函数返回值","slug":"solidity-28-function-return","date":"2018-11-22T03:34:41.000Z","updated":"2018-11-23T12:57:02.217Z","comments":true,"path":"2018/11/22/solidity-28-function-return/","link":"","permalink":"https://dreamerjonson.com/2018/11/22/solidity-28-function-return/","excerpt":"","text":"函数返回值一般形式 12345678910function resValue() pure public returns(uint)&#123; uint a = 10; return a;&#125;function recieveValue() pure public returns(uint)&#123; uint b; b = resValue(); return b;&#125; 函数命名返回值 12345678910111213&#x2F;&#x2F;1、直接赋值、不需要return返回function resValue2() pure public returns(uint num1)&#123; num1 &#x3D; 100;&#125;&#x2F;&#x2F;2、如果有return，以return为准function resValue3() pure public returns(uint num1)&#123; num1 &#x3D; 100; return 99;&#125;&#x2F;&#x2F;3、不return，也不赋值，那么为0function resValue4() pure public returns(uint num1)&#123; uint b &#x3D; 88;&#125; 函数多返回值 solidity语言支持函数的多返回值。 12345678910function mulvalue(uint a,uint b) pure public returns(uint,uint)&#123; uint add = a+b; uint mul = a*b; return (add,mul);&#125;//命名返回值+多返回值 function mulvalue2(uint a,uint b) pure public returns(uint add,uint mul)&#123; add = a+b; mul = a*b;&#125; 案例：多返回值实现参数的反转 状态变量resA、resB传递过来之后。函数reverse2将会使得函数 12345678910function reverse(uint a,uint b) returns(uint ,uint)&#123; return (b,a);&#125; uint public resA = 0; uint public resB = 0; function reverse2(uint a,uint b) &#123; (resA,resB) = reverse(a,b);&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[27]-函数与函数重载","slug":"solidity-27-function-overload","date":"2018-11-20T16:08:43.000Z","updated":"2018-11-20T16:36:23.104Z","comments":true,"path":"2018/11/21/solidity-27-function-overload/","link":"","permalink":"https://dreamerjonson.com/2018/11/21/solidity-27-function-overload/","excerpt":"","text":"函数的一般形式 1function (&lt;parameter types&gt;) &#123;public|internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)] 函数的作用 1、与区块链交互 2、本地执行 3、封装代码 带参数函数 1234567uint public num; string public name; function setparam(uint _num,string _name) public &#123; num &#x3D; _num; name &#x3D; _name; &#125; 带参函数调用—函数命名参数 12345678910111213141516171819202122232425262728293031323334pragma solidity ^0.4.23;contract funcParam&#123; &#x2F;&#x2F;状态变量 uint public num; string public name; &#x2F;&#x2F;代餐函数 function setparam(uint _num,string _name) public &#123; num &#x3D; _num; name &#x3D; _name; &#125; &#x2F;&#x2F;调用 function Test() public &#123; setparam(99,&quot;bob&quot;); &#125; &#x2F;&#x2F;函数命名参数 function Test2() public &#123; setparam(&#123;_num:99,_name:&quot;bob&quot;&#125;); &#125; function Test3() public &#123; setparam(&#123;_name:&quot;Alice&quot;,_num:999&#125;); &#125; &#x2F;&#x2F;错误代码，参数个数不匹配 &#x2F;&#x2F; function Test4() public &#123; &#x2F;&#x2F; setparam(100); &#x2F;&#x2F; &#125;&#125; 函数重载 在一个合约中有相同名字的函数，就是函数的重载。 重载必须要函数的类型与长度都不相同。 下面的例子都是错误的写法 错误1 1234567function fun()&#123;&#125; function fun()&#123;&#125; 错误2 1234567function fun() returns(uint)&#123; &#125; function fun() returns(bytes1)&#123; &#125; 错误3 1234567 function fun() returns(uint)&#123;&#125; function fun()&#123;&#125; 正确1 1234567function fun(uint k) public pure&#123; &#125;function fun() public pure&#123;&#125; 正确2 1234567function fun2(uint a) public pure&#123;&#125;function fun2(bytes1 b) public pure&#123;&#125; 例子剖析1 在下面的例子中，fun3有两个重载的函数。函数test不能够调用fun3(2)，因为不能够明确到底是要调用哪一个。 fun3(256)能够执行成功。因为256超过了int8的最大值，只能够调用fun3(uint a). 如果想明确，可以强制的转换,例如uint256(2)。 12345678910111213function fun3(uint a) public &#123; num = 256;&#125;function fun3(uint8 b) public&#123; num = 8;&#125; function test() public&#123; //fun3(2);错误，不明确 fun3(256); fun3(uint256(2));&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[26]-mapping","slug":"solidity-26-mapping","date":"2018-11-20T15:39:16.000Z","updated":"2018-12-06T00:59:04.915Z","comments":true,"path":"2018/11/20/solidity-26-mapping/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-26-mapping/","excerpt":"","text":"mapping mapping是一张表，存储key-value对。更准确的说，mapping是一张hash映射表，内部并没有存储真实的key值。 123Mappings can be seen as hashtables which are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type’s default value. The similarity ends here, though: The key data is not actually stored in a mapping, only its keccak256 hash used to look up the value.Because of this, mappings do not have a length or a concept of a key or value being “set”. mapping用例 下面的案例模拟了一个登陆网站，将地址与id绑定在一起。id又与姓名绑定在一起。 123456789101112131415161718192021222324pragma solidity ^0.4.23;contract mappingTest&#123; uint id = 0; mapping(address =&gt;uint) idmap;//将地址与id绑定在一起 mapping(uint =&gt;string) namemap;//id又与姓名绑定在一起。 //注册 function regist(string name) public&#123; address acount = msg.sender; id++; idmap[acount] = id; namemap[id] = name; &#125; //根据地址获取id function getIdByAddress(address _address) public view returns(uint)&#123; return idmap[_address]; &#125; //根据id获取名字 function getNameByID(uint _id) public view returns(string)&#123; return namemap[_id]; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[25]-转账的3种方式与比较","slug":"solidity-25-thansfer2","date":"2018-11-20T15:30:57.000Z","updated":"2018-11-20T16:36:38.297Z","comments":true,"path":"2018/11/20/solidity-25-thansfer2/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-25-thansfer2/","excerpt":"","text":"转账的3种方式 123address.transfer()address.send()address.call.value().gas()() 转账transfer 12345678910function transfer(address _address) public payable&#123; _address.transfer(msg.value); &#125; function transfer2(address _address) public payable&#123; _address.transfer(10 * 10**18); &#125; 转账send 123function transfer4(address _address) public payable &#123; _address.send(10 ether); &#125; 转账call 123function transfer5(address _address) public payable returns(bool)&#123; return _address.call.value(10 ether)();&#125; 对比总结 123456transfer与send相似，都为转账操作transfer出错抛出异常send、call出错不抛出异常，返回true或falsetansfer相对send更安全send、call即便转账失败也会执行其后的代码慎用call函数转账，容易发生重入攻击。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[24]-global","slug":"solidity-24-global","date":"2018-11-20T15:11:20.000Z","updated":"2018-11-20T16:36:42.657Z","comments":true,"path":"2018/11/20/solidity-24-global/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-24-global/","excerpt":"","text":"solidity中的全局属性 block.blockhash(uint blockNumber) returns (bytes32)：返回给定区块号的哈 希值，只支持最近256个区块，且不包含当前区块。在版本0.4.22中弃用并被替换为。blockhash(uint blockNumber) block.coinbase (address): 当前块矿工的地址。 block.difficulty (uint):当前块的难度。 block.gaslimit (uint):当前块的gaslimit。 block.number (uint):当前区块的块号。 block.timestamp (uint): 当前块的Unix时间戳（从1970/1/1 00:00:00 UTC开始所经过的秒数） msg.data (bytes): 完整的调用数据（calldata）。 msg.sender (address): 当前调用发起人的地址。 msg.sig (bytes4):调用数据(calldata)的前四个字节（例如为：函数标识符）。 msg.value (uint): 这个消息所附带的以太币，单位为wei。 now (uint): 当前块的时间戳(block.timestamp的别名) tx.gasprice (uint) : 交易的gas价格。 tx.origin (address): 交易的发送者（全调用链） 案例 1234567891011121314151617181920212223242526272829303132333435363738pragma solidity ^0.4.23;contract global&#123; function getGlobal1() public view returns(address)&#123; return msg.sender ; &#125; function getGlobal2() public view returns(uint)&#123; return block.difficulty; &#125; function getGlobal3() public view returns(uint)&#123; return block.number; &#125; function getGlobal4() public view returns(address)&#123; return block.coinbase; &#125; function getGlobal5() public pure returns(bytes)&#123; return msg.data; &#125; function getGlobal6() public payable returns(uint )&#123; return msg.value ; &#125; function getGlobal7() public view returns(address )&#123; return tx.origin; &#125; function getGlobal8() public view returns(uint )&#123; return now; &#125; function getGlobal9() public view returns(bytes32 )&#123; return blockhash(block.number-1); &#125;&#125; 参考资料： https://solidity.readthedocs.io/en/develop/units-and-global-variables.html","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[23]-payable","slug":"solidity-23-payable","date":"2018-11-20T15:01:15.000Z","updated":"2018-11-20T15:13:43.941Z","comments":true,"path":"2018/11/20/solidity-23-payable/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-23-payable/","excerpt":"","text":"转账 如果在函数中涉及到以太币的转移，需要使用到payable关键词。意味着可以在调用这笔函数的消息中附带以太币。 123function pay() public payable&#123; &#125; this代表合约地址 this 代表当前部署的合约地址 12345function getThis() public view returns(address)&#123; return this; // 0x9F4c14f487B8e4E3986467c2a2aA5bDE93052666 //0x9f4c14f487b8e4e3986467c2a2aa5bde93052666 &#125; 获取合约账户余额 1234function getbalance() public view returns(uint)&#123; return address(this).balance; &#125; 获取外部账户余额 123function getExternalBalance(address account) public view returns(uint)&#123; return account.balance; &#125; 转账 12345678910&#x2F;&#x2F;给外部账户转账function transfer() public payable&#123; address account &#x3D; 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; account.transfer(msg.value); &#125;&#x2F;&#x2F;给合约地址转账 function transfer2() public payable&#123; address(this).transfer(msg.value);&#125; 给合约地址与外部地址同时转账 在下面的例子中，如果在调用此函数时，附带了20Ether，那么就会给account账户转移10ether，给合约账户转移10ether 1234function transfer3() public payable&#123; address account &#x3D; 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; account.transfer(10*10**18);&#125; 全部代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445pragma solidity ^0.4.23;contract payableTest&#123; function pay() public payable&#123; &#125; function getbalance() public view returns(uint)&#123; return address(this).balance; &#125; function getThis() public view returns(address)&#123; return this; // 0x9F4c14f487B8e4E3986467c2a2aA5bDE93052666 //0x9f4c14f487b8e4e3986467c2a2aa5bde93052666 &#125; function getExternalBalance(address account) public view returns(uint)&#123; return account.balance; &#125; function transfer() public payable&#123; address account = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; account.transfer(msg.value); &#125; function transfer2() public payable&#123; address(this).transfer(msg.value); &#125; function () public payable&#123; &#125; function transfer3() public payable&#123; address account = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; account.transfer(10*10**18); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"go语言渐入佳境[14]-指针","slug":"golang-14-pointer","date":"2018-11-20T10:26:24.000Z","updated":"2019-01-21T06:21:09.655Z","comments":true,"path":"2018/11/20/golang-14-pointer/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/golang-14-pointer/","excerpt":"","text":"变量的地址 12a :&#x3D;10fmt.Printf(&quot;a变量的地址为：%#X\\n&quot;,&amp;a)&#x2F;&#x2F;a变量的地址为：0XC420092008 指针的声明 12&#x2F;&#x2F;声明var p *int 空指针 123if p&#x3D;&#x3D;nil&#123; fmt.Println(&quot;p为空指针&quot;)&#125; 通过指针获取值 12p &#x3D; &amp;afmt.Printf(&quot;p的类型为%T, p的值为：%v,p指向的int的值为：%v,a的值为：%d\\n&quot;,p,p,*p,a) 通过指针修改值 12*p &#x3D; 99fmt.Printf(&quot;p的类型为%T, p的值为：%v,p指向的int的值为：%v,a的值为：%d\\n&quot;,p,p,*p,a) 完整例子1 123456789101112131415161718192021222324252627282930package mainimport \"fmt\"func main()&#123; //变量的地址 a :=10 fmt.Printf(\"a变量的地址为：%#X\\n\",&amp;a) //声明 var p *int //空指针 if p==nil&#123; fmt.Println(\"p为空指针\") &#125; //通过指针获取值 p = &amp;a fmt.Printf(\"p的类型为%T, p的值为：%v,p指向的int的值为：%v,a的值为：%d\\n\",p,p,*p,a) //通过指针修改值 *p = 99 fmt.Printf(\"p的类型为%T, p的值为：%v,p指向的int的值为：%v,a的值为：%d\\n\",p,p,*p,a)&#125; 指针作为函数参数 指针作为函数参数,修改原来的值： 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; a := 10 fmt.Printf(\"1、变量a的内存地址是：%p ，值为：%v \\n\\n\", &amp;a, a)//10 b := &amp;a change(b) fmt.Printf(\"3、change函数调用之后，变量a的内存地址是：%p ，值为：%v \\n\\n\", &amp;a, a)//20 change0(a) fmt.Printf(\"5、change0函数调用之后，变量a的内存地址是：%p ，值为：%v \\n\\n\", &amp;a, a)//20&#125;func change(a *int) &#123; fmt.Printf(\"2、change函数内，变量a的内存地址是：%p ，值为：%v \\n\\n\", &amp;a, a)//20 *a = 50&#125;func change0(a int) &#123; fmt.Printf(\"4、change0函数内，变量a的内存地址是：%p ，值为：%v \\n\\n\", &amp;a, a)//20 a = 90&#125; 切片类型指针作为函数参数 123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; a := []int&#123;1, 2, 3, 4&#125; fmt.Printf(\"1、变量a的内存地址是：%p ，值为：%v \\n\\n\", &amp;a, a) modify(&amp;a) fmt.Printf(\"3、调用modify函数后，变量a的内存地址是：%p ，值为：%v \\n\\n\", &amp;a, a) modify0(a) fmt.Printf(\"5、调用modify0函数后，变量a的内存地址是：%p ，值为：%v \\n\", &amp;a, a)&#125;func modify(arr *[]int) &#123; fmt.Printf(\"2、modify函数中参数a的内存地址是：%p ，值为：%v \\n\", &amp;arr, arr) (*arr)[0] = 250&#125;func modify0(arr []int) &#123; fmt.Printf(\"4、modify0函数中参数a的内存地址是：%p ，值为：%v \\n\", &amp;arr, arr) arr[0] = 99&#125; 指针作为函数参数例子2 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; //定义两个局部变量 a, b := 100, 200 // 返回值的写法实现数据交换 a, b = swap0(a, b) fmt.Println(\"第一次交换后：\" , a, b) // 使用指针实现交换 swap(&amp;a, &amp;b) fmt.Println(\"第二次交换后：\" , a, b)&#125;//具有返回值的惯用写法，实现两个数据的交换func swap0(x, y int) (int, int) &#123; return y, x&#125;//使用指针作为参数的写法func swap(x, y *int) &#123; *x, *y = *y, *x&#125; 指针数组 数组，数组中的元素存储的都是指针。 1234567891011121314151617181920212223242526272829303132package mainimport \"fmt\"const COUNT int = 4func main() &#123; a := [COUNT]string&#123;\"abc\", \"ABC\", \"123\", \"一二三\"&#125; //查看数组的指针的类型和值 fmt.Printf(\"%T , %v \\n\", &amp;a, &amp;a) //定义指针数组 var ptr [COUNT]*string fmt.Printf(\"%T , %v \\n\", ptr, ptr) for i := 0; i &lt; COUNT; i++ &#123; // 将数组中每个元素的地址赋值给指针数组的每个元素 ptr[i] = &amp;a[i] &#125; fmt.Printf(\"%T , %v \\n\", ptr, ptr) fmt.Println(ptr[0]) // 根据指针数组元素的每个地址获取该地址所指向的元素的真实数值 for i:=0; i&lt;COUNT ;i++ &#123; fmt.Println(*ptr[i]) &#125; for _,value :=range ptr &#123; fmt.Println(*value) &#125;&#125; 多级指针 1234567891011121314151617181920212223package mainimport \"fmt\"func main() &#123; var a int var ptr *int var pptr **int a = 123 // 为指针赋值 ptr = &amp;a fmt.Println(\"ptr:\" , ptr) //为pptr赋值 pptr = &amp;ptr fmt.Println(\"pptr\" , pptr) //获取指针对应的值 fmt.Printf(\"变量 a = %d \\n\" , a) fmt.Printf(\"指针变量 *ptr = %d \\n\" , *ptr) fmt.Printf(\"指向到指针的变量 **pptr = %d \\n\" ,**pptr)&#125; 那么垃Go语言的自动圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。 因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。 编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。 1234567var global *intfunc f() &#123; func g() &#123; var x int y :&#x3D; new(int) x &#x3D; 1 *y &#x3D; 1 global &#x3D; &amp;x &#125;&#125; 这里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。 Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[13]-切片","slug":"golang-13-slice","date":"2018-11-20T01:32:36.000Z","updated":"2019-02-15T15:03:28.102Z","comments":true,"path":"2018/11/20/golang-13-slice/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/golang-13-slice/","excerpt":"","text":"切片 Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。 数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。数组这样定义 1months :&#x3D; [...]string&#123;1: &quot;January&quot;, &#x2F;* ... *&#x2F;, 12: &quot;December&quot;&#125; 因此一月份是months[1]，十二月份是months[12]。通常，数组的第一个元素从索引0开始，但是月份一般是从1开始的，因此我们声明数组时直接第0个元素，第0个元素会被自动初始化为空字符串。 slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。新的slice将只有ji个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。因此，months[1:13]切片操作将引用全部有效的月份，和months[1:]操作等价；months[:]切片操作则是引用整个数组。让我们分别定义表示第二季度和北方夏天月份的slice，它们有重叠部分： 1、切片可以修改大小 2、切片的拷贝不是单纯值的拷贝，一个切片指向了一个数组 slice 123456789101112Q2 :&#x3D; months[4:7]summer :&#x3D; months[6:9]fmt.Println(Q2) &#x2F;&#x2F; [&quot;April&quot; &quot;May&quot; &quot;June&quot;]fmt.Println(summer) &#x2F;&#x2F; [&quot;June&quot; &quot;July&quot; &quot;August&quot;]两个slice都包含了六月份，下面的代码是一个包含相同月份的测试（性能较低）：for _, s :&#x3D; range summer &#123; for _, q :&#x3D; range Q2 &#123; if s &#x3D;&#x3D; q &#123; fmt.Printf(&quot;%s appears in both\\n&quot;, s) &#125; &#125;&#125; 如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大： fmt.Println(summer[:20]) // panic: out of range endlessSummer := summer[:5] // extend a slice (within capacity) fmt.Println(endlessSummer) // “[June July August September October]” 另外，字符串的切片操作和[]byte字节类型切片的切片操作是类似的。它们都写作x[m:n]，并且都是返回一个原始字节系列的子序列，底层都是共享之前的底层数组，因此切片操作对应常量时间复杂度。x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte。 因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名（§2.3.2）。下面的reverse函数在原内存空间将[]int类型的slice反转，而且它可以用于任意长度的slice。 1234567&#x2F;&#x2F; reverse reverses a slice of ints in place.func reverse(s []int) &#123; for i, j :&#x3D; 0, len(s)-1; i &lt; j; i, j &#x3D; i+1, j-1 &#123; s[i], s[j] &#x3D; s[j], s[i] &#125;&#125; 这里我们反转数组的应用： a := […]int{0, 1, 2, 3, 4, 5} reverse(a[:]) fmt.Println(a) // “[5 4 3 2 1 0]” 一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数，第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。（如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了。） s := []int{0, 1, 2, 3, 4, 5} // Rotate s left by two positions. reverse(s[:2]) reverse(s[2:]) reverse(s) fmt.Println(s) // “[2 3 4 5 0 1]” 要注意的是slice类型的变量s和数组类型的变量a的初始化语法的差异。slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者的两种风格的混合语法初始化。 和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较： 1234567891011func equal(x, y []string) bool &#123; if len(x) != len(y) &#123; return false &#125; for i := range x &#123; if x[i] != y[i] &#123; return false &#125; &#125; return true&#125; 上面关于两个slice的深度相等测试，运行的时间并不比支持==操作的数组或字符串更多，但是为何slice不直接支持比较运算符呢？这方面有两个原因。第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身。虽然有很多办法处理这种情形，但是没有一个是简单有效的。 第二个原因，因为slice的元素是间接引用的，一个固定值的slice在不同的时间可能包含不同的元素，因为底层数组的元素可能会被修改。并且Go语言中map等哈希表之类的数据结构的key只做简单的浅拷贝，它要求在整个声明周期中相等的key必须对相同的元素。对于像指针或chan之类的引用类型，相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的操作符可能是有一定用处的，也能临时解决map类型的key问题，但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做饭是直接禁止slice之间的比较操作。 slice唯一合法的比较操作是和nil比较，例如： 123456if summer == nil &#123; /* ... */ &#125;一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int&#123;&#125;或make([]int, 3)[3:]。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。var s []int // len(s) == 0, s == nils = nil // len(s) == 0, s == nils = []int(nil) // len(s) == 0, s == nils = []int&#123;&#125; // len(s) == 0, s != nil 如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。除了和nil相等比较外，一个nil值的slice的行为和其它任意0产长度的slice一样；例如reverse(nil)也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。 内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。 make([]T, len) make([]T, len, cap) // same as make([]T, cap)[:len] 在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。 切片的声明 1234567&#x2F;&#x2F;切片的声明1 &#x2F;&#x2F;nilvar slice1 []int &#x2F;&#x2F;切片的声明2var slice2 []int &#x3D; make([]int,5)var slice3 []int &#x3D; make([]int,5,7)numbers:&#x3D; []int&#123;1,2,3,4,5,6,7,8&#125; 切片截取 12345678numbers:= []int&#123;1,2,3,4,5,6,7,8&#125;//从下标1一直到下标4，但是不包括下标4numbers1 :=numbers[1:4]//从下标0一直到下标3，但是不包括下标3numbers2 :=numbers[:3]//从下标3一直到结束numbers3 :=numbers[3:] 切片截取例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport \"fmt\"//1、切片可以修改大小//2、切片的拷贝不是单纯值的拷贝，一个切片指向了一个数组//切片的声明1var slice1 []int//切片的声明2var slice2 []int = make([]int,5)var slice3 []int = make([]int,5,7)func main()&#123; slice4 := make([]int,5) slice5 := make([]int,5,7) slice6 := make([]int,0) fmt.Printf(\"len=%d,cap=%d,slice=%v\\n\",len(slice4),cap(slice4),slice4) fmt.Printf(\"len=%d,cap=%d,slice=%v\",len(slice5),cap(slice5),slice5) if slice4 ==nil&#123; fmt.Printf(\"len=%d,cap=%d,slice=%v\\n\",len(slice4),cap(slice4),slice4) &#125; // slice6 := make([]int,0)不为nil if slice6 !=nil&#123; fmt.Printf(\"len=%d,cap=%d,slice=%v\\n\",len(slice6),cap(slice6),slice6) &#125; //var slice1 []int为nil if slice1 ==nil&#123; fmt.Printf(\"len=%d,cap=%d,slice=%v\\n\",len(slice1),cap(slice1),slice1) &#125; sliceTest()&#125;//截取func sliceTest()&#123; numbers:= []int&#123;1,2,3,4,5,6,7,8&#125; printSliceInfo(numbers) numbers1 :=numbers[1:4] printSliceInfo(numbers1) numbers2 :=numbers[:3] printSliceInfo(numbers2) numbers3 :=numbers[3:] printSliceInfo(numbers3)&#125;//打印切片func printSliceInfo(x []int)&#123; fmt.Printf(\"len=%d,cap=%d,slice=%v\\n\",len(x),cap(x),x)&#125; 利用切片截取进行删除 1234567891011// 切片删除// 删除第一个元素numbers = numbers[1:] // 删除最后一个numbers = numbers[:len(numbers)-1]//删除中间一个元素a := int(len(numbers) / 2)numbers = append(numbers[:a], numbers[a+1:]...) 切片与数组的拷贝对比 数组的拷贝是副本拷贝。对于副本的改变不会影响到 切片的拷贝很特殊，切片的副本仍然指向了相同的数组。所以，对于副本的修改会影响到相同的数组。 下面的例子说明 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; //数组是值类型 a := [4]int&#123;1, 2, 3, 4&#125; //切片是引用类型 b := []int&#123;100, 200, 300&#125; c := a d := b c[1] = 200 d[0] = 1 fmt.Println(\"a=\", a, \"c=\", c) //c[1 200 3 4] a[1 2 3 4] fmt.Println(\"b=\", b, \"d=\", d) //d[1 200 300] b[1 200 300]&#125; append添加元素 12345678910111213numbers := make([]int, 0, 20)//append一个元素numbers = append(numbers, 0)//append多个元素numbers = append(numbers, 1, 2, 3, 4, 5, 6, 7)//append添加切片s1 := []int&#123;100, 200, 300, 400, 500, 600, 700&#125;numbers = append(numbers, s1...) //[0 1 2 3 4 5 6 7 100 200 300 400 500 600 700] copy 毫无疑问，创建新的目标切片就会有新的指向的数组。数组的copy是对于不同的数组的值的拷贝 12345//创建目标切片numbers1 := make([]int, len(numbers), cap(numbers)*2)// 将numbers的元素拷贝到numbers1中count := copy(numbers1, numbers) slice 转array 12345678910111213You need to use copy:slice :&#x3D; []byte(&quot;abcdefgh&quot;)var arr [4]bytecopy(arr[:], slice[:4])fmt.Println(arr)As Aedolon notes you can also just usecopy(arr[:], slice)as copy will always only copy the minimum of len(src) and len(dst) bytes. 例子2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport \"fmt\"func main() &#123; fmt.Println(\"1、--------------\") //var numbers []int numbers := make([]int, 0, 20) //append一个元素 numbers = append(numbers, 0) printSlice(\"numbers:\", numbers) //[0] //append多个元素 numbers = append(numbers, 1, 2, 3, 4, 5, 6, 7) printSlice(\"numbers:\", numbers) //[0 1 2 3 4 5 6 7] //append添加切片 s1 := []int&#123;100, 200, 300, 400, 500, 600, 700&#125; numbers = append(numbers, s1...) //[0 1 2 3 4 5 6 7 100 200 300 400 500 600 700] printSlice(\"numbers:\", numbers) fmt.Println(\"2、--------------\") // 切片删除 // 删除第一个元素 numbers = numbers[1:] printSlice(\"numbers:\", numbers) //[ 1 2 3 4 5 6 7 100 200 300 400 500 600 700] // 删除最后一个 numbers = numbers[:len(numbers)-1] printSlice(\"numbers:\", numbers) //[ 1 2 3 4 5 6 7 100 200 300 400 500 600] //删除中间一个元素 a := int(len(numbers) / 2) fmt.Println(\"中间下标：\", a) numbers = append(numbers[:a], numbers[a+1:]...) printSlice(\"numbers:\", numbers) //[1 2 3 4 5 6 100 200 300 400 500 600] fmt.Println(\"3、--------------\") //创建目标切片 numbers1 := make([]int, len(numbers), cap(numbers)*2) // 将numbers的元素拷贝到numbers1中 count := copy(numbers1, numbers) fmt.Println(\"拷贝的个数：\", count) printSlice(\"numbers1:\", numbers1) //拷贝的两个切片是否有关联 numbers[0] = 99 numbers1[len(numbers1)-1] = 100 printSlice(\"numbers\", numbers) printSlice(\"numbers1\", numbers1)&#125;func printSlice(name string, x []int) &#123; fmt.Print(name, \"\\t\") fmt.Printf(\"地址：%p \\t len=%d \\t cap=%d \\t value=%v \\n\", x, len(x), cap(x), x)&#125; 疯狂切片原理 理解了下面代码到底输出什么，就理解了切片的原理。 12345678910111213141516package mainimport \"fmt\"func f(s []string, level int) &#123; if level &gt; 5 &#123; return &#125; s = append(s, fmt.Sprint(level)) f(s, level+1) fmt.Println(\"level:\", level, \"slice:\", s)&#125;func main() &#123; f(nil, 0)&#125; 输出结果： 123456level: 5 slice: [0 1 2 3 4 5]level: 4 slice: [0 1 2 3 4]level: 3 slice: [0 1 2 3]level: 2 slice: [0 1 2]level: 1 slice: [0 1]level: 0 slice: [0] 参考资料： https://dave.cheney.net/2018/07/12/slices-from-the-ground-up append函数深入 内置的append函数用于向slice追加元素： 12345var runes []runefor _, r := range \"Hello, 世界\" &#123; runes = append(runes, r)&#125;fmt.Printf(\"%q\\n\", runes) // \"['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']\" 在循环中使用append函数构建一个由九个rune字符构成的slice，当然对应这个特殊的问题我们可以通过Go语言内置的[]rune(“Hello, 世界”)转换操作完成。 append函数对于理解slice底层是如何工作的非常重要，所以让我们仔细查看究竟是发生了什么。下面是第一个版本的appendInt函数，专门用于处理[]int类型的slice： 1234567891011121314151617181920func appendInt(x []int, y int) []int &#123; var z []int zlen := len(x) + 1 if zlen &lt;= cap(x) &#123; // There is room to grow. Extend the slice. z = x[:zlen] &#125; else &#123; // There is insufficient space. Allocate a new array. // Grow by doubling, for amortized linear complexity. zcap := zlen if zcap &lt; 2*len(x) &#123; zcap = 2 * len(x) &#125; z = make([]int, zlen, zcap) copy(z, x) // a built-in function; see text &#125; z[len(x)] = y return z&#125; 每次调用appendInt函数，必须先检测slice底层数组是否有足够的容量来保存新添加的元素。如果有足够空间的话，直接扩展slice（依然在原有的底层数组之上），将新添加的y元素复制到新扩展的空间，并返回slice。因此，输入的x和输出的z共享相同的底层数组。 如果没有足够的增长空间的话，appendInt函数则会先分配一个足够大的slice用于保存新的结果，先将输入的x复制到新的空间，然后添加y元素。结果z和输入的x引用的将是不同的底层数组。 虽然通过循环复制元素更直接，不过内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。copy函数的第一个参数是要复制的目标slice，第二个参数是源slice，目标和源的位置顺序和dst = src赋值语句是一致的。两个slice可以共享同一个底层数组，甚至有重叠也没有问题。copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度，所以我们不用担心覆盖会超出目标slice的范围。 为了提高内存使用效率，新分配的数组一般略大于保存x和y所需要的最低大小。通过在每次扩展数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间。这个程序演示了效果： 12345678func main() &#123; var x, y []int for i :&#x3D; 0; i &lt; 10; i++ &#123; y &#x3D; appendInt(x, i) fmt.Printf(&quot;%d cap&#x3D;%d\\t%v\\n&quot;, i, cap(y), y) x &#x3D; y &#125;&#125; 每一次容量的变化都会导致重新分配内存和copy操作： 123456789100 cap&#x3D;1 [0]1 cap&#x3D;2 [0 1]2 cap&#x3D;4 [0 1 2]3 cap&#x3D;4 [0 1 2 3]4 cap&#x3D;8 [0 1 2 3 4]5 cap&#x3D;8 [0 1 2 3 4 5]6 cap&#x3D;8 [0 1 2 3 4 5 6]7 cap&#x3D;8 [0 1 2 3 4 5 6 7]8 cap&#x3D;16 [0 1 2 3 4 5 6 7 8]9 cap&#x3D;16 [0 1 2 3 4 5 6 7 8 9] 内置的append函数可能使用比a​​ppendInt更复杂的内存扩展策略。因此，通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量： runes = append(runes, r) 更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型： 1234type IntSlice struct &#123; ptr *int len, cap int&#125; 我们的appendInt函数每次只能向slice追加一个元素，但是内置的append函数则可以追加多个元素，甚至追加一个slice。 123456var x []intx &#x3D; append(x, 1)x &#x3D; append(x, 2, 3)x &#x3D; append(x, 4, 5, 6)x &#x3D; append(x, x...) &#x2F;&#x2F; append the slice xfmt.Println(x) &#x2F;&#x2F; &quot;[1 2 3 4 5 6 1 2 3 4 5 6]&quot; 通过下面的小修改，我们可以可以达到append函数类似的功能。其中在appendInt函数参数中的最后的“…”省略号表示接收变长的参数为slice。我们将在5.7节详细解释这个特性。 1234567func appendInt(x []int, y ...int) []int &#123; var z []int zlen :&#x3D; len(x) + len(y) &#x2F;&#x2F; ...expand z to at least zlen... copy(z[len(x):], y) return z&#125; 为了避免重复，和前面相同的代码并没有显示。 Slice内存技巧 让我们看看更多的例子，比如旋转slice、反转slice或在slice原有内存空间修改元素。给定一个字符串列表，下面的nonempty函数将在原有slice内存空间之上返回不包含空字符串的列表： 123456789101112131415161718&#x2F;&#x2F; Nonempty is an example of an in-place slice algorithm.package mainimport &quot;fmt&quot;&#x2F;&#x2F; nonempty returns a slice holding only the non-empty strings.&#x2F;&#x2F; The underlying array is modified during the call.func nonempty(strings []string) []string &#123; i :&#x3D; 0 for _, s :&#x3D; range strings &#123; if s !&#x3D; &quot;&quot; &#123; strings[i] &#x3D; s i++ &#125; &#125; return strings[:i]&#125; 比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样： data := []string{“one”, “”, “three”} fmt.Printf(&quot;%q\\n&quot;, nonempty(data)) // [&quot;one&quot; &quot;three&quot;] fmt.Printf(&quot;%q\\n&quot;, data) // [&quot;one&quot; &quot;three&quot; &quot;three&quot;] 因此我们通常会这样使用nonempty函数：data = nonempty(data)。 nonempty函数也可以使用append函数实现： 123456789func nonempty2(strings []string) []string &#123; out :&#x3D; strings[:0] &#x2F;&#x2F; zero-length slice of original for _, s :&#x3D; range strings &#123; if s !&#x3D; &quot;&quot; &#123; out &#x3D; append(out, s) &#125; &#125; return out&#125; 无论如何实现，以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值，事实上很多这类算法都是用来过滤或合并序列中相邻的元素。这种slice用法是比较复杂的技巧，虽然使用到了slice的一些技巧，但是对于某些场合是比较清晰和有效的。 一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack： stack = append(stack, v) // push v stack的顶部位置对应slice的最后一个元素： top := stack[len(stack)-1] // top of stack 通过收缩stack可以弹出栈顶的元素 stack = stack[:len(stack)-1] // pop 要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成： func remove(slice []int, i int) []int { copy(slice[i:], slice[i+1:]) return slice[:len(slice)-1] } func main() { s := []int{5, 6, 7, 8, 9} fmt.Println(remove(s, 2)) // “[5 6 8 9]” } 如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素： func remove(slice []int, i int) []int { slice[i] = slice[len(slice)-1] return slice[:len(slice)-1] } func main() { s := []int{5, 6, 7, 8, 9} fmt.Println(remove(s, 2)) // &quot;[5 6 9 8] }","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"solidity智能合约[22]-地址","slug":"solidity-22-addressAndPayable","date":"2018-11-19T16:44:11.000Z","updated":"2018-11-20T16:36:52.755Z","comments":true,"path":"2018/11/20/solidity-22-addressAndPayable/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-22-addressAndPayable/","excerpt":"","text":"地址 solidity语言中有账户的概念，solidity语言中有两类账户。一类是合约账户、一类是外部账户。账户都有地址。地址为160位。 定义地址 address public account1 = 0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB; address public account2 = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c; address底层以uint160存储 123456function changeIt() view public returns(uint160)&#123; return uint160(account2);&#x2F;&#x2F;428365927726247537526132020791190998556166378203 &#125; function changeIt2() pure public returns(address)&#123; return address(1154414090619811796818182302139415280051214250812);&#x2F;&#x2F;0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB&#125; 地址比较 地址可以进行比较，和整数比较大小类似。 1234567891011121314function check1() view public returns(bool)&#123; return account1&gt;account2; &#125; function check2() view public returns(bool)&#123; return account1&gt;&#x3D;account2; &#125; function check3() view public returns(bool)&#123; return account1&lt;&#x3D;account2; &#125; function check4() view public returns(bool)&#123; return account1&lt;&#x3D;account2; &#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[21]-数组字面量","slug":"solidity-21-arrayiterator","date":"2018-11-19T16:20:07.000Z","updated":"2018-11-20T16:36:56.517Z","comments":true,"path":"2018/11/20/solidity-21-arrayiterator/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-21-arrayiterator/","excerpt":"","text":"数组字面量特点 1、数组字面量类似与一个常量数组，不能修改大小和长度，例如[1,2,3] 2、数组字面量满足最小匹配原则，意味着[1,2,3]存储的类型为uint8，[256,2,3]存储的类型为uint16。Solidity会自动的匹配最小的能够容纳的类型 3、如果要改变类型的大小，如[1,2,3]中类型为uint256，那么我们可以强制转换为[uint(1),2,3]。 代码例子如下 1234567891011121314151617181920212223242526272829303132333435pragma solidity ^0.4.23;contract ArrayLiterals&#123; // function getarrayLiteratel() returns(uint[3])&#123; // return [1,2,3]; // &#125; // function getarrayLiteratel() returns(uint[3])&#123; // return [256,2,3]; // &#125; function getarrayLiteratel() public pure returns(uint8[3])&#123; return [1,2,3]; &#125; function getarrayLiteratel2() public pure returns(uint16[3])&#123; return [256,2,3]; &#125; function getarrayLiteratel3() public pure returns(uint[3])&#123; return [uint(1),2,3]; &#125; //可以传递数组字面量，在remix调用栏中输入[1,2,3] function getarrayLiteratel3(uint[3] grade) public pure returns(uint)&#123; uint sum = 0; for(uint i = 0;i&lt;grade.length;i++)&#123; sum+=grade[i]; &#125; return sum; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[20]-动态二维数组","slug":"solidity-20-dynamictwoarray","date":"2018-11-19T16:11:58.000Z","updated":"2018-11-20T16:37:00.208Z","comments":true,"path":"2018/11/20/solidity-20-dynamictwoarray/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-20-dynamictwoarray/","excerpt":"","text":"动态二维数组定义 uint[][] public grade = [[60,80],[40,20],[50,50]]; 获取长度 123456789function getLength() view public returns(uint)&#123; return grade.length; &#125; function getLength2() view public returns(uint)&#123; return grade[0].length; &#125; 修改长度 12345678910111213141516function changeLength() public&#123; grade.length = 4; &#125; function changeLength2() public&#123; grade.length =2; &#125; function changeLength3() public&#123; grade[0].length =3; &#125; function changeLength4() public&#123; grade[0].length =1; &#125; 添加修改内容 1234567function changeContent() public&#123; grade[1][0] = 100; &#125; function changeContent2() public&#123; grade.push([100,90]); &#125; 遍历内容 12345678910//获取内容并求和function add() view public returns(uint)&#123; uint sum = 0; for(uint i = 0;i&lt;3;i++)&#123; for(uint j = 0;j&lt;2;j++)&#123; sum+= grade[i][j]; &#125; &#125; return sum;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[19]-for循环","slug":"solidity-19-for","date":"2018-11-19T16:05:59.000Z","updated":"2018-11-20T16:37:04.578Z","comments":true,"path":"2018/11/20/solidity-19-for/","link":"","permalink":"https://dreamerjonson.com/2018/11/20/solidity-19-for/","excerpt":"","text":"for for 语句为&quot;当型&quot;循环结构。 for语句的语法为： 123for ( 表达式 1; 表达式 2; 表达式)&#123; 语句&#125; 说明： 表达式 1为循环变量赋初始值。 表达式 2为循环条件。 表达式 3为循环变量增值。 for循环打印斐波拉耶数列 123456789101112131415161718192021pragma solidity ^0.4.23;contract forTest&#123; //0,1,1,2,3,5,8,13,21 uint[] public arr=[1,1]; function getArr() public view returns(uint[])&#123; return arr; &#125; function fab() public&#123; for(uint i = 0;i&lt;10;i++)&#123; uint an = arr[arr.length-1]; uint bn = arr[arr.length-2]; uint sum = an+bn; arr.push(sum); &#125; &#125;&#125; 二维数组遍历与解释 1234567891011121314151617181920212223242526272829 uint[2][3] grade = [[60,80],[40,20],[50,50]];//获取内容并求和function add() view public returns(uint)&#123; uint sum = 0; //定义的时候和获取数据的时候有些差别，在获取数据的时候，第一个数字i代表的是i+1元素，第二个数据j代表的是i+1个元素内的第j+1个内容 //1、 i = 0 i&lt;3 //2、j=0 j &lt;2 //3、sum += grade[0][0];、sum += 60; //4、j++----&gt;j=1; //5.j&lt;2? //6.sum+=grade[0][1];sum += 80 //7.j++------j=2; //8.j&lt;2 //9.i++ ---&gt;i=1; //10.i&lt;3 //11.j = 0 //12.j&lt;2? //13.sum += grade[1][0] //14.j++ //15......... //最后遍历了grade[0][0]，grade[0][1]，grade[1][0]，grade[1][1]，grade[2][0]，grade[2][1] for(uint i = 0;i&lt;3;i++)&#123; for(uint j = 0;j&lt;2;j++)&#123; sum+= grade[i][j]; &#125; &#125; return sum;&#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[18]-twoarray","slug":"solidity-18-twoarray","date":"2018-11-19T15:56:34.000Z","updated":"2018-11-20T16:37:08.105Z","comments":true,"path":"2018/11/19/solidity-18-twoarray/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/solidity-18-twoarray/","excerpt":"","text":"二维数组定义 1uint[2][3] grade &#x3D; [[60,80],[40,20],[50,50]]; 返回二维数组 1234function getGrade() view public returns(uint[2][3])&#123; return grade;&#125; 获取二维数组长度 123456789function getLength() view public returns(uint)&#123; return grade.length;&#125; function getLength2() view public returns(uint)&#123; return grade[0].length;&#125; 改变内容 1234567function changeContent() public &#123; grade[0][1] &#x3D; 100; &#x2F;&#x2F; grade.push(ericGrade); &#x2F;&#x2F; grade[0][2]&#x3D;90; &#125; 完整代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374pragma solidity ^0.4.23;contract twoArray&#123; // uint[2] jonsongrade = [60,80]; uint[2] ericGrade = [40,20]; // uint[2] stevenGrade = [50,50]; uint[2][3] grade = [[60,80],[40,20],[50,50]]; function getGrade() view public returns(uint[2][3])&#123; return grade; &#125; function getLength() view public returns(uint)&#123; return grade.length; &#125; function getLength2() view public returns(uint)&#123; return grade[0].length; &#125; // function changelength() public &#123; // grade[0].length =10; // &#125; function changeContent() public &#123; grade[0][1] = 100; // grade.push(ericGrade); // grade[0][2]=90; &#125; //获取内容并求和 function add() view public returns(uint)&#123; uint sum = 0; //定义的时候和获取数据的时候有些差别，在获取数据的时候，第一个数字i代表的是i+1元素，第二个数据j代表的是i+1个元素内的第j+1个内容 //1、 i = 0 i&lt;3 //2、j=0 j &lt;2 //3、sum += grade[0][0];、sum += 60; //4、j++----&gt;j=1; //5.j&lt;2? //6.sum+=grade[0][1];sum += 80 //7.j++------j=2; //8.j&lt;2 //9.i++ ---&gt;i=1; //10.i&lt;3 //11.j = 0 //12.j&lt;2? //13.sum += grade[1][0] //14.j++ //15......... //最后遍历了grade[0][0]，grade[0][1]，grade[1][0]，grade[1][1]，grade[2][0]，grade[2][1] for(uint i = 0;i&lt;3;i++)&#123; for(uint j = 0;j&lt;2;j++)&#123; sum+= grade[i][j]; &#125; &#125; return sum; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[17]-动态长度数组","slug":"solidity-17-dynamicarray","date":"2018-11-19T15:44:41.000Z","updated":"2018-11-20T16:37:11.790Z","comments":true,"path":"2018/11/19/solidity-17-dynamicarray/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/solidity-17-dynamicarray/","excerpt":"","text":"动态长度数组 动态长度数组可以改变大小和长度 动态长度数组的定义 uint[] grade=[1,2,3,4,5]; 返回动态长度数组 123function getArray() public view returns(uint[])&#123; return grade; &#125; 获取动态数组长度 123function getlength() public view returns(uint)&#123; return grade.length;&#125; 遍历动态长度数组 123456789function cheng() public view returns(uint)&#123; uint result = 1; for(uint i = 0;i&lt;grade.length;i++)&#123; result *= grade[i]; // result = result * grade[i] &#125; return result;&#125; 改变动态数组长度 123456789101112//截断function changeLength() public &#123; grade.length = 3;&#125; function changeLength2() public &#123; grade.length = 5;&#125; function pushelement() public &#123; grade.push(99);&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[16]-固定长度数组","slug":"solidity-16-fixarray","date":"2018-11-19T15:35:40.000Z","updated":"2018-11-20T16:37:15.352Z","comments":true,"path":"2018/11/19/solidity-16-fixarray/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/solidity-16-fixarray/","excerpt":"","text":"数组 内存中的一片连续区域 定义 12int[7] math;bytes2[3] bytesTest; 赋值 1uint[5] public grade &#x3D;[1,2,3,4,5]; 修改内容 123function init2() public &#123; bytesTest[1] &#x3D; 0x6a6f;&#125; 返回数组 1234function getArray2() public view returns(bytes2[3])&#123;return bytesTest;&#125; 获取数组长度 1234function getlength() public view returns(uint)&#123; return grade.length; &#125; 数组遍历求和 1234567function add() public view returns(uint)&#123; uint sum&#x3D; 0 ; for(uint i &#x3D; 0;i&lt;5;i++)&#123; sum+&#x3D;grade[i]; &#125; return sum;&#125; 错误代码 固定数组不能修改大小和内容 1234567891011&#x2F;&#x2F; function getlength2() public&#123;&#x2F;&#x2F; grade.length &#x3D;90;&#x2F;&#x2F; &#125;&#x2F;&#x2F; function pushelement() public &#123;&#x2F;&#x2F; grade.push(90);&#x2F;&#x2F; &#125; 完整例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152pragma solidity ^0.4.23;contract arrayTest&#123; uint[5] public grade =[1,2,3,4,5]; int[7] math; bytes2[3] bytesTest; function init2() public &#123; bytesTest[1] = 0x6a6f; &#125; function getArray2() public view returns(bytes2[3])&#123; return bytesTest; &#125; function init() public &#123; grade[0] = 100; grade[1] = 200; &#125; function getArray() public view returns(uint[5])&#123; return grade; &#125; function add() public view returns(uint)&#123; uint sum= 0 ; for(uint i = 0;i&lt;5;i++)&#123; sum+=grade[i]; &#125; return sum; &#125; function getlength() public view returns(uint)&#123; return grade.length; &#125; // function getlength2() public&#123; // grade.length =90; // &#125; // function pushelement() public &#123; // grade.push(90); // &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[15]-fixtostring","slug":"solidity-15-fixtostring","date":"2018-11-19T15:24:30.000Z","updated":"2018-11-20T16:37:19.032Z","comments":true,"path":"2018/11/19/solidity-15-fixtostring/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/solidity-15-fixtostring/","excerpt":"","text":"固定字节数组转string 固定字节数组转换为string没有好的办法，必须要首先将固定字节数组转换为动态字节数组，再将动态字节数组转换为string 123456789101112//bytes2 -&gt; bytes ----&gt;string function fixtostr(bytes32 _newname) pure public returns(string)&#123; bytes memory newName = new bytes(_newname.length); for(uint i = 0;i&lt;newName.length;i++)&#123; newName[i] = _newname[i]; &#125; return string(newName);&#125; 上面的函数传递0x6a6f的时候，返回的结果为&quot;bytes32 newname&quot;: &quot;0x6a6f000000000000000000000000000000000000000000000000000000000000 这显然不是我们想要的。这是由于新建的动态数组的长度为32的原因。下面对其进行改进： 123456789101112131415161718function fixtostr2(bytes32 _newname) pure public returns(string)&#123; //计数 uint count = 0 ; for(uint i = 0;i&lt;_newname.length;i++)&#123; bytes1 ch = _newname[i]; if(ch !=0)&#123; count++; &#125; &#125; bytes memory name2 = new bytes(count); for(uint j = 0;j&lt;name2.length;j++)&#123; name2[j] = _newname[j]; &#125; return string(name2);&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[14]-动态字节数组转换为string","slug":"solidity-14-dynamictostring","date":"2018-11-19T15:19:50.000Z","updated":"2018-11-20T16:37:22.966Z","comments":true,"path":"2018/11/19/solidity-14-dynamictostring/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/solidity-14-dynamictostring/","excerpt":"","text":"动态字节数组转换为string 动态字节数组可以通过string(name)非常直接的转换为string类型，下面为例子： 1234567891011121314pragma solidity ^0.4.23;contract dynamicTostring&#123; bytes name = new bytes(2); function InitName() public&#123; name[0] = 0x6a; name[1] = 0x6f; &#125; function dynamictostr() view public returns(string)&#123; return string(name); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[13]-固定字节数组转动态字节数组","slug":"solidity-13-fixtodynamic","date":"2018-11-19T15:11:30.000Z","updated":"2018-11-20T16:37:27.818Z","comments":true,"path":"2018/11/19/solidity-13-fixtodynamic/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/solidity-13-fixtodynamic/","excerpt":"","text":"固定字节数组转动态字节数组 要将固定长度的字节数组转换为动态长度的字节数组，需要首先创建动态数组，并挨个赋值。 12345678910111213141516pragma solidity ^0.4.23;contract fixTodynamic&#123; bytes6 name = 0x6a6f6e736f6e; function Todynamic() view public returns(bytes)&#123; //return bytes(name); bytes memory newName = new bytes(name.length); //for循环挨个赋值 for(uint i = 0;i&lt;name.length;i++)&#123; newName[i] = name[i]; &#125; return newName; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[12]-固定字节数组相互转换","slug":"solidity-12-fixByteConvertion","date":"2018-11-19T15:00:32.000Z","updated":"2018-11-20T16:37:31.871Z","comments":true,"path":"2018/11/19/solidity-12-fixByteConvertion/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/solidity-12-fixByteConvertion/","excerpt":"","text":"固定字节数组相互转换 固定长度字节数组之间能够进行相互转换 1234567891011121314151617181920pragma solidity ^0.4.23;contract fixTofix&#123; bytes6 name = 0x6a6f6e736f6e; //bytes1: 0x6a function Tobytes1() view public returns(bytes1)&#123; return bytes1(name); &#125; //bytes2: 0x6a6f function Tobytes2() view public returns(bytes2)&#123; return bytes2(name); &#125; // bytes8: 0x6a6f6e736f6e0000 function Tobytes3() view public returns(bytes8)&#123; return bytes8(name); &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"go语言渐入佳境[12]-array","slug":"golang-12-array","date":"2018-11-19T11:06:51.000Z","updated":"2019-02-15T14:42:22.021Z","comments":true,"path":"2018/11/19/golang-12-array/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/golang-12-array/","excerpt":"","text":"数组声明与定义 1234&#x2F;&#x2F;声明三种方式var arr [3]intvar arr2 &#x3D; [4]int&#123;1,2,3,4&#125;arr4 :&#x3D;[...] int&#123;2,3,4&#125; 打印数组 1fmt.Println(arr4) 数组类型 1fmt.Printf(&quot;类型arr3: %T,类型arr4: %T\\n&quot;,arr3,arr4) 数组长度与下标 12fmt.Println(&quot;arr3的长度为：&quot;,len(arr3))fmt.Println(&quot;arr3的下标为2：&quot;,arr3[2]) ##遍历数组两种方式 12345678910&#x2F;&#x2F;遍历数组for i:&#x3D;0;i&lt;len(arr3);i++&#123; fmt.Println(arr3[i])&#125;&#x2F;&#x2F;遍历数组2for _,value:&#x3D;range arr3&#123; fmt.Println(value)&#125; 冒泡排序 1234567891011121314151617181920212223//冒泡排序func array()&#123; arr :=[10]int&#123;1,3,2,4,9,2,6,5,4,8&#125; fmt.Println(\"一开始：\",arr) for i:=0;i&lt;len(arr)-1;i++&#123; for j:=0;j&lt;len(arr)-1-i;j++&#123; if(arr[j] &gt;arr[j+1])&#123; temp:=arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; fmt.Println(arr) &#125; &#125; fmt.Println(\"结束：\",arr)&#125; 二维数组 1234567891011func twoarray()&#123; a :=[3][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125; for i:=0;i&lt;len(a);i++&#123; for j:=0;j&lt;len(a[0]);j++&#123; fmt.Printf(\"a[%d][%d]=%d\\n\",i,j,a[i][j]) &#125; &#125;&#125; 全部例子代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport \"fmt\"//声明var arr [3]intvar arr2 = [4]int&#123;1,2,3,4&#125;func main()&#123; arr3 := [4]float64&#123;1,2,3,4&#125; fmt.Println(arr3) arr4 :=[...] int&#123;2,3,4&#125; fmt.Println(arr4) fmt.Printf(\"类型arr3: %T,类型arr4: %T\\n\",arr3,arr4) fmt.Println(\"arr3的长度为：\",len(arr3)) fmt.Println(\"arr3的下标为2：\",arr3[2]) //遍历数组 for i:=0;i&lt;len(arr3);i++&#123; fmt.Println(arr3[i]) &#125; //遍历数组2 for _,value:=range arr3&#123; fmt.Println(value) &#125; array() twoarray()&#125;//冒泡排序func array()&#123; arr :=[10]int&#123;1,3,2,4,9,2,6,5,4,8&#125; fmt.Println(\"一开始：\",arr) for i:=0;i&lt;len(arr)-1;i++&#123; for j:=0;j&lt;len(arr)-1-i;j++&#123; if(arr[j] &gt;arr[j+1])&#123; temp:=arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; fmt.Println(arr) &#125; &#125; fmt.Println(\"结束：\",arr)&#125;func twoarray()&#123; a :=[3][3]int&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125; for i:=0;i&lt;len(a);i++&#123; for j:=0;j&lt;len(a[0]);j++&#123; fmt.Printf(\"a[%d][%d]=%d\\n\",i,j,a[i][j]) &#125; &#125;&#125; 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。 数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。 12345678910111213var a [3]int // array of 3 integersfmt.Println(a[0]) // print the first elementfmt.Println(a[len(a)-1]) // print the last element, a[2]// Print the indices and elements.for i, v := range a &#123; fmt.Printf(\"%d %d\\n\", i, v)&#125;// Print the elements only.for _, v := range a &#123; fmt.Printf(\"%d\\n\", v)&#125; 默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组： var q [3]int = [3]int{1, 2, 3} var r [3]int = [3]int{1, 2} fmt.Println(r[2]) // “0” 在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为 q := […]int{1, 2, 3} fmt.Printf(&quot;%T\\n&quot;, q) // “[3]int” 数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。 q := [3]int{1, 2, 3} q = [4]int{1, 2, 3, 4} // compile error: cannot assign [4]int to [3]int 我们将会发现，数组、slice、map和结构体字面值的写法都很相似。上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样： type Currency int const ( USD Currency = iota // 美元 EUR // 歐元 GBP // 英鎊 RMB // 人民幣 ) symbol := […]string{USD: “$”, EUR: “€”, GBP: “￡”, RMB: “￥”} fmt.Println(RMB, symbol[RMB]) // “3 ￥” 在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。例如， r := […]int{99: -1} 定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。 如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。 a := [2]int{1, 2} b := […]int{1, 2} c := [2]int{1, 3} fmt.Println(a == b, a == c, b == c) // “true false false” d := [3]int{1, 2} fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int 作为一个眞实的例子，crypto/sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）；如果消息摘要不同，那么消息本身必然也是不同的。下面的例子用SHA256算法分别生成“x”和“X”两个信息的摘要： 12345678910111213import &quot;crypto&#x2F;sha256&quot;func main() &#123; c1 :&#x3D; sha256.Sum256([]byte(&quot;x&quot;)) c2 :&#x3D; sha256.Sum256([]byte(&quot;X&quot;)) fmt.Printf(&quot;%x\\n%x\\n%t\\n%T\\n&quot;, c1, c2, c1 &#x3D;&#x3D; c2, c1) &#x2F;&#x2F; Output: &#x2F;&#x2F; 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881 &#x2F;&#x2F; 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015 &#x2F;&#x2F; false &#x2F;&#x2F; [32]uint8&#125; 上面例子中，两个消息虽然只有一个字符的差异，但是生成的消息摘要则几乎有一半的bit位是不相同的。需要注意Printf函数的%x副词参数，它用于指定以十六进制的格式打印数组或slice全部的元素，%t副词参数是用于打印布尔型数据，%T副词参数是用于显示一个值对应的数据类型。 当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。 当然，我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。下面的函数用于给[32]byte类型的数组清零： 123456789func zero(ptr *[32]byte) &#123; for i := range ptr &#123; ptr[i] = 0 &#125;&#125;//其实数组字面值[32]byte&#123;&#125;就可以生成一个32字节的数组。而且每个数组的元素都是零值初始化，也就是0。因此，我们可以将上面的zero函数写的更简洁一点：func zero(ptr *[32]byte) &#123; *ptr = [32]byte&#123;&#125;&#125; 虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的zero函数并不能接收指向[16]byte类型数组的指针，而且也没有任何添加或删除数组元素的方法。由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[11]-function2","slug":"golang-11-function2","date":"2018-11-19T07:18:21.000Z","updated":"2018-11-20T02:43:42.178Z","comments":true,"path":"2018/11/19/golang-11-function2/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/golang-11-function2/","excerpt":"","text":"匿名函数 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\" \"math\")//匿名函数func main()&#123; //无参匿名函数 func()&#123; fmt.Println(\"jonson\") &#125;() //有参匿名函数 func(data int)&#123; fmt.Println(\"data:\",data) &#125;(5) //有返回值的匿名函数 result:=func(data float64) float64&#123; return math.Sqrt(data) &#125;(9) fmt.Println(\"result:\",result) //函数表达式 greet:=func()&#123; fmt.Println(\"greet jonson\") &#125; greet() fmt.Printf(\"greet的类型是%T\\n\",greet) 闭包 1234567891011func greetjonson()&#123; x:=0 increment:= func() int&#123; x++ return x &#125; fmt.Println(increment()) fmt.Println(increment())&#125; 函数作为返回值 123456func makeGreeter() func() string&#123; return func() string &#123; return \"hello jonson\" &#125;&#125; 闭包与函数返回值 1234567func makeEvenGenerator() func() int&#123; i:=0 return func() int&#123; i+=2 return i &#125;&#125; callback函数作为参数 123456func visit(numbers []int,callback func(int))&#123; for _,n :=range numbers&#123; callback(n) &#125;&#125; 递归 12345678910111213141516171819202122// 计算阶乘 5 5*4*3*2*1func factorial(x uint) uint&#123; if x==0&#123; return 1 &#125; return x * factorial(x-1)&#125;// factorial(5) //120// returns: 5 * factorial(4)// factorial(4) /24// returns: 4 * factorial(3)// factorial(3) //6// returns: 3 * factorial(2)// factorial(2) //2// returns: 2 * factorial(1)// factorial(1) //1// returns: 1 * factorial(0)// factorial(0)// returns: 1 所有例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package mainimport ( \"fmt\" \"math\")//匿名函数func main()&#123; //无参匿名函数 func()&#123; fmt.Println(\"jonson\") &#125;() //有参匿名函数 func(data int)&#123; fmt.Println(\"data:\",data) &#125;(5) //有返回值的匿名函数 result:=func(data float64) float64&#123; return math.Sqrt(data) &#125;(9) fmt.Println(\"result:\",result) greet:=func()&#123; fmt.Println(\"greet jonson\") &#125; greet() fmt.Printf(\"greet的类型是%T\\n\",greet) //闭包 greetjonson() //函数作为返回值 makejonson := makeGreeter() fmt.Printf(\"类型：%T，返回值：%v\\n\",makejonson,makejonson()) //闭包做为返回值 makeeven := makeEvenGenerator() fmt.Println(\"makeeven i = \",makeeven()) fmt.Println(\"makeeven i = \",makeeven()) fmt.Println(\"makeeven i = \",makeeven()) //callback函数作为参数 visit([]int&#123;1,2,3,4&#125;,func(n int)&#123; fmt.Println(n+1) &#125;) //死循环 fmt.Println(factorial(5)) var i uint = 0 for ;i&lt;20;i++&#123; fmt.Println(fabicc(i)) &#125;&#125;//闭包func greetjonson()&#123; x:=0 increment:= func() int&#123; x++ return x &#125; fmt.Println(increment()) fmt.Println(increment())&#125;//函数作为返回值func makeGreeter() func() string&#123; return func() string &#123; return \"hello jonson\" &#125;&#125;//闭包与函数返回值func makeEvenGenerator() func() int&#123; i:=0 return func() int&#123; i+=2 return i &#125;&#125;//callback函数作为参数func visit(numbers []int,callback func(int))&#123; for _,n :=range numbers&#123; callback(n) &#125;&#125;//递归// 计算阶乘 5 5*4*3*2*1func factorial(x uint) uint&#123; if x==0&#123; return 1 &#125; return x * factorial(x-1)&#125;//fabiccfunc fabicc(x uint) uint&#123; if(x==0)&#123; return 0 &#125; if(x==1)&#123; return 1 &#125; return fabicc(x-2) + fabicc(x-1)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[10]-function","slug":"golang-10-function","date":"2018-11-19T07:13:43.000Z","updated":"2019-02-23T09:12:30.718Z","comments":true,"path":"2018/11/19/golang-10-function/","link":"","permalink":"https://dreamerjonson.com/2018/11/19/golang-10-function/","excerpt":"","text":"函数的开括号{必须与函数的结尾在同一行，不是在一行上 无参函数 123func printstring()&#123; fmt.Println(\"hello jonson\")&#125; 带参函数 123func add(a,b int)&#123; fmt.Println(\"a+b=\",a+b)&#125; 返回值 123func addres(a,b int) int&#123; return a+b&#125; 有名字的返回值 1234func addresname(a,b int)(sum int)&#123; sum = a+b return&#125; 多返回值 123456func addmuti(a,b int)(int,int)&#123; add := a+b mul:= a*b return add,mul&#125; 不定个数参数 1234567func addsum(nums ... int) int&#123; var sum int for _,value :=range nums&#123; sum +=value &#125; return sum&#125; 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package mainimport \"fmt\"func main()&#123; printstring() add(2,4) fmt.Println(\"addres 6+7 = \",addres(6,7)) fmt.Println(\"addresname 3+4 = \",addresname(3,4)) add,sum :=addmuti(5,6) fmt.Printf(\"addmuti 5+6=%d,5*6=%d\\n\",add,sum) ADDsum := addsum(1,2,3,4,5) fmt.Println(\"addsum = \",ADDsum)&#125;//无参函数func printstring()&#123; fmt.Println(\"hello jonson\")&#125;//带参函数 func add(a,b int)&#123; fmt.Println(\"a+b=\",a+b) &#125;//返回值func addres(a,b int) int&#123; return a+b&#125;// 有名字的返回值func addresname(a,b int)(sum int)&#123; sum = a+b return&#125;//多返回值func addmuti(a,b int)(int,int)&#123; add := a+b mul:= a*b return add,mul&#125;//不定个数参数func addsum(nums ... int) int&#123; var sum int for _,value :=range nums&#123; sum +=value &#125; return sum&#125;函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。func name(parameter-list) (result-list) &#123; body&#125;形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。在hypot函数中,func hypot(x, y float64) float64 &#123; return math.Sqrt(x*x + y*y)&#125;fmt.Println(hypot(3,4)) // \"5\"x和y是形参名,3和4是调用时的传入的实数，函数返回了一个float64类型的值。返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为0。如果一个函数在声明时，包含返回值列表，该函数必须以return语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了panic异常或函数中存在无限循环。正如hypot一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的：func f(i, j, k int, s, t string) &#123; /* ... */ &#125;func f(i int, j int, k int, s string, t string) &#123; /* ... */ &#125;下面，我们给出4种方法声明拥有2个int型参数和1个int型返回值的函数.blank identifier(译者注：卽下文的_符号)可以强调某个参数未被使用。func add(x int, y int) int &#123;return x + y&#125;func sub(x, y int) (z int) &#123; z = x - y; return&#125;func first(x int, _ int) int &#123; return x &#125;func zero(int, int) int &#123; return 0 &#125;fmt.Printf(\"%T\\n\", add) // \"func(int, int) int\"fmt.Printf(\"%T\\n\", sub) // \"func(int, int) int\"fmt.Printf(\"%T\\n\", first) // \"func(int, int) int\"fmt.Printf(\"%T\\n\", zero) // \"func(int, int) int\"函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的简介引用被修改。你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。package mathfunc Sin(x float64) float //implemented in assembly language 函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。 递归 函数可以是递归的，这意味着函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在4.4节，我们通过遍历二叉树来实现简单的插入排序，在本章节，我们再次使用它来处理HTML文件。 下文的示例代码使用了非标准包golang.org/x/net/html ，解析HTML。golang.org/x/… 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。 例子中调用golang.org/x/net/html的部分api如下所示。html.Parse函数读入一组bytes.解析后，返回html.node类型的HTML页面树状结构根节点。HTML拥有很多类型的结点如text（文本）,commnets（注释）类型，在下面的例子中，我们只关注&lt; name key=‘value’ &gt;形式的结点。 12345678910111213141516171819202122232425package htmltype Node struct &#123; Type NodeType Data string Attr []Attribute FirstChild, NextSibling *Node&#125;type NodeType int32const ( ErrorNode NodeType &#x3D; iota TextNode DocumentNode ElementNode CommentNode DoctypeNode)type Attribute struct &#123; Key, Val string&#125;func Parse(r io.Reader) (*Node, error) main函数解析HTML标准输入，通过递归函数visit获得links（链接），并打印出这些links： 1234567891011121314151617181920&#x2F;&#x2F; Findlinks1 prints the links in an HTML document read from standard input.package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;golang.org&#x2F;x&#x2F;net&#x2F;html&quot;)func main() &#123; doc, err :&#x3D; html.Parse(os.Stdin) if err !&#x3D; nil &#123; fmt.Fprintf(os.Stderr, &quot;findlinks1: %v\\n&quot;, err) os.Exit(1) &#125; for _, link :&#x3D; range visit(nil, doc) &#123; fmt.Println(link) &#125;&#125; visit函数遍历HTML的节点树，从每一个anchor元素的href属性获得link,将这些links存入字符串数组中，并返回这个字符串数组。 // visit appends to links each link found in n and returns the result. 12345678910111213func visit(links []string, n *html.Node) []string &#123; if n.Type &#x3D;&#x3D; html.ElementNode &amp;&amp; n.Data &#x3D;&#x3D; &quot;a&quot; &#123; for _, a :&#x3D; range n.Attr &#123; if a.Key &#x3D;&#x3D; &quot;href&quot; &#123; links &#x3D; append(links, a.Val) &#125; &#125; &#125; for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123; links &#x3D; visit(links, c) &#125; return links&#125; 为了遍历结点n的所有后代结点，每次遇到n的孩子结点时，visit递归的调用自身。这些孩子结点存放在FirstChild链表中。 让我们以Go的主页（golang.org）作为目标，运行findlinks。我们以fetch（1.5章）的输出作为findlinks的输入。下面的输出做了简化处理。 $ go build gopl.io/ch1/fetch $ go build gopl.io/ch5/findlinks1 $ ./fetch https://golang.org | ./findlinks1 /doc/ /pkg/ /help/ /blog/ http://play.golang.org/ //tour.golang.org/ https://golang.org/dl/ //blog.golang.org/ /LICENSE /doc/tos.html http://www.google.com/intl/en/policies/privacy/ 注意在页面中出现的链接格式，在之后我们会介绍如何将这些链接，根据根路径（https://golang.org）生成可以直接访问的url。 在函数outline中，我们通过递归的方式遍历整个HTML结点树，并输出树的结构。在outline内部，每遇到一个HTML元素标签，就将其入栈，并输出。 1234567891011121314151617func main() &#123; doc, err :&#x3D; html.Parse(os.Stdin) if err !&#x3D; nil &#123; fmt.Fprintf(os.Stderr, &quot;outline: %v\\n&quot;, err) os.Exit(1) &#125; outline(nil, doc)&#125;func outline(stack []string, n *html.Node) &#123; if n.Type &#x3D;&#x3D; html.ElementNode &#123; stack &#x3D; append(stack, n.Data) &#x2F;&#x2F; push tag fmt.Println(stack) &#125; for c :&#x3D; n.FirstChild; c !&#x3D; nil; c &#x3D; c.NextSibling &#123; outline(stack, c) &#125;&#125; 有一点值得注意：outline有入栈操作，但没有相对应的出栈操作。当outline调用自身时，被调用者接收的是stack的拷贝。被调用者的入栈操作，修改的是stack的拷贝，而不是调用者的stack,因对当函数返回时,调用者的stack并未被修改。 下面是https://golang.org页面的简要结构: $ go build gopl.io/ch5/outline $ ./fetch https://golang.org | ./outline [html] [html head] [html head meta] [html head title] [html head link] [html body] [html body div] [html body div] [html body div div] [html body div div form] [html body div div form div] [html body div div form div a] … 正如你在上面实验中所见，大部分HTML页面只需几层递归就能被处理，但仍然有些页面需要深层次的递归。 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。 递归案例 获取链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package mainimport ( \"fmt\" \"os\" \"golang.org/x/net/html\" \"io/ioutil\" \"bytes\")func main() &#123; allbyte,_:= ioutil.ReadFile(\"index.html\") fmt.Println(allbyte) doc, err := html.Parse( bytes.NewReader(allbyte)) if err != nil &#123; fmt.Fprintf(os.Stderr, \"findlinks1: %v\\n\", err) os.Exit(1) &#125; for _, link := range visit(nil, doc) &#123; fmt.Println(link) &#125;&#125;//!-main//!+visit// visit appends to links each link found in n and returns the result.func visit(links []string, n *html.Node) []string &#123; if n.Type == html.ElementNode &amp;&amp; n.Data == \"a\" &#123; for _, a := range n.Attr &#123; if a.Key == \"href\" &#123; links = append(links, a.Val) &#125; &#125; &#125; for c := n.FirstChild; c != nil; c = c.NextSibling &#123; links = visit(links, c) &#125; return links&#125;//!-visit/*//!+htmlpackage htmltype Node struct &#123; Type NodeType Data string Attr []Attribute FirstChild, NextSibling *Node&#125;type NodeType int32const ( ErrorNode NodeType = iota TextNode DocumentNode ElementNode CommentNode DoctypeNode)type Attribute struct &#123; Key, Val string&#125;func Parse(r io.Reader) (*Node, error)//!-html*/ 在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。例子如下： 1234567891011121314151617181920 func square(n int) int &#123; return n * n &#125; func negative(n int) int &#123; return -n &#125; func product(m, n int) int &#123; return m * n &#125; f :&#x3D; square fmt.Println(f(3)) &#x2F;&#x2F; &quot;9&quot; f &#x3D; negative fmt.Println(f(3)) &#x2F;&#x2F; &quot;-3&quot; fmt.Printf(&quot;%T\\n&quot;, f) &#x2F;&#x2F; &quot;func(int) int&quot; f &#x3D; product &#x2F;&#x2F; compile error: can&#39;t assign func(int, int) int to func(int) int函数类型的零值是nil。调用值为nil的函数值会引起panic错误： var f func(int) int f(3) &#x2F;&#x2F; 此處f的值爲nil,會引起panic錯誤函数值可以与nil比较： var f func(int) int if f !&#x3D; nil &#123; f(3) &#125; 但是函数值之间是不可比较的，也不能用函数值作为map的key。 函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。标准库中包含许多这样的例子。下面的代码展示了如何使用这个技巧。string.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。 12345func add1(r rune) rune &#123; return r + 1 &#125;fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) &#x2F;&#x2F; &quot;IBM.:111&quot;fmt.Println(strings.Map(add1, &quot;VMS&quot;)) &#x2F;&#x2F; &quot;WNT&quot;fmt.Println(strings.Map(add1, &quot;Admix&quot;)) &#x2F;&#x2F; &quot;Benjy&quot; 可变参数 参数数量可变的函数称为为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个的必备参数，之后接收任意个数的后续参数。 在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。 1234567func sum(vals...int) int &#123; total :&#x3D; 0 for _, val :&#x3D; range vals &#123; total +&#x3D; val &#125; return total&#125; sum函数返回任意个int型参数的和。在函数体中,vals被看作是类型为[] int的切片。sum可以接收任意数量的int型参数： fmt.Println(sum()) // “0” fmt.Println(sum(3)) // “3” fmt.Println(sum(1, 2, 3, 4)) // “10” 在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。 values := []int{1, 2, 3, 4} fmt.Println(sum(values…)) // “10” 虽然在可变参数函数内部，…int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。 1234func f(...int) &#123;&#125;func g([]int) &#123;&#125;fmt.Printf(&quot;%T\\n&quot;, f) &#x2F;&#x2F; &quot;func(...int)&quot;fmt.Printf(&quot;%T\\n&quot;, g) &#x2F;&#x2F; &quot;func([]int)&quot; 可变参数函数经常被用于格式化字符串。下面的errorf函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串。 func errorf(linenum int, format string, args…interface{}) { fmt.Fprintf(os.Stderr, &quot;Line %d: &quot;, linenum) fmt.Fprintf(os.Stderr, format, args…) fmt.Fprintln(os.Stderr) } linenum, name := 12, “count” errorf(linenum, “undefined: %s”, name) // “Line 12: undefined: count” 方法 在函数声明时，在其名字之前放上一个变量，卽是一个方法。这个附加的参数会将该函数附加到这种类型上，卽相当于为这种类型定义了一个独占的方法。 下面来写我们第一个方法的例子，这个例子在package geometry下： 12345678910111213141516package geometryimport &quot;math&quot;type Point struct&#123; X, Y float64 &#125;&#x2F;&#x2F; traditional functionfunc Distance(p, q Point) float64 &#123; return math.Hypot(q.X-p.X, q.Y-p.Y)&#125;&#x2F;&#x2F; same thing, but as a method of the Point typefunc (p Point) Distance(q Point) float64 &#123; return math.Hypot(q.X-p.X, q.Y-p.Y)&#125; 上面的代码里那个附加的参数p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。 在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。 在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子： 1234p :&#x3D; Point&#123;1, 2&#125;q :&#x3D; Point&#123;4, 6&#125;fmt.Println(Distance(p, q)) &#x2F;&#x2F; &quot;5&quot;, function callfmt.Println(p.Distance(q)) &#x2F;&#x2F; &quot;5&quot;, method call 可以看到，上面的两个函数调用都是Distance，但是却没有发生冲突。第一个Distance的调用实际上用的是包级别的函数geometry.Distance，而第二个则是使用刚刚声明的Point，调用的是Point类下声明的Point.Distance方法。 这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如pX。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用pX时会有歧义(译注：这里确实挺奇怪的)。 因为每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。让我们来定义一个Path类型，这个Path代表一个线段的集合，并且也给这个Path定义一个叫Distance的方法。 123456789101112&#x2F;&#x2F; A Path is a journey connecting the points with straight lines.type Path []Point&#x2F;&#x2F; Distance returns the distance traveled along the path.func (path Path) Distance() float64 &#123; sum :&#x3D; 0.0 for i :&#x3D; range path &#123; if i &gt; 0 &#123; sum +&#x3D; path[i-1].Distance(path[i]) &#125; &#125; return sum&#125; Path是一个命名的slice类型，而不是Point那样的struct类型，然而我们依然可以为它定义方法。在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。方法可以被声明到任意类型，只要不是一个指针或者一个interface。 两个Distance方法有不同的类型。他们两个方法之间没有任何关系，尽管Path的Distance方法会在内部调用Point.Distance方法来计算每个连接邻接点的线段的长度。 让我们来调用一个新方法，计算三角形的周长： perim := Path{ {1, 1}, {5, 1}, {5, 4}, {1, 1}, } fmt.Println(perim.Distance()) // “12” 在上面两个对Distance名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。第一个例子中path[i-1]数组中的类型是Point，因此Point.Distance这个方法被调用；在第二个例子中perim的类型是Path，因此Distance调用的是Path.Distance。 对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子： 12345import &quot;gopl.io&#x2F;ch6&#x2F;geometry&quot;perim :&#x3D; geometry.Path&#123;&#123;1, 1&#125;, &#123;5, 1&#125;, &#123;5, 4&#125;, &#123;1, 1&#125;&#125;fmt.Println(geometry.PathDistance(perim)) &#x2F;&#x2F; &quot;12&quot;, standalone functionfmt.Println(perim.Distance()) &#x2F;&#x2F; &quot;12&quot;, method of geometry.Path 译注：如果我们要用方法去计算perim的distance，还需要去写全geometry的包名，和其函数名，但是因为Path这个变量定义了一个可以直接用的Distance方法，所以我们可以直接写perim. Distance()。相当于可以少打很多字，作者应该是这个意思。因为在Go里包外调用函数需要带上包名，还是挺麻烦的。 基于指针对象的方法 当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下： 1234func (p *Point) ScaleBy(factor float64) &#123; p.X *&#x3D; factor p.Y *&#x3D; factor&#125; 这个方法的名字是(*Point).ScaleBy。这里的括号是必须的；没有括号的话这个表达式可能会被理解为*(Point.ScaleBy)。 在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，卽使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。 只有类型(Point)和指向他们的指针(*Point)，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子： 12type P *intfunc (P) f() &#123; &#x2F;* ... *&#x2F; &#125; &#x2F;&#x2F; compile error: invalid receiver type 想要调用指针类型方法(*Point).ScaleBy，只要提供一个Point类型的指针卽可，像下面这样。 123456789101112r :&#x3D; &amp;Point&#123;1, 2&#125;r.ScaleBy(2)fmt.Println(*r) &#x2F;&#x2F; &quot;&#123;2, 4&#125;&quot;或者这样：p :&#x3D; Point&#123;1, 2&#125;pptr :&#x3D; &amp;ppptr.ScaleBy(2)fmt.Println(p) &#x2F;&#x2F; &quot;&#123;2, 4&#125;&quot;或者这样:p :&#x3D; Point&#123;1, 2&#125;(&amp;p).ScaleBy(2)fmt.Println(p) &#x2F;&#x2F; &quot;&#123;2, 4&#125;&quot; 不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法： p.ScaleBy(2) 编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如pX，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到： 1Point&#123;1, 2&#125;.ScaleBy(2) &#x2F;&#x2F; compile error: can&#39;t take address of Point literal 但是我们可以用一个Point这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号来取到该变量卽可。编译器在这里也会给我们隐式地插入*这个操作符，所以下面这两种写法等价的： 12pptr.Distance(q)(*pptr).Distance(q) 这里的几个例子可能让你有些困惑，所以我们总结一下：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的： 不论是接收器的实际参数和其接收器的形式参数相同，比如两者都是类型T或者都是类型*T： 12Point&#123;1, 2&#125;.Distance(q) &#x2F;&#x2F; Pointpptr.ScaleBy(2) &#x2F;&#x2F; *Point 或者接收器形参是类型T，但接收器实参是类型T，这种情况下编译器会隐式地为我们取变量的地址： p.ScaleBy(2) // implicit (&amp;p) 或者接收器形参是类型T，实参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量： pptr.Distance(q) // implicit (*pptr) 如果类型T的所有方法都是用T类型自己来做接收器(而不是*T)，那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。比如time.Duration的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。比如你对bytes.Buffer对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，但实际上其指向的对象是一致的。紧接着对拷贝后的变量进行修改可能会有让你意外的结果。 译注：作者这里说的比较绕，其实有两点： 1.不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换2.在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C艹的人这里应该很快能明白。 通过嵌入结构体来扩展类型 来看看ColoredPoint这个类型： 12345678910// type RGBA struct &#123;// R, G, B, A uint8// &#125;import \"image/color\"type Point struct&#123; X, Y float64 &#125;type ColoredPoint struct &#123; Point Color color.RGBA&#125; 我们完全可以将ColoredPoint定义为一个有三个字段的struct，但是我们却将Point这个类型嵌入到ColoredPoint来提供X和Y这两个字段。内嵌可以使我们在定义ColoredPoint时得到一种句法上的简写形式，并使其包含Point类型所具有的一切字段，然后再定义一些自己的。如果我们想要的话，我们可以直接认为通过嵌入的字段就是ColoredPoint自身的字段，而完全不需要在调用时指出Point，比如下面这样。 12345var cp ColoredPointcp.X &#x3D; 1fmt.Println(cp.Point.X) &#x2F;&#x2F; &quot;1&quot;cp.Point.Y &#x3D; 2fmt.Println(cp.Y) &#x2F;&#x2F; &quot;2&quot; 对于Point中的方法我们也有类似的用法，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，卽使ColoredPoint里没有声明这些方法： 12345678red :&#x3D; color.RGBA&#123;255, 0, 0, 255&#125;blue :&#x3D; color.RGBA&#123;0, 0, 255, 255&#125;var p &#x3D; ColoredPoint&#123;Point&#123;1, 1&#125;, red&#125;var q &#x3D; ColoredPoint&#123;Point&#123;5, 4&#125;, blue&#125;fmt.Println(p.Distance(q.Point)) &#x2F;&#x2F; &quot;5&quot;p.ScaleBy(2)q.ScaleBy(2)fmt.Println(p.Distance(q.Point)) &#x2F;&#x2F; &quot;10&quot; Point类的方法也被引入了ColoredPoint。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。 读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将Point看作一个基类，而ColoredPoint看作其子类或者继承类，或者将ColoredPoint看作&quot;is a&quot; Point类型。但这是错误的理解。请注意上面例子中对Distance方法的调用。Distance有一个参数是Point类型，但q并不是一个Point类，所以尽管q有着Point这个内嵌类型，我们也必须要显式地选择它。尝试直接传q的话你会看到下面这样的错误： p.Distance(q) // compile error: cannot use q (ColoredPoint) as Point 一个ColoredPoint并不是一个Point，但他&quot;has a&quot;Point，并且它有从Point类里引入的Distance和ScaleBy方法。如果你喜欢从实现的角度来考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的： 1234567func (p ColoredPoint) Distance(q Point) float64 &#123; return p.Point.Distance(q)&#125;func (p *ColoredPoint) ScaleBy(factor float64) &#123; p.Point.ScaleBy(factor)&#125; 当Point.Distance被第一个包装方法调用时，它的接收器值是p.Point，而不是p，当然了，在Point类的方法里，你是访问不到ColoredPoint的任何字段的。 在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中(译注：访问需要通过该指针指向的对象去取)。添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。下面这个ColoredPoint的声明内嵌了一个*Point的指针。 1234567891011type ColoredPoint struct &#123; *Point Color color.RGBA&#125;p :&#x3D; ColoredPoint&#123;&amp;Point&#123;1, 1&#125;, red&#125;q :&#x3D; ColoredPoint&#123;&amp;Point&#123;5, 4&#125;, blue&#125;fmt.Println(p.Distance(*q.Point)) &#x2F;&#x2F; &quot;5&quot;q.Point &#x3D; p.Point &#x2F;&#x2F; p and q now share the same Pointp.ScaleBy(2)fmt.Println(*p.Point, *q.Point) &#x2F;&#x2F; &quot;&#123;2 2&#125; &#123;2 2&#125;&quot; 一个struct类型也可能会有多个匿名字段。我们将ColoredPoint定义为下面这样： type ColoredPoint struct { Point color.RGBA } 然后这种类型的值便会拥有Point和RGBA类型的所有方法，以及直接定义在ColoredPoint中的方法。当编译器解析一个选择器到方法时，比如p.ScaleBy，它会首先去找直接定义在这个类型里的ScaleBy方法，然后找被ColoredPoint的内嵌字段们引入的方法，然后去找Point和RGBA的内嵌字段引入的方法，然后一直递归向下找。如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。 方法只能在命名类型(像Point)或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名struct类型来定义方法也有了手段。 下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量(§9.2)和它所操作的cache： 1234567891011var ( mu sync.Mutex &#x2F;&#x2F; guards mapping mapping &#x3D; make(map[string]string))func Lookup(key string) string &#123; mu.Lock() v :&#x3D; mapping[key] mu.Unlock() return v&#125; 下面这个版本在功能上是一致的，但将两个包级吧的变量放在了cache这个struct一组内： 1234567891011121314var cache &#x3D; struct &#123; sync.Mutex mapping map[string]string&#125;&#123; mapping: make(map[string]string),&#125;func Lookup(key string) string &#123; cache.Lock() v :&#x3D; cache.mapping[key] cache.Unlock() return v&#125; 我们给新的变量起了一个更具表达性的名字：cache。因为sync.Mutex字段也被嵌入到了这个struct里，其Lock和Unlock方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。 方法值和方法表达式 我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。p.Distance叫作“选择器”，选择器会返回一个方法&quot;值&quot;-&gt;一个将方法(Point.Distance)绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器卽可被调用；卽调用时不需要指定接收器(译注：因为已经在前文中指定过了)，只要传入函数的参数卽可： 123456789101112p :&#x3D; Point&#123;1, 2&#125;q :&#x3D; Point&#123;4, 6&#125;distanceFromP :&#x3D; p.Distance &#x2F;&#x2F; method valuefmt.Println(distanceFromP(q)) &#x2F;&#x2F; &quot;5&quot;var origin Point &#x2F;&#x2F; &#123;0, 0&#125;fmt.Println(distanceFromP(origin)) &#x2F;&#x2F; &quot;2.23606797749979&quot;, sqrt(5)scaleP :&#x3D; p.ScaleBy &#x2F;&#x2F; method valuescaleP(2) &#x2F;&#x2F; p becomes (2, 4)scaleP(3) &#x2F;&#x2F; then (6, 12)scaleP(10) &#x2F;&#x2F; then (60, 120) 在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法&quot;值&quot;会非常实用。举例来说，下面例子中的time.AfterFunc这个函数的功能是在指定的延迟时间之后来执行一个(译注：另外的)函数。且这个函数操作的是一个Rocket对象r 1234type Rocket struct &#123; &#x2F;* ... *&#x2F; &#125;func (r *Rocket) Launch() &#123; &#x2F;* ... *&#x2F; &#125;r :&#x3D; new(Rocket)time.AfterFunc(10 * time.Second, func() &#123; r.Launch() &#125;) 直接用方法&quot;值&quot;传入AfterFunc的话可以更为简短： time.AfterFunc(10 * time.Second, r.Launch) 译注：省掉了上面那个例子里的匿名函数。 和方法&quot;值&quot;相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(p.Distance)语法来指定方法的接收器。 当T是一个类型时，方法表达式可能会写作Tf或者(*T).f，会返回一个函数&quot;值&quot;，这种函数会将其第一个参数用作接收器，所以可以用通常(译注：不写选择器)的方式来对其进行调用： 1234567891011p :&#x3D; Point&#123;1, 2&#125;q :&#x3D; Point&#123;4, 6&#125;distance :&#x3D; Point.Distance &#x2F;&#x2F; method expressionfmt.Println(distance(p, q)) &#x2F;&#x2F; &quot;5&quot;fmt.Printf(&quot;%T\\n&quot;, distance) &#x2F;&#x2F; &quot;func(Point, Point) float64&quot;scale :&#x3D; (*Point).ScaleByscale(&amp;p, 2)fmt.Println(p) &#x2F;&#x2F; &quot;&#123;2 4&#125;&quot;fmt.Printf(&quot;%T\\n&quot;, scale) &#x2F;&#x2F; &quot;func(*Point, float64)&quot; // 譯註：這個Distance實際上是指定了Point對象爲接收器的一個方法func (p Point) Distance()， // 但通過Point.Distance得到的函數需要比實際的Distance方法多一個參數， // 卽其需要用第一個額外參數指定接收器，後面排列Distance方法的參數。 // 看起來本書中函數和方法的區别是指有沒有接收器，而不像其他語言那樣是指有沒有返迴值。 当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量op代表Point类型的addition或者subtraction方法，Path.TranslateBy方法会为其Path数组中的每一个Point来调用对应的方法： 12345678910111213141516171819type Point struct&#123; X, Y float64 &#125;func (p Point) Add(q Point) Point &#123; return Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;func (p Point) Sub(q Point) Point &#123; return Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;type Path []Pointfunc (path Path) TranslateBy(offset Point, add bool) &#123; var op func(p, q Point) Point if add &#123; op &#x3D; Point.Add &#125; else &#123; op &#x3D; Point.Sub &#125; for i :&#x3D; range path &#123; &#x2F;&#x2F; Call either path[i].Add(offset) or path[i].Sub(offset). path[i] &#x3D; op(path[i], offset) &#125;&#125; 封装 一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。 Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。 这也就是前面的小节中IntSet被定义为struct类型的原因，尽管它只有一个字段： type IntSet struct { words []uint64 } 当然，我们也可以把IntSet定义为一个slice类型，尽管这样我们就需要把代码中所有方法里用到的s.words用s替换掉了： type IntSet []uint64 尽管这个版本的IntSet在本质上是一样的，他也可以允许其它包中可以直接读取并编辑这个slice。换句话说，相对s这个表达式会出现在所有的包中，s.words只需要在定义IntSet的包中出现(译注：所以还是推荐后者吧的意思)。 这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。 封装提供了三方面的优点。首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值卽可。 第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。 把bytes.Buffer这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为Buffer是一个struct类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。这样在外部的调用方只能看到性能的提升，但并不会得到这个附加变量。Buffer和其增长算法我们列在这里，为了简洁性稍微做了一些精简： 123456789101112131415161718type Buffer struct &#123; buf []byte initial [64]byte &#x2F;* ... *&#x2F;&#125;&#x2F;&#x2F; Grow expands the buffer&#39;s capacity, if necessary,&#x2F;&#x2F; to guarantee space for another n bytes. [...]func (b *Buffer) Grow(n int) &#123; if b.buf &#x3D;&#x3D; nil &#123; b.buf &#x3D; b.initial[:0] &#x2F;&#x2F; use preallocated space initially &#125; if len(b.buf)+n &gt; cap(b.buf) &#123; buf :&#x3D; make([]byte, b.Len(), 2*cap(b.buf) + n) copy(buf, b.buf) b.buf &#x3D; buf &#125;&#125; 封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。比如下面的Counter类型允许调用方来增加counter变量的值，并且允许将这个值reset为0，但是不允许随便设置这个值(译注：因为压根就访问不到)： 1234type Counter struct &#123; n int &#125;func (c *Counter) N() int &#123; return c.n &#125;func (c *Counter) Increment() &#123; c.n++ &#125;func (c *Counter) Reset() &#123; c.n &#x3D; 0 &#125; 只用来访问或修改内部变量的函数被称为setter或者getter，例子如下，比如log包里的Logger类型对应的一些函数。在命名一个getter方法时，我们通常会省略掉前面的Get前缀。这种简洁上的偏好也可以推广到各种类型的前缀比如Fetch，Find或者Lookup。 12345678910package logtype Logger struct &#123; flags int prefix string &#x2F;&#x2F; ...&#125;func (l *Logger) Flags() intfunc (l *Logger) SetFlags(flag int)func (l *Logger) Prefix() stringfunc (l *Logger) SetPrefix(prefix string) Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。 封装并不总是理想的。虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，比如：time.Duration将其表现暴露为一个int64数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量： 12const day &#x3D; 24 * time.Hourfmt.Println(day.Seconds()) &#x2F;&#x2F; &quot;86400&quot;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[9]-doubleloop","slug":"golang-9-doubleloop","date":"2018-11-18T13:43:45.000Z","updated":"2018-11-20T02:43:37.442Z","comments":true,"path":"2018/11/18/golang-9-doubleloop/","link":"","permalink":"https://dreamerjonson.com/2018/11/18/golang-9-doubleloop/","excerpt":"","text":"循环嵌套 一般形式 12345678910111213package mainimport \"fmt\"func main()&#123; var sum int for i:=0;i&lt;5;i++&#123; for j:=0;j&lt;3;j++&#123; sum = i*j &#125; &#125; fmt.Println(sum)&#125; 双for循环案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package mainimport ( \"fmt\")var lines = 9func main() &#123; // 打印矩形 printRectangle() //打印左下直角三角形 printRightTriangleLB() //打印左上直角三角形 printRightTriangleLT() // 打印右下直角三角形 printRightTriangleRB() // 打印右上直角三角形 printRightTriangleRT() // 打印等腰三角形 printEqualTriangle() // 打印九九乘法表 multiple99()&#125;//1、打印矩形func printRectangle() &#123; fmt.Println(\"\\n打印矩形\") for i := 1; i &lt;= lines; i++ &#123; for j := 1; j &lt;= lines; j++ &#123; fmt.Print(\"❤ \") &#125; fmt.Println() &#125;&#125;//2、打印左下直角三角形func printRightTriangleLB() &#123; fmt.Println(\"\\n打印左下直角三角形\") for i := 1; i &lt;= lines; i++ &#123; for j := 1; j &lt;= i; j++ &#123; fmt.Print(\"❤ \") &#125; fmt.Println() &#125;&#125;//3、打印左上直角三角形func printRightTriangleLT() &#123; fmt.Println(\"\\n打印左上直角三角形\") for i := 1; i &lt;= lines; i++ &#123; for j := lines; j &gt;= i; j-- &#123; fmt.Print(\"❤ \") &#125; fmt.Println() &#125;&#125;//4、打印右下直角三角形func printRightTriangleRB() &#123; fmt.Println(\"\\n打印右下直角三角形\") for i := 1; i &lt;= lines; i++ &#123; //打印空格 for m := lines; m &gt;= i; m-- &#123; fmt.Print(\" \") &#125; //打印三角形 for j := 1; j &lt;= i; j++ &#123; fmt.Print(\"❤ \") &#125; fmt.Println() &#125;&#125;//5、打印右上直角三角形func printRightTriangleRT() &#123; fmt.Println(\"\\n打印右上直角三角形\") for i := 1; i &lt;= lines; i++ &#123; //打印空格 for m := 1; m &lt;= i; m++ &#123; fmt.Print(\" \") &#125; //打印三角形 for j := lines; j &gt;= i; j-- &#123; fmt.Print(\"❤ \") &#125; fmt.Println() &#125;&#125;//6、打印等腰三角形func printEqualTriangle() &#123; fmt.Println(\"\\n打印等腰三角形\") for i := 1; i &lt;= lines; i++ &#123; //打印空格 for m := lines; m &gt;= i; m-- &#123; fmt.Print(\" \") &#125; // 打印三角形 for j := 1; j &lt;= 2*i-1; j++ &#123; fmt.Print(\"❤ \") &#125; fmt.Println() &#125;&#125; 输出结果为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576打印矩形❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤打印左下直角三角形❤❤ ❤❤ ❤ ❤❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤打印左上直角三角形❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤ ❤❤ ❤ ❤ ❤❤ ❤ ❤❤ ❤❤打印右下直角三角形 ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤打印右上直角三角形 ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤打印等腰三角形 ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤ ❤打印九九乘法表1*1&#x3D; 11*2&#x3D; 2 2*2&#x3D; 41*3&#x3D; 3 2*3&#x3D; 6 3*3&#x3D; 91*4&#x3D; 4 2*4&#x3D; 8 3*4&#x3D;12 4*4&#x3D;161*5&#x3D; 5 2*5&#x3D;10 3*5&#x3D;15 4*5&#x3D;20 5*5&#x3D;251*6&#x3D; 6 2*6&#x3D;12 3*6&#x3D;18 4*6&#x3D;24 5*6&#x3D;30 6*6&#x3D;361*7&#x3D; 7 2*7&#x3D;14 3*7&#x3D;21 4*7&#x3D;28 5*7&#x3D;35 6*7&#x3D;42 7*7&#x3D;491*8&#x3D; 8 2*8&#x3D;16 3*8&#x3D;24 4*8&#x3D;32 5*8&#x3D;40 6*8&#x3D;48 7*8&#x3D;56 8*8&#x3D;641*9&#x3D; 9 2*9&#x3D;18 3*9&#x3D;27 4*9&#x3D;36 5*9&#x3D;45 6*9&#x3D;54 7*9&#x3D;63 8*9&#x3D;72 9*9&#x3D;81","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"nodejs渐入佳境[21]-express+mondoDB应用部署到heroku","slug":"node-21-deploy-heroku","date":"2018-11-18T12:37:35.000Z","updated":"2018-11-29T03:14:40.180Z","comments":true,"path":"2018/11/18/node-21-deploy-heroku/","link":"","permalink":"https://dreamerjonson.com/2018/11/18/node-21-deploy-heroku/","excerpt":"","text":"express+mongoDB部署到heroku 注意process.env.PORT 与 process.env.MONGODB_URI 源代码postman.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');const &#123;ObjectID&#125; = require('mongodb');//appvar app = express();const port = process.env.PORT || 3000;//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//获取所有属性app.get('/todos', (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;)&#125;);//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;);//监听app.listen(port,()=&gt;&#123; console.log(`Start on port $&#123;port&#125;`);&#125;);module.exports = &#123; app, Todo&#125; package.json package.json配置文件中指定start脚本与node的版本 12345678&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha&quot;, &quot;test-watch&quot;:&quot;nodemon --exec &#39;npm test&#39;&quot;, &quot;start&quot;: &quot;node postman.js&quot;&#125;,&quot;engines&quot;:&#123; &quot;node&quot;: &quot;10.13.0&quot;&#125;, heroku部署 123456heroku createheroku addons:create mongolab:sandbox &#x2F;&#x2F;添加mongodb到 herokuheroku config &#x2F;&#x2F;查看git add .git commit -m &quot;commit&quot;git push heroxu master 测试 12访问 domain&#x2F;todos配合postman增加document","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[20]-postman测试express+mogoDB项目","slug":"node-20-postman","date":"2018-11-18T04:07:21.000Z","updated":"2018-11-29T03:13:59.357Z","comments":true,"path":"2018/11/18/node-20-postman/","link":"","permalink":"https://dreamerjonson.com/2018/11/18/node-20-postman/","excerpt":"","text":"安装postman 网址：https://www.getpostman.com 网址访问,保存数据 postman.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var mongoose = require('mongoose');var express = require('express');var bodyParser = require('body-parser');//appvar app = express();//express middleware Jonson对象与字符串转换。app.use(bodyParser.json());//mongoose.Promise = global.Promise;//连接mogodbmongoose.connect('mongodb://localhost:27017/TodoApp');//模版var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);//express routeapp.post('/todos',(req,res)=&gt;&#123;// console.log(req.body); //建立对象document var todo = new Todo(&#123; text:req.body.text &#125;); //保存 todo.save().then((doc)=&gt;&#123; res.send(doc); &#125;,(e)=&gt;&#123; res.status(400).send(e); &#125;);&#125;)//监听app.listen(3000,()=&gt;&#123; console.log('Start on port 3000');&#125;);module.exports = &#123; app, Todo&#125; 测试 安装expect nodemon supertest mocha //test/postman.test.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const &#123;app,Todo&#125; = require('../postman')const expect = require('expect')const request = require('supertest')beforeEach((done) =&gt; &#123; Todo.remove(&#123;&#125;).then(() =&gt; done());&#125;);describe('POST /todos', () =&gt; &#123; it('should create a new todo', (done) =&gt; &#123; var text = 'Test todo text'; request(app) .post('/todos') .send(&#123;text&#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.text).toBe(text); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find().then((todos) =&gt; &#123; expect(todos.length).toBe(1); expect(todos[0].text).toBe(text); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;); it('should not create todo with invalid body data', (done) =&gt; &#123; request(app) .post('/todos') .send(&#123;&#125;) .expect(400) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find().then((todos) =&gt; &#123; expect(todos.length).toBe(0); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;);&#125;); 修改package.json 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha&quot;, &quot;test-watch&quot;:&quot;nodemon --exec &#39;npm test&#39;&quot;,&#125; 运行 1&gt;npm run test-watch 获取所有document 1234567app.get(&#39;&#x2F;todos&#39;, (req, res) &#x3D;&gt; &#123; Todo.find().then((todos) &#x3D;&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) &#x3D;&gt; &#123; res.status(400).send(e); &#125;)&#125;); 测试2 //test/postman.test.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const &#123;app,Todo&#125; = require('../postman')const expect = require('expect')const request = require('supertest')const todos = [&#123; text: 'First test todo'&#125;, &#123; text: 'Second test todo'&#125;];beforeEach((done) =&gt; &#123; Todo.remove(&#123;&#125;).then(() =&gt; &#123;// 删除后插入对象 return Todo.insertMany(todos); &#125;).then(() =&gt; done());&#125;);describe('POST /todos', () =&gt; &#123; it('should create a new todo', (done) =&gt; &#123; var text = 'Test todo text'; request(app) .post('/todos') .send(&#123;text&#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.text).toBe(text); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find(&#123;text&#125;).then((todos) =&gt; &#123; expect(todos.length).toBe(1); expect(todos[0].text).toBe(text); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;); it('should not create todo with invalid body data', (done) =&gt; &#123; request(app) .post('/todos') .send(&#123;&#125;) .expect(400) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find().then((todos) =&gt; &#123; expect(todos.length).toBe(2); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;);&#125;);describe('GET /todos', () =&gt; &#123; it('should get all todos', (done) =&gt; &#123; request(app) .get('/todos') .expect(200) .expect((res) =&gt; &#123; expect(res.body.todos.length).toBe(2); &#125;) .end(done); &#125;);&#125;); 查询id 123456789101112131415161718//查询idapp.get('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;); 测试3： //test/postman.test.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const &#123;app,Todo&#125; = require('../postman')const &#123;ObjectID&#125; = require('mongodb');const expect = require('expect')const request = require('supertest')const todos = [&#123; _id: new ObjectID(), text: 'First test todo'&#125;, &#123; _id: new ObjectID(), text: 'Second test todo'&#125;];beforeEach((done) =&gt; &#123; Todo.remove(&#123;&#125;).then(() =&gt; &#123; return Todo.insertMany(todos); &#125;).then(() =&gt; done());&#125;);describe('POST /todos', () =&gt; &#123; it('should create a new todo', (done) =&gt; &#123; var text = 'Test todo text'; request(app) .post('/todos') .send(&#123;text&#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.text).toBe(text); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find(&#123;text&#125;).then((todos) =&gt; &#123; expect(todos.length).toBe(1); expect(todos[0].text).toBe(text); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;); it('should not create todo with invalid body data', (done) =&gt; &#123; request(app) .post('/todos') .send(&#123;&#125;) .expect(400) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find().then((todos) =&gt; &#123; expect(todos.length).toBe(2); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;);&#125;);describe('GET /todos', () =&gt; &#123; it('should get all todos', (done) =&gt; &#123; request(app) .get('/todos') .expect(200) .expect((res) =&gt; &#123; expect(res.body.todos.length).toBe(2); &#125;) .end(done); &#125;);&#125;);describe('GET /todos/:id', () =&gt; &#123; it('should return todo doc', (done) =&gt; &#123; request(app) .get(`/todos/$&#123;todos[0]._id.toHexString()&#125;`) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo.text).toBe(todos[0].text); &#125;) .end(done); &#125;); it('should return 404 if todo not found', (done) =&gt; &#123; var hexId = new ObjectID().toHexString(); request(app) .get(`/todos/$&#123;hexId&#125;`) .expect(404) .end(done); &#125;); it('should return 404 for non-object ids', (done) =&gt; &#123; request(app) .get('/todos/123abc') .expect(404) .end(done); &#125;);&#125;); 删除id 123456789101112131415161718//删除app.delete('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;); 测试4 //test/postman.test.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140const &#123;app,Todo&#125; = require('../postman')const &#123;ObjectID&#125; = require('mongodb');const expect = require('expect')const request = require('supertest')const todos = [&#123; _id: new ObjectID(), text: 'First test todo'&#125;, &#123; _id: new ObjectID(), text: 'Second test todo'&#125;];beforeEach((done) =&gt; &#123; Todo.remove(&#123;&#125;).then(() =&gt; &#123; return Todo.insertMany(todos); &#125;).then(() =&gt; done());&#125;);describe('POST /todos', () =&gt; &#123; it('should create a new todo', (done) =&gt; &#123; var text = 'Test todo text'; request(app) .post('/todos') .send(&#123;text&#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.text).toBe(text); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find(&#123;text&#125;).then((todos) =&gt; &#123; expect(todos.length).toBe(1); expect(todos[0].text).toBe(text); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;); it('should not create todo with invalid body data', (done) =&gt; &#123; request(app) .post('/todos') .send(&#123;&#125;) .expect(400) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find().then((todos) =&gt; &#123; expect(todos.length).toBe(2); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;);&#125;);describe('GET /todos', () =&gt; &#123; it('should get all todos', (done) =&gt; &#123; request(app) .get('/todos') .expect(200) .expect((res) =&gt; &#123; expect(res.body.todos.length).toBe(2); &#125;) .end(done); &#125;);&#125;);describe('GET /todos/:id', () =&gt; &#123; it('should return todo doc', (done) =&gt; &#123; request(app) .get(`/todos/$&#123;todos[0]._id.toHexString()&#125;`) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo.text).toBe(todos[0].text); &#125;) .end(done); &#125;); it('should return 404 if todo not found', (done) =&gt; &#123; var hexId = new ObjectID().toHexString(); request(app) .get(`/todos/$&#123;hexId&#125;`) .expect(404) .end(done); &#125;); it('should return 404 for non-object ids', (done) =&gt; &#123; request(app) .get('/todos/123abc') .expect(404) .end(done); &#125;);&#125;);describe('DELETE /todos/:id', () =&gt; &#123; it('should remove a todo', (done) =&gt; &#123; var hexId = todos[1]._id.toHexString(); request(app) .delete(`/todos/$&#123;hexId&#125;`) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo._id).toBe(hexId); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.findById(hexId).then((todo) =&gt; &#123; expect(todo).toBeFalsy(); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;); it('should return 404 if todo not found', (done) =&gt; &#123; var hexId = new ObjectID().toHexString(); request(app) .delete(`/todos/$&#123;hexId&#125;`) .expect(404) .end(done); &#125;); it('should return 404 if object id is invalid', (done) =&gt; &#123; request(app) .delete('/todos/123abc') .expect(404) .end(done); &#125;);&#125;); 更新 1&gt; npm install --save lodash 1234567891011121314151617181920212223242526//更新app.patch('/todos/:id', (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, ['text', 'completed']); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;)&#125;); 测试5 //test/postman.test.js: 123456789101112131415161718192021222324252627282930313233343536373839describe('PATCH /todos/:id', () =&gt; &#123; it('should update the todo', (done) =&gt; &#123; var hexId = todos[0]._id.toHexString(); var text = 'This should be the new text'; request(app) .patch(`/todos/$&#123;hexId&#125;`) .send(&#123; completed: true, text &#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo.text).toBe(text); expect(res.body.todo.completed).toBe(true); expect(typeof res.body.todo.completedAt).toBe('number'); &#125;) .end(done); &#125;); it('should clear completedAt when todo is not completed', (done) =&gt; &#123; var hexId = todos[1]._id.toHexString(); var text = 'This should be the new text!!'; request(app) .patch(`/todos/$&#123;hexId&#125;`) .send(&#123; completed: false, text &#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo.text).toBe(text); expect(res.body.todo.completed).toBe(false); expect(res.body.todo.completedAt).toBeFalsy(); &#125;) .end(done); &#125;);&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"node[19]-mongoose操作mongoDB数据库","slug":"node-19-mongoose","date":"2018-11-18T03:10:41.000Z","updated":"2018-11-29T03:12:51.445Z","comments":true,"path":"2018/11/18/node-19-mongoose/","link":"","permalink":"https://dreamerjonson.com/2018/11/18/node-19-mongoose/","excerpt":"","text":"mongoose 1234567891011121314151617181920212223242526272829var mongoose = require('mongoose');mongoose.Promise = global.Promise;mongoose.connect('mongodb://localhost:27017/TodoApp');//建立模型var Todo = mongoose.model('Todo',&#123; text:&#123; type:String &#125;, completed:&#123; type:Boolean &#125;, completedAt:&#123; type:Number &#125;&#125;);//存储var newTodo = new Todo(&#123; text:'Cook dinner'&#125;);newTodo.save().then((doc)=&gt;&#123; console.log('Save todo',doc);&#125;,(e)=&gt;&#123; console.log('Unable to save todo');&#125;); mongoose validators 下面的程序失败，因为text去空格后的值的长度小于1: 12345678910111213141516171819202122232425262728293031323334var mongoose = require('mongoose');mongoose.Promise = global.Promise;mongoose.connect('mongodb://localhost:27017/TodoApp');var Todo = mongoose.model('Todo',&#123; text:&#123; type:String, //类型 required:true, //必须要有 minlength:1, //最小长度 trim:true //去除空格 &#125;, completed:&#123; type:Boolean, default:false //默认值 &#125;, completedAt:&#123; type:Number, default:null &#125;&#125;);//失败，因为text去空格后的值的长度小于1。var newTodo = new Todo(&#123; text:' ',&#125;);newTodo.save().then((doc)=&gt;&#123; console.log('Save todo',doc);&#125;,(e)=&gt;&#123; console.log('Unable to save todo');&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"go语言渐入佳境[8]-loop","slug":"golang-8-loop","date":"2018-11-17T14:41:46.000Z","updated":"2018-11-20T02:16:49.288Z","comments":true,"path":"2018/11/17/golang-8-loop/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-8-loop/","excerpt":"","text":"123456789101112package mainimport ( &quot;fmt&quot;)func main()&#123; &#x2F;&#x2F;调用 loop1() sum2()&#125; 第1种形式 12345678func loop1()&#123; //形式1 for i:=0;i&lt;10;i++&#123; fmt.Println(i) &#125;&#125; 第2种形式 12345678func loop2()&#123; //形式二 i:=0 for ;i&lt;10;i++&#123; fmt.Println(i) &#125;&#125; 第3种形式 1234567891011func loop3()&#123; //第三种形式 i:=0 for ;;i++&#123; if(i&gt;20)&#123; break &#125; fmt.Println(i) &#125;&#125; 第4种形式 1234567891011func loop4()&#123; //第四种形式 i:=0 for ; ; &#123; if i&gt;20&#123; break &#125; i++ fmt.Println(i) &#125;&#125; 第5种形式 12345678func loop5()&#123; i:=0 for i&lt;20&#123; i++ fmt.Println(i) &#125;&#125; 第6种形式 12345678910111213func loop6()&#123; i:=0 for&#123; if i &lt;20&#123; i++ fmt.Println(i) &#125;else&#123; break &#125; &#125;&#125; 简单案例：计算1-100之间的和： 1234567891011func sum()&#123; result:=0 for i:=0;i&lt;=100;i++&#123; fmt.Printf(\"result:%d i:%d\\n\",result,i) result +=i &#125; fmt.Println(result)&#125; 简单案例：计算1 - 100之间所有的奇数的和 12345678910func sum2()&#123; result:=0 for i:=0;i&lt;=100;i++&#123; if(i %2 ==0)&#123; result +=i &#125; &#125;&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[7]-if判断条件","slug":"golang-7-if","date":"2018-11-17T12:40:12.000Z","updated":"2018-11-20T02:16:56.185Z","comments":true,"path":"2018/11/17/golang-7-if/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-7-if/","excerpt":"","text":"if条件语句的表现形式： 1234567891011121314151617//第一种最基本num := 26 if(num %2==0)&#123; fmt.Printf(\"num是偶数\\n\") &#125; //第二种 初始化： if str:=\"jonson\"; num %2==0 &#123; fmt.Printf(str)&#125;//第三种 else语句：if(num %2==0)&#123; fmt.Printf(\"num是偶数\\n\") &#125;else&#123; fmt.Printf(\"num是奇数\\n\") &#125; if语句判断学生成绩1 12345678910111213141516171819202122232425//判断学生成绩func scoreTest()&#123; var score =80 if(score &gt;=90)&#123; fmt.Printf(\"优秀\") &#125; if(score &gt;=80 &amp;&amp; score &lt;90)&#123; fmt.Printf(\"良好\") &#125; if(score &gt;=70 &amp;&amp; score &lt;80)&#123; fmt.Printf(\"中等\") &#125; if(score &gt;=60 &amp;&amp; score &lt;70)&#123; fmt.Printf(\"及格\") &#125; if(score &lt;60)&#123; fmt.Printf(\"不及格\") &#125;&#125; if语句判断学生成绩改进2 12345678910111213&#x2F;&#x2F;判断学生成绩func scoreTest3(score int)&#123; if(score &gt;&#x3D;90)&#123; fmt.Printf(&quot;优秀&quot;) &#125;else if(score &gt;&#x3D;80)&#123; fmt.Printf(&quot;良好&quot;) &#125;else if(score &gt;&#x3D;70)&#123; fmt.Printf(&quot;中等&quot;) &#125;else if(score &gt;&#x3D;60)&#123; fmt.Printf(&quot;及格&quot;) &#125;else&#123; fmt.Printf(&quot;不及格&quot;) &#125; 注意顺序，下面的代码是错误的： 1234567891011121314if(score &gt;=80 &amp;&amp; score &lt;90)&#123; fmt.Printf(\"良好\")&#125;if(score &gt;=70 &amp;&amp; score &lt;80)&#123; fmt.Printf(\"中等\")&#125;if(score &gt;=60 &amp;&amp; score &lt;70)&#123; fmt.Printf(\"及格\")&#125;if(score &lt;60)&#123; fmt.Printf(\"不及格\")&#125; switch switch形式一 使用switch语句判断成绩： 123456789101112131415161718192021222324package mainimport \"fmt\"func main()&#123; score :=56 switch&#123; case score &gt;=90: fmt.Printf(\"优秀\") case score &gt;=80: fmt.Printf(\"良好\") case score &gt;=70: fmt.Printf(\"中等\") case score &gt;=60: fmt.Printf(\"及格\") default: fmt.Printf(\"不及格\") &#125; operate()&#125; switch形式二 12345678910111213141516171819202122func operate()&#123; a,b,c := 4,2,0 operate :=\"*\" switch operate&#123; case \"+\": c=a+b case \"-\": c=a-b case \"*\": c=a*b case \"/\": c=a/b default: c = -1 &#125; fmt.Println(c)&#125; switch形式三 判断月份 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"func main() &#123; getDaysByMonth()&#125;func getDaysByMonth() &#123; // 定义局部变量：年、月、日 year := 2008 month := 12 days := 0 switch month &#123; case 1, 3, 5, 7, 8, 10, 12: days = 31 case 4, 6, 9, 11: days = 30 case 2: //判断闰年 if (year%4 == 0 &amp;&amp; year%100 != 0) || year%400 == 0 &#123; days = 29 &#125; else &#123; days = 28 &#125; default: days = -1 &#125; fmt.Printf(\"%d年%d月的天数为：%d\", year , month , days)&#125; switch形式四 1234567891011121314151617181920212223242526272829func main() &#123; eval()&#125;func eval() &#123; num1, num2, result := 12, 4, 0 operation := \"+\" switch operation &#123; case \"+\": result = num1 + num2 //fallthrough case \"-\": result = num1 - num2 //fallthrough case \"*\": result = num1 * num2 //fallthrough case \"/\": result = num1 / num2 //fallthrough case \"%\": result = num1 % num2 default: result = -1 &#125; fmt.Println(result)&#125; 总结 12345671、switch 语句执行的过程自上而下，直到找到case匹配项，匹配项中无需使用break，因为Go语言中的switch默认给每个case自带break，因此匹配成功后不会向下执行其他的case分支，而是跳出整个switch。2、变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同类型或最终结果为相同类型的表达式。3、case后的值不能重复。4、可以同时测试多个符合条件的值，也就是说case后可以有多个值，这些值之间使用逗号分割，例如：case val1, val2, val3。5、Go语言中switch后的表达式可以省略，那么默认是switch true。6、Go语言中的switch case因为自带break，所以匹配某个case后不会自动向下执行其他case，如需贯通后续的case，可以添加fallthrough（中文含义是：贯穿）， 强制执行后面的case分支7、fallthrough必须放在case分支的最后一行。如果它出现在中间的某个地方，编译器就会抛出错误（fallthrough statement out of place，含义是fallthrough不在合适的位置）。","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[6]-operator运算符","slug":"golang-6-operator","date":"2018-11-17T09:55:45.000Z","updated":"2018-11-20T02:17:01.109Z","comments":true,"path":"2018/11/17/golang-6-operator/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-6-operator/","excerpt":"","text":"运算符 和其他语言一样，Go语言支持多种运算符，用于对变量进行运算。 12345678910111213package mainimport \"fmt\"func main()&#123; //math() //relation() //logic() //wei() Assign()&#125; 算术运算符 123456789101112func math()&#123; a := 4 b:=2 fmt.Printf(\"a+b的结果为：%d\\n\", a+b) fmt.Printf(\"a-b的结果为：%d\\n\", a-b) fmt.Printf(\"a*b的结果为：%d\\n\", a*b) fmt.Printf(\"a/b的结果为：%d\\n\", a/b)&#125; 关系运算符 123456789101112131415161718192021222324252627282930313233343536func relation()&#123; a := 4 b := 2 if(a==b)&#123; fmt.Printf(\"a与b相同\\n\") &#125;else&#123; fmt.Printf(\"a与b不同\\n\") &#125; if(a&lt;b)&#123; fmt.Printf(\"a小于b\\n\") &#125;else&#123; fmt.Printf(\"a大于b\\n\") &#125; if(a&gt;b)&#123; fmt.Printf(\"a大于b\\n\") &#125;else&#123; fmt.Printf(\"a小于b\\n\") &#125; if(a&lt;=b)&#123; fmt.Printf(\"a小于等于b\\n\") &#125;else&#123; fmt.Printf(\"a大于等于b\\n\") &#125; if(a&gt;=b)&#123; fmt.Printf(\"a大于等于b\\n\") &#125;else&#123; fmt.Printf(\"a小于等于b\\n\") &#125;&#125; 逻辑运算符 1234567891011121314151617181920212223func logic()&#123; a:=true b:=false if(a &amp;&amp; b)&#123; fmt.Printf(\"a与b 同时为true\\n\") &#125;else&#123; fmt.Printf(\"a与b 不同时为true\\n\") &#125; if(a || b)&#123; fmt.Printf(\"a与b 至少一个为true\\n\") &#125;else&#123; fmt.Printf(\"a与b 全部为false\\n\") &#125; if(!b)&#123; fmt.Printf(\"取反成功\\n\") &#125;else&#123; fmt.Printf(\"取反失败\\n\") &#125;&#125; 位运算 12345678910111213func wei()&#123; a := 3 b:= 4 fmt.Println(\"a &amp; b :\",a &amp; b) fmt.Println(\"a | b :\",a | b) fmt.Println(\"a ^ b :\",a ^ b) fmt.Println(\"^ b :\",^b) fmt.Println(\"a左移1位 :\",a &lt;&lt;1) fmt.Println(\"a右移一位:\",a &gt;&gt;1)&#125; 赋值运算符 12345678910111213141516func Assign()&#123; a := 3 var c int= 2 c += a // c = c+a fmt.Println(\"c+=a的结果为:\",c) c -= a //c = c -a fmt.Println(\"c-=a的结果为:\",c) c *= a // c = a *c fmt.Println(\"c*=a的结果为:\",c) c /= a // c = c /a fmt.Println(\"c/=a的结果为:\",c)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[5]-printf格式化打印","slug":"golang-5-printf","date":"2018-11-17T08:12:19.000Z","updated":"2019-01-20T05:20:32.049Z","comments":true,"path":"2018/11/17/golang-5-printf/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-5-printf/","excerpt":"","text":"输入： 下面的功能为获取键盘输入存储到map表中，打印数量超过1的字符串与个数 123456789101112131415161718192021222324package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot;)func main() &#123; counts :&#x3D; make(map[string]int) input :&#x3D; bufio.NewScanner(os.Stdin) for i:&#x3D;0;input.Scan();i++&#123; counts[input.Text()]++ if i&gt;5&#123; break; &#125; &#125; &#x2F;&#x2F; NOTE: ignoring potential errors from input.Err() for line, n :&#x3D; range counts &#123; if n &gt; 1 &#123; fmt.Printf(&quot;%d\\t%s\\n&quot;, n, line) &#125; &#125;&#125; 输入改进2： 即可获取键盘输入，又可获取文件的输入 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"bufio\" \"fmt\" \"os\")func main() &#123; counts := make(map[string]int) files := os.Args[1:] if len(files) == 0 &#123; countLines(os.Stdin, counts) &#125; else &#123; for _, arg := range files &#123; f, err := os.Open(arg) if err != nil &#123; fmt.Fprintf(os.Stderr, \"dup2: %v\\n\", err) continue &#125; countLines(f, counts) f.Close() &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(\"%d\\t%s\\n\", n, line) &#125; &#125;&#125;func countLines(f *os.File, counts map[string]int) &#123; input := bufio.NewScanner(f) for input.Scan() &#123; counts[input.Text()]++ &#125; // NOTE: ignoring potential errors from input.Err()&#125; 输入改进3： 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"io/ioutil\" \"os\" \"strings\")func main() &#123; counts := make(map[string]int) for _, filename := range os.Args[1:] &#123; data, err := ioutil.ReadFile(filename) if err != nil &#123; fmt.Fprintf(os.Stderr, \"dup3: %v\\n\", err) continue &#125; for _, line := range strings.Split(string(data), \"\\n\") &#123; counts[line]++ &#125; &#125; for line, n := range counts &#123; if n &gt; 1 &#123; fmt.Printf(\"%d\\t%s\\n\", n, line) &#125; &#125;&#125; golang输出的格式化打印 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport \"fmt\"func main()&#123; //通用的格式 str:=\"jonson\" fmt.Printf(\"%T,%v\\n\",str,str) //布尔 var booeanl = true fmt.Printf(\"%T,%t\\n\",booeanl,booeanl) //特殊字符 fmt.Printf(\"%%\\n\") fmt.Printf(\"\\\"\\n\") fmt.Printf(\"\\\\\\n\") //整数 fmt.Printf(\"%T,%d\\n\",123,123) fmt.Printf(\"%T,%6d\\n\",123,123) //6代表长度 fmt.Printf(\"%T,%06d\\n\",123,123)//0代表填充0 fmt.Printf(\"%T,%b\\n\",123,123) //二进制 fmt.Printf(\"%T,%o\\n\",123,123) //8进制 fmt.Printf(\"%T,%x\\n\",123,123) //16进制 fmt.Printf(\"%T,%#x\\n\",123,123) //前面加上0x fmt.Printf(\"%T,%#o\\n\",123,123)//前面加上0 fmt.Printf(\"%T,%#X\\n\",123,123) //大写的X代表字母会大写 fmt.Printf(\"% d,% d\\n\",123,-123) //空格代表正数前方会预留一个空格 // 浮点数 fmt.Printf(\"%T,%f\\n\",123.456,123.456) fmt.Printf(\"%T,%10f\\n\",123.456,123.456)//长度 fmt.Printf(\"%T,%.1f\\n\",123.456,123.456) //保留的小数位数 fmt.Printf(\"%T,%10.2f\\n\",123.456,123.456) //字符串 fmt.Printf(\"%T,%s\\n\",\"jonson\",\"jonson\") //字符串 fmt.Printf(\"%T,%c\\n\",'c',97)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[4]-scope作用域","slug":"golang-4-scope","date":"2018-11-17T03:15:53.000Z","updated":"2020-03-11T03:47:57.965Z","comments":true,"path":"2018/11/17/golang-4-scope/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-4-scope/","excerpt":"","text":"作用域 universe block &gt; package block &gt; file block &gt; function block &gt; inner block universe block 预声明的标识符。Go文件全部使用 12345678Types:bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptrConstants:true false iotaZero value:nilFunctions:append cap close complex copy delete imag len make new panic print println real recover package block 例子 fmt下面的函数println 就是package scope 12345678910package mainimport \"fmt\"var x int=5func main()&#123; fmt.Println(\"mainx:\",x)&#125; 外部变量是package block： 下面的代码有效： 1234567891011// f1.gopackage mainvar x int//-------------------------------------// f2.gopackage mainfunc f() &#123; fmt.Println(x)&#125; 调用另一个包中的函数和属性： 12345678910111213141516171819202122//testdemo/destdemo.gopackage testdemoimport \"fmt\"var Birth uint = 23func Haha()&#123; fmt.Println(\"lalalal\")&#125;//-------------------------------------package main // main/scope.goimport ( \"testdemo\" \"fmt\")func main()&#123; testdemo.Haha() fmt.Println(testdemo.Birth)&#125; 权限 如果要让包中的属性和变量被外部包调用，必须要首字母大写。 file block 下面的代码无效，因为import 是file block 。不能跨文件 12345678910// f1.gopackage mainimport \"fmt\"// f2.go 无效package mainfunc f() &#123; fmt.Println(\"Hello World\")&#125; function block 函数体内部的变量是function block，注意前后顺序，同时不能跨函数使用。 1234567891011121314151617181920212223242526func main() &#123; fmt.Println(\"Hello World\") x := 5 fmt.Println(x)&#125;//下面的代码无效：func main() &#123; fmt.Println(\"Hello World\") fmt.Println(x) x := 5&#125;//下面的代码无效2：func main() &#123; fmt.Println(\"Hello World\") x := 5 fmt.Println(x)&#125;//func test()&#123; fmt.Println(x)&#125; 函数内部变量与外部变量重名 就近原则 1234567891011121314package mainimport \"fmt\"var x int=5func test()&#123; var x int = 99; x = 100; fmt.Println(\"testx\",x) //fmt.Println(\"testy\",y)&#125; inner block 在花括号中声明的变量只在花括号中有效。 12345678&#x2F;&#x2F;内部变量func main() &#123; fmt.Println(&quot;Hello World&quot;) &#x2F;&#x2F; x is out of scope &#123; &#x2F;&#x2F; x is out of scope x :&#x3D; 5 &#x2F;&#x2F; x is in scope fmt.Println(x) &#x2F;&#x2F; x is in scope &#125; &#x2F;&#x2F; x is out of scope again&#125; 下面代码无效： 123456func main() &#123; &#123; x :&#x3D; 5 &#125; fmt.Println(x)&#125; 参考资料： Variables","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"go语言渐入佳境[3]-变量声明与赋值","slug":"golang-3-variables","date":"2018-11-17T02:23:33.000Z","updated":"2019-03-19T00:25:15.142Z","comments":true,"path":"2018/11/17/golang-3-variables/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-3-variables/","excerpt":"","text":"变量 变量是内存当中一段空间的抽象描述。变量的类型明确了空间的大小以及空间如何解析。 Go中的变量类型 1bool byte complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr 变量的声明与赋值 方式1 123456789package mainimport \"fmt\"func main() &#123; var x string x = \"Hello World\" fmt.Println(x)&#125; 方式2 注意，x := “Hello World” 等价于 var x = “Hello World” 自动推断类型，并且必须在函数体内部 12345678package mainimport \"fmt\"func main() &#123; x := 1 fmt.Println(x)&#125; 多样的赋值 123456789101112var i intvar U, V, W float64var k = 0var x, y float32 = -1, -2var ( i int u, v, s = 2.0, 3.0, \"bar\")//一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：var f, err = os.Open(name) // os.Open returns a file and an error 例子： 123456789101112131415161718192021222324package mainimport \"fmt\"func main()&#123; var a,b string= \"jonson\",\"jackson\" c,d := true,false e,f,g := \"jonson\",true,123 fmt.Println(\"a:\",a) fmt.Println(\"b:\",b) fmt.Println(\"c:\",c) fmt.Println(\"d:\",d) fmt.Println(\"e:\",e) fmt.Println(\"f:\",f) fmt.Println(\"g:\",g) //和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的os.Open函数调用将返回两个值：//f, err := os.Open(name)&#125; 元祖赋值 元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值： x, y = y, x a[i], a[j] = a[j], a[i] 或者是计算两个整数值的的最大公约数（GCD）（译注：GCD不是那个敏感字，而是greatest common divisor的缩写，欧几里德的GCD是最早的非平凡算法）： 123456func gcd(x, y int) int &#123; for y !&#x3D; 0 &#123; x, y &#x3D; y, x%y &#125; return x&#125; 或者是计算斐波纳契数列（Fibonacci）的第N个数： 1234567func fib(n int) int &#123; x, y :&#x3D; 0, 1 for i :&#x3D; 0; i &lt; n; i++ &#123; x, y &#x3D; y, x+y &#125; return x&#125; 零值问题 变量初始化不赋值的情况，默认为空。 例子： 123456789101112131415package mainimport \"fmt\"func main() &#123; var a int var b string var c float64 var d bool fmt.Printf(\"%v \\n\", a) fmt.Printf(\"%v \\n\", b) fmt.Printf(\"%v \\n\", c) fmt.Printf(\"%v \\n\", d) fmt.Println()&#125; 常量 常量一旦声明不能改变，并且常量必须赋予初始值。此代码无效func main() {const x int} 有效： 1234567891011package mainconst ( m = 1 n = 2)func main()&#123; const k = 8&#125; 常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。 一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。例如，常量比变量更适合用于表达像π之类的数学常数，因为它们的值不会发生变化： const pi = 3.14159 // approximately; math.Pi is a better approximation 和变量声明一样，可以批量声明多个常量；这比较适合声明一组相关的常量： const ( e = 2.71828182845904523536028747135266249775724709369995957496696763 pi = 3.14159265358979323846264338327950288419716939937510582097494459 ) 所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。 常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof。 因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度： const IPv4Len = 4 // parseIPv4 parses an IPv4 address (d.d.d.d). func parseIPv4(s string) IP { var p [IPv4Len]byte // … } 一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，time.Duration是一个命名类型，底层类型是int64，time.Minute是对应类型的常量。下面声明的两个常量都是time.Duration类型，可以通过%T参数打印类型信息： const noDelay time.Duration = 0 const timeout = 5 * time.Minute fmt.Printf(&quot;%T %[1]v\\n&quot;, noDelay) // “time.Duration 0” fmt.Printf(&quot;%T %[1]v\\n&quot;, timeout) // “time.Duration 5m0s” fmt.Printf(&quot;%T %[1]v\\n&quot;, time.Minute) // “time.Duration 1m0s” 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如： const ( a = 1 b c = 2 d ) fmt.Println(a, b, c, d) // “1 1 2 2” 如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是iota常量生成器语法。 iota 使用 常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。 下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。 type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) 周一将对应0，周一为1，如此等等。 我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字： type Flags uint const ( FlagUp Flags = 1 &lt;&lt; iota // is up FlagBroadcast // supports broadcast access capability FlagLoopback // is a loopback interface FlagPointToPoint // belongs to a point-to-point link FlagMulticast // supports multicast access capability ) 随着iota的递增，每个常量对应表达式1 &lt;&lt; iota，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值： 1234567891011121314func IsUp(v Flags) bool &#123; return v&amp;FlagUp &#x3D;&#x3D; FlagUp &#125;func TurnDown(v *Flags) &#123; *v &amp;^&#x3D; FlagUp &#125;func SetBroadcast(v *Flags) &#123; *v |&#x3D; FlagBroadcast &#125;func IsCast(v Flags) bool &#123; return v&amp;(FlagBroadcast|FlagMulticast) !&#x3D; 0 &#125;func main() &#123; var v Flags &#x3D; FlagMulticast | FlagUp fmt.Printf(&quot;%b %t\\n&quot;, v, IsUp(v)) &#x2F;&#x2F; &quot;10001 true&quot; TurnDown(&amp;v) fmt.Printf(&quot;%b %t\\n&quot;, v, IsUp(v)) &#x2F;&#x2F; &quot;10000 false&quot; SetBroadcast(&amp;v) fmt.Printf(&quot;%b %t\\n&quot;, v, IsUp(v)) &#x2F;&#x2F; &quot;10010 false&quot; fmt.Printf(&quot;%b %t\\n&quot;, v, IsCast(v)) &#x2F;&#x2F; &quot;10010 true&quot;&#125; 下面是一个更复杂的例子，每个常量都是1024的幂： const ( _ = 1 &lt;&lt; (10 * iota) KiB // 1024 MiB // 1048576 GiB // 1073741824 TiB // 1099511627776 (exceeds 1 &lt;&lt; 32) PiB // 1125899906842624 EiB // 1152921504606846976 ZiB // 1180591620717411303424 (exceeds 1 &lt;&lt; 64) YiB // 1208925819614629174706176 ) 不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符。 iota从0开始循环 12345678910111213const ( a &#x3D; iota b &#x3D; iota c &#x3D; iota d &#x3D; iota)等价于：const ( a &#x3D; iota b c d) 使用案例： 123456789101112131415161718package mainimport \"fmt\"func main() &#123; const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i)&#125; 变态iota 12345678910111213141516package mainimport \"fmt\"const ( i=1&lt;&lt;iota j=3&lt;&lt;iota k l)func main() &#123; fmt.Println(\"i=\",i) fmt.Println(\"j=\",j) fmt.Println(\"k=\",k) fmt.Println(\"l=\",l)&#125; 结果： 1234i&#x3D; 1j&#x3D; 6k&#x3D; 12l&#x3D; 24 iota表示从0开始自动加1，所以 i=1&lt;&lt;0, j=3&lt;&lt;1（&lt;&lt;表示左移的意思），即：i=1,j=6，这没问题，关键在k和l，从输出结果看 k=3&lt;&lt;2，l=3&lt;&lt;3。 简单表述: • i=1：左移 0 位,不变仍为 1; • j=3：左移 1 位,变为二进制 110, 即 6; • k=3：左移 2 位,变为二进制 1100, 即 12; • l=3：左移 3 位,变为二进制 11000,即 24。 Go语言中的byte和rune Go语言中byte和rune实质上就是uint8和int32类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。参考规范： uint8 the set of all unsigned 8-bit integers (0 to 255) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) byte alias for uint8 rune alias for int32 可以通过下面程序验证： 12345678910111213141516171819202122232425package mainimport \"fmt\"func byteSlice(b []byte) []byte &#123; return b&#125;func runeSlice(r []rune) []rune &#123; return r&#125;func main() &#123; b := []byte&#123;0, 1&#125; u8 := []uint8&#123;2, 3&#125; fmt.Printf(\"%T %T \\n\", b, u8) fmt.Println(byteSlice(b)) fmt.Println(byteSlice(u8)) r := []rune&#123;4, 5&#125; i32 := []int32&#123;6, 7&#125; fmt.Printf(\"%T %T \\n\", r, i32) fmt.Println(runeSlice(r)) fmt.Println(runeSlice(i32))&#125; 执行结果如下： 123456[]uint8 []uint8[0 1][2 3][]int32 []int32[4 5][6 7] 特殊 1234567891011package mainimport ( \"fmt\")func main() &#123; type newstring = string var a newstring = \"hello\" fmt.Println(a)&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[2]-args","slug":"golang-2-args","date":"2018-11-17T01:23:33.000Z","updated":"2019-01-21T03:50:18.788Z","comments":true,"path":"2018/11/17/golang-2-args/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-2-args/","excerpt":"","text":"go打印命令行参数 123456789101112131415package mainimport ( \"fmt\" \"os\")func main() &#123; var s, sep string for i := 1; i &lt; len(os.Args); i++ &#123; s += sep + os.Args[i] sep = \" \" &#125; fmt.Println(s)&#125; 测试 123$ go build main.go$ .&#x2F;main a b c d fa b c d f 更新2 123456789101112131415package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; s, sep :&#x3D; &quot;&quot;, &quot;&quot; for _, arg :&#x3D; range os.Args[1:] &#123; s +&#x3D; sep + arg sep &#x3D; &quot; &quot; &#125; fmt.Println(s)&#125; 更新3 123456789101112package mainimport ( \"fmt\" \"os\" \"strings\")func main() &#123; fmt.Println(strings.Join(os.Args[1:], \" \"))&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"golang[1]-basic","slug":"golang-1-basic","date":"2018-11-17T00:23:33.000Z","updated":"2019-01-21T08:40:18.931Z","comments":true,"path":"2018/11/17/golang-1-basic/","link":"","permalink":"https://dreamerjonson.com/2018/11/17/golang-1-basic/","excerpt":"","text":"Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。 12345break default func interface selectcase defer go map structchan else goto package switchconst fallthrough if range typecontinue for import return var 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。 12345678910內建常量: true false iota nil內建類型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error內建函數: make len cap new append copy close delete complex real imag panic recover 如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。 名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样；你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名。通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。 在习惯上，Go语言程序员推荐使用驼峰式命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但是一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。 整型与运算 Go语言的数值类型包括几种不同大小的整形数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。让我们先从整形数类型开始介绍。 Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整形数类型，分别对应8、16、32、64bit大小的有符号整形数，与此对应的是uint8、uint16、uint32和uint64四种无符号整形数类型。 这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因为不同的编译器卽使在相同的硬件平台上可能产生不同的大小。 Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。 最后，还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程是才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。我们将在第十三章的unsafe包相关部分看到类似的例子。 不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，卽使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。 下面是Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照先级递减的顺序的排列： / % &lt;&lt; &gt;&gt; &amp; &amp;^ - | ^ == != &lt; &lt;= &gt; &gt;= &amp;&amp; || 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647算术运算符+、-、*和&#x2F;可以适用与于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。对于不同编程语言，%取模运算的行为可能并不相同。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符&#x2F;的行为则依赖于操作数是否为全为整数，比如5.0&#x2F;4.0的结果是1.25，但是5&#x2F;4的结果是1，因为整数除法会向着0方向截断余数。如果一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表示的话，就说明计算结果是溢出了。超出的高位的bit位部分将被丢弃。如果原始的数值是有符号类型，而且最左边的bit为是1的话，那么最终结果可能是负的，例如int8的例子：var u uint8 &#x3D; 255fmt.Println(u, u+1, u*u) &#x2F;&#x2F; &quot;255 0 1&quot;var i int8 &#x3D; 127fmt.Println(i, i+1, i*i) &#x2F;&#x2F; &quot;127 -128 1&quot;两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。&#x3D;&#x3D; equal to!&#x3D; not equal to&lt; less than&lt;&#x3D; less than or equal to&gt; greater than&gt;&#x3D; greater than or equal to事实上，布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用&#x3D;&#x3D;和!&#x3D;进行比较。此外，整数、浮点数和字符串可以根据比较结果排序。许多其它类型的值可能是不可比较的，因此也就可能是不可排序的。对于我们遇到的每种类型，我们需要保证规则的一致性。这里是一元的加法和减法运算符：+ 一元加法 (無效果)- 負數对于整数，+x是0+x的简写，-x则是0-x的简写；对于浮点数和复数，+x就是x，-x则是x 的负数。Go语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数：&amp; 位運算 AND| 位運算 OR^ 位運算 XOR&amp;^ 位清空 (AND NOT)&lt;&lt; 左移&gt;&gt; 右移位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。位操作运算符&amp;^用于按位置零（AND NOT）：表达式z &#x3D; x &amp;^ y结果z的bit位为0，如果对应y中bit位为1的话，否则对应的bit位等于x相应的bit位的值。下面的代码演示了如何使用位操作解释uint8类型值的8个独立的bit位。它使用了Printf函数的%b参数打印二进制格式的数字；其中%08b中08表示打印至少8个字符宽度，不足的前缀部分用0填充。var x uint8 &#x3D; 1&lt;&lt;1 | 1&lt;&lt;5var y uint8 &#x3D; 1&lt;&lt;1 | 1&lt;&lt;2fmt.Printf(&quot;%08b\\n&quot;, x) &#x2F;&#x2F; &quot;00100010&quot;, the set &#123;1, 5&#125;fmt.Printf(&quot;%08b\\n&quot;, y) &#x2F;&#x2F; &quot;00000110&quot;, the set &#123;1, 2&#125;fmt.Printf(&quot;%08b\\n&quot;, x&amp;y) &#x2F;&#x2F; &quot;00000010&quot;, the intersection &#123;1&#125;fmt.Printf(&quot;%08b\\n&quot;, x|y) &#x2F;&#x2F; &quot;00100110&quot;, the union &#123;1, 2, 5&#125;fmt.Printf(&quot;%08b\\n&quot;, x^y) &#x2F;&#x2F; &quot;00100100&quot;, the symmetric difference &#123;2, 5&#125;fmt.Printf(&quot;%08b\\n&quot;, x&amp;^y) &#x2F;&#x2F; &quot;00100000&quot;, the difference &#123;5&#125;for i :&#x3D; uint(0); i &lt; 8; i++ &#123; if x&amp;(1&lt;&lt;i) !&#x3D; 0 &#123; &#x2F;&#x2F; membership test fmt.Println(i) &#x2F;&#x2F; &quot;1&quot;, &quot;5&quot; &#125;&#125;fmt.Printf(&quot;%08b\\n&quot;, x&lt;&lt;1) &#x2F;&#x2F; &quot;01000100&quot;, the set &#123;2, 6&#125;fmt.Printf(&quot;%08b\\n&quot;, x&gt;&gt;1) &#x2F;&#x2F; &quot;00010001&quot;, the set &#123;0, 4&#125;","categories":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://dreamerjonson.com/tags/go/"}]},{"title":"node-http-socket5","slug":"node-http-socket5","date":"2018-11-16T15:50:42.000Z","updated":"2018-11-16T15:55:24.348Z","comments":true,"path":"2018/11/16/node-http-socket5/","link":"","permalink":"https://dreamerjonson.com/2018/11/16/node-http-socket5/","excerpt":"","text":"request moudle 使用socket5 代理访问https网页 12345678910111213141516const request = require('request');var Agent = require('socks5-https-client/lib/Agent');request(&#123; url: 'https://google.com/', strictSSL: true, agentClass: Agent, agentOptions: &#123; socksHost: 'localhost', // Defaults to 'localhost'. socksPort: 1086, // Defaults to 1080. &#125;&#125;, function(err, res) &#123; console.log(err || res.body);&#125;); 参考资料； SOCKS5 HTTPS Client Add Socks Proxy support","categories":[{"name":"server","slug":"server","permalink":"https://dreamerjonson.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"https://dreamerjonson.com/tags/server/"}]},{"title":"nodejs渐入佳境[18]-mongodb-node增删查改","slug":"node-18-mongodb-node","date":"2018-11-16T10:45:56.000Z","updated":"2018-11-29T03:12:26.737Z","comments":true,"path":"2018/11/16/node-18-mongodb-node/","link":"","permalink":"https://dreamerjonson.com/2018/11/16/node-18-mongodb-node/","excerpt":"","text":"1&gt; npm install --save mongodb 12345678910111213141516171819202122232425//mongodb 3以上写法const MongoClient = require('mongodb').MongoClient;//TodoApp是一个数据库名字，mongo中不需要创建数据库MongoClient.connect('mongodb://localhost:27017/TodoApp',(err,client)=&gt;&#123; if(err)&#123; return console.log('Unable to connect to MongoDB server'); &#125; console.log('Connect to MongoDB server'); const db = client.db('TodoApp'); //插入数据 db.collection('Todos').insertOne(&#123; text:'Something to do', completed:false &#125;,(err,result)=&gt;&#123; if(err)&#123; return console.log('unable to insert todo',err); &#125; console.log(JSON.stringify(result.ops,undefined,2)); &#125;);//关闭客户端 client.close();&#125;); id 插入一个对象的时候，会自动的产生一个随机的id。id包含了时间戳和机器识别码。 我们可以借助与mongo的方法，为我们产生一个随机数。 12345const &#123;MongoClient,ObjectID&#125; = require('mongodb');var obj = new ObjectID();console.log(obj);//返回时间console.log(obj.getTimestamp()); 参考资料： MongoDB Node.js Driver Documentation node-mongodb-native 查询 原始数据： 123456789101112[ &#123; &quot;_id&quot;: &quot;5bee9e3794c5f22eb989f6eb&quot;, &quot;text&quot;: &quot;Something to do&quot;, &quot;completed&quot;: false &#125;, &#123; &quot;_id&quot;: &quot;5beeaf0a2d48eb2b7c90758f&quot;, &quot;text&quot;: &quot;Something to do&quot;, &quot;completed&quot;: true &#125;] js代码： 12345678910111213141516171819const &#123;MongoClient,ObjectID&#125; = require('mongodb');MongoClient.connect('mongodb://localhost:27017/TodoApp',(err,client)=&gt;&#123; if(err)&#123; return console.log('Unable to connect to MongoDB server'); &#125; console.log('Connect to MongoDB server'); const db = client.db('TodoApp'); //返回所有document db.collection('Todos').find().toArray().then((docs)=&gt;&#123; console.log('Todos'); console.log(JSON.stringify(docs,undefined,2)); &#125;,(err)=&gt;&#123; console.log('unable to fetch todos', err); &#125;) client.close();&#125;); 执行代码返回： 123456789101112[ &#123; &quot;_id&quot;: &quot;5bee9e3794c5f22eb989f6eb&quot;, &quot;text&quot;: &quot;Something to do&quot;, &quot;completed&quot;: false &#125;, &#123; &quot;_id&quot;: &quot;5beeaf0a2d48eb2b7c90758f&quot;, &quot;text&quot;: &quot;Something to do&quot;, &quot;completed&quot;: true &#125;] 筛选 123456789101112131415161718const &#123;MongoClient,ObjectID&#125; = require('mongodb');MongoClient.connect('mongodb://localhost:27017/TodoApp',(err,client)=&gt;&#123; if(err)&#123; return console.log('Unable to connect to MongoDB server'); &#125; console.log('Connect to MongoDB server'); const db = client.db('TodoApp'); db.collection('Todos').find(&#123;completed:true&#125;).toArray().then((docs)=&gt;&#123; console.log('Todos'); console.log(JSON.stringify(docs,undefined,2)); &#125;,(err)=&gt;&#123; console.log('unable to fetch todos', err); &#125;) client.close();&#125;); 执行代码返回： 1234567[ &#123; &quot;_id&quot;: &quot;5beeaf0a2d48eb2b7c90758f&quot;, &quot;text&quot;: &quot;Something to do&quot;, &quot;completed&quot;: true &#125;] 筛选id 1234567891011121314151617181920const &#123;MongoClient,ObjectID&#125; = require('mongodb');MongoClient.connect('mongodb://localhost:27017/TodoApp',(err,client)=&gt;&#123; if(err)&#123; return console.log('Unable to connect to MongoDB server'); &#125; console.log('Connect to MongoDB server'); const db = client.db('TodoApp'); db.collection('Todos').find(&#123; new ObjectID('5beeaf0a2d48eb2b7c90758f') &#125;).toArray().then((docs)=&gt;&#123; console.log('Todos'); console.log(JSON.stringify(docs,undefined,2)); &#125;,(err)=&gt;&#123; console.log('unable to fetch todos', err); &#125;) client.close();&#125;); 执行代码返回： 1234567[ &#123; &quot;_id&quot;: &quot;5beeaf0a2d48eb2b7c90758f&quot;, &quot;text&quot;: &quot;Something to do&quot;, &quot;completed&quot;: true &#125;] 删除document 1234567891011121314151617181920212223const &#123;MongoClient,ObjectID&#125; = require('mongodb');MongoClient.connect('mongodb://localhost:27017/TodoApp',(err,client)=&gt;&#123; if(err)&#123; return console.log('Unable to connect to MongoDB server'); &#125; console.log('Connect to MongoDB server'); const db = client.db('TodoApp');// db.collection('Todos').deleteMany(&#123;text:'mike'&#125;); 删除全部//删除一个 // db.collection('Todos').deleteOne(&#123;text:'mike'&#125;).then((result)=&gt;&#123; // console.log(result); // &#125;);//删除并返回对象 db.collection('Todos').findOneAndDelete(&#123;text:'mike'&#125;).then((result)=&gt;&#123; console.log(result); &#125;); client.close();&#125;); 更新 12345678910111213141516171819202122const &#123;MongoClient,ObjectID&#125; = require('mongodb');MongoClient.connect('mongodb://localhost:27017/TodoApp',(err,client)=&gt;&#123; if(err)&#123; return console.log('Unable to connect to MongoDB server'); &#125; console.log('Connect to MongoDB server'); const db = client.db('TodoApp');//查找并更新 db.collection('Todos').findOneAndUpdate(&#123;text:'mike'&#125;,&#123; $set:&#123; completed:false //设置更改 &#125; &#125;,&#123; returnOriginal:false //返回的结果为更新后的值。 &#125;).then((result)=&gt;&#123; console.log(result); //打印跟新结果 &#125;); client.close();&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[17]-mongodb数据库入门","slug":"node-17-mongodb","date":"2018-11-16T07:09:50.000Z","updated":"2018-11-29T03:12:34.773Z","comments":true,"path":"2018/11/16/node-17-mongodb/","link":"","permalink":"https://dreamerjonson.com/2018/11/16/node-17-mongodb/","excerpt":"","text":"下载mongodb https://www.mongodb.com mongod 解压，进入bin目录 12&#x2F;&#x2F;-dbpath代表数据放置在哪里.&#x2F;mongod -dbpath &#x2F;Users&#x2F;jackson&#x2F;Downloads&#x2F;mongodb-data waiting for connections on port 27017 新开窗口，测试测试 123456&gt; .&#x2F;mongo&gt; db.Todos.insert(&#123;text:&#39;Film new node course&#39;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; db.Todos.find()&#123; &quot;_id&quot; : ObjectId(&quot;5bee6fc6ae6967bacc3d709b&quot;), &quot;text&quot; : &quot;Film new node course&quot; &#125; 可视化 下载： https://studio3t.com/download-now/","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[16]-node express项目部署到heroku","slug":"node-16-heroku-deploy","date":"2018-11-16T06:01:58.000Z","updated":"2018-11-29T03:12:11.312Z","comments":true,"path":"2018/11/16/node-16-heroku-deploy/","link":"","permalink":"https://dreamerjonson.com/2018/11/16/node-16-heroku-deploy/","excerpt":"","text":"源文件 views/partials/footer.hbs: 123&lt;Header&gt; &lt;footer&gt;&#123;&#123;pageTitle&#125;&#125;&lt;&#x2F;footer&gt;&lt;Header&gt; views/about.hbs: 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Some Website&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;pageTitle&#125;&#125;&lt;/h1&gt; &lt;p&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=\"/about\"&gt;About&lt;/a&gt;&lt;/p&gt; &lt;p&gt;Some text here&lt;/p&gt; &#123;&#123;&gt; footer&#125;&#125; &lt;/body&gt;&lt;/html&gt;sx express.js: 1234567891011121314151617181920212223242526272829303132const express = require('express');const hbs = require('hbs');const fs = require('fs');var app = express();const port = process.env.PORT || 3000;hbs.registerPartials(__dirname + '/views/partials');app.set('view engine','hbs');// 参数是一个middlewareapp.use(express.static(__dirname +'/public'));//返回html格式app.get('/',(req,res)=&gt;&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);//返回json格式app.get('/fast',(req,res)=&gt;&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);//返回文件，about.hbs在views文件夹下app.get('/about',(req,res)=&gt;&#123; res.render('about.hbs',&#123; pageTitle:'About Page', currentYear:new Date().getFullYear() &#125;);&#125;);//监听端口, 第二个回调是开启服务器后调用app.listen(port,()=&gt;&#123; console.log('hello jonson');&#125;); git 1234.gitignore里面的文件不会提交git initgit add .git commit -m &quot;fitst commit&quot; heroku 安装heroku-cli 略… 1234heroku login &#x2F;&#x2F; 登陆账号密码hexoru create &#x2F;&#x2F;创建分支git push heroku master &#x2F;&#x2F;提交到heroku管理的远程分支hexoru open &#x2F;打开网址 参考： heroku部署 heroku监控台","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[15]-express框架","slug":"node-15-express","date":"2018-11-15T06:54:02.000Z","updated":"2018-11-29T03:11:37.907Z","comments":true,"path":"2018/11/15/node-15-express/","link":"","permalink":"https://dreamerjonson.com/2018/11/15/node-15-express/","excerpt":"","text":"最简单的服务器 12345678910111213141516171819202122const express = require('express');var app = express();//返回html格式app.get('/',(req,res)=&gt;&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);//返回json格式app.get('/fast',(req,res)=&gt;&#123; res.send(&#123; name:'json', likes:[ 'reading', 'coding' ] &#125;);&#125;);//监听端口app.listen(3000); 访问： localhost:3000 localhost:3000/fast 访问静态文件 创建public/help.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" dir=\"ltr\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello Jonson&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; express.js: 12345678910111213141516171819202122232425const express = require('express');var app = express();// 参数是一个middlewareapp.use(express.static(__dirname +'/public'));//返回html格式app.get('/',(req,res)=&gt;&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);//返回json格式app.get('/fast',(req,res)=&gt;&#123; res.send(&#123; name:'json', likes:[ 'reading', 'coding' ] &#125;);&#125;);//监听端口, 第二个回调是开启服务器后调用app.listen(3000,()=&gt;&#123; console.log('hello jonson');&#125;); 访问： http://localhost:3000/help.html 会打开public/help.html的页面并显示出来。 动态注入 express template engines 1npm install --save hbs 新建views/about.hbs: 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot; dir&#x3D;&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;currentYear&#125;&#125;&lt;&#x2F;h1&gt; &lt;footer&gt;&#123;&#123;pageTitle&#125;&#125;&lt;&#x2F;footer&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; express.js: 1234567891011121314151617181920212223242526272829303132333435363738const express = require('express');const hbs = require('hbs');var app = express();app.set('view engine','hbs');// 参数是一个middlewareapp.use(express.static(__dirname +'/public'));//返回html格式app.get('/',(req,res)=&gt;&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);//返回json格式app.get('/fast',(req,res)=&gt;&#123; res.send(&#123; name:'json', likes:[ 'reading', 'coding' ] &#125;);&#125;);//动态传递参数。app.get('/about',(req,res)=&gt;&#123; res.render('about.hbs',&#123; pageTitle:'About Page', currentYear:new Date().getFullYear() &#125;);&#125;);//监听端口, 第二个回调是开启服务器后调用app.listen(3000,()=&gt;&#123; console.log('hello jonson');&#125;); 访问： localhost/about 模版封装 新建：views/partial/footer.hbs: 123&lt;Header&gt; &lt;footer&gt;&#123;&#123;pageTitle&#125;&#125;&lt;&#x2F;footer&gt;&lt;Header&gt; view/abut.hbs: 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" dir=\"ltr\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;currentYear&#125;&#125;&lt;/h1&gt; &#123;&#123;&gt; footer&#125;&#125; &lt;/body&gt;&lt;/html&gt; express.js: 123456789101112131415161718192021const express = require('express');const hbs = require('hbs');var app = express();hbs.registerPartials(__dirname + '/views/partials');app.set('view engine','hbs');// 参数是一个middlewareapp.use(express.static(__dirname +'/public'));//返回json格式app.get('/about',(req,res)=&gt;&#123; res.render('about.hbs',&#123; pageTitle:'About Page', currentYear:new Date().getFullYear() &#125;);&#125;);//监听端口, 第二个回调是开启服务器后调用app.listen(3000,()=&gt;&#123; console.log('hello jonson');&#125;); 访问： localhost/about express middleware 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const express = require('express');const hbs = require('hbs');const fs = require('fs');var app = express();hbs.registerPartials(__dirname + '/views/partials');app.set('view engine','hbs');// 参数是一个middlewareapp.use(express.static(__dirname +'/public'));//返回html格式app.get('/',(req,res)=&gt;&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);//自定义middlewareapp.use((req,res,next)=&gt;&#123; var now = new Date().toString(); var log = `$&#123;now&#125;:$&#123;req.method&#125; $&#123;req.url&#125;`; console.log(log); fs.appendFile('server.log',log+'\\n',(err)=&gt;&#123;&#125;); next();&#125;);//返回json格式app.get('/fast',(req,res)=&gt;&#123; res.send(&#123; name:'json', likes:[ 'reading', 'coding' ] &#125;);&#125;);//返回文件，about.hbs在views文件夹下app.get('/about',(req,res)=&gt;&#123; res.render('about.hbs',&#123; pageTitle:'About Page', currentYear:new Date().getFullYear() &#125;);&#125;);//监听端口, 第二个回调是开启服务器后调用app.listen(3000,()=&gt;&#123; console.log('hello jonson');&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[14]-promise对象处理异步","slug":"node-14-promise","date":"2018-11-15T04:30:50.000Z","updated":"2018-11-29T03:11:29.212Z","comments":true,"path":"2018/11/15/node-14-promise/","link":"","permalink":"https://dreamerjonson.com/2018/11/15/node-14-promise/","excerpt":"","text":"Promise promise是nodejs的对象，用于处理异步的同步操作。 new Promsie新建一个promise对象，两个参数(resolve,reject)是两个函数。 当调用resolve意味着操作成功。 当调用reject意味着操作失败。 resolve和reject都只会执行一次。 then 函数会在promise执行完毕之后调用。 第一个参数回调函数会在resolve成功后调用，第二个回调函数会在reject触发后调用。 resolve操作成功 123456789101112var somePromise = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve('hey it works'); &#125;,2500);&#125;);somePromise.then((message)=&gt;&#123; console.log('Success',message);&#125;,(errorMessage)=&gt;&#123; console.log('Error:',errorMessage);&#125;); 打印出hey it works reject操作失败 123456789101112var somePromise = new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject('ai it is error'); &#125;,2500);&#125;);somePromise.then((message)=&gt;&#123; console.log('Success',message);&#125;,(errorMessage)=&gt;&#123; console.log('Error:',errorMessage);&#125;); 打印出Error: ai it is error 复杂promise 带参数并且多重then函数。 12345678910111213141516171819202122var asyncAdd = (a,b)=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(typeof a==='number' &amp;&amp; typeof b==='number')&#123; resolve(a+b); &#125;else&#123; reject('Argument must be number'); &#125; &#125;); &#125;);&#125;;asyncAdd(5,7).then((res)=&gt;&#123; console.log('Result',res); return asyncAdd(res,'33');&#125;,(errorMessage)=&gt;&#123; console.log(errorMessage);&#125;).then((res)=&gt;&#123; console.log('should be 45',res);&#125;,(errorMessage)=&gt;&#123; console.log(errorMessage);&#125;); 执行结果： 123Result 12Argument must be numberError: ai it is error 多重then特性 在asyncAdd(5,‘7’)函数reject失败后，第二个then仍然调用的是第一个回调函数。 12345678910111213141516171819202122var asyncAdd = (a,b)=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; if(typeof a==='number' &amp;&amp; typeof b==='number')&#123; resolve(a+b); &#125;else&#123; reject('Argument must be number'); &#125; &#125;); &#125;);&#125;;asyncAdd(5,'7').then((res)=&gt;&#123; console.log('Result',res); return asyncAdd(res,'33');&#125;,(errorMessage)=&gt;&#123; console.log(errorMessage);&#125;).then((res)=&gt;&#123; console.log('should be 45',res);&#125;,(errorMessage)=&gt;&#123; console.log(errorMessage);&#125;); 结果为： 123Argument must be numbershould be 45 undefinedError: ai it is error","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[13]-node回调操作","slug":"node-13","date":"2018-11-15T02:37:20.000Z","updated":"2018-11-29T03:11:14.692Z","comments":true,"path":"2018/11/15/node-13/","link":"","permalink":"https://dreamerjonson.com/2018/11/15/node-13/","excerpt":"","text":"自定义回调函数 123456789101112131415//自定义函数，包含回调函数var getUser=(id,callback)=&gt;&#123; var user = &#123; id:id, name:'jonson' &#125; setTimeout(()=&gt;&#123; callback(user); &#125;,3000);&#125;//调用，并且传递了一个回调函数getUser(31,(userobject)=&gt;&#123; console.log(userobject);&#125;) 执行后输出： 1&#123; id: 31, name: &#39;jonson&#39; &#125; 天气网站回调 1&gt; npm install --save request 12345678const request = require('request');request(&#123; url:'https://api.openweathermap.org/data/2.5/forecast?q=beijing,cn&amp;appid=09ec05ac89602c9970393fe760db2bf5', json:true // 将json返回结果解析为json对象&#125;,(error,response,body)=&gt;&#123; console.log(body);&#125;); 打印出： 12345678910111213141516171819202122&#123; cod: &#39;200&#39;, message: 0.0038, cnt: 38, list: [ &#123; dt: 1542261600, main: [Object], weather: [Array], clouds: [Object], wind: [Object], rain: [Object], sys: [Object], dt_txt: &#39;2018-11-15 06:00:00&#39; &#125;, &#123; dt: 1542272400, main: [Object], weather: [Array], clouds: [Object], wind: [Object], rain: [Object], sys: [Object], dt_txt: &#39;2018-11-15 09:00:00&#39; &#125;, ... 好看的格式显示 123456789const request = require('request');request(&#123; url:'https://api.openweathermap.org/data/2.5/forecast?q=beijing,cn&amp;appid=09ec05ac89602c9970393fe760db2bf5', json:true // 将返回结果解析为json对象&#125;,(error,response,body)=&gt;&#123; console.log(JSON.stringify(body,undefined,2));&#125;); 打印出： 12345678910111213141516171819202122232425262728293031323334353637383940&#123; &quot;cod&quot;: &quot;200&quot;, &quot;message&quot;: 0.0026, &quot;cnt&quot;: 38, &quot;list&quot;: [ &#123; &quot;dt&quot;: 1542261600, &quot;main&quot;: &#123; &quot;temp&quot;: 282.38, &quot;temp_min&quot;: 277.973, &quot;temp_max&quot;: 282.38, &quot;pressure&quot;: 1017.9, &quot;sea_level&quot;: 1043.48, &quot;grnd_level&quot;: 1017.9, &quot;humidity&quot;: 90, &quot;temp_kf&quot;: 4.4 &#125;, &quot;weather&quot;: [ &#123; &quot;id&quot;: 500, &quot;main&quot;: &quot;Rain&quot;, &quot;description&quot;: &quot;light rain&quot;, &quot;icon&quot;: &quot;10d&quot; &#125; ], &quot;clouds&quot;: &#123; &quot;all&quot;: 92 &#125;, &quot;wind&quot;: &#123; &quot;speed&quot;: 1.71, &quot;deg&quot;: 330.5 &#125;, &quot;rain&quot;: &#123; &quot;3h&quot;: 0.98 &#125;, &quot;sys&quot;: &#123; &quot;pod&quot;: &quot;d&quot; &#125;, &quot;dt_txt&quot;: &quot;2018-11-15 06:00:00&quot; &#125;, 处理用户输入： 12345678910111213141516171819202122const request = require('request');const yargs = require('yargs');const argv = yargs.options(&#123; a:&#123; demand:true, alias:'address', describe:'Address to fetch weather for', string:true &#125;&#125;).help().alias('help','h').argv;request(&#123; url:`https://samples.openweathermap.org/data/2.5/forecast?q=$&#123;argv.address&#125;,cn&amp;appid=b6907d289e10d714a6e88b30761fae22`, json:true // 将返回结果解析为json对象&#125;,(error,response,body)=&gt;&#123; console.log(JSON.stringify(body,undefined,2));&#125;); 测试 1&gt; node async.js -a xingjiang","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[12]-node异步操作","slug":"node-12","date":"2018-11-15T02:27:48.000Z","updated":"2018-11-29T03:11:02.502Z","comments":true,"path":"2018/11/15/node-12/","link":"","permalink":"https://dreamerjonson.com/2018/11/15/node-12/","excerpt":"","text":"如下异步代码： 12345678910111213console.log('start...');setTimeout(()=&gt;&#123; console.log('first callback');&#125;,2000)setTimeout(()=&gt;&#123; console.log('second callback');&#125;,0)console.log('end...'); 打印结果为： 1234start...end...second callbackfirst callback 总结： 首先执行了下面console.log(‘end…’);，再执行了settimeout的回调函数，即便是settimeout中的时间为0. 原因是nodejs的事件循环机制,出现了异步的效果。 参考：深度理解nodejs[2]-事件循环","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"solidity智能合约[11]-字符串","slug":"solidity-11","date":"2018-11-14T16:44:53.000Z","updated":"2018-11-20T16:37:35.067Z","comments":true,"path":"2018/11/15/solidity-11/","link":"","permalink":"https://dreamerjonson.com/2018/11/15/solidity-11/","excerpt":"","text":"字符串 string 类型存储字符串， 在solidity中使用了UTF-8格式来存储字符串。 123string public name&#x3D;&quot;jonson&quot;;&#x2F;&#x2F;6a6f6e736f6estring public name1&#x3D;&quot;!@#$%^&amp;*())*&quot;;string public name2&#x3D;&quot;我爱你&quot;; 字符串不能直接的获取长度和内容 下面是错误的方式 1234567&#x2F;&#x2F; function getLength() returns(uint)&#123; &#x2F;&#x2F; name.length; &#x2F;&#x2F; &#125; &#x2F;&#x2F; function getName() returns(bytes1) &#123; &#x2F;&#x2F; return name[0]; &#x2F;&#x2F; &#125; 获取字符串长度和内容和的正确方式 1234567 function getLength() public view returns(uint)&#123; return bytes(name).length;&#125;function getName() public view returns(bytes1)&#123;return bytes(name)[1];&#125; 修改字符串中的内容 1234function changeName() public&#123;&#x2F;&#x2F; bytes(name)[0]&#x3D;0x55; bytes(name)[0]&#x3D;&#39;P&#39;;&#125; 证明中文占了3个字节 1234 string public name2&#x3D;&quot;我爱你&quot;; function getLength2() public view returns(uint)&#123; return bytes(name2).length;&#125; 字符串转动态字节数组 1234function getBytes() public view returns(bytes)&#123; return bytes(name);&#125; 完整代码测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.23;contract StringTest&#123; string public name=\"jonson\";//6a6f6e736f6e string public name1=\"!@#$%^&amp;*())*\"; string public name2=\"我爱你\"; // function getLength() returns(uint)&#123; // name.length; // &#125; function getLength() public view returns(uint)&#123; return bytes(name).length; &#125; // function getName() returns(bytes1) &#123; // return name[0]; // &#125; function getName() public view returns(bytes1)&#123; return bytes(name)[1]; &#125; function changeName() public&#123; // bytes(name)[0]=0x55; bytes(name)[0]='P'; &#125; function getBytes() public view returns(bytes)&#123; return bytes(name); &#125; function getLength1() public view returns(uint)&#123; return bytes(name1).length; &#125; function getBytes1() public view returns(bytes)&#123; return bytes(name1); &#125; function getLength2() public view returns(uint)&#123; return bytes(name2).length; &#125; function getBytes2() public view returns(bytes)&#123; return bytes(name2); &#125;&#125; 总结 1、字符串是特殊的动态长度字节数组 2、字符串不能够字节的修改长度和内容，需要转换为bytes动态字节数组 3、字符串在solidity中使用了UTF8格式来存储，所以汉字占了3个字节，英文和特殊字符占了一个字节","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[10]-动态字节数组","slug":"solidity-10","date":"2018-11-14T15:13:14.000Z","updated":"2018-11-20T16:37:39.224Z","comments":true,"path":"2018/11/14/solidity-10/","link":"","permalink":"https://dreamerjonson.com/2018/11/14/solidity-10/","excerpt":"","text":"动态字节数组的定义 bytes 变量名 = new bytes(大小); 动态字节数组的属性 可以修改大小和长度 动态字节数组默认初始化为0 bytes public name = new bytes(2); name的值一开始为0x0000 动态字节数组的赋值 1234function InitName() public&#123; name[0] &#x3D; 0x6a; name[1] &#x3D;0x6f; &#125; 动态字节数组的属性 123function getLength() view public returns(uint)&#123; return name.length; &#125; 动态字节数组修改长度和添加变量 123456789function changeLength() public&#123; name.length &#x3D; 5;&#125;&#x2F;&#x2F;添加到后方function pushBytes() public&#123; name.push(0x99);&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[9]-字节数组与运算","slug":"solidity-9","date":"2018-11-14T14:50:39.000Z","updated":"2018-11-20T16:37:42.418Z","comments":true,"path":"2018/11/14/solidity-9/","link":"","permalink":"https://dreamerjonson.com/2018/11/14/solidity-9/","excerpt":"","text":"byte类型 有byte bytes1 bytes2 … bytes32 特殊的有byte == bytes1 后面的数字代表占了多少字节。1个字节在内存中占了8位 性质 固定字节数组不能修改长度和内容 字节一般用16进制来存储 16进制中的1个数字代表占了4位。 1234567bytes1 public num1 = 0x6a; //转换为10进制：106bytes2 public num2 = 0x6a6f; //转换为10进制：27247bytes6 public num3 = 0x6a6f6e736f6e; bytes1 public a = 0x6a;//转换为2进制：0110 1010 bytes1 public b = 0x6f;//转换为2进制：0110 1111 字节可以有长度属性 123function getlength() view public returns(uint,uint,uint)&#123; return (num1.length,num2.length,num3.length);&#125; 字节可以比较大小 不同类型的字节也可以比较大小 1234567891011121314151617181920212223242526function test1() public view returns(bool)&#123; return a&gt;b;&#125; function test2() public view returns(bool)&#123; return a&gt;=b;&#125; function test3() public view returns(bool)&#123; return a&lt;b;&#125; function test4() public view returns(bool)&#123; return a&lt;=b;&#125;function test5() public view returns(bool)&#123; return a==b;&#125; function test6() public view returns(bool)&#123; return a!=b;&#125; function test7() public view returns(bool)&#123; return num2 &gt;num1;&#125; 字节可以进行位运算 12345678910111213141516171819202122232425262728// 0110 1010// 0110 1111//&amp;0110 1010 106 0x6a//|0110 1111 111 0x6f//^0000 0101 5 0x05//~1001 0101 149 0x95//&lt;1101 0100 212 0xd4//&gt;0011 0101 53 0x35 function weiTest1() public view returns(bytes1)&#123; return a &amp; b;&#125; function weiTest2() public view returns(bytes1)&#123; return a | b;&#125; function weiTest3() public view returns(bytes1)&#123; return a ^ b;&#125; function weiTest4() public view returns(bytes1)&#123; return ~a;&#125; function weiTest5() public view returns(bytes1)&#123; return a&lt;&lt;1; &#125; function weiTest6() public view returns(bytes1)&#123; return a &gt;&gt;1;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081pragma solidity ^0.4.23;contract bytesTest&#123; //0x6a6f6e736f6e bytes1 public num1 = 0x6a; //106 bytes2 public num2 = 0x6a6f; //27247 bytes6 public num3 = 0x6a6f6e736f6e; bytes1 public a = 0x6a;//0110 1010 106 bytes1 public b = 0x6f;//0110 1111 111 function getlength() view public returns(uint,uint,uint)&#123; return (num1.length,num2.length,num3.length); &#125; // function changeLength() public &#123; // num1.length = 9; // &#125; function test1() public view returns(bool)&#123; return a&gt;b; &#125; function test2() public view returns(bool)&#123; return a&gt;=b; &#125; function test3() public view returns(bool)&#123; return a&lt;b; &#125; function test4() public view returns(bool)&#123; return a&lt;=b; &#125; function test5() public view returns(bool)&#123; return a==b; &#125; function test6() public view returns(bool)&#123; return a!=b; &#125; function test7() public view returns(bool)&#123; return num2 &gt;num1; &#125; // 0110 1010 // 0110 1111 //&amp;0110 1010 106 0x6a //|0110 1111 111 0x6f //^0000 0101 5 0x05 //~1001 0101 149 0x95 //&lt;1101 0100 212 0xd4 //&gt;0011 0101 53 0x35 function weiTest1() public view returns(bytes1)&#123; return a &amp; b; &#125; function weiTest2() public view returns(bytes1)&#123; return a | b; &#125; function weiTest3() public view returns(bytes1)&#123; return a ^ b; &#125; function weiTest4() public view returns(bytes1)&#123; return ~a; &#125; function weiTest5() public view returns(bytes1)&#123; return a&lt;&lt;1; &#125; function weiTest6() public view returns(bytes1)&#123; return a &gt;&gt;1; &#125;&#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"nodejs渐入佳境[11]-yargs获取用户输入高级用法","slug":"node-11-yargs","date":"2018-11-14T06:45:44.000Z","updated":"2018-11-29T03:10:51.579Z","comments":true,"path":"2018/11/14/node-11-yargs/","link":"","permalink":"https://dreamerjonson.com/2018/11/14/node-11-yargs/","excerpt":"","text":"yargs高级用法，用于输出帮助信息，缩写提示等。 app.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//打印字符串const yargs = require('yargs');const nodes = require('./nodes.js')const argv = yargs .command('add','add a new note',&#123; //add为命令参数，第二个为说明 title:&#123; //--titile describe:'Title of note', demand:true, //必须要的参数 alias:'t' //缩写 //--t &#125;, body:&#123; describe:'Body of note', demand:true, alias:'b' &#125; &#125;) .command('list','List all notes') .command('read','Read a note',&#123; title:&#123; describe:'Title of note', demand:true, alias:'t' &#125; &#125;) .command('remove','Remove a note',&#123; title:&#123; describe:'Title of note', demand:true, alias:'t' &#125; &#125;) .help() .argv;var command = process.argv[2];if(command==='add')&#123; var note = nodes.addNote(argv.title,argv.body); if(note)&#123; console.log('add success'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;&#125;else if(command === 'list')&#123; var allnotes = nodes.getAll(); allnotes.forEach((note)=&gt;&#123; console.log(note)&#125;);&#125;else if(command =='read')&#123; var note = nodes.getNote(argv.title); if(note)&#123; console.log('find'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;else&#123; console.log('note not found'); &#125;&#125;else if(command=='remove')&#123; var noteRemoved = nodes.removeNote(argv.title); var message = noteRemoved?'Note was removed':'note not found'; console.log(message);&#125;else&#123; console.log('command not find');&#125; nodes.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263console.log('start nodes.js');const fs = require('fs');//从文件中获取节点var fetchNode = ()=&gt;&#123; try&#123; var notesString = fs.readFileSync('notes-data.json'); return JSON.parse(notesString); &#125;catch(e)&#123; return []; &#125;&#125;//保存节点到文件var saveNote = (notes)=&gt;&#123; fs.writeFileSync('notes-data.json',JSON.stringify(notes));&#125;//增加节点，如果新增返回新增节点。var addNote = (title,body)=&gt;&#123; var notes = fetchNode(); var note = &#123; title, body &#125;; //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); //没有相同的节点 if(duplicateNotes.length ===0)&#123; notes.push(note); saveNote(notes); return note; &#125;&#125;var getAll = ()=&gt;&#123; var notes = fetchNode(); return notes;&#125;;var getNote = (title)=&gt;&#123; var notes = fetchNode(); //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); return duplicateNotes[0];&#125;;var removeNote = (title)=&gt;&#123; var notes = fetchNode(); //筛选出不同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title!==title); saveNote(duplicateNotes); return notes.length !==duplicateNotes.length;&#125;;module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 测试 打开控制台，在当前目录下输入： 1&gt; node app.js add --help 控制台返回结果： 123456789app.js addadd a new note选项： --version 显示版本号 [布尔] --help 显示帮助信息 [布尔] --title, -t Title of note [必需] --body, -b Body of note [必需] 输入： 1&gt; node app.js --help 控制台返回结果： 1234567891011app.js [命令]命令： app.js add add a new note app.js list List all notes app.js read Read a note app.js remove Remove a note选项： --version 显示版本号 [布尔] --help 显示帮助信息 [布尔]","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[10]-案例-用户输入+json增删查改","slug":"node-10","date":"2018-11-14T04:11:04.000Z","updated":"2018-11-29T03:10:29.940Z","comments":true,"path":"2018/11/14/node-10/","link":"","permalink":"https://dreamerjonson.com/2018/11/14/node-10/","excerpt":"","text":"对于之前的代码进行封装 原始文件app.js 对于返回节点进行判断，如果新增了节点，就打印新增节点。 12345678910111213141516171819202122232425262728//打印字符串const yargs = require('yargs');const nodes = require('./nodes.js')console.log('Start app.');console.log(process.argv);console.log('yargs',yargs.argv);const argv = yargs.argv;var command = process.argv[2];if(command==='add')&#123; var note = nodes.addNote(argv.title,argv.body); if(note)&#123; console.log('add success'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;&#125;else if(command === 'list')&#123; nodes.getAll();&#125;else if(command =='read')&#123; nodes.getNote(argv.title);&#125;else if(command=='remove')&#123; nodes.removeNote(argv.title);&#125;else&#123; console.log('command not find');&#125; notes.js: 封装 获取节点以及保存节点、返回节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556console.log('start nodes.js');const fs = require('fs');//从文件中获取节点var fetchNode = ()=&gt;&#123; try&#123; var notesString = fs.readFileSync('notes-data.json'); return JSON.parse(notesString); &#125;catch(e)&#123; return []; &#125;&#125;//保存节点到文件var saveNote = (notes)=&gt;&#123; fs.writeFileSync('notes-data.json',JSON.stringify(notes));&#125;//增加节点，如果新增返回新增节点。var addNote = (title,body)=&gt;&#123; var notes = fetchNode(); var note = &#123; title, body &#125;; //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); //没有相同的节点 if(duplicateNotes.length ===0)&#123; notes.push(note); saveNote(notes); return note; &#125;&#125;var getAll = ()=&gt;&#123;console.log('Get All notes');&#125;;var getNote = (title)=&gt;&#123; console.log('getting note',title);&#125;;var removeNote = (title)=&gt;&#123; console.log('Removing note',title);&#125;;module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 测试 打开控制台，在当前目录下输入： 1&gt; node app.js add --title&#x3D;&quot;buy book3&quot; --body&#x3D;&quot;jonson&quot; 控制台返回结果： 1234567891011121314start nodes.jsStart app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;add&#39;, &#39;--title&#x3D;buy book3&#39;, &#39;--body&#x3D;jonson&#39; ]yargs &#123; _: [ &#39;add&#39; ], title: &#39;buy book3&#39;, body: &#39;jonson&#39;, &#39;$0&#39;: &#39;app.js&#39; &#125;add successtitle:buy book3body:jonson 移除节点 app.js： 123456789101112131415161718192021222324252627282930//打印字符串const yargs = require('yargs');const nodes = require('./nodes.js')console.log('Start app.');console.log(process.argv);console.log('yargs',yargs.argv);const argv = yargs.argv;var command = process.argv[2];if(command==='add')&#123; var note = nodes.addNote(argv.title,argv.body); if(note)&#123; console.log('add success'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;&#125;else if(command === 'list')&#123; nodes.getAll();&#125;else if(command =='read')&#123; nodes.getNote(argv.title);&#125;else if(command=='remove')&#123; var noteRemoved = nodes.removeNote(argv.title); var message = noteRemoved?'Note was removed':'note not found'; console.log(message);&#125;else&#123; console.log('command not find');&#125; notes.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859console.log('start nodes.js');const fs = require('fs');//从文件中获取节点var fetchNode = ()=&gt;&#123; try&#123; var notesString = fs.readFileSync('notes-data.json'); return JSON.parse(notesString); &#125;catch(e)&#123; return []; &#125;&#125;//保存节点到文件var saveNote = (notes)=&gt;&#123; fs.writeFileSync('notes-data.json',JSON.stringify(notes));&#125;//增加节点，如果新增返回新增节点。var addNote = (title,body)=&gt;&#123; var notes = fetchNode(); var note = &#123; title, body &#125;; //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); //没有相同的节点 if(duplicateNotes.length ===0)&#123; notes.push(note); saveNote(notes); return note; &#125;&#125;var getAll = ()=&gt;&#123;console.log('Get All notes');&#125;;var getNote = (title)=&gt;&#123; console.log('getting note',title);&#125;;var removeNote = (title)=&gt;&#123; var notes = fetchNode(); //筛选出不同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title!==title); saveNote(duplicateNotes); return notes.length !==duplicateNotes.length;&#125;;module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 测试2 打开控制台，在当前目录下输入： 1&gt; node app.js remove --title&#x3D;&quot;buy book2&quot; 控制台返回结果并且josn文件中对应元素被移除： 12345678start nodes.jsStart app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;remove&#39;, &#39;--title&#x3D;buy book2&#39; ]yargs &#123; _: [ &#39;remove&#39; ], title: &#39;buy book2&#39;, &#39;$0&#39;: &#39;app.js&#39; &#125;Note was removed 获取节点 app.js 12345678910111213141516171819202122232425262728293031323334353637//打印字符串const yargs = require('yargs');const nodes = require('./nodes.js')console.log('Start app.');console.log(process.argv);console.log('yargs',yargs.argv);const argv = yargs.argv;var command = process.argv[2];if(command==='add')&#123; var note = nodes.addNote(argv.title,argv.body); if(note)&#123; console.log('add success'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;&#125;else if(command === 'list')&#123; nodes.getAll();&#125;else if(command =='read')&#123; var note = nodes.getNote(argv.title); if(note)&#123; console.log('find'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;else&#123; console.log('note not found'); &#125;&#125;else if(command=='remove')&#123; var noteRemoved = nodes.removeNote(argv.title); var message = noteRemoved?'Note was removed':'note not found'; console.log(message);&#125;else&#123; console.log('command not find');&#125; notes.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162console.log('start nodes.js');const fs = require('fs');//从文件中获取节点var fetchNode = ()=&gt;&#123; try&#123; var notesString = fs.readFileSync('notes-data.json'); return JSON.parse(notesString); &#125;catch(e)&#123; return []; &#125;&#125;//保存节点到文件var saveNote = (notes)=&gt;&#123; fs.writeFileSync('notes-data.json',JSON.stringify(notes));&#125;//增加节点，如果新增返回新增节点。var addNote = (title,body)=&gt;&#123; var notes = fetchNode(); var note = &#123; title, body &#125;; //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); //没有相同的节点 if(duplicateNotes.length ===0)&#123; notes.push(note); saveNote(notes); return note; &#125;&#125;var getAll = ()=&gt;&#123;&#125;;var getNote = (title)=&gt;&#123; var notes = fetchNode(); //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); return duplicateNotes[0];&#125;;var removeNote = (title)=&gt;&#123; var notes = fetchNode(); //筛选出不同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title!==title); saveNote(duplicateNotes); return notes.length !==duplicateNotes.length;&#125;;module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 测试3 打开控制台，在当前目录下输入： 1&gt; node app.js read --title&#x3D;&quot;buy book3&quot; 控制台返回结果： 1234567891011start nodes.jsStart app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;read&#39;, &#39;--title&#x3D;buy book3&#39;, &#39;--body&#x3D;123&#39; ]yargs &#123; _: [ &#39;read&#39; ], title: &#39;buy book3&#39;, body: 123, &#39;$0&#39;: &#39;app.js&#39; &#125;findtitle:buy book3body:jonson 列出所有节点 app.js 12345678910111213141516171819202122232425262728293031323334353637//打印字符串const yargs = require('yargs');const nodes = require('./nodes.js')console.log('Start app.');console.log(process.argv);console.log('yargs',yargs.argv);const argv = yargs.argv;var command = process.argv[2];if(command==='add')&#123; var note = nodes.addNote(argv.title,argv.body); if(note)&#123; console.log('add success'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;&#125;else if(command === 'list')&#123; var allnotes = nodes.getAll(); allnotes.forEach((note)=&gt;&#123; console.log(note)&#125;);&#125;else if(command =='read')&#123; var note = nodes.getNote(argv.title); if(note)&#123; console.log('find'); console.log(`title:$&#123;note.title&#125;`); console.log(`body:$&#123;note.body&#125;`); &#125;else&#123; console.log('note not found'); &#125;&#125;else if(command=='remove')&#123; var noteRemoved = nodes.removeNote(argv.title); var message = noteRemoved?'Note was removed':'note not found'; console.log(message);&#125;else&#123; console.log('command not find');&#125; nodes.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556console.log('start nodes.js');const fs = require('fs');//从文件中获取节点var fetchNode = ()=&gt;&#123; try&#123; var notesString = fs.readFileSync('notes-data.json'); return JSON.parse(notesString); &#125;catch(e)&#123; return []; &#125;&#125;//保存节点到文件var saveNote = (notes)=&gt;&#123; fs.writeFileSync('notes-data.json',JSON.stringify(notes));&#125;//增加节点，如果新增返回新增节点。var addNote = (title,body)=&gt;&#123; var notes = fetchNode(); var note = &#123; title, body &#125;; //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); //没有相同的节点 if(duplicateNotes.length ===0)&#123; notes.push(note); saveNote(notes); return note; &#125;&#125;var getAll = ()=&gt;&#123; var notes = fetchNode(); return notes;&#125;;var getNote = (title)=&gt;&#123; var notes = fetchNode(); //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); return duplicateNotes[0];&#125;;var removeNote = (title)=&gt;&#123; var notes = fetchNode(); //筛选出不同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title!==title); saveNote(duplicateNotes); return notes.length !==duplicateNotes.length;&#125;; 测试4 打开控制台，在当前目录下输入： 1&gt; node app.js list 控制台返回结果： 12345678start nodes.jsStart app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;list&#39; ]yargs &#123; _: [ &#39;list&#39; ], &#39;$0&#39;: &#39;app.js&#39; &#125;&#123; title: &#39;buy book3&#39;, body: &#39;jonson&#39; &#125;&#123; title: &#39;buy book2&#39;, body: &#39;jonson&#39; &#125;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[9]-保存节点到json文件","slug":"node-9","date":"2018-11-13T13:03:36.000Z","updated":"2018-11-29T03:09:13.036Z","comments":true,"path":"2018/11/13/node-9/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-9/","excerpt":"","text":"原始文件 app.js: 12345678910111213141516171819202122const yargs = require('yargs');const nodes = require('./nodes.js')console.log('Start app.');console.log(process.argv);console.log('yargs',yargs.argv);const argv = yargs.argv;var command = process.argv[2];if(command==='add')&#123; nodes.addNote(argv.title,argv.body);&#125;else if(command === 'list')&#123; nodes.getAll();&#125;else if(command =='read')&#123; nodes.getNote(argv.title);&#125;else if(command=='remove')&#123; nodes.removeNote(argv.title);&#125;else&#123; console.log('command not find');&#125; nodes.js 123456789101112131415161718192021222324252627282930313233343536373839404142console.log('start nodes.js');const fs = require('fs');var addNote = (title,body)=&gt;&#123; var notes = []; var note = &#123; title, body &#125;; try&#123; //读取json文件，读出来是string var notesString = fs.readFileSync('notes-data.json'); // string转换为json对象 notes = JSON.parse(notesString); &#125;catch(e)&#123; &#125; //增加 notes.push(note); //保存 fs.writeFileSync('notes-data.json',JSON.stringify(notes));&#125;var getAll = ()=&gt;&#123;console.log('Get All notes');&#125;;var getNote = (title)=&gt;&#123; console.log('getting note',title);&#125;;var removeNote = (title)=&gt;&#123; console.log('Removing note',title);&#125;;module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 打开控制台，在当前目录下输入： 1&gt; node app.js add --title&#x3D;&quot;buy book2&quot; --body&#x3D;&quot;jonson&quot; 将节点添加到notes-data.json文件中. 再次输入： 1&gt; node app.js add --title&#x3D;&quot;buy book2&quot; --body&#x3D;&quot;jonson&quot; notes-data.json: 1[&#123;\"title\":\"buy book2\",\"body\":\"jonson\"&#125;,&#123;\"title\":\"buy book2\",\"body\":\"jonson\"&#125;] 改进 不添加重复的节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546console.log('start nodes.js');const fs = require('fs');var addNote = (title,body)=&gt;&#123; var notes = []; var note = &#123; title, body &#125;; try&#123; var notesString = fs.readFileSync('notes-data.json'); notes = JSON.parse(notesString); &#125;catch(e)&#123; &#125; //筛选出相同的节点 var duplicateNotes = notes.filter((note)=&gt;note.title===title); //没有相同的节点 if(duplicateNotes.length ===0)&#123; notes.push(note); fs.writeFileSync('notes-data.json',JSON.stringify(notes)); &#125;&#125;var getAll = ()=&gt;&#123;console.log('Get All notes');&#125;;var getNote = (title)=&gt;&#123; console.log('getting note',title);&#125;;var removeNote = (title)=&gt;&#123; console.log('Removing note',title);&#125;;module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 再次输入不会添加节点： 1&gt; node app.js add --title&#x3D;&quot;buy book2&quot; --body&#x3D;&quot;jonson&quot;","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[8]-json处理","slug":"node-8-json","date":"2018-11-13T12:53:49.000Z","updated":"2018-11-29T03:05:17.090Z","comments":true,"path":"2018/11/13/node-8-json/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-8-json/","excerpt":"","text":"原始文件 json.js: 1234567891011121314151617181920212223242526//字符串var personString = '&#123;\"name\":\"Andrew\",\"age\":25&#125;';console.log( typeof personString);//string//转换为对象var person = JSON.parse(personString);console.log(typeof person);//objectconsole.log(person);//&#123; name: 'Andrew', age: 25 &#125;const fs= require('fs');//对象var originalNote = &#123; title:'some title', body:'some body'&#125;;//转换为字符串var originalNoteString = JSON.stringify(originalNote);//字符串写入到文件中fs.writeFileSync('notes.json',originalNoteString);//读取文件var noteString = fs.readFileSync('notes.json');//转换为对象var note = JSON.parse(noteString);console.log(typeof note);//objectconsole.log(note.title);//some title 获取用户输入 打开控制台，在当前目录下输入： 1&gt; node json.js 输出字符串 12345stringobject&#123; name: &#39;Andrew&#39;, age: 25 &#125;objectsome title","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[7]-yargs处理命令行参数","slug":"node-7-yargs","date":"2018-11-13T12:08:06.000Z","updated":"2018-11-29T03:05:07.426Z","comments":true,"path":"2018/11/13/node-7-yargs/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-7-yargs/","excerpt":"","text":"yargs用于方便的处理命令行参数。导入yargs包，在项目路径下： 1&gt; npm install --save yargs 原始文件 app.js: 12345678const yargs = require('yargs');console.log('Start app.');console.log(process.argv);console.log('yargs',yargs.argv);var command = process.argv[2]; 获取用户输入 打开控制台，在当前目录下输入： 1&gt; node app.js remove --title&#x3D;&quot;buy book&quot; 输出字符串 1234567Start app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;remove&#39;, &#39;--title&#x3D;buy book&#39; ]yargs &#123; _: [ &#39;remove&#39; ], title: &#39;buy book&#39;, &#39;$0&#39;: &#39;app.js&#39; &#125;Remove node app.js 1234567891011121314151617181920212223//打印字符串const yargs = require('yargs');const nodes = require('./nodes.js')console.log('Start app.');console.log(process.argv);console.log('yargs',yargs.argv);const argv = yargs.argv;var command = process.argv[2];if(command==='add')&#123; nodes.addNote(argv.title,argv.body);&#125;else if(command === 'list')&#123; nodes.getAll();&#125;else if(command =='read')&#123; nodes.getNote(argv.title);&#125;else if(command=='remove')&#123; nodes.removeNote(argv.title);&#125;else&#123; console.log('command not find');&#125; notes.js: 12345678910111213141516171819202122232425console.log('start nodes.js');var addNote = (title,body)=&gt;&#123;console.log('Adding note',title,body);&#125;var getAll = ()=&gt;&#123;console.log('Get All notes');&#125;;var getNote = (title)=&gt;&#123; console.log('getting note',title);&#125;;var removeNote = (title)=&gt;&#123; console.log('Removing note',title);&#125;;module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 测试 打开控制台，在当前目录下输入： 1&gt; node app.js remove --title&#x3D;&quot;buy book&quot; 输出字符串: 12345678start nodes.jsStart app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;remove&#39;, &#39;--title&#x3D;buy book&#39; ]yargs &#123; _: [ &#39;remove&#39; ], title: &#39;buy book&#39;, &#39;$0&#39;: &#39;app.js&#39; &#125;Removing note buy book 打开控制台，在当前目录下输入： 1&gt; node app.js add --title&#x3D;&quot;buy book&quot; --body&#x3D;&quot;jonson&quot; 输出字符串: 123456789101112start nodes.jsStart app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;add&#39;, &#39;--title&#x3D;buy book&#39;, &#39;--body&#x3D;jonson&#39; ]yargs &#123; _: [ &#39;add&#39; ], title: &#39;buy book&#39;, body: &#39;jonson&#39;, &#39;$0&#39;: &#39;app.js&#39; &#125;Adding note buy book jonson","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[6]-获取用户输入","slug":"node-6","date":"2018-11-13T09:50:36.000Z","updated":"2018-11-29T03:04:53.943Z","comments":true,"path":"2018/11/13/node-6/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-6/","excerpt":"","text":"原始文件 app.js: 123console.log('Start app.');console.log(process.argv); 获取用户输入 打开控制台，在当前目录下输入： 1&gt; nodemon app.js add 输出字符串 默认第一个为node系统路径 第二个为文件路径 后面为输入的控制台参数 1234Start app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;add&#39; ] 打开控制台，在当前目录下输入： 1&gt; node app.js add list 输出字符串: 1234[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;add&#39;, &#39;list&#39; ] 利用命令行执行不同操作 123456789101112131415161718192021//打印字符串console.log('Start app.');console.log(process.argv);//获取第三个参数var command = process.argv[2];//不同命令执行不同操作if(command==='add')&#123; console.log('Adding new note');&#125;else if(command === 'list')&#123; console.log('Listing allnodes');&#125;else if(command =='read')&#123; console.log('reading node');&#125;else if(command=='remove')&#123; console.log('Remove node');&#125;else&#123; console.log('command not find');&#125; 缺点 打开控制台，在当前目录下输入： 1&gt; node app.js remove --title&#x3D;&quot;buy book&quot; 不能很好的区分开’–title=buy book’ 输出字符串: 123456Start app.[ &#39;&#x2F;Users&#x2F;jackson&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v10.13.0&#x2F;bin&#x2F;node&#39;, &#39;&#x2F;Users&#x2F;jackson&#x2F;Desktop&#x2F;compaign&#x2F;app.js&#39;, &#39;remove&#39;, &#39;--title&#x3D;buy book&#39; ]Remove node","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[5]-nodemon实现自动测试","slug":"node-5-nodemon","date":"2018-11-13T03:59:34.000Z","updated":"2018-11-29T03:04:44.819Z","comments":true,"path":"2018/11/13/node-5-nodemon/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-5-nodemon/","excerpt":"","text":"nodemon nodemon帮助我们，当我们修改文件时，node程序自动从新执行。 安装 1&gt; npm install -g nodemon 原始文件 app.js: 12345678910console.log('Start app.');const _ = require('lodash');判断是否为字符串console.log(_.isString(true));console.log(_.isString(\"abc\"));//筛选重复数组var filteredArray = _.uniq(['Jonson',1,'Jonson',1,2,3,4]);console.log(filteredArray); 打开控制台，在当前目录下输入： 1&gt; nodemon app.js 输出字符串 12345678[nodemon] 1.18.6[nodemon] to restart at any time, enter &#96;rs&#96;[nodemon] watching: *.*[nodemon] starting &#96;node app.js&#96;Start app.falsetrue[ &#39;Jonson&#39;, 1, 2, 3, 4 ] 修改文件： 123var filteredArray = _.uniq(['Jonson',1,'Jonson',1,2,3,4]);替换为：var filteredArray = _.uniq(['Jonson',1,'Jonson',1]); 自动输出字符串: 1234567[nodemon] clean exit - waiting for changes before restart[nodemon] restarting due to changes...[nodemon] starting `node app.js`Start app.falsetrue[ 'Jonson', 1 ]","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[4]-第三方包","slug":"node-4","date":"2018-11-13T03:50:09.000Z","updated":"2018-11-29T03:04:34.214Z","comments":true,"path":"2018/11/13/node-4/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-4/","excerpt":"","text":"导入第三方包 nodejs 有丰富的第三方模块导入，例如要导入lodash包，在项目路径下： 1&gt; npm install --save lodash app.js: 12345678910console.log('Start app.');const _ = require('lodash');判断是否为字符串console.log(_.isString(true));console.log(_.isString(\"abc\"));//筛选重复数组var filteredArray = _.uniq(['Jonson',1,'Jonson',1,2,3,4]);console.log(filteredArray); 打开控制台，在当前目录下输入： 1&gt; node app.js 输出字符串 1234Start app.falsetrue[ &#39;Jonson&#39;, 1, 2, 3, 4 ] 参考： npm 官网 lodash文档","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[3]-require导入模块","slug":"node-3-require","date":"2018-11-13T03:05:12.000Z","updated":"2018-11-29T03:04:26.331Z","comments":true,"path":"2018/11/13/node-3-require/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-3-require/","excerpt":"","text":"require 导入其他文件 require可以执行其他文件的内容。 新建文件: nodes.js: 1console.log('start nodes.js'); app.js: 1234567891011121314151617//打印字符串console.log('Start app.');const nodes = require('./nodes.js')//导入node自带modules，fs文件操作const fs = require('fs');//os系统操作const os = require('os');//获取系统名字var user = os.userInfo();//添加字符串到回调函数中，并执行回调函数。出错就会报错，不出错就会打印出'The \"data to append\" was appended to file!'fs.appendFile('greetings.txt',`Hello $&#123;user.username&#125;`,(err) =&gt; &#123; if (err) throw err; console.log('The \"data to append\" was appended to file!');&#125;); 打开控制台，在当前目录下输入： 1&gt; node app.js 输出字符串 123Start app.start nodes.jsThe &quot;data to append&quot; was appended to file! require 导入属性 nodes.js: 123console.log('start nodes.js');module.exports.age = 25; app.js: 1234567891011121314151617//打印字符串console.log('Start app.');const nodes = require('./nodes.js')//导入node自带modules，fs文件操作const fs = require('fs');//os系统操作const os = require('os');//获取系统名字var user = os.userInfo();//添加字符串到回调函数中，并执行回调函数。出错就会报错，不出错就会打印出'The \"data to append\" was appended to file!'fs.appendFile('greetings.txt',`Hello $&#123;user.username&#125; age $&#123;nodes.age&#125;`,(err) =&gt; &#123; if (err) throw err; console.log('The \"data to append\" was appended to file!');&#125;); 打开控制台，在当前目录下输入： 1&gt; node app.js 文件中存储：Hello jackson age 25 require 导入函数 nodes.js: 123456console.log('start nodes.js');module.exports.addNote = ()=&gt;&#123; console.log('addNode'); return 'New Node';&#125;; app.js: 123456console.log('Start app.');const nodes = require('./nodes.js') const res = nodes.addNote();console.log(res); 打开控制台，在当前目录下输入： 1&gt; node app.js 输出字符串 1234Start app.start nodes.jsaddNodeNew Node require 导入带参函数 nodes.js: 1234567891011console.log('start nodes.js');module.exports.add = (a,b)=&gt;&#123; return a+b;&#125;;module.exports.addNote = ()=&gt;&#123; console.log('addNode'); return 'New Node';&#125;; app.js: 1234567//打印字符串console.log('Start app.');const nodes = require('./nodes.js') const res = nodes.add(1,2);console.log(res); 打开控制台，在当前目录下输入： 1&gt; node app.js 输出字符串 123Start app.start nodes.js3","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"nodejs渐入佳境[2]-Helloworld入门","slug":"node-2-Helloworld","date":"2018-11-12T16:51:44.000Z","updated":"2018-11-29T03:04:04.581Z","comments":true,"path":"2018/11/13/node-2-Helloworld/","link":"","permalink":"https://dreamerjonson.com/2018/11/13/node-2-Helloworld/","excerpt":"","text":"nodejs helloworld 新建文件app.js： 12//打印字符串console.log('Start app.'); 打开控制台，在当前目录下输入： 1&gt; node app.js 输出字符串Start app. nodejs 复杂helloworld 12345678910111213141516//打印字符串console.log('Start app.');//导入node自带modules，fs文件操作const fs = require('fs');//os系统操作const os = require('os');//获取系统名字var user = os.userInfo();//添加字符串到回调函数中，并执行回调函数。出错就会报错，不出错就会打印出'The \"data to append\" was appended to file!'fs.appendFile('greetings.txt',`Hello $&#123;user.username&#125;`,(err) =&gt; &#123; if (err) throw err; console.log('The \"data to append\" was appended to file!');&#125;); 打开控制台，在当前目录下输入： 1&gt; node app.js 执行结果为，创建greetings.txt文件夹，并且添加了Hello jackson。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/categories/nodejs/"}],"tags":[{"name":"nodejs 前端","slug":"nodejs-前端","permalink":"https://dreamerjonson.com/tags/nodejs-%E5%89%8D%E7%AB%AF/"}]},{"title":"深度理解nodejs[4]-cluster多线程node","slug":"深度理解nodejs-4-cluster多线程node","date":"2018-11-10T11:57:57.000Z","updated":"2018-11-10T14:00:47.842Z","comments":true,"path":"2018/11/10/深度理解nodejs-4-cluster多线程node/","link":"","permalink":"https://dreamerjonson.com/2018/11/10/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3nodejs-4-cluster%E5%A4%9A%E7%BA%BF%E7%A8%8Bnode/","excerpt":"","text":"传统node单线程缺陷 下面的express程序可以看出nodejs单线程的缺陷，当访问主页面localhost:3000时，doWork(5000)方法会暂停5秒钟。 由于长时间的等待时间会使得node陷入到停顿的状态。当其他的请求来的时候，也只能够等待。例如当访问后立即访问localhost:3000/fast，只能够等待一段时间。 12345678910111213141516const express = require('express');const app = express();function doWork(duration)&#123; const start = Date.now(); while(Date.now()-start&lt;duration)&#123;&#125;&#125;app.get('/',(req,res)=&gt;&#123; doWork(5000); res.send(\"i like jonson\")&#125;)app.get('/fast',(req,res)=&gt;&#123; res.send(\"i like jonson\")&#125;)app.listen(3000); cluster多线程node增强node表现 使用nodejs内置的cluster module可以让多个node实例同时运行，管理多个node实例。 cluster管理多个node实例。cluster manager实例与child实例都会调用此文件中的代码。 通过cluster.isMaster将两者区分开。 cluster manager 中cluster.isMaster为true。 child实例实例中cluster.isMaster为false。 cluster.fork()代表新开一个child 实例。 下面的代码在一开始，cluster manager实例就新开了4个child 实例。 所以即便是一个child停顿不会影响其他child实例工作。 1234567891011121314151617181920212223242526const cluster = require(\"cluster\");if(cluster.isMaster)&#123; cluster.fork(); cluster.fork(); cluster.fork(); cluster.fork();&#125;else&#123; const express = require('express'); const app = express(); function doWork(duration)&#123; const start = Date.now(); while(Date.now()-start&lt;duration)&#123;&#125; &#125; app.get('/',(req,res)=&gt;&#123; doWork(5000); res.send(\"i like jonson\") &#125;) app.get('/fast',(req,res)=&gt;&#123; res.send(\"i like jonson\") &#125;) app.listen(3000);&#125; cluster缺陷 并不是cluster创建的child实数越多越好。因为cluster会让所有的请求都同时的结束。 想象一下我们fork了6个child，当6个请求来的时候，如果计算机没有这个处理能力，只能处理两个线程，但是6个请求又必须同时的时间结束，这反而拖慢了所有的速度。 这不如两个两个的执行好！","categories":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"solidity智能合约[8]-位运算与字面量","slug":"solidity-8","date":"2018-11-10T07:29:18.000Z","updated":"2018-11-20T16:37:46.932Z","comments":true,"path":"2018/11/10/solidity-8/","link":"","permalink":"https://dreamerjonson.com/2018/11/10/solidity-8/","excerpt":"","text":"位运算 solidity中，可以对于最底层的位进行操作。 由于以太坊中需要消耗gas，因此，为了节约gas、所以对于位的操作会用到比较频繁。 solidity中支持多种类型的位运算操作 1、位与 &amp; 2、位或 | 3、位异或 ^ 4、位取反 ~ 5、&lt;&lt; 6、&gt;&gt; 数字3、4的二进制表示 数字3、4的底层表示 位与 位与 位或 位或 位异或 位异或 位取反 位取反 位左移 位左移 位右移 位右移 位运算例子 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.23;contract weiTest&#123; uint8 a = 3; uint8 b = 4; function weiyu() public view returns(uint8)&#123; return a &amp;b; &#125; function weihuo() public view returns(uint8)&#123; return a |b; &#125; function weiyihuo() public view returns(uint8)&#123; return a^b; &#125; function qufan() public view returns(uint8)&#123; return ~a; &#125; function leftMove() public view returns(uint8)&#123; return a&lt;&lt;1; &#125; function rightMove() public view returns(uint8)&#123; return a&gt;&gt;1; &#125;&#125; 整型字面量 solidity在计算过程中的中间值，支持任意的精度，如小数。不会发生溢出操作。 只有在将计算结果赋值给特定类型的时候，才会发生截断溢出等操作。 123456789101112131415//返回1function TestInterger() public pure returns(uint8)&#123; uint8 num = (2**800+1) - 2**800; return num; &#125;//返回50 function TestInterger2() public pure returns(uint8)&#123; uint8 num = 2/4*100; return num; &#125;//返回1 function TestInterger3() public pure returns(uint8)&#123; uint8 num =11111111111111111111111111111111111111111111112-11111111111111111111111111111111111111111111111; return num; &#125;","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[7]-整型与运算","slug":"solidity-7","date":"2018-11-10T02:49:54.000Z","updated":"2018-11-20T16:37:50.635Z","comments":true,"path":"2018/11/10/solidity-7/","link":"","permalink":"https://dreamerjonson.com/2018/11/10/solidity-7/","excerpt":"","text":"整型变量 整数是现实中处理最多的单位，在solidity中的整数类型有int和uint，int类型可以存储负数，uint类型只能够存储非负数。 int类型：int8,int16,int24,int32…int256 uint类型：uint8,uint16,uint24,uint32…uint256 后面的数字代表的是计算机的最小存储单位：位。 1个字节代表8位。类型以一个字节递增，最大到256位，也就是32个字节。 int == int256 uint == uint256 整型运算 1、加 2、减 3、乘 4、除 5、取余数 6、平方 123456789101112131415161718192021222324//1、加function add(uint a,uint b) public pure returns(uint)&#123; return a+b; &#125; //2、减 function sub(uint a,uint b) public pure returns(uint)&#123; return a-b; &#125; //3、乘 function cheng(uint a,uint b) public pure returns(uint)&#123; return a*b; &#125; //4、除 function chu(uint a,uint b) public pure returns(uint)&#123; return a/b; &#125; //5、取余数 function yu(uint a,uint b) public pure returns(uint)&#123; return a%b; &#125;//6、平方 function pingfang(uint a,uint b) public pure returns(uint)&#123; return a**b; &#125; 整型溢出 整数如果处理不当，会发生溢出效应。如下面的函数overflow。 函数的功能为执行+1的操作。 当传递4、返回5. 传递200，返回201，但是当传递255的时候，会返回0，这是由于发生了溢出。 要理解溢出的本质，需要明白整型在计算机中的存储方式。 12345// 1111 1111//10000 0000function overflow(uint8 a) public pure returns(uint8)&#123; return a +1;&#125; 整型在底层的存储方式 计算机最小的存储单位为位，存储0或者1。 下面的图片描述了以位标示的二进制代码101转换为10进制后的计算方式。 底层存储方式 以此类推，可知道，uint8在内存中占8位，最大值为全部都存储1的时候，转换为10进制为255。 uint8最大值 当加一之后， 1111 1111 变为了 10000 0000 但是只能存储8位，所以截断之后，变为了 0000 0000 所以返回结果为0","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[6]-基本类型与bool运算","slug":"solidity-6","date":"2018-11-09T16:22:51.000Z","updated":"2018-11-20T16:37:54.328Z","comments":true,"path":"2018/11/10/solidity-6/","link":"","permalink":"https://dreamerjonson.com/2018/11/10/solidity-6/","excerpt":"","text":"变量 存储数据的抽象单位，代表内存中的一段空间。 类型 同其他的编程语言一样，solidity中也有许多基本的类型。类型决定了存储空间的大小和解析的方式。 下面列举出了solidity中基本的类型int、uint、byte、string、bool 基本类型 bool类型 这一小节中介绍基本的bool类型，bool类型只能够存储true或者false。 bool运算与运算符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pragma solidity ^0.4.23;contract BooleanTest&#123; bool _a; int num1 = 100; int num2 = 200;//1、不赋初值的变量和默认返回false function getBool() public view returns(bool)&#123; return _a; &#125;//2、 返回true。 !运算符 将true变为false，false变为true function getBool2() public view returns(bool)&#123; return !_a; &#125;//3、==运算符，判断变量是否相同，相等为true，不等为false function equal() public view returns(bool)&#123; return num1==num2; &#125;//4、！=运算符，判断变量是否不同，相等为fasle，不等为true function equal2() public view returns(bool)&#123; return num1!=num2; &#125;//5、&amp;&amp; || 与或非的逻辑 function yu() public view returns(bool)&#123; return (num1==num2) &amp;&amp; true; &#125; function yu2() public view returns(bool)&#123; return (num1!=num2) &amp;&amp; true; &#125; function huo() public view returns(bool)&#123; return (num1==num2) || true; &#125; function huo2() public view returns(bool)&#123; return (num1==num2) || false; &#125;&#125; &amp;&amp; || 与或非的逻辑 1234567true &amp;&amp; false falsefalse &amp;&amp; true falsetrue &amp;&amp; true truetrue || false truefalse || true truefalse || false false 与或非","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[5]——一笔交易详解","slug":"solidity-5","date":"2018-11-09T12:46:26.000Z","updated":"2018-11-20T16:37:57.652Z","comments":true,"path":"2018/11/09/solidity-5/","link":"","permalink":"https://dreamerjonson.com/2018/11/09/solidity-5/","excerpt":"","text":"在之前,我们已经写好了一个最简单的helloworld合约,如下： 1234567891011121314151617pragma solidity ^0.4.23;contract HelloWorld&#123; string public name = \"jonson\"; function getName() public view returns(string)&#123; return name; &#125; function changeName(string _name) public&#123; name = _name; &#125; function testPure(uint a,uint b) public pure returns(uint)&#123; return a+b; &#125;&#125; 和pure和view不同，当我们执行changeName方法时，会发现，我们需要消耗gas。这笔事务会发送给全网所有的节点。全网所有的节点都会执行同样的操作。 当我们调用函数会在remix控制台中显示一些信息。 一笔交易的信息详解： 控制台信息 其中： 1、statues：代表当前交易状态，是否提交到区块链中成功。 2、transation hash:唯一标识此交易。 3、from:调用者地址。 4、to:合约地址 5、gas：此交易gas的最大限制 6、transation cost:此交易花费的总gas的大小。包含了excution cost。例如一笔交易基本的cost为21000gas。部署合约最小的成本为32000gas 7、excution cost：交易的执行成本。特指在以太坊虚拟机中运行的成本。 8、hash：同transation hash。 9、input 调用函数、传递进以太坊虚拟机中的二进制代码。 10、decode input 构造函数输入。 11、函数返回值 12、log 事件信息存储在其中 13、value 交易附带的以太币。 input详解 对于此例来说，如果我调用changeName传递的参数为&quot;olaya&quot;,那么input中的信息为： input 1、0x5353a2d8前4个字节，是函数声明hash后的前4个字节，用于查找到函数的位置。 2、0000000000000000000000000000000000000000000000000000000000000020第一个参数的偏移量，0x20是10进制的32，代表olaya这个参数偏移了32个字节。 3、0000000000000000000000000000000000000000000000000000000000000005string是特殊的动态长度数组，前面需要有长度来标示占了几个字节，扩充到32个字节。 4、6f6c617961000000000000000000000000000000000000000000000000000000olaya16进制标示，扩充到32个字节。。 参考资料： transation cost and excution cost","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[4]-pure与view剖析","slug":"solidity-4","date":"2018-11-09T09:46:32.000Z","updated":"2018-11-20T16:38:01.616Z","comments":true,"path":"2018/11/09/solidity-4/","link":"","permalink":"https://dreamerjonson.com/2018/11/09/solidity-4/","excerpt":"","text":"pure与view代码例子 如下的一段solidity智能合约中，只要有了pure与view修饰符的函数，那么调用函数就不会消耗gas。 而没有pure与view修饰的函数，如下面的change就会消耗gas。 12345678910111213141516171819pragma solidity ^0.4.23;contract HelloWorld&#123; string public name = \"jonson\"; function getName() public view returns(string)&#123; return name; &#125; function changeName(string _name) public&#123; name = _name; &#125; function testPure(uint a,uint b) public pure returns(uint)&#123; return a+b; &#125;&#125; pure与view使用场景 view: 可以自由调用，因为它只是“查看”区块链的状态而不改变它 pure: 也可以自由调用，既不读取也不写入区块链 pure与view原理 pure：不读取更不修改区块上的变量，使用本机的CPU资源计算我们的函数。所以不消耗任何的资源这是很容易的理解的。 view: 但是view既然要读取区块链上的值，为什么也不用消耗gas呢？😃 其实很简单，因为作为一个全节点来说，会同步保存所有的信息，保存在本地中。 那么我们要查看区块链上的资源，同样可以直接在一个全节点之上查询数据即可。 我不需要全世界的节点都知道。都去同时的处理这笔事务。我也不需要将调用这笔函数的信息记录在区块链上。 所以view仍然不消耗gas。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity智能合约[3]-代码结构","slug":"solidity-3-","date":"2018-11-09T09:19:45.000Z","updated":"2018-11-20T16:38:05.186Z","comments":true,"path":"2018/11/09/solidity-3-/","link":"","permalink":"https://dreamerjonson.com/2018/11/09/solidity-3-/","excerpt":"","text":"合约结构 1、明确solidity的版本号。 此行意味着我们正在阻止我们的程序被一个比0.4.0更老的编译器编译^表示向上兼容，但是不能够被0.5.0及其以上的编译器编译。 我们这样做是为了尽量减少代码以意想不到或不兼容的方式编译时可能发生的错误的风险。 2、定义一个合约，内部有不同的方法和属性。 描述一个对象，可以从属性和行为两个方面，这正是面向对象的重要特征。 3、在合约的内部声明变量的方法和属性。 4、定义不同的函数、属于不同的函数成员。 代码结构 函数的一般形式 1function (&lt;parameter types&gt;) &#123;public|internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)] function 函数修饰符 public：任何人都可以调用该函数，包括DApp的使用者。 private：只有合约本身可以调用该函数（在另一个函数中）。 internal：只有这份合同以及由此产生的所有合同才能称之为合同。 external：只有外部可以调用该函数，而合约内部不能调用。 view: 可以自由调用，因为它只是“查看”区块链的状态而不改变它 pure: 也可以自由调用，既不读取也不写入区块链 payable:常常用于将代币发送给合约地址。 修饰符","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"深度理解nodejs[3]—疯狂事件代码","slug":"深度理解nodejs-3-—疯狂事件代码","date":"2018-11-09T05:14:16.000Z","updated":"2018-11-09T05:28:08.781Z","comments":true,"path":"2018/11/09/深度理解nodejs-3-—疯狂事件代码/","link":"","permalink":"https://dreamerjonson.com/2018/11/09/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3nodejs-3-%E2%80%94%E7%96%AF%E7%8B%82%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%A0%81/","excerpt":"","text":"疯狂的代码。 下面这段疯狂的代码，你能知道它输出什么结果吗？ 123456789101112131415161718192021222324252627282930const https = require('https');const start = Date.now();const fs = require('fs');const crypto = require('crypto');function dorequest()&#123; https.request('https://www.baidu.com',res=&gt;&#123; res.on('data',()=&gt;&#123;&#125;); res.on('end',()=&gt;&#123; console.log(Date.now()-start); &#125;); &#125;) .end();&#125;function dohash()&#123; crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('hash:',Date.now()-start); &#125;);&#125;dorequest();fs.readFile('test.js','utf8',()=&gt;&#123; console.log('FS:',Date.now()-start);&#125;);dohash();dohash();dohash();dohash(); 测试速度： 12345642hash: 785FS: 785hash: 788hash: 790hash: 790 解释： https不依靠libuv库的4个默认线程，操作系统资源。其第一个最快的执行完毕 FS和pbkdf2都使用了libuv中的线程池 一开始FS与三个pbkdf2抢占了libuv线程池的4个线程，但是由于FS读取文件，中断操作。libuv将线程切换到执行最后一个pbkdf2函数。 等到某一个pbkdf2函数执行完毕后，则继续执行FS函数，所以看到了上面的结果。","categories":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"深度理解nodejs[2]-事件循环","slug":"深度理解nodejs-2","date":"2018-11-09T01:07:15.000Z","updated":"2018-11-09T05:33:06.264Z","comments":true,"path":"2018/11/09/深度理解nodejs-2/","link":"","permalink":"https://dreamerjonson.com/2018/11/09/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3nodejs-2/","excerpt":"","text":"进程与线程 我们在电脑中会运行多个程序，每一个程序中都会有多个线程。 例如我们运行比特币客户端的时候，我们某一个线程要处理网络、某一个线程要处理挖矿、某一个线程要处理用户输入… 线程的调度使用了操作系统级别的调度器来明确了哪一个线程应该被执行。线程也有优先级之分，例如监听鼠标滑动的优先级就会很高，因为其不能等待太长的时间。 为了在给定的时间内更快更多的处理线程： 1、我们可以通过增加CPU的核心数量或者是 2、调度器当监测到线程中运行中断，如读取文件网络时，及时切换到其他的线程中执行。 事件循环 nodejs是单线程的事件循环机制 伪代码演示事件循环： 123456789101112131415161718192021222324const peningTimers =[];const pendingOSTasks=[];cosnt pendingOperations=[];1、初始化myfile.runContent()function shouldContinue()&#123; //是否继续 1、检查setTimeOut、setInterval、setImmediate 2、检查是否有监听端口等操作系统级别的任务 3、检查是否有文件、网络等长期的操作return peningTimers.length || pendingOSTasks.length || pendingOperations.length;&#125;2、事件循环while(shouldContinue())&#123;//1.观察peningTimers.length，是否调查setTimeOut、setInterval等函数//2、观察pendingOSTasks.length pendingOperations.length，并调用相关回调函数//3.暂停、一直等到上面的某一个事件完成//4、调用setImmediate等函数//5、处理close事件&#125;3、退出 nodejs的单线程与多线程 nodejs的单线程，是对于其处理事件循环来讲的，有了事件触发，就会执行相应函数。没有事件触发，就会等待。从这个意义上来说，nodejs是单线程的。 但是在处理具体的任务，函数的时候。nodejs确是多线程的。 nodejs的单线程与多线程证明 1234567const crypto = require('crypto');const start = Date.now();crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('1:',Date.now()-start);&#125;); 测试pbkdf2速度：1: 868 1234567891011const crypto = require('crypto');const start = Date.now();crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('1:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('2:',Date.now()-start);&#125;); 测试pbkdf2速度: 121: 8912: 893 说明了pbkdf2函数是多线程来执行的。libuv中默认有4个线程，pbkdf2函数正是借助libuv实现了多线程。 测试libuv中默认有4个线程 12345678910111213141516171819const crypto = require('crypto');const start = Date.now();crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('1:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('2:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('3:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('4:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('5:',Date.now()-start);&#125;); 123454: 9191: 9223: 9362: 9365: 1813 注意，明显第5个线程时间增加了一倍，因为默认libuv中默认有4个线程，第5个线程陷入了等待。 修改libuv中默认默认线程 123456789101112131415161718192021process.env.UV_THREADPOOL_SIZE = 5;const crypto = require('crypto');const start = Date.now();crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('1:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('2:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('3:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('4:',Date.now()-start);&#125;);crypto.pbkdf2('a','b',100000,512,'sha512',()=&gt;&#123; console.log('5:',Date.now()-start);&#125;); 测试速度： 123451: 9565: 9633: 9702: 9714: 974 http库 123456789101112131415161718192021const https &#x3D; require(&#39;https&#39;);const start &#x3D; Date.now();function dorequest()&#123; https.request(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;,res&#x3D;&gt;&#123; res.on(&#39;data&#39;,()&#x3D;&gt;&#123;&#125;); res.on(&#39;end&#39;,()&#x3D;&gt;&#123; console.log(Date.now()-start); &#125;); &#125;) .end();&#125;dorequest();dorequest();dorequest();dorequest();dorequest();dorequest();dorequest();dorequest();dorequest(); 测试速度： 123456789485052535455575862 https网络访问，调用了操作系统资源，libuv只是起到了代理的作用，所以不收到libuv默认4个线程的限制。 总结 pbkdf2等函数是借助libuv实现多线程的。但是当这些函数执行完毕后，会触发完成事件.nodejs主线程触发事件的处理却是单线程的。","categories":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"深度理解nodejs[1]-node底层机制","slug":"深度理解nodejs","date":"2018-11-08T15:17:47.000Z","updated":"2018-11-13T09:50:42.020Z","comments":true,"path":"2018/11/08/深度理解nodejs/","link":"","permalink":"https://dreamerjonson.com/2018/11/08/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3nodejs/","excerpt":"","text":"nodejs作为javascript在后端运行的环境，源码由js与C完成。本质上，nodejs是借助于谷歌V8引擎来运行javascript代码。使用了C的libuv库来处理网络，访问文件系统等操作。 nodejs的作用 1、提供一种接口，仅仅书写javascript的代码，就可以让他们正确执行，不用书写C++代码。 2、丰富的api。http、fs、path、crypto …modules nodejs源码 nodejs源码： https://github.com/nodejs/node lib:nodejs库函数 src:库函数的C++实现。 pbkdf2中js代码 pbkdf2函数的实现：node/lib/internal/crypto/pbkdf2.js 123456789101112function pbkdf2(password, salt, iterations, keylen, digest, callback) &#123; ... handleError(keybuf, password, salt, iterations, digest, wrap);&#125;调用了：const rc = _pbkdf2(keybuf, password, salt, iterations, digest, wrap);_pbkdf2绑定了C++函数的实现。const &#123; pbkdf2: _pbkdf2 &#125; = internalBinding('crypto'); internalBinding链接javascript代码与C++代码。 pbkdf2中c++代码 crypto库源代码实现：node/src/node_crypto.cc 12345678910111213绑定 env-&gt;SetMethod(target, \"pbkdf2\", PBKDF2); inline void PBKDF2(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; ... job-&gt;iteration_count = args[3].As&lt;Uint32&gt;()-&gt;Value(); Utf8Value digest_name(args.GetIsolate(), args[4]); job-&gt;digest = EVP_get_digestbyname(*digest_name); if (job-&gt;digest == nullptr) return rv.Set(-1); if (args[5]-&gt;IsObject()) return PBKDF2Job::Run(std::move(job), args[5]); env-&gt;PrintSyncTrace(); job-&gt;DoThreadPoolWork(); rv.Set(job-&gt;ToResult()); &#125; v8 node/src/node_crypto.cc中我们还会看到很多的v8,将javascript类型转换为c++类型 123456 using v8::Array; using v8::Boolean; using v8::ConstructorBehavior; using v8::Context; using v8::DontDelete;... libuv node/src/node_crypto.cc中我们还会看到很多的libuv，处理并发操作。 123...static uv_once_t init_once &#x3D; UV_ONCE_INIT;uv_once(&amp;init_once, InitCryptoOnce);","categories":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://dreamerjonson.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"nodejs","permalink":"https://dreamerjonson.com/tags/nodejs/"}]},{"title":"添加网站https的证书","slug":"添加网站https的证书","date":"2018-11-07T15:31:45.000Z","updated":"2018-11-07T16:05:52.931Z","comments":true,"path":"2018/11/07/添加网站https的证书/","link":"","permalink":"https://dreamerjonson.com/2018/11/07/%E6%B7%BB%E5%8A%A0%E7%BD%91%E7%AB%99https%E7%9A%84%E8%AF%81%E4%B9%A6/","excerpt":"","text":"准备工作 首先有一个linux虚拟机 12345$ apt-get install letsencrypt$ apt-get install python-pip$ pip install --upgrade pip$ pip install certbot$ certbot certonly --manual --preferred-challenges dns --email foo@bar.com --domains test001.bar.com 执行成功后 123Please deploy a DNS TXT record under the name_acme-challenge.erpnext.xyz with the following value:J50GNXkhGmKCfn-0LQJcknVGtPEAQ_U_WajcLXgqWqo 产生key-value对，添加dns中(Create TXT record via DNS console and setup key and value): Record Name: acme-challenge.erpnext.xyz Record Value: J50GNXkhGmKCfn-0LQJcknVGtPEAQ_U_WajcLXgqWqo 点击继续，出现下面的提示，导出证书成功： 12345IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;nova.moe&#x2F;fullchain.pem Your key file has been saved at: &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;nova.moe&#x2F;privkey.pem 创建google Cloud load balancing 谷歌云负载平衡 添加google Cloud load balancing https负载， 后端服务器连接到网页存储的cloud storage中。 前端配置https，导入证书。 如果希望https和hhtp都可用，可以让此ip分别监听80和443两个端口，同时早域名商中，添加域名到ip的链接。 参考资料 使用 Google Cloud Platform 的 Storage 托管静态站点并通过 Google CDN 加速 Generate Wildcard SSL certificate using Let’s Encrypt/Certbot Letsencrypt how to use preferred-challenges cloud google load balancing How to Setup a SSL for Google Cloud Storage hosted Site? Google Cloud Load Balancer redirect HTTP to HTTPS","categories":[{"name":"server","slug":"server","permalink":"https://dreamerjonson.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"https://dreamerjonson.com/tags/server/"}]},{"title":"solidity智能合约[2]-helloworld","slug":"solidity-2-helloworld","date":"2018-11-07T14:57:01.000Z","updated":"2018-11-20T16:38:18.592Z","comments":true,"path":"2018/11/07/solidity-2-helloworld/","link":"","permalink":"https://dreamerjonson.com/2018/11/07/solidity-2-helloworld/","excerpt":"","text":"运行你的合约 现在编译完全顺利，请转到“run”选项卡，以便我们可以运行我们的合约！ compile 在这里，您可以指定一些选项来创建合约，例如，选择哪个地址部署它。 现在我们不会混淆这些设置。只要确保环境设置为“JavaScript VM”，然后点击粉红色的“Deploy”按钮即可。 deploy 消息日志不多，但意味着将你的合同部署到了以太坊地址（尽管只在虚拟环境中）！ 部署合同也使用Gas，并花费一定的以太币。这就是为什么，如果你检查选项中的账户地址，你的余额应该从100以太币略微下降到接近99。 ether 减少 现在HelloWorld合约已启动并正在运行，只需按下浏览器窗口中的蓝色按钮 “getIt” ，即可调用其getIt函数。 solidity 正如你看到的，日志系统中详细记录了调用的详情： 另外要注意的是，你的账户中的以太币并没有发生变化，因为他只是一个“view”函数。 log 添加一个可写入的函数 到目前为止一切顺利，但我们真正想要做的是让任何人将名称变量改为别的。为此，我们将添加一个新的changeIt函数。 12345678910pragma solidity ^0.4.0;contract HelloWorld &#123; &#x2F;&#x2F; ... function changeIt(string _newString) public &#123; firstTest&#x3D; _ newString; &#125;&#125; 正如你所看到的，这个函数在几个方面与getIt不同。它并没有使用视图修改，因为它实际上改变了存储在blockchain数据，也不会返回任何东西。 Solidity函数中的参数通常以下划线（_）作为前缀，以将其与全局状态变量（如firstTest）区分开来。我们将在整个课程中采用这一惯例。 再次运行 我们再次单击“deploy”按钮来重新部署我们的合同。 change 注意新的“changeIt”按钮是粉红色而不是蓝色，以强调它是可写入函数的事实。 您现在应该可以在输入字段中键入新名称（不要忘记在名称周围添加双引号），单击“changeIt”按钮并通过单击“getIt”来获取它。 complete 恭喜！你已经完成了第一个solidity的智能合约。获取和设置不同类型的状态变量我们将在后续反复使用。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"solidity[1]-HelloWorld","slug":"solidity-HelloWorld","date":"2018-11-04T12:31:15.000Z","updated":"2018-12-02T02:06:51.677Z","comments":true,"path":"2018/11/04/solidity-HelloWorld/","link":"","permalink":"https://dreamerjonson.com/2018/11/04/solidity-HelloWorld/","excerpt":"","text":"solidity介绍 以太坊拥有多种高级语言，可用于编写智能合约，每种语言都受到另一种广泛使用的语言的启发。最流行的一种叫做Solidity，它基于JavaScript。由于Solidity是迄今为止最成熟的以太坊语言，因此它是社区大力鼓励开发人员现在使用的语言。 Solidity与其它语言相关的特点？ 它的语法接近于Javascript，是一种面向对象的语言。但作为一种真正意义上运行在网络上的去中心合约，它又有很多的不同，下面列举一些😉： 以太坊底层是基于帐户，而非UTXO的，所以有一个特殊的Address的类型。用于定位用户，定位合约，定位合约的代码（合约本身也是一个帐户）。 由于语言内嵌框架是支持支付的，所以提供了一些关键字，如payable，可以在语言层面直接支持支付，而且超级简单。 存储是使用网络上的区块链，数据的每一个状态都可以永久存储，所以需要确定变量使用内存，还是区块链。 运行环境是在去中心化的网络上，会比较强调合约或函数执行的调用的方式。因为原来一个简单的函数调用变为了一个网络上的节点中的代码执行，分布式的感觉。 最后一个非常大的不同则是它的异常机制，一旦出现异常，所有的执行都将会被回撤，这主要是为了保证合约执行的原子性，以避免中间状态出现的数据不一致。 solidity官方文档 由于在本地计算机上开始使用Solidity有点复杂，因此我们将使用名为Remix的在线IDE 作为DApp程序员的第一步。 在线remix编译器 Solidity是一种智能合约高级语言，运行在Ethereum虚拟机（EVM）之上。 如果你第一次进入这个网站，你会看到有一个名为ballot.sol的虚拟合约。让我们忽略这一点，而是从头开始，在左侧导航菜单中创建一个名为HelloWorld.sol的新文件。 现在我们有一个完全空白的文件，让我们来看看Solidity的工作原理。 我们需要指定的第一件事是我们的程序应该解释为什么版本的Solidity。这是通过第一行的版本编译指示完成的： 1pragma solidity ^0.4.0; 此行意味着我们正在阻止我们的程序被一个比0.4.0更老的编译器编译 ^表示向上兼容，但是不能够被0.5.0及其以上的编译器编译。我们这样做是为了尽量减少代码以意想不到或不兼容的方式编译时可能发生的错误的风险。接下来，是时候编写实际的合同代码了！我们通过使用声明新合同的特殊关键字contract来做到这一点。如果你习惯了面向对象的语言，你会注意到它和类的定义类似。 1234pragma solidity ^0.4.0;contract HelloWorld &#123; //从这里放置合约代码&#125; 合约名字是随意指定的，为了当前的目的相契合，我们命名为HellowWorld，在合约内部，我们添加一个状态变量，用字符串来存储一串汉字，我们将变量名定义为firstTest, 1234contract HelloWorld &#123; // 放置你喜欢的字符串 string myName = \"jonson\";&#125; 请注意，Solidity是静态类型的，因此在为其分配值之前，您总是需要定义变量的类型。所有类型的列表可以在Solidity的文档中找到。 最后，我们希望能够通过调用函数从我们的合约中查询出这个值。我们将调用这个函数getIt： 1234567contract HelloWorld &#123; string firstTest = \"jonson\"; //添加函数: function getIt() returns(string) &#123; return firstTest; &#125;&#125; 请注意，我们需要在Solidity中指定函数的返回值。由于在这种情况下我们只是返回myName字符串，所以我们编写了returns (string) 解决编译器警告 如果您一直沿用这种方式并将代码放在Remix中，那么您可能已经注意到窗口右侧存在一些警告。 😢 如果勾上了右侧的自动编译,每当你改变代码中的某些东西时，Remix就会自动尝试编译它。红色字段表示代码编译失败（由于语法错误），黄色字段表示编译时有一些警告。 第一个警告告诉我们，我们函数的可见性没有被指定（因此默认为“public”）。以太坊实际上有4种可见度类型： public：任何人都可以调用该函数，包括DApp的使用者。 private：只有合约本身可以调用该函数（在另一个函数中）。 internal：只有这份合同以及由此产生的所有合同才能称之为合同。 external：只有外部可以调用该函数，而合约内部不能调用。 根据经验，public 与 private 是最常用的类型。 由于我们现在只是在测试，所以我们不介意将函数的可见性设置为public。请注意，尽管Solidity设置为public，但始终明确指定函数的可见性被认为是一种良好习惯，以避免潜在的灾难性疏忽。 1234//在函数名称后加上public修饰符 function getIt() public returns(string) &#123; return firstTest; &#125; 这样做后，只剩下一个警告。这一个很难理解： 1Warning: Function state mutability can be restricted to view 编译器真正在说的是它检测到我们的函数从不改变区块链上的任何状态变量 -而仅仅读取。因此，我们可以使用view修饰符来使其更加清晰： 1234 //在public后添加view function getIt() public view returns(string) &#123; return firstTest;&#125; 当一个函数有一个“view”修饰符时，你不需要花费任何gas来调用它们（即使它们使用了消耗气体的操作），因为不需要进行事务处理。它们基本上是“免费使用”的。 有3种内置的函数修饰符会影响花费gas的量: view: 可以自由调用，因为它只是“查看”区块链的状态而不改变它 pure: 也可以自由调用，既不读取也不写入区块链 payable:常常用于将代币发送给合约地址。","categories":[{"name":"智能合约 solidity语法","slug":"智能合约-solidity语法","permalink":"https://dreamerjonson.com/categories/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-solidity%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://dreamerjonson.com/tags/solidity/"},{"name":"智能合约","slug":"智能合约","permalink":"https://dreamerjonson.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"以太坊","slug":"以太坊","permalink":"https://dreamerjonson.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}]},{"title":"唯识相链由来","slug":"wsxl-origin","date":"2018-11-04T03:43:34.000Z","updated":"2018-11-06T12:53:46.514Z","comments":true,"path":"2018/11/04/wsxl-origin/","link":"","permalink":"https://dreamerjonson.com/2018/11/04/wsxl-origin/","excerpt":"","text":"桃花源记 复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田美池桑竹之属。阡陌交通，鸡犬相闻。其中往来种作，男女衣着，悉如外人；黄发垂髫，并怡然自乐。 陶渊明曾经描绘过桃花源这样美丽的世外桃源。 在这片信任的社会中，大家都各自和睦共处并怡然自乐。 博弈论 其实从现代博弈的观点来看，在这样一个封闭的信任社会中，一个人要想犯罪、欺骗的代价是非常高的，甚至高到他不愿意去选择欺骗。 因为一次欺骗就足以毁灭其在这个社会生存的可能。时代在前进，当前的资源是跨时间与空间的交换，交易人甚至在地球的另外一端。 如何在无信的社会（truthless）还能够建立一种共识或是信任是几十年来人类在思考的问题。国家、中心、权威或是中介一定程度上就是在为其作出努力。 但是这还远远不够，我们还希望建立一个去中心化的理想社会，每个人都是自己的主人。中本聪关于区块链的精巧设计让我们看到了未来的大门。 唯识相链 唯识其实就是唯一的共识。其阐释了区块链的哲学魅力，在这个系统中所有人链在一起，达成了都认同一个独一无二的真相，唯识便产生了。在这个系统中，欺骗的代价如此之高，甚至高到他不愿意去选择欺骗。 唯识也是佛教的一个分支，他代表人类真正的了解自己的学问。这代表我们对于人类和人类社会的思考。新的时代真正的开始了，时代不会等待任何一个人。站在时代的风口浪尖，走在人生的十字路口。是被乘着海浪起飞实现鲤鱼跳龙门、还是被淹没在时代的浪潮中，作出你的选择（make your choice）","categories":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}]},{"title":"google cloud storage托管静态页面","slug":"google-cloud-storage托管静态页面","date":"2018-11-02T16:34:21.000Z","updated":"2018-11-08T16:04:52.481Z","comments":true,"path":"2018/11/03/google-cloud-storage托管静态页面/","link":"","permalink":"https://dreamerjonson.com/2018/11/03/google-cloud-storage%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"初始步骤 1、 域名 2、 google Cloud create project. the project name must match the domain name 3、cname 12NAME TYPE DATAwww.example.com CNAME c.storage.googleapis.com. Google Cloud SDK oogle Cloud SDK 是一套工具，您可以使用这套工具来管理托管在 Google Cloud Platform 上的资源和应用。其中包括 gcloud、gsutil 和 bq 命令行工具。install gsutil 工具 设置所有文件的权限可见 1gsutil acl -r ch -u AllUsers:R gs:&#x2F;&#x2F;www.dreamerjonson.com&#x2F;* 删除文件： -r递归遍历所有 1gsutil rm -r gs:&#x2F;&#x2F;www.dreamerjonson.com&#x2F;.git&#x2F; 上传单个文件 1gsutil cp test.js gs:&#x2F;&#x2F;www.dreamerjonson.com 上传文件夹下所有文件 1gsutil cp -r .&#x2F; gs:&#x2F;&#x2F;www.dreamerjonson.com 增量同步 -m多线程 -d 删除不匹配的文件 -r递归 1gsutil -m rsync -d -r .&#x2F; gs:&#x2F;&#x2F;www.dreamerjonson.com 设置 MainPageSuffix 和 NotFoundPage 在以下示例中，MainPageSuffix 被设置为 index.html，NotFoundPage 被设置为 404.html： 1gsutil web set -m index.html -e 404.html gs:&#x2F;&#x2F;www.example.com 更新默认上传权限 1gsutil defacl ch -u AllUsers:R gs:&#x2F;&#x2F;www.dreamerjonson.com 参考资料 google domains help storage托管静态页面 gsutil使用 gsutil快速入门 gsutil defacl","categories":[{"name":"server","slug":"server","permalink":"https://dreamerjonson.com/categories/server/"}],"tags":[{"name":"server","slug":"server","permalink":"https://dreamerjonson.com/tags/server/"}]},{"title":"hexo-excerpt","slug":"hexo-excerpt","date":"2018-07-14T02:17:32.000Z","updated":"2018-12-14T02:19:02.784Z","comments":true,"path":"2018/07/14/hexo-excerpt/","link":"","permalink":"https://dreamerjonson.com/2018/07/14/hexo-excerpt/","excerpt":"","text":"hexo 博客摘要 1234567891011121314Use a html comment with the word &quot;more&quot; to mark the excerpt of your post, like this:title: post title---This part is the excerpt, get it with the &lt;%- post.excerpt %&gt;&lt;!-- more --&gt;This is the rest of the post. You can get it with &lt;%- post.more %&gt;All the text after the &lt;!-- more --&gt; is only displayed when you view the page of the post.Font: https:&#x2F;&#x2F;groups.google.com&#x2F;forum&#x2F;#!topic&#x2F;hexo&#x2F;cdbCM0lb9A0Edit: You can also use this hexo-front-matter-excerpt plugin to define the excerpt in the front matter with whatever content you want.Cheers!","categories":[{"name":"hexo","slug":"hexo","permalink":"https://dreamerjonson.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://dreamerjonson.com/tags/hexo/"}]},{"title":"区块链游戏的革命(下)","slug":"区块链游戏的革命-下","date":"2018-06-06T12:28:55.000Z","updated":"2018-11-06T12:53:40.049Z","comments":true,"path":"2018/06/06/区块链游戏的革命-下/","link":"","permalink":"https://dreamerjonson.com/2018/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B8%B8%E6%88%8F%E7%9A%84%E9%9D%A9%E5%91%BD-%E4%B8%8B/","excerpt":"","text":"Vitalik Buterin > 在2007到2010年，我痴迷于玩“魔兽世界”这款游戏，但是突然有一天，暴雪移除了我心爱术士的虹吸生命术技能所具有的的伤害。 我哭着到睡着了。从那一天起，我意识到了中心化服务器带来的可怕后果。我很快决定退出这一切... ——Vitalik Buterin 以太坊创始人 在上一篇文章中，我们介绍了区块链由于其代码的可验证性，对于赌博游戏带来了新的生机。但是区块链给游戏带来的冲击还远远不止于此。比如说？ 永远不会被关闭 当我们在玩一款游戏的时候，我们常常会担心这款游戏在几年以后突然就关闭了，自己为游戏中的所有物品、为这款游戏倾注的心血都会随此全部消失。我们也常常会担心这款游戏轻易的就会被黑客所袭击、或是服务器故障所带来的致命问题。但是！在区块链的世界中完全不用担心这些问题。由于数据存储在区块链之上，而网络中的所有节点都存储了完整的区块信息。意味着一个节点的奔溃或是欺骗不会对于系统带来冲击。蓦然回首，数据就一直在那里等着你。 稀有性 当我们在玩一款游戏的时候，我们会因为开到了一个及其稀有的卡牌或是装备而兴奋 (比如在吃鸡游戏中开到的衣服，或是炉石传说中的稀有卡牌)。但是，我们很快就发现随着时间的推移这些装备甚至会变得一文不值。但是，在一款优秀的区块链游戏中，我们能够验证到我们的装备是真正的稀有，意味着从这款游戏从出生到结束，这个装备的数量都会被验证为有限多个。玩家能够真正知道自己获得了稀有的装备。激动吧！！ 独一无二的所有权 区块链的特性之一就是异常安全，一款运行在区块链之上的游戏将会比传统游戏拥有更强的安全性。自己可以宣誓主权，证明自己对于物品独一无二的所有权。除非你自己愿意转移给其他人。 可交易 独一无二的所有权与稀有性就为游戏倾注了更多激动人心的元素，那就是可交易。在区块链之上，同一款游戏的代币甚至于不同游戏的代币之间只要满足相同的协议(如ERC721代币协议)，就能够很方便的实现交易。同时，游戏的代币也会很容易的同以太币、比特币等高价值货币进行交换。这意味着玩家投入的时间、玩家拥有的稀有物品将能够真正的变现。从而开启了游戏赚钱的时代。 分叉带来自由 当我们玩魔兽、英雄联盟的时候，我们会知道游戏的生产商常常会有巨大的版本升级、这对于一些玩家的游戏体验来说是毁灭性的，他们因此退出了这款游戏。更重要的是，我们需要相信游戏的生产商是站在玩家的立场上来考虑问题的，但是很显然，这也是一群唯利是图的人。区块链游戏所带来的变革在于，一款优秀的产品即便是游戏的设计者也不能够随意的修改游戏的属性。决定游戏走向的真正的变成了游戏的玩家和社区。如果我希望削弱剑圣这个英雄，而其他玩家不愿意这样做，那我们就分道扬镳好了，一个游戏分叉为了两个世界，在第一个世界中你有你的标准，在第二个世界中我有我的标准。区块链的分叉为我们带来了自由。 还有太多太多理由……但是我们已经有理由相信，游戏行业将会迎来的第二春。 Zombie Battleground 2017年末的迷恋猫游戏（CryptoKitties）算是区块链游戏的很好尝试，但这还远远不够。毕竟迷恋猫游戏设计逻辑简单，变化太少，页面交互还太差，代码中还留有过多的后门。 现在越来越多的公司开始盯上了区块链游戏，Loom network公司无疑走在了世界的前列。其目前设计的Zombie Battleground将会是一个大型区块链游戏很好的尝试。 Zombie Battleground是一款运行在以太坊侧链上的游戏，预计在下周发布正式版。其风格类似于炉石传说，基于五行相生相克的独特的游戏规则设计。 在当前（2018年6月17日17:37:30），这款游戏在国外最大的众筹平台上，3天之内募集的资金超过了17万美元，可见市场对其的关注程度。 走在时代的风口浪尖、区块链游戏会掀起多大的风浪，让我们拭目以待…","categories":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}]},{"title":"区块链游戏的革命(上)","slug":"区块链游戏的革命","date":"2018-06-06T10:08:34.000Z","updated":"2018-11-06T12:53:43.413Z","comments":true,"path":"2018/06/06/区块链游戏的革命/","link":"","permalink":"https://dreamerjonson.com/2018/06/06/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B8%B8%E6%88%8F%E7%9A%84%E9%9D%A9%E5%91%BD/","excerpt":"","text":"区块链Dapp背景 伴随着区块链2.0—以太坊的火爆，诞生了各式各样的dapp(decentralized Application)。 核心数据的存储与交互都是依靠分布式的区块链。完全区别于从前服务器—客户端的模式。 在2018年的上半年，平均每天就会有5款dapp诞生。 Dapp市场 CryptoKitties 在这一系列的dapp中，各类游戏尤其让人影响深刻。迷恋猫游戏无疑是最成功的的一款。 运行在以太坊上的迷恋猫游戏（CryptoKitties）在2017年末曾经引起了以太坊网络的堵塞，导致当时大量的交易得不到确认。从此为我们打开了区块链+游戏的大门。这款简单的游戏可是赚了上百万美元哟。联合创始人Benny Giang还是学心理学的哟，所以大家不要怕，果断入场吧！ cryptocountries 击鼓传花 迷恋猫市场 区块链+博彩游戏还会带来更加疯狂的浪潮，最近火爆的游戏cryptocountries，他是一款收藏国家卡片的游戏. 当下一个买家从你的手上购买国家的时候，你就可以获得20%的利润。而平台会赚取2%-5%的利润。 我们目睹了代表中国的卡片从最初的3 Ether在短短的1小时内就变为了200 以太币Ether，在第二天早上就变为了639Ether，按照当前的市场价值，其价值超过了百万人民币。现在的拥有者为JOCY LOVE艾玲曾这个兄弟，他还等待着割别人的韭菜。这个简单的击鼓传花的游戏让我们看到了人性疯狂的一面，再仔细看看排名前列的都是东南亚的国家，连朝鲜都排在了第五位。 Cryptocountries前4位 对比东南亚 东南亚国家的疯狂读者会有什么启示呢？是不是一个分析国家和地域文化差异很好的材料呢？ 博彩 人似乎生来就是游戏的动物，即便是最简单的筛子游戏也能牵动起人类的神经。 etherRoll 下面这个很火的etherRoll赌博游戏，你可以自己设置自己押注的以太币和赢得概率，从而在赢下游戏之后获取相应的回报。 产品清单 运行在以太坊之上的智能合约，似乎为博彩游戏提供了天然的土壤。 由于在区块链之上的代码可以被所有人验证，意味着你的赌博逻辑是公开透明的，我能明确平台到底有没有作弊，抽走了多少提成。 中心化的平台不再是一个黑箱，认为平台有猫腻的困惑完全将会被打消，为游戏行业迎来了新的变革，我们有理由相信区块链带给游戏行业的巨大变革。 但是区块链带给游戏的冲击还远远不止于此， 请关注下一篇文章。","categories":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"区块链原理","slug":"区块链原理","permalink":"https://dreamerjonson.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"}]}]}