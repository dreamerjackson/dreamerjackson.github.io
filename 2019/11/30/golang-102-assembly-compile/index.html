<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>golang[102]-assembly-汇编教程 | 郑建勋的个人网站</title>
  <meta name="description" content="introduce golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编主要了解各种寄存器的使用跟寻址方式。根据汇编我们能够一探golang的底层实现。比如内存如何分配，栈如何扩张。接口如何转变。  register 各种伪计数器:  FP: Frame pointer: arguments and locals.(指向当前栈帧) PC: Pro">
<meta name="keywords" content="go">
<meta property="og:type" content="article">
<meta property="og:title" content="golang[102]-assembly-汇编教程">
<meta property="og:url" content="https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/index.html">
<meta property="og:site_name" content="Jonson">
<meta property="og:description" content="introduce golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编主要了解各种寄存器的使用跟寻址方式。根据汇编我们能够一探golang的底层实现。比如内存如何分配，栈如何扩张。接口如何转变。  register 各种伪计数器:  FP: Frame pointer: arguments and locals.(指向当前栈帧) PC: Pro">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-12-04T10:43:49.265Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="golang[102]-assembly-汇编教程">
<meta name="twitter:description" content="introduce golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编主要了解各种寄存器的使用跟寻址方式。根据汇编我们能够一探golang的底层实现。比如内存如何分配，栈如何扩张。接口如何转变。  register 各种伪计数器:  FP: Frame pointer: arguments and locals.(指向当前栈帧) PC: Pro">
  <!-- Canonical links -->
  <link rel="canonical" href="https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Jonson" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">



</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/dreamerjackson" target="_blank">
          <img class="img-circle img-rotate" src="/images/jonson.png" width="992" height="1532">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">郑建勋（jonson）</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">区块链工程师 &amp; Web工程师</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> beijing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech="">
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope="" itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-bitcoin">
          <a href="/bitcoin">
            
            <i class="icon fab fa-bitcoin"></i>
            
            <span class="menu-title">比特币文献</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-aboutme">
          <a href="/aboutme">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">关于我</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/dreamerjackson" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
          <div id="mrmy" style="padding-bottom:30px"></div>
              <div class="content">
                  <!-- <p>I've learned that people will forget what you said, people will forget what you did, but people will never forget how you made them feel.</p> -->
                  <!--  -->
                  <!-- 弱者，连自己的死法都无权选择。&lt;br/&gt;&lt;p align=&#34;right&#34;&gt;--特拉法尔加·罗&lt;/p&gt; -->
                    <!-- 弱者，连自己的死法都无权选择。<br/><p align="right">--特拉法尔加·罗</p> -->
                商业合作微信：dreamerjonson<br><br>
                51CTO区块链交流群：837814276<br><br>
                go语言交流2群：713385260<br>
                <!-- <div><img src="/images/xingqiu-qrcode.jpg" width="150" height="150"></div> -->
              </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DAPP/">DAPP</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bootstrap/">bootstrap</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/git/mac环境配置/">mac环境配置</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">151</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/go/数据结构/">数据结构</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/go-数据结构/">go 数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kali/">kali</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/kali-linux/">kali-linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac/">mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/macOS/">macOS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/network/">network</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodejs/">nodejs</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/server/">server</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链原理/">区块链原理</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发配置/">开发配置</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/智能合约-solidity语法/">智能合约 solidity语法</a><span class="category-list-count">60</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/置顶/">置顶</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/bootstrap/">bootstrap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a><span class="tag-list-count">151</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go-数据结构/">go 数据结构</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali/">kali</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali-linux/">kali-linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macOS/">macOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac环境配置/">mac环境配置</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs-前端/">nodejs 前端</a><span class="tag-list-count">32</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/server/">server</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solidity/">solidity</a><span class="tag-list-count">64</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/以太坊/">以太坊</a><span class="tag-list-count">64</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链原理/">区块链原理</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发配置/">开发配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能合约/">智能合约</a><span class="tag-list-count">64</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/置顶/">置顶</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/bootstrap/" style="font-size: 13px;">bootstrap</a> <a href="/tags/css/" style="font-size: 13px;">css</a> <a href="/tags/docker/" style="font-size: 13.38px;">docker</a> <a href="/tags/git/" style="font-size: 13px;">git</a> <a href="/tags/go/" style="font-size: 14px;">go</a> <a href="/tags/go-数据结构/" style="font-size: 13.13px;">go 数据结构</a> <a href="/tags/hexo/" style="font-size: 13px;">hexo</a> <a href="/tags/js/" style="font-size: 13.13px;">js</a> <a href="/tags/kali/" style="font-size: 13px;">kali</a> <a href="/tags/kali-linux/" style="font-size: 13px;">kali-linux</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/mac/" style="font-size: 13.25px;">mac</a> <a href="/tags/macOS/" style="font-size: 13px;">macOS</a> <a href="/tags/mac环境配置/" style="font-size: 13.13px;">mac环境配置</a> <a href="/tags/network/" style="font-size: 13px;">network</a> <a href="/tags/nodejs/" style="font-size: 13.63px;">nodejs</a> <a href="/tags/nodejs-前端/" style="font-size: 13.75px;">nodejs 前端</a> <a href="/tags/python/" style="font-size: 13px;">python</a> <a href="/tags/server/" style="font-size: 13.25px;">server</a> <a href="/tags/solidity/" style="font-size: 13.88px;">solidity</a> <a href="/tags/以太坊/" style="font-size: 13.88px;">以太坊</a> <a href="/tags/前端/" style="font-size: 13.38px;">前端</a> <a href="/tags/区块链/" style="font-size: 13px;">区块链</a> <a href="/tags/区块链原理/" style="font-size: 13.5px;">区块链原理</a> <a href="/tags/开发配置/" style="font-size: 13px;">开发配置</a> <a href="/tags/数据结构/" style="font-size: 13px;">数据结构</a> <a href="/tags/智能合约/" style="font-size: 13.88px;">智能合约</a> <a href="/tags/置顶/" style="font-size: 13px;">置顶</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">33</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">44</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">119</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/go/">go</a>
              </p>
              <p class="item-title">
                <a href="/2019/12/25/golang-109-lab-simulate-rpc/" class="title">golang[109]-lab-模拟rpc远程过程调用</a>
              </p>
              <p class="item-date">
                <time datetime="2019-12-25T03:24:06.000Z" itemprop="datePublished">2019-12-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/go/">go</a>
              </p>
              <p class="item-title">
                <a href="/2019/12/18/golang-108-pow-of-two/" class="title">golang[108]-2的幂</a>
              </p>
              <p class="item-date">
                <time datetime="2019-12-17T16:41:10.000Z" itemprop="datePublished">2019-12-18</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/go/">go</a>
              </p>
              <p class="item-title">
                <a href="/2019/12/14/golang-107-Josephus-problem/" class="title">golang[107]-约瑟夫问题与2的次方的特性</a>
              </p>
              <p class="item-date">
                <time datetime="2019-12-14T13:12:12.000Z" itemprop="datePublished">2019-12-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/go/">go</a>
              </p>
              <p class="item-title">
                <a href="/2019/12/11/golang-106-IEE754-float/" class="title">golang[106]-深入浮点数</a>
              </p>
              <p class="item-date">
                <time datetime="2019-12-11T07:49:51.000Z" itemprop="datePublished">2019-12-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/go/">go</a>
              </p>
              <p class="item-title">
                <a href="/2019/12/05/golang-105-stack-trace/" class="title">golang[105]-stack-trace</a>
              </p>
              <p class="item-date">
                <time datetime="2019-12-05T14:10:18.000Z" itemprop="datePublished">2019-12-05</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#introduce"><span class="toc-number">1.</span> <span class="toc-text"> introduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#register"><span class="toc-number">2.</span> <span class="toc-text"> register</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#analysis-for-add"><span class="toc-number">3.</span> <span class="toc-text"> analysis for add</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#analysis-for-main"><span class="toc-number">4.</span> <span class="toc-text"> analysis for main</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reciever-method"><span class="toc-number">5.</span> <span class="toc-text"> reciever method</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#anatomy-of-an-interface"><span class="toc-number">6.</span> <span class="toc-text"> Anatomy of an interface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#overview-of-the-datastructures"><span class="toc-number">6.1.</span> <span class="toc-text"> Overview of the datastructures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-iface-structure"><span class="toc-number">6.2.</span> <span class="toc-text"> The iface structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-itab-structure"><span class="toc-number">6.3.</span> <span class="toc-text"> The itab structure</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-golang-102-assembly-compile" class="article article-type-post" itemscope="" itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      golang[102]-assembly-汇编教程
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/11/30/golang-102-assembly-compile/" class="article-date">
	  <time datetime="2019-11-30T05:15:47.000Z" itemprop="datePublished">2019-11-30</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/go/">go</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/go/">go</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/11/30/golang-102-assembly-compile/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6.7k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 41(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="introduce"><a class="markdownIt-Anchor" href="#introduce"></a> introduce</h2>
<p>golang的汇编基于plan9汇编,是一个中间汇编方式。这样可以忽略底层不同架构之间的一些差别。汇编主要了解各种寄存器的使用跟寻址方式。根据汇编我们能够一探golang的底层实现。比如内存如何分配，栈如何扩张。接口如何转变。</p>
<h2 id="register"><a class="markdownIt-Anchor" href="#register"></a> register</h2>
<p>各种伪计数器:</p>
<ul>
<li>FP: Frame pointer: arguments and locals.(指向当前栈帧)</li>
<li>PC: Program counter: jumps and branches.(指向指令地址)</li>
<li>SB: Static base pointer: global symbols.(指向全局符号表)</li>
<li>SP: Stack pointer: top of stack.(指向当前栈顶部)</li>
<li>注意: 栈是向下整长 golang的汇编是调用者维护参数返回值跟返回地址。所以FP的值小于参数跟返回值。</li>
</ul>
<h2 id="analysis-for-add"><a class="markdownIt-Anchor" href="#analysis-for-add"></a> analysis for add</h2>
<p>think about this simple program:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="params">(<span class="keyword">int32</span>, <span class="keyword">bool</span>)</span></span> &#123; <span class="keyword">return</span> a + b, <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; add(<span class="number">10</span>, <span class="number">32</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>generate assemly  code in linux:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go tool compile -S main.go</span><br></pre></td></tr></table></figure>
<p>this is the logic of add function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 0x0000: Offset of the current instruction, relative to the start of the function.</span><br><span class="line">// TEXT &quot;&quot;.add: The TEXT directive declares the &quot;&quot;.add symbol as part of the .text section (i.e. runnable code) and indicates that the instructions that follow are the body of the function.</span><br><span class="line">// The empty string &quot;&quot; will be replaced by the name of the current package at link-time: i.e., &quot;&quot;.add will become main.add once linked into our final binary.</span><br><span class="line">// (SB): SB is the virtual register that holds the &quot;static-base&quot; pointer, i.e. the address of the beginning of the address-space of our program.</span><br><span class="line">// &quot;&quot;.add(SB) declares that our symbol is located at some constant offset (computed by the linker) from the start of our address-space. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// NOSPLIT: Indicates to the compiler that it should not insert the stack-split preamble, which checks whether the current stack needs to be grown.</span><br><span class="line">// In the case of our add function, the compiler has set the flag by itself: it is smart enough to figure that, since add has no local variables and no stack-frame of its own, it simply cannot outgrow the current stack; thus it&apos;d be a complete waste of CPU cycles to run these checks at each call site.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// $0-16: $0 denotes the size in bytes of the stack-frame that will be allocated; while $16 specifies the size of the arguments passed in by the caller.</span><br><span class="line">// In the general case, the frame size is followed by an argument size, separated by a minus sign. (It&apos;s not a subtraction, just idiosyncratic syntax.)</span><br><span class="line">// The frame size $24-8 states that the function has a 24-byte frame and is called with 8 bytes of argument, which live on the caller&apos;s frame.</span><br><span class="line">// If NOSPLIT is not specified for the TEXT, the argument size must be provided. For assembly functions with Go prototypes, go vet will check that the argument size is correct.</span><br><span class="line"></span><br><span class="line">0x0000 00000 (main.go:4)	TEXT	&quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-16</span><br><span class="line"></span><br><span class="line">//for GOLANG GC</span><br><span class="line">0x0000 00000 (main.go:4)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 00000 (main.go:4)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 00000 (main.go:4)	FUNCDATA	$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">  0x0000 00000 (main.go:4)	PCDATA	$2, $0</span><br><span class="line">  0x0000 00000 (main.go:4)	PCDATA	$0, $0</span><br><span class="line">  </span><br><span class="line">//   The Go calling convention mandates that every argument must be passed on the stack, using the pre-reserved space on the caller&apos;s stack-frame.</span><br><span class="line">//   It is the caller&apos;s responsibility to grow (and shrink back) the stack appropriately so that arguments can be passed to the callee, and potential return-values passed back to the caller.</span><br><span class="line">//   The Go compiler never generates instructions from the PUSH/POP family: the stack is grown or shrunk by respectively decrementing or incrementing the virtual hardware stack pointer SP.</span><br><span class="line">//   The SP pseudo-register is a virtual stack pointer used to refer to frame-local variables and the arguments being prepared for function calls.</span><br><span class="line">//   It points to the top of the local stack frame, so references should use negative offsets in the range [−framesize, 0): x-8(SP), y-4(SP), and so on.</span><br><span class="line"></span><br><span class="line">// &quot;&quot;.b+12(SP) and &quot;&quot;.a+8(SP) respectively refer to the addresses 12 bytes and 8 bytes below the top of the stack (remember: it grows downwards!).</span><br><span class="line">// .a and .b are arbitrary aliases given to the referred locations; although they have absolutely no semantic meaning whatsoever, they are mandatory when using relative addressing on virtual registers. The documentation about the virtual frame-pointer has some to say about this:</span><br><span class="line"></span><br><span class="line">// The FP pseudo-register is a virtual frame pointer used to refer to function arguments. The compilers maintain a virtual frame pointer and refer to the arguments on the stack as offsets from that pseudo-register. Thus 0(FP) is the first argument to the function, 8(FP) is the second (on a 64-bit machine), and so on. However, when referring to a function argument this way, it is necessary to place a name at the beginning, as in first_arg+0(FP) and second_arg+8(FP). (The meaning of the offset —offset from the frame pointer— distinct from its use with SB, where it is an offset from the symbol.) The assembler enforces this convention, rejecting plain 0(FP) and 8(FP). The actual name is semantically irrelevant but should be used to document the argument&apos;s name.</span><br><span class="line"></span><br><span class="line">//  The first argument a is not located at 0(SP), but rather at 8(SP); that&apos;s because the caller stores its return-address in 0(SP) via the CALL pseudo-instruction.</span><br><span class="line">// Arguments are passed in reverse-order; i.e. the first argument is the closest to the top of the stack.</span><br><span class="line"></span><br><span class="line">0x0000 00000 (main.go:4)	MOVL	&quot;&quot;.b+12(SP), AX</span><br><span class="line">0x0004 00004 (main.go:4)	MOVL	&quot;&quot;.a+8(SP), CX</span><br><span class="line"></span><br><span class="line">// ADDL does the actual addition of the two Long-words (i.e. 4-byte values) stored in AX and CX, then stores the final result in AX.</span><br><span class="line">0x0008 00008 (main.go:4)	ADDL	CX, AX</span><br><span class="line">// That result is then moved over to &quot;&quot;.~r2+16(SP), where the caller had previously reserved some stack space and expects to find its return values. Once again, &quot;&quot;.~r2 has no semantic meaning here.</span><br><span class="line">0x000a 00010 (main.go:4)	MOVL	AX, &quot;&quot;.~r2+16(SP)</span><br><span class="line">0x000e 00014 (main.go:4)	MOVB	$1, &quot;&quot;.~r3+20(SP)</span><br><span class="line">// A final RET pseudo-instruction tells the Go assembler to insert whatever instructions are required by the calling convention of the target platform in order to properly return from a subroutine call.</span><br><span class="line">// Most likely this will cause the code to pop off the return-address stored at 0(SP) then jump back to it.</span><br><span class="line">0x0013 00019 (main.go:4)	RET</span><br></pre></td></tr></table></figure>
<p>look at more concise version：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;; Declare global function symbol &quot;&quot;.add (actually main.add once linked)</span><br><span class="line">;; Do not insert stack-split preamble</span><br><span class="line">;; 0 bytes of stack-frame, 16 bytes of arguments passed in</span><br><span class="line">;; func add(a, b int32) (int32, bool)</span><br><span class="line">0x0000 TEXT	&quot;&quot;.add(SB), NOSPLIT, $0-16</span><br><span class="line">  ;; ...omitted FUNCDATA stuff...</span><br><span class="line">  0x0000 MOVL	&quot;&quot;.b+12(SP), AX	    ;; move second Long-word (4B) argument from caller&apos;s stack-frame into AX</span><br><span class="line">  0x0004 MOVL	&quot;&quot;.a+8(SP), CX	    ;; move first Long-word (4B) argument from caller&apos;s stack-frame into CX</span><br><span class="line">  0x0008 ADDL	CX, AX		    ;; compute AX=CX+AX</span><br><span class="line">  0x000a MOVL	AX, &quot;&quot;.~r2+16(SP)   ;; move addition result (AX) into caller&apos;s stack-frame</span><br><span class="line">  0x000e MOVB	$1, &quot;&quot;.~r3+20(SP)   ;; move `true` boolean (constant) into caller&apos;s stack-frame</span><br><span class="line">  0x0013 RET			    ;; jump to return address stored at 0(SP)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   |    +-------------------------+ &lt;-- 32(SP)              </span><br><span class="line">   |    |                         |                         </span><br><span class="line"> G |    |                         |                         </span><br><span class="line"> R |    |                         |                         </span><br><span class="line"> O |    | main.main&apos;s saved       |                         </span><br><span class="line"> W |    |     frame-pointer (BP)  |                         </span><br><span class="line"> S |    |-------------------------| &lt;-- 24(SP)              </span><br><span class="line">   |    |      [alignment]        |                         </span><br><span class="line"> D |    | &quot;&quot;.~r3 (bool) = 1/true  | &lt;-- 21(SP)              </span><br><span class="line"> O |    |-------------------------| &lt;-- 20(SP)              </span><br><span class="line"> W |    |                         |                         </span><br><span class="line"> N |    | &quot;&quot;.~r2 (int32) = 42     |                         </span><br><span class="line"> W |    |-------------------------| &lt;-- 16(SP)              </span><br><span class="line"> A |    |                         |                         </span><br><span class="line"> R |    | &quot;&quot;.b (int32) = 32       |                         </span><br><span class="line"> D |    |-------------------------| &lt;-- 12(SP)              </span><br><span class="line"> S |    |                         |                         </span><br><span class="line">   |    | &quot;&quot;.a (int32) = 10       |                         </span><br><span class="line">   |    |-------------------------| &lt;-- 8(SP)               </span><br><span class="line">   |    |                         |                         </span><br><span class="line">   |    |                         |                         </span><br><span class="line">   |    |                         |                         </span><br><span class="line"> \ | /  | return address to       |                         </span><br><span class="line">  \|/   |     main.main + 0x30    |                         </span><br><span class="line">   -    +-------------------------+ &lt;-- 0(SP) (TOP OF STACK)</span><br><span class="line"></span><br><span class="line">(diagram made with https://textik.com)</span><br></pre></td></tr></table></figure>
<h2 id="analysis-for-main"><a class="markdownIt-Anchor" href="#analysis-for-main"></a> analysis for main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    // &quot;&quot;.main (main.main once linked) is a global function symbol in the .text section, whose address is some constant offset from the beginning of our address-space.</span><br><span class="line">// It allocates a 24 bytes stack-frame and doesn&apos;t receive any argument nor does it return any value</span><br><span class="line"></span><br><span class="line">    // As we mentioned above, the Go calling convention mandates that every argument must be passed on the stack.</span><br><span class="line"></span><br><span class="line">// Our caller, main, grows its stack-frame by 24 bytes (remember that the stack grows downwards, so SUBQ here actually makes the stack-frame bigger) by decrementing the virtual stack-pointer. Of those 24 bytes:</span><br><span class="line"></span><br><span class="line">// 8 bytes (16(SP)-24(SP)) are used to store the current value of the frame-pointer BP (the real one!) to allow for stack-unwinding and facilitate debugging</span><br><span class="line">// 1+3 bytes (12(SP)-16(SP)) are reserved for the second return value (bool) plus 3 bytes of necessary alignment on amd64</span><br><span class="line">// 4 bytes (8(SP)-12(SP)) are reserved for the first return value (int32)</span><br><span class="line">// 4 bytes (4(SP)-8(SP)) are reserved for the value of argument b (int32)</span><br><span class="line">// 4 bytes (0(SP)-4(SP)) are reserved for the value of argument a (int32).</span><br><span class="line">	0x0000 00000 (main.go:6)	TEXT	&quot;&quot;.main(SB), ABIInternal, $24-0</span><br><span class="line">	//   ;; stack-split prologue...</span><br><span class="line">    // The prologue checks whether the goroutine is running out of space and, if it&apos;s the case, jumps to the epilogue.</span><br><span class="line">    // TLS is a virtual register maintained by the runtime that holds a pointer to the current g, i.e. the data-structure that keeps track of all the state of a goroutine.</span><br><span class="line"> // Looking at the definition of g from the source code of the runtime:</span><br><span class="line"> //   type g struct &#123;</span><br><span class="line">//	stack       stack   // 16 bytes</span><br><span class="line">	// stackguard0 is the stack pointer compared in the Go stack growth prologue.</span><br><span class="line">	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.</span><br><span class="line">//	stackguard0 uintptr</span><br><span class="line">//	stackguard1 uintptr</span><br><span class="line"></span><br><span class="line">	// ...omitted dozens of fields...</span><br><span class="line">//    &#125;</span><br><span class="line">    // We can see that 16(CX) corresponds to g.stackguard0, which is the threshold value maintained by the runtime that, when compared to the stack-pointer, indicates whether or not a goroutine is about to run out of space.</span><br><span class="line">// The prologue thus checks if the current SP value is less than or equal to the stackguard0 threshold (that is, it&apos;s bigger), then jumps to the epilogue if it happens to be the case.</span><br><span class="line">  </span><br><span class="line">0x0000 00000 (main.go:6)	MOVQ	(TLS), CX ;; store current *g in CX</span><br><span class="line">0x0009 00009 (main.go:6)	CMPQ	SP, 16(CX) ;; compare SP and g.stackguard0</span><br><span class="line">0x000d 00013 (main.go:6)	JLS	58 ;; jumps to 0x3a if SP &lt;= g.stackguard0</span><br><span class="line">	// 把栈减了24个字节。增大了栈空间。</span><br><span class="line">    0x000f 00015 (main.go:6)	SUBQ	$24, SP</span><br><span class="line">    // 保存老的bp设置新的bp。这里的bp是真实的寄存器</span><br><span class="line">0x0013 00019 (main.go:6)	MOVQ	BP, 16(SP)</span><br><span class="line">0x0018 00024 (main.go:6)	LEAQ	16(SP), BP</span><br><span class="line">    //  ;; ... PCDATA stuff...</span><br><span class="line">0x001d 00029 (main.go:6)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)	FUNCDATA	$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 00029 (main.go:6)	PCDATA	$2, $0</span><br><span class="line">0x001d 00029 (main.go:6)	PCDATA	$0, $0</span><br><span class="line">	//Finally, following the growth of the stack, LEAQ computes the new address of the frame-pointer and stores it in BP.</span><br><span class="line">    // The caller pushes the arguments for the callee as a Quad word (i.e. an 8-byte value) at the top of the stack that it has just grown.</span><br><span class="line">// Although it might look like random garbage at first, 137438953482 actually corresponds to the 10 and 32 4-byte values concatenated into one 8-byte value:</span><br><span class="line">    </span><br><span class="line">// $ echo &apos;obase=2;137438953482&apos; | bc</span><br><span class="line">//10000000000000000000000000000000001010</span><br><span class="line">// \____/\______________________________/</span><br><span class="line">//    32                              10</span><br><span class="line">    </span><br><span class="line">0x001d 00029 (main.go:6)	MOVQ	$137438953482, AX</span><br><span class="line">0x0027 00039 (main.go:6)	MOVQ	AX, (SP)</span><br><span class="line">0x002b 00043 (main.go:6)	CALL	&quot;&quot;.add(SB)</span><br><span class="line">   // 恢复BP寄存器，缩减栈空间</span><br><span class="line">0x0030 00048 (main.go:6)	MOVQ	16(SP), BP</span><br><span class="line">0x0035 00053 (main.go:6)	ADDQ	$24, SP</span><br><span class="line">0x0039 00057 (main.go:6)	RET</span><br><span class="line">	  ;; ... stack-split epilogue...</span><br><span class="line">      // The epilogue, on the other hand, triggers the stack-growth machinery and then jumps back to the prologue.</span><br><span class="line">  // This creates a feedback loop that goes on for as long as a large enough stack hasn&apos;t been allocated for our starved goroutine.</span><br><span class="line"></span><br><span class="line">    // The body of the epilogue is pretty straightforward: it calls into the runtime, which will do the actual work of growing the stack, then jumps back to the first instruction of the function (i.e. to the prologue).</span><br><span class="line"></span><br><span class="line">// The NOP instruction just before the CALL exists so that the prologue doesn&apos;t jump directly onto a CALL instruction. On some platforms, doing so can lead to very dark places; it&apos;s a common pratice to set-up a noop instruction right before the actual call and land on this NOP instead.</span><br><span class="line"> 0x003a 00058 (main.go:6)	NOP</span><br><span class="line">0x003a 00058 (main.go:6)	PCDATA	$0, $-1</span><br><span class="line">0x003a 00058 (main.go:6)	PCDATA	$2, $-1</span><br><span class="line">0x003a 00058 (main.go:6)	CALL	runtime.morestack_noctxt(SB)</span><br><span class="line">0x003f 00063 (main.go:6)	JMP	0</span><br></pre></td></tr></table></figure>
<h2 id="reciever-method"><a class="markdownIt-Anchor" href="#reciever-method"></a> reciever method</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; id int32 &#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder *Adder) AddPtr(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) AddVal(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	Add(10, 32) // direct call of top-level function</span><br><span class="line"></span><br><span class="line">	adder := Adder&#123;id: 6754&#125;</span><br><span class="line">	adder.AddPtr(10, 32) // direct call of method with pointer receiver</span><br><span class="line">	adder.AddVal(10, 32) // direct call of method with value receiver</span><br><span class="line"></span><br><span class="line">	(&amp;adder).AddVal(10, 32) // implicit dereferencing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (main.go:14)	TEXT	&quot;&quot;.main(SB), ABIInternal, $40-0</span><br><span class="line">	0x0000 00000 (main.go:14)	MOVQ	(TLS), CX </span><br><span class="line">	0x0009 00009 (main.go:14)	CMPQ	SP, 16(CX)</span><br><span class="line">	0x000d 00013 (main.go:14)	JLS	161</span><br><span class="line">    // 把栈减了40个字节。增大了栈空间。</span><br><span class="line">	0x0013 00019 (main.go:14)	SUBQ	$40, SP</span><br><span class="line">	0x0017 00023 (main.go:14)	MOVQ	BP, 32(SP)</span><br><span class="line">	0x001c 00028 (main.go:14)	LEAQ	32(SP), BP</span><br><span class="line">	0x0021 00033 (main.go:14)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0021 00033 (main.go:14)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">	0x0021 00033 (main.go:14)	FUNCDATA	$3, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)</span><br><span class="line">	0x0021 00033 (main.go:15)	PCDATA	$2, $0</span><br><span class="line">	0x0021 00033 (main.go:15)	PCDATA	$0, $0</span><br><span class="line">	// move (10,32) to </span><br><span class="line">    0x0021 00033 (main.go:15)	MOVQ	$137438953482, AX</span><br><span class="line">	0x002b 00043 (main.go:15)	MOVQ	AX, (SP)</span><br><span class="line">	0x002f 00047 (main.go:15)	CALL	&quot;&quot;.Add(SB)</span><br><span class="line"></span><br><span class="line">   // First things first, the receiver is initialized via adder := Adder&#123;id: 6754&#125;:</span><br><span class="line">    0x0034 00052 (main.go:17)	MOVL	$0, &quot;&quot;.adder+28(SP)</span><br><span class="line">	0x003c 00060 (main.go:17)	MOVL	$6754, &quot;&quot;.adder+28(SP)</span><br><span class="line">	0x0044 00068 (main.go:18)	PCDATA	$2, $1</span><br><span class="line">    // recieve address to the AX,8 bytes.</span><br><span class="line">    0x0044 00068 (main.go:18)	LEAQ	&quot;&quot;.adder+28(SP), AX</span><br><span class="line">	0x0049 00073 (main.go:18)	PCDATA	$2, $0</span><br><span class="line">	0x0049 00073 (main.go:18)	MOVQ	AX, (SP)</span><br><span class="line">	0x004d 00077 (main.go:18)	MOVQ	$137438953482, AX</span><br><span class="line">	0x0057 00087 (main.go:18)	MOVQ	AX, 8(SP)</span><br><span class="line">	0x005c 00092 (main.go:18)	CALL	&quot;&quot;.(*Adder).AddPtr(SB)</span><br><span class="line">	</span><br><span class="line">    // value to the AX.</span><br><span class="line">    0x0061 00097 (main.go:19)	MOVL	&quot;&quot;.adder+28(SP), AX</span><br><span class="line">	0x0065 00101 (main.go:19)	MOVL	AX, (SP)</span><br><span class="line">	0x0068 00104 (main.go:19)	MOVQ	$137438953482, AX</span><br><span class="line">	0x0072 00114 (main.go:19)	MOVQ	AX, 4(SP)</span><br><span class="line">	0x0077 00119 (main.go:19)	CALL	&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line">	</span><br><span class="line">    // Somehow, Go automagically dereferences our pointer and manages to make the call. How so?</span><br><span class="line"></span><br><span class="line">// How the compiler handles this kind of situation depends on whether or not the receiver being pointed to has escaped to the heap or not.</span><br><span class="line">  </span><br><span class="line">// Case A: The receiver is on the stack</span><br><span class="line"></span><br><span class="line">// If the receiver is still on the stack and its size is sufficiently small that it can be copied in a few instructions, as is the case here, the compiler simply copies its value over to the top of the stack then does a straightforward method call to &quot;&quot;.Adder.AddVal (i.e. the one with a value receiver).</span><br><span class="line"></span><br><span class="line">// (&amp;adder).AddVal(10, 32) thus looks like this in this situation:</span><br><span class="line"></span><br><span class="line">// 0x0074 MOVL	&quot;&quot;.adder+28(SP), AX	;; move (i.e. copy) adder (note the MOV instead of a LEA) to..</span><br><span class="line">// 0x0078 MOVL	AX, (SP)		;; ..the top of the stack (argument #1)</span><br><span class="line">// 0x007b MOVQ	$137438953482, AX	;; move (32,10) to..</span><br><span class="line">// 0x0085 MOVQ	AX, 4(SP)		;; ..the top of the stack (arguments #3 &amp; #2)</span><br><span class="line">// 0x008a CALL	&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line">// Boring (although efficient). Let&apos;s move on to case B.</span><br><span class="line"></span><br><span class="line">// Case B: The receiver is on the heap</span><br><span class="line"></span><br><span class="line">// If the receiver has escaped to the heap then the compiler has to take a cleverer route: it generates a new method (with a pointer receiver, this time) that wraps &quot;&quot;.Adder.AddVal, and replaces the original call to &quot;&quot;.Adder.AddVal (the wrappee) with a call to &quot;&quot;.(*Adder).AddVal (the wrapper).</span><br><span class="line">// The wrapper&apos;s sole mission, then, is to make sure that the receiver gets properly dereferenced before being passed to the wrappee, and that any arguments and return values involved are properly copied back and forth between the caller and the wrappee.</span><br><span class="line"></span><br><span class="line">// (NOTE: In assembly outputs, these wrapper methods are marked as &lt;autogenerated&gt;.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x007c 00124 (main.go:21)	MOVL	&quot;&quot;.adder+28(SP), AX</span><br><span class="line">0x0080 00128 (main.go:21)	MOVL	AX, (SP)</span><br><span class="line">0x0083 00131 (main.go:21)	MOVQ	$137438953482, AX</span><br><span class="line">0x008d 00141 (main.go:21)	MOVQ	AX, 4(SP)</span><br><span class="line">0x0092 00146 (main.go:21)	CALL	&quot;&quot;.Adder.AddVal(SB)</span><br><span class="line">0x0097 00151 (main.go:22)	MOVQ	32(SP), BP</span><br><span class="line">0x009c 00156 (main.go:22)	ADDQ	$40, SP</span><br><span class="line">0x00a0 00160 (main.go:22)	RET</span><br><span class="line">0x00a1 00161 (main.go:22)	NOP</span><br><span class="line">0x00a1 00161 (main.go:14)	PCDATA	$0, $-1</span><br><span class="line">0x00a1 00161 (main.go:14)	PCDATA	$2, $-1</span><br><span class="line">0x00a1 00161 (main.go:14)	CALL	runtime.morestack_noctxt(SB)</span><br><span class="line">0x00a6 00166 (main.go:14)	JMP	0</span><br></pre></td></tr></table></figure>
<p>Here’s an annotated listing of the generated wrapper that should hopefully clear things up a bit:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0x0000 TEXT	&quot;&quot;.(*Adder).AddVal(SB), DUPOK|WRAPPER, $32-24</span><br><span class="line">  ;; ...omitted preambles...</span><br><span class="line"></span><br><span class="line">  0x0026 MOVQ	&quot;&quot;..this+40(SP), AX ;; check whether the receiver..</span><br><span class="line">  0x002b TESTQ	AX, AX		    ;; ..is nil</span><br><span class="line">  0x002e JEQ	92		    ;; if it is, jump to 0x005c (panic)</span><br><span class="line"></span><br><span class="line">  0x0030 MOVL	(AX), AX            ;; dereference pointer receiver..</span><br><span class="line">  0x0032 MOVL	AX, (SP)            ;; ..and move (i.e. copy) the resulting value to argument #1</span><br><span class="line"></span><br><span class="line">  ;; forward (copy) arguments #2 &amp; #3 then call the wrappee</span><br><span class="line">  0x0035 MOVL	&quot;&quot;.a+48(SP), AX</span><br><span class="line">  0x0039 MOVL	AX, 4(SP)</span><br><span class="line">  0x003d MOVL	&quot;&quot;.b+52(SP), AX</span><br><span class="line">  0x0041 MOVL	AX, 8(SP)</span><br><span class="line">  0x0045 CALL	&quot;&quot;.Adder.AddVal(SB) ;; call the wrapped method</span><br><span class="line"></span><br><span class="line">  ;; copy return value from wrapped method then return</span><br><span class="line">  0x004a MOVL	16(SP), AX</span><br><span class="line">  0x004e MOVL	AX, &quot;&quot;.~r2+56(SP)</span><br><span class="line">  ;; ...omitted frame-pointer stuff...</span><br><span class="line">  0x005b RET</span><br><span class="line"></span><br><span class="line">  ;; throw a panic with a detailed error</span><br><span class="line">  0x005c CALL	runtime.panicwrap(SB)</span><br><span class="line"></span><br><span class="line">  ;; ...omitted epilogues...</span><br></pre></td></tr></table></figure>
<p>Obviously, this kind of wrapper can induce quite a bit of overhead considering all the copying that needs to be done in order to pass the arguments back and forth; especially if the wrappee is just a few instructions.<br>
Fortunately, in practice, the compiler would have inlined the wrappee directly into the wrapper to amortize these costs (when feasible, at least).</p>
<p>Note the WRAPPER directive in the definition of the symbol, which indicates that this method shouldn’t appear in backtraces (so as not to confuse the end-user), nor should it be able to recover from panics that might be thrown by the wrappee.</p>
<p>WRAPPER: This is a wrapper function and should not count as disabling recover.</p>
<p>The runtime.panicwrap function, which throws a panic if the wrapper’s receiver is nil, is pretty self-explanatory; here’s its complete listing for reference (src/runtime/error.go):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// panicwrap generates a panic for a call to a wrapped value method</span><br><span class="line">// with a nil pointer receiver.</span><br><span class="line">//</span><br><span class="line">// It is called from the generated wrapper code.</span><br><span class="line">func panicwrap() &#123;</span><br><span class="line">    pc := getcallerpc()</span><br><span class="line">    name := funcname(findfunc(pc))</span><br><span class="line">    // name is something like &quot;main.(*T).F&quot;.</span><br><span class="line">    // We want to extract pkg (&quot;main&quot;), typ (&quot;T&quot;), and meth (&quot;F&quot;).</span><br><span class="line">    // Do it by finding the parens.</span><br><span class="line">    i := stringsIndexByte(name, &apos;(&apos;)</span><br><span class="line">    if i &lt; 0 &#123;</span><br><span class="line">        throw(&quot;panicwrap: no ( in &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    pkg := name[:i-1]</span><br><span class="line">    if i+2 &gt;= len(name) || name[i-1:i+2] != &quot;.(*&quot; &#123;</span><br><span class="line">        throw(&quot;panicwrap: unexpected string after package name: &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    name = name[i+2:]</span><br><span class="line">    i = stringsIndexByte(name, &apos;)&apos;)</span><br><span class="line">    if i &lt; 0 &#123;</span><br><span class="line">        throw(&quot;panicwrap: no ) in &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    if i+2 &gt;= len(name) || name[i:i+2] != &quot;).&quot; &#123;</span><br><span class="line">        throw(&quot;panicwrap: unexpected string after type name: &quot; + name)</span><br><span class="line">    &#125;</span><br><span class="line">    typ := name[:i]</span><br><span class="line">    meth := name[i+2:]</span><br><span class="line">    panic(plainError(&quot;value method &quot; + pkg + &quot;.&quot; + typ + &quot;.&quot; + meth + &quot; called using nil *&quot; + typ + &quot; pointer&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="anatomy-of-an-interface"><a class="markdownIt-Anchor" href="#anatomy-of-an-interface"></a> Anatomy of an interface</h2>
<h3 id="overview-of-the-datastructures"><a class="markdownIt-Anchor" href="#overview-of-the-datastructures"></a> Overview of the datastructures</h3>
<p>Before we can understand how they work, we first need to build a mental model of the datastructures that make up interfaces and how they’re laid out in memory.<br>
To that end, we’ll have a quick peek into the runtime package to see what an interface actually looks like from the standpoint of the Go implementation.</p>
<h3 id="the-iface-structure"><a class="markdownIt-Anchor" href="#the-iface-structure"></a> The iface structure</h3>
<p>iface is the root type that represents an interface within the runtime (src/runtime/runtime2.go).<br>
Its definition goes like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123; // 16 bytes on a 64bit arch</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>An interface is thus a very simple structure that maintains 2 pointers:</p>
<ul>
<li>tab holds the address of an itab object, which embeds the datastructures that describe both the type of the interface as well as the type of the data it points to.</li>
<li>data is a raw (i.e. unsafe) pointer to the value held by the interface.</li>
</ul>
<p>More often than not, this will result in a heap allocation as the compiler takes the conservative route and forces the receiver to escape.<br>
This holds true even for scalar types!</p>
<p>We can prove that with a few lines of code (escape.go):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Addifier interface&#123; Add(a, b int32) int32 &#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; name string &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    adder := Adder&#123;name: &quot;myAdder&quot;&#125;</span><br><span class="line">    adder.Add(10, 32)	      // doesn&apos;t escape</span><br><span class="line">    Addifier(adder).Add(10, 32) // escapes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One could even visualize the resulting heap allocation using a simple benchmark (escape_test.go):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkDirect(b *testing.B) &#123;</span><br><span class="line">    adder := Adder&#123;id: 6754&#125;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        adder.Add(10, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkInterface(b *testing.B) &#123;</span><br><span class="line">    adder := Adder&#123;id: 6754&#125;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        Addifier(adder).Add(10, 32)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ GOOS=linux GOARCH=amd64 go test -bench=. -benchmem ./escape_test.go</span><br><span class="line">BenchmarkDirect-8      	2000000000	         1.60 ns/op	       0 B/op	       0 allocs/op</span><br><span class="line">BenchmarkInterface-8   	100000000	         15.0 ns/op	       4 B/op	       1 allocs/op</span><br></pre></td></tr></table></figure>
<p>We can clearly see how each time we create a new Addifier interface and initialize it with our adder variable, a heap allocation of sizeof(Adder) actually takes place. Later in this chapter, we’ll see how even simple scalar types can lead to heap allocations when used with interfaces.</p>
<p>Let’s turn our attention towards the next datastructure: itab.</p>
<h3 id="the-itab-structure"><a class="markdownIt-Anchor" href="#the-itab-structure"></a> The itab structure</h3>
<p>itab is defined thusly (src/runtime/runtime2.go):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123; // 40 bytes on a 64bit arch</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type</span><br><span class="line">    hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">    _     [4]byte</span><br><span class="line">    fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>An itab is the heart &amp; brain of an interface.</p>
<p>First, it embeds a _type, which is the internal representation of any Go type within the runtime.<br>
A _type describes every facets of a type: its name, its characteristics (e.g. size, alignment…), and to some extent, even how it behaves (e.g. comparison, hashing…)!<br>
In this instance, the _type field describes the type of the value held by the interface, i.e. the value that the data pointer points to.</p>
<p>Second, we find a pointer to an interfacetype, which is merely a wrapper around _type with some extra information that are specific to interfaces.<br>
As you’d expect, the inter field describes the type of the interface itself.</p>
<p>Finally, the fun array holds the function pointers that make up the virtual/dispatch table of the interface.<br>
Notice the comment that says // variable sized, meaning that the size with which this array is declared is irrelevant.<br>
We’ll see later in this chapter that the compiler is responsible for allocating the memory that backs this array, and does so independently of the size indicated here. Likewise, the runtime always accesses this array using raw pointers, thus bounds-checking does not apply here.</p>
<p>The _type structure</p>
<p>As we said above, the _type structure gives a complete description of a Go type.<br>
It’s defined as such (src/runtime/type.go):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type _type struct &#123; // 48 bytes on a 64bit arch</span><br><span class="line">    size       uintptr</span><br><span class="line">    ptrdata    uintptr // size of memory prefix holding all pointers</span><br><span class="line">    hash       uint32</span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      uint8</span><br><span class="line">    fieldalign uint8</span><br><span class="line">    kind       uint8</span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    // gcdata stores the GC type data for the garbage collector.</span><br><span class="line">    // If the KindGCProg bit is set in kind, gcdata is a GC program.</span><br><span class="line">    // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span><br><span class="line">    gcdata    *byte</span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thankfully, most of these fields are quite self-explanatory.</p>
<p>The nameOff &amp; typeOff types are int32 offsets into the metadata embedded into the final executable by the linker. This metadata is loaded into runtime.moduledata structures at run time (src/runtime/symtab.go), which should look fairly similar if you’ve ever had to look at the content of an ELF file.<br>
The runtime provide helpers that implement the necessary logic for following these offsets through the moduledata structures, such as e.g. resolveNameOff (src/runtime/type.go) and resolveTypeOff (src/runtime/type.go):</p>
<p>func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name {}<br>
func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type {}</p>
<p>I.e., assuming t is a _type, calling resolveTypeOff(t, t.ptrToThis) returns a copy of t.</p>
<p>The interfacetype structure</p>
<p>Finally, here’s the interfacetype structure (src/runtime/type.go):</p>
<p>type interfacetype struct { // 80 bytes on a 64bit arch<br>
typ     _type<br>
pkgpath name<br>
mhdr    []imethod<br>
}</p>
<p>type imethod struct {<br>
name nameOff<br>
ityp typeOff<br>
}<br>
As mentioned, an interfacetype is just a wrapper around a _type with some extra interface-specific metadata added on top.<br>
In the current implementation, this metadata is mostly composed of a list of offsets that points to the respective names and types of the methods exposed by the interface ([]imethod).</p>
<p>Conclusion</p>
<p>Here’s an overview of what an iface looks like when represented with all of its sub-types inlined; this hopefully should help connect all the dots:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// `iface`</span></span><br><span class="line">    tab *<span class="keyword">struct</span> &#123; <span class="comment">// `itab`</span></span><br><span class="line">        inter *<span class="keyword">struct</span> &#123; <span class="comment">// `interfacetype`</span></span><br><span class="line">            typ <span class="keyword">struct</span> &#123; <span class="comment">// `_type`</span></span><br><span class="line">                size       <span class="keyword">uintptr</span></span><br><span class="line">                ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">                hash       <span class="keyword">uint32</span></span><br><span class="line">                tflag      tflag</span><br><span class="line">                align      <span class="keyword">uint8</span></span><br><span class="line">                fieldalign <span class="keyword">uint8</span></span><br><span class="line">                kind       <span class="keyword">uint8</span></span><br><span class="line">                alg        *typeAlg</span><br><span class="line">                gcdata     *<span class="keyword">byte</span></span><br><span class="line">                str        nameOff</span><br><span class="line">                ptrToThis  typeOff</span><br><span class="line">            &#125;</span><br><span class="line">            pkgpath name</span><br><span class="line">            mhdr    []<span class="keyword">struct</span> &#123; <span class="comment">// `imethod`</span></span><br><span class="line">                name nameOff</span><br><span class="line">                ityp typeOff</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _type *<span class="keyword">struct</span> &#123; <span class="comment">// `_type`</span></span><br><span class="line">            size       <span class="keyword">uintptr</span></span><br><span class="line">            ptrdata    <span class="keyword">uintptr</span></span><br><span class="line">            hash       <span class="keyword">uint32</span></span><br><span class="line">            tflag      tflag</span><br><span class="line">            align      <span class="keyword">uint8</span></span><br><span class="line">            fieldalign <span class="keyword">uint8</span></span><br><span class="line">            kind       <span class="keyword">uint8</span></span><br><span class="line">            alg        *typeAlg</span><br><span class="line">            gcdata     *<span class="keyword">byte</span></span><br><span class="line">            str        nameOff</span><br><span class="line">            ptrToThis  typeOff</span><br><span class="line">        &#125;</span><br><span class="line">        hash <span class="keyword">uint32</span></span><br><span class="line">        _    [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">        fun  [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">    &#125;</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This section glossed over the different data-types that make up an interface to help us to start building a mental model of the various cogs involved in the overall machinery, and how they all work with each other.</p>
<p>Creating an interface<br>
Now that we’ve had a quick look at all the datastructures involved, we’ll focus on how they actually get allocated and initiliazed.</p>
<p>Consider the following program (iface.go):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Mather interface &#123;</span><br><span class="line">    Add(a, b int32) int32</span><br><span class="line">    Sub(a, b int64) int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Adder struct&#123; id int32 &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Add(a, b int32) int32 &#123; return a + b &#125;</span><br><span class="line">//go:noinline</span><br><span class="line">func (adder Adder) Sub(a, b int64) int64 &#123; return a - b &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    m := Mather(Adder&#123;id: 6754&#125;)</span><br><span class="line"></span><br><span class="line">    // This call just makes sure that the interface is actually used.</span><br><span class="line">    // Without this call, the linker would see that the interface defined above</span><br><span class="line">    // is in fact never used, and thus would optimize it out of the final</span><br><span class="line">    // executable.</span><br><span class="line">    m.Add(10, 32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NOTE: For the remainder of this chapter, we will denote an interface I that holds a type T as &lt;I,T&gt;. E.g. Mather(Adder{id: 6754}) instantiates an iface&lt;Mather, Adder&gt;.</p>
<p>Let’s zoom in on the instantiation of iface&lt;Mather, Adder&gt;:</p>
<p>m := Mather(Adder{id: 6754})<br>
This single line of Go code actually sets off quite a bit of machinery, as the assembly listing generated by the compiler can attest:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;; part 1: allocate the receiver</span><br><span class="line">;; A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame.</span><br><span class="line">;; It&apos;s stored there so that the compiler will later be able to reference it by its address;</span><br><span class="line">0x001d MOVL	$6754, &quot;&quot;..autotmp_1+36(SP)</span><br><span class="line">;; part 2: set up the itab</span><br><span class="line">;; Semantically, this gives us something along the lines of the following pseudo-code:</span><br><span class="line"></span><br><span class="line">;; tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line">;; That&apos;s half of our interface right there!</span><br><span class="line"></span><br><span class="line">;; Now, while we&apos;re at it, let&apos;s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol.</span><br><span class="line">;; As usual, the -S flag of the compiler can tell us a lot:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0x0025 LEAQ	go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX</span><br><span class="line">0x002c MOVQ	AX, (SP)</span><br><span class="line">;; part 3: set up the data</span><br><span class="line">0x0030 LEAQ	&quot;&quot;..autotmp_1+36(SP), AX</span><br><span class="line">0x0035 MOVQ	AX, 8(SP)</span><br><span class="line">0x003a CALL	runtime.convT2I32(SB)</span><br><span class="line">0x003f MOVQ	16(SP), AX</span><br><span class="line">0x0044 MOVQ	24(SP), CX</span><br></pre></td></tr></table></figure>
<p>Part 1: Allocate the receiver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x001d MOVL	$6754, &quot;&quot;..autotmp_1+36(SP)</span><br></pre></td></tr></table></figure>
<p>A constant decimal value of 6754, corresponding to the ID of our Adder, is stored at the beginning of the current stack-frame.<br>
It’s stored there so that the compiler will later be able to reference it by its address; we’ll see why in part 3.</p>
<p>Part 2: Set up the itab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0025 LEAQ	go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX</span><br><span class="line">0x002c MOVQ	AX, (SP)</span><br></pre></td></tr></table></figure>
<p>It looks like the compiler has already created the necessary itab for representing our iface&lt;Mather, Adder&gt; interface, and made it available to us via a global symbol: go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather.</p>
<p>We’re in the process of building an iface&lt;Mather, Adder&gt; interface and, in order to do so, we’re loading the effective address of this global go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol at the top of the current stack-frame.<br>
Once again, we’ll see why in part 3.<br>
Semantically, this gives us something along the lines of the following pseudo-code:<br>
tab := getSymAddr(<code>go.itab.main.Adder,main.Mather</code>).(*itab)<br>
That’s half of our interface right there!</p>
<p>Now, while we’re at it, let’s have a deeper look at that go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather symbol.<br>
As usual, the -S flag of the compiler can tell us a lot:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ GOOS=linux GOARCH=amd64 go tool compile -S iface.go | grep -A 7 &apos;^go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather&apos;</span><br><span class="line">go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40</span><br><span class="line">    0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">    0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............</span><br><span class="line">    0x0020 00 00 00 00 00 00 00 00                          ........</span><br><span class="line">    rel 0+8 t=1 type.&quot;&quot;.Mather+0</span><br><span class="line">    rel 8+8 t=1 type.&quot;&quot;.Adder+0</span><br><span class="line">    rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0</span><br><span class="line">    rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0</span><br></pre></td></tr></table></figure>
<p>Neat. Let’s analyze this piece by piece.</p>
<p>The first piece declares the symbol and its attributes:</p>
<p>go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather SRODATA dupok size=40<br>
As usual, since we’re looking directly at the intermediate object file generated by the compiler (i.e. the linker hasn’t run yet), symbol names are still missing package names. Nothing new on that front.<br>
Other than that, what we’ve got here is a 40-byte global object symbol that will be stored in the .rodata section of our binary.</p>
<p>Note the dupok directive, which tells the linker that it is legal for this symbol to appear multiple times at link-time: the linker will have to arbitrarily choose one of them over the others.</p>
<p>The second piece is a hexdump of the 40 bytes of data associated with the symbol. I.e., it’s a serialized representation of an itab structure:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0010 8a 3d 5f 61 00 00 00 00 00 00 00 00 00 00 00 00  .=_a............</span><br><span class="line">0x0020 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>As you can see, most of this data is just a bunch of zeros at this point. The linker will take care of filling them up, as we’ll see in a minute.</p>
<p>Notice how, among all these zeros, 4 bytes actually have been set though, at offset 0x10+4.<br>
If we take a look back at the declaration of the itab structure and annotate the respective offsets of its fields:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123; // 40 bytes on a 64bit arch</span><br><span class="line">    inter *interfacetype // offset 0x00 ($00)</span><br><span class="line">    _type *_type	 // offset 0x08 ($08)</span><br><span class="line">    hash  uint32	 // offset 0x10 ($16)</span><br><span class="line">    _     [4]byte	 // offset 0x14 ($20)</span><br><span class="line">    fun   [1]uintptr	 // offset 0x18 ($24)</span><br><span class="line">			 // offset 0x20 ($32)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We see that offset 0x10+4 matches the hash uint32 field: i.e., the hash value that corresponds to our main.Adder type is already right there in our object file.</p>
<p>The third and final piece lists a bunch of relocation directives for the linker:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rel 0+8 t=1 type.&quot;&quot;.Mather+0</span><br><span class="line">rel 8+8 t=1 type.&quot;&quot;.Adder+0</span><br><span class="line">rel 24+8 t=1 &quot;&quot;.(*Adder).Add+0</span><br><span class="line">rel 32+8 t=1 &quot;&quot;.(*Adder).Sub+0</span><br></pre></td></tr></table></figure>
<p>rel 0+8 t=1 type.&quot;&quot;.Mather+0 tells the linker to fill up the first 8 bytes (0+8) of the contents with the address of the global object symbol type.&quot;&quot;.Mather.<br>
rel 8+8 t=1 type.&quot;&quot;.Adder+0 then fills the next 8 bytes with the address of type.&quot;&quot;.Adder, and so on and so forth.</p>
<p>Once the linker has done its job and followed all of these directives, our 40-byte serialized itab will be complete.<br>
Overall, we’re now looking at something akin to the following pseudo-code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line"></span><br><span class="line">// NOTE: The linker strips the `type.` prefix from these symbols when building</span><br><span class="line">// the executable, so the final symbol names in the .rodata section of the</span><br><span class="line">// binary will actually be `main.Mather` and `main.Adder` rather than</span><br><span class="line">// `type.main.Mather` and `type.main.Adder`.</span><br><span class="line">// Don&apos;t get tripped up by this when toying around with objdump.</span><br><span class="line">tab.inter = getSymAddr(`type.main.Mather`).(*interfacetype)</span><br><span class="line">tab._type = getSymAddr(`type.main.Adder`).(*_type)</span><br><span class="line"></span><br><span class="line">tab.fun[0] = getSymAddr(`main.(*Adder).Add`).(uintptr)</span><br><span class="line">tab.fun[1] = getSymAddr(`main.(*Adder).Sub`).(uintptr)</span><br></pre></td></tr></table></figure>
<p>We’ve got ourselves a ready-to-use itab, now if we just had some data to along with it, that’d make for a nice, complete interface.</p>
<p>Remember from part 1 that the top of the stack (SP) currently holds the address of go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather (argument #1).<br>
Also remember from part 2 that we had stored a $6754 decimal constant in “”…autotmp_1+36(SP): we now load the effective address of this constant just below the top of the stack-frame, at 8(SP) (argument #2).</p>
<p>These two pointers are the two arguments that we pass into runtime.convT2I32, which will apply the final touches of glue to create and return our complete interface.<br>
Let’s have a closer look at it (src/runtime/iface.go):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func convT2I32(tab *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">    t := tab._type</span><br><span class="line">    /* ...omitted debug stuff... */</span><br><span class="line">    var x unsafe.Pointer</span><br><span class="line">    if *(*uint32)(elem) == 0 &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[0])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        x = mallocgc(4, t, false)</span><br><span class="line">        *(*uint32)(x) = *(*uint32)(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So runtime.convT2I32 does 4 things:</p>
<p>It creates a new iface structure i (to be pedantic, its caller creates it… same difference).<br>
It assigns the itab pointer we just gave it to i.tab.<br>
It allocates a new object of type i.tab._type on the heap, then copy the value pointed to by the second argument elem into that new object.<br>
It returns the final interface.</p>
<p>This process is quite straightforward overall, although the 3rd step does involve some tricky implementation details in this specific case, which are caused by the fact that our Adder type is effectively a scalar type.<br>
We’ll look at the interactions of scalar types and interfaces in more details in the section about the special cases of interfaces.</p>
<p>Conceptually, we’ve now accomplished the following (pseudo-code):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tab := getSymAddr(`go.itab.main.Adder,main.Mather`).(*itab)</span><br><span class="line">elem := getSymAddr(`&quot;&quot;..autotmp_1+36(SP)`).(*int32)</span><br><span class="line"></span><br><span class="line">i := runtime.convTI32(tab, unsafe.Pointer(elem))</span><br><span class="line"></span><br><span class="line">assert(i.tab == tab)</span><br><span class="line">assert(*(*int32)(i.data) == 6754) // same value..</span><br><span class="line">assert((*int32)(i.data) != elem)  // ..but different (al)locations!</span><br></pre></td></tr></table></figure>
<p>To summarize all that just went down, here’s a complete, annotated version of the assembly code for all 3 parts:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x001d MOVL	$6754, &quot;&quot;..autotmp_1+36(SP)         ;; create an addressable $6754 value at 36(SP)</span><br><span class="line">0x0025 LEAQ	go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather(SB), AX  ;; set up go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather..</span><br><span class="line">0x002c MOVQ	AX, (SP)                            ;; ..as first argument (tab *itab)</span><br><span class="line">0x0030 LEAQ	&quot;&quot;..autotmp_1+36(SP), AX            ;; set up &amp;36(SP)..</span><br><span class="line">0x0035 MOVQ	AX, 8(SP)                           ;; ..as second argument (elem unsafe.Pointer)</span><br><span class="line">0x003a CALL	runtime.convT2I32(SB)               ;; call convT2I32(go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather, &amp;$6754)</span><br><span class="line">0x003f MOVQ	16(SP), AX                          ;; AX now holds i.tab (go.itab.&quot;&quot;.Adder,&quot;&quot;.Mather)</span><br><span class="line">0x0044 MOVQ	24(SP), CX                          ;; CX now holds i.data (&amp;$6754, somewhere on the heap)</span><br></pre></td></tr></table></figure>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/" title="golang[102]-assembly-汇编教程" target="_blank" rel="external">https://dreamerjonson.com/2019/11/30/golang-102-assembly-compile/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/dreamerjackson" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/jonson.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/dreamerjackson" target="_blank"><span class="text-dark">郑建勋（jonson）</span><small class="ml-1x">区块链工程师 &amp; Web工程师</small></a></h3>
        <div>灾难总是接踵而至，这正是世间的常理。你以为只要哭诉一下，就会有谁来救你？如果失败了，就只能说明我不过是如此程度的男人</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom="">
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2019/12/03/golang-103-ldflags技巧/" title="golang[103]-ldflags技巧"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2019/11/24/emacs-package-for-golang/" title="emacs-package-for-golang"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">
        <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  

  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>

  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫">
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫">
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope="" itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/dreamerjackson" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	<!-- Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>. -->
						天下风云出我辈，一入江湖岁月催。<br>皇图霸业谈笑中，不胜人生一场醉 
			  </div>
    </div>
</footer>

  <!-- <script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>　
<script src="https://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js"></script> -->
<script data-ad-client="ca-pub-9425496202910941" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>


<script src="/js/mrmy.js"></script>



    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'c22fa591ad87e1b03638',
    clientSecret: '0646579e4dd8a301be7a42bcf3f5dd39ce803dcb',
    repo: 'dreamerjackson.github.io',
    owner: 'dreamerjackson',
    admin: ['dreamerjackson'],
    id: md5(location.pathname),
    distractionFreeMode: true
  })
  gitalk.render('comments')
  </script>

      








</body>
</html>